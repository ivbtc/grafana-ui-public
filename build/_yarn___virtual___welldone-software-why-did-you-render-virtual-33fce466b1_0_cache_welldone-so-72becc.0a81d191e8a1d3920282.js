/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["_yarn___virtual___welldone-software-why-did-you-render-virtual-33fce466b1_0_cache_welldone-so-72becc"],{

/***/ "./.yarn/__virtual__/@welldone-software-why-did-you-render-virtual-33fce466b1/0/cache/@welldone-software-why-did-you-render-npm-7.0.1-33d725f830-0bfc59f1f8.zip/node_modules/@welldone-software/why-did-you-render/dist/whyDidYouRender.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * @welldone-software/why-did-you-render 7.0.1\n * MIT Licensed\n * Generated by Vitali Zaidman <vzaidman@gmail.com> (https://github.com/vzaidman)\n * Generated at 2022-04-04\n */\n\n(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(\"./.yarn/cache/react-npm-18.2.0-1eae08fee2-88e38092da.zip/node_modules/react/index.js\"), __webpack_require__(\"./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js\")) :\n  0;\n})(this, (function (React, lodash) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  var wdyrStore = {\n    /* The React object we patch */\n    React: undefined,\n\n    /* Processed user options for WDYR */\n    options: undefined,\n\n    /* The original React.createElement function */\n    origCreateElement: undefined,\n\n    /* The original React.createFactory function */\n    origCreateFactory: undefined,\n\n    /* The original React.cloneElement function */\n    origCloneElement: undefined,\n\n    /* A weak map of all React elements to their WDYR patched react elements */\n    componentsMap: new WeakMap(),\n\n    /* A weak map of props to the owner element that passed them */\n    ownerDataMap: new WeakMap(),\n\n    /* An array of hooks tracked during one render */\n    hooksPerRender: []\n  };\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n\n    return target;\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n      writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    } else if (call !== void 0) {\n      throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get() {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(arguments.length < 3 ? target : receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get.apply(this, arguments);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n\n    var _s, _e;\n\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (!it) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = it.call(o);\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  var _diffTypesDescription;\n  var diffTypes = {\n    'different': 'different',\n    'deepEquals': 'deepEquals',\n    'date': 'date',\n    'regex': 'regex',\n    'reactElement': 'reactElement',\n    'function': 'function',\n    'same': 'same'\n  };\n  var diffTypesDescriptions = (_diffTypesDescription = {}, _defineProperty(_diffTypesDescription, diffTypes.different, 'different objects'), _defineProperty(_diffTypesDescription, diffTypes.deepEquals, 'different objects that are equal by value'), _defineProperty(_diffTypesDescription, diffTypes.date, 'different date objects with the same value'), _defineProperty(_diffTypesDescription, diffTypes.regex, 'different regular expressions with the same value'), _defineProperty(_diffTypesDescription, diffTypes.reactElement, 'different React elements (remember that the <jsx/> syntax always produces a *NEW* immutable React element so a component that receives <jsx/> as props always re-renders)'), _defineProperty(_diffTypesDescription, diffTypes[\"function\"], 'different functions with the same name'), _defineProperty(_diffTypesDescription, diffTypes.same, 'same objects by ref (===)'), _diffTypesDescription); // copied from packages/shared/ReactSymbols.js in https://github.com/facebook/react\n\n  var hasSymbol$1 = typeof Symbol === 'function' && Symbol[\"for\"];\n  var REACT_MEMO_TYPE = hasSymbol$1 ? Symbol[\"for\"]('react.memo') : 0xead3;\n  var REACT_FORWARD_REF_TYPE = hasSymbol$1 ? Symbol[\"for\"]('react.forward_ref') : 0xead0;\n  var REACT_VERSION = Number(React__default[\"default\"].version.split('.')[0]) || 0;\n  var REACT_STRICT_MODE = REACT_VERSION >= 18 ? 8 : 1;\n\n  var hasElementType = typeof Element !== 'undefined'; // copied from https://github.com/facebook/react/packages/shared/ReactSymbols.js\n\n  var hasSymbol = typeof Symbol === 'function' && Symbol[\"for\"];\n  var REACT_ELEMENT_TYPE = hasSymbol ? Symbol[\"for\"]('react.element') : 0xeac7;\n\n  var isReactElement = function isReactElement(object) {\n    return object.$$typeof === REACT_ELEMENT_TYPE;\n  }; // end\n\n\n  function trackDiff(a, b, diffsAccumulator, pathString, diffType) {\n    diffsAccumulator.push({\n      diffType: diffType,\n      pathString: pathString,\n      prevValue: a,\n      nextValue: b\n    });\n    return diffType !== diffTypes.different;\n  }\n\n  function isGetter(obj, prop) {\n    return !!Object.getOwnPropertyDescriptor(obj, prop)['get'];\n  }\n\n  var dependenciesMap = new WeakMap();\n\n  function accumulateDeepEqualDiffs(a, b, diffsAccumulator) {\n    var pathString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n    var _ref = arguments.length > 4 ? arguments[4] : undefined,\n        detailed = _ref.detailed;\n\n    if (a === b) {\n      if (detailed) {\n        trackDiff(a, b, diffsAccumulator, pathString, diffTypes.same);\n      }\n\n      return true;\n    }\n\n    if (!a || !b) {\n      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n\n    if (lodash.isArray(a) && lodash.isArray(b)) {\n      var arrayLength = a.length;\n\n      if (arrayLength !== b.length) {\n        return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.different);\n      }\n\n      var arrayItemDiffs = [];\n      var numberOfDeepEqualsItems = 0;\n\n      for (var i = arrayLength; i--; i > 0) {\n        var diffEquals = accumulateDeepEqualDiffs(a[i], b[i], arrayItemDiffs, \"\".concat(pathString, \"[\").concat(i, \"]\"), {\n          detailed: detailed\n        });\n\n        if (diffEquals) {\n          numberOfDeepEqualsItems++;\n        }\n      }\n\n      if (detailed || numberOfDeepEqualsItems !== arrayLength) {\n        diffsAccumulator.push.apply(diffsAccumulator, arrayItemDiffs);\n      }\n\n      if (numberOfDeepEqualsItems === arrayLength) {\n        return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.deepEquals);\n      }\n\n      return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.different);\n    }\n\n    if (lodash.isSet(a) && lodash.isSet(b)) {\n      if (a.size !== b.size) {\n        return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.different);\n      }\n\n      var _iterator = _createForOfIteratorHelper(a),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var valA = _step.value;\n\n          if (!b.has(valA)) {\n            return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.different);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.deepEquals);\n    }\n\n    if (lodash.isDate(a) && lodash.isDate(b)) {\n      return a.getTime() === b.getTime() ? trackDiff(new Date(a), new Date(b), diffsAccumulator, pathString, diffTypes.date) : trackDiff(new Date(a), new Date(b), diffsAccumulator, pathString, diffTypes.different);\n    }\n\n    if (lodash.isRegExp(a) && lodash.isRegExp(b)) {\n      return a.toString() === b.toString() ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes.regex) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n\n    if (hasElementType && a instanceof Element && b instanceof Element) {\n      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n\n    if (isReactElement(a) && isReactElement(b)) {\n      if (a.type !== b.type) {\n        return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n      }\n\n      var reactElementPropsAreDeepEqual = accumulateDeepEqualDiffs(a.props, b.props, [], \"\".concat(pathString, \".props\"), {\n        detailed: detailed\n      });\n      return reactElementPropsAreDeepEqual ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes.reactElement) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n\n    if (lodash.isFunction(a) && lodash.isFunction(b)) {\n      if (a.name !== b.name) {\n        return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n      }\n\n      var aDependenciesObj = dependenciesMap.get(a);\n      var bDependenciesObj = dependenciesMap.get(b);\n\n      if (aDependenciesObj && bDependenciesObj) {\n        var dependenciesAreDeepEqual = accumulateDeepEqualDiffs(aDependenciesObj.deps, bDependenciesObj.deps, diffsAccumulator, \"\".concat(pathString, \":parent-hook-\").concat(aDependenciesObj.hookName, \"-deps\"), {\n          detailed: detailed\n        });\n        return dependenciesAreDeepEqual ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes[\"function\"]) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n      }\n\n      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes[\"function\"]);\n    }\n\n    if (_typeof(a) === 'object' && _typeof(b) === 'object' && Object.getPrototypeOf(a) === Object.getPrototypeOf(b)) {\n      var aKeys = Object.getOwnPropertyNames(a);\n      var bKeys = Object.getOwnPropertyNames(b);\n      var allKeys = lodash.uniq([].concat(_toConsumableArray(aKeys), _toConsumableArray(bKeys)));\n      var clonedA = lodash.isPlainObject(a) ? _objectSpread2({}, a) : a;\n      var clonedB = lodash.isPlainObject(b) ? _objectSpread2({}, b) : b;\n\n      if (allKeys.length !== aKeys.length || allKeys.length !== bKeys.length) {\n        return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);\n      }\n\n      var relevantKeys = allKeys.filter(function (key) {\n        // do not compare the stack as it differ even though the errors are identical.\n        if (key === 'stack' && lodash.isError(a)) {\n          return false;\n        } // getters checking is causing too much problems because of how it's used in js.\n        // not only getters can throw errors, they also cause side effects in many cases.\n\n\n        if (isGetter(a, key)) {\n          return false;\n        }\n\n        return true;\n      });\n      var keysLength = relevantKeys.length;\n\n      for (var _i = keysLength; _i--; _i > 0) {\n        if (!lodash.has(b, relevantKeys[_i])) {\n          return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);\n        }\n      }\n\n      var objectValuesDiffs = [];\n      var numberOfDeepEqualsObjectValues = 0;\n\n      for (var _i2 = keysLength; _i2--; _i2 > 0) {\n        var key = relevantKeys[_i2];\n        var deepEquals = accumulateDeepEqualDiffs(a[key], b[key], objectValuesDiffs, \"\".concat(pathString, \".\").concat(key), {\n          detailed: detailed\n        });\n\n        if (deepEquals) {\n          numberOfDeepEqualsObjectValues++;\n        }\n      }\n\n      if (detailed || numberOfDeepEqualsObjectValues !== keysLength) {\n        diffsAccumulator.push.apply(diffsAccumulator, objectValuesDiffs);\n      }\n\n      if (numberOfDeepEqualsObjectValues === keysLength) {\n        return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.deepEquals);\n      }\n\n      return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);\n    }\n\n    return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n  }\n\n  function calculateDeepEqualDiffs(a, b, initialPathString) {\n    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref2$detailed = _ref2.detailed,\n        detailed = _ref2$detailed === void 0 ? false : _ref2$detailed;\n\n    try {\n      var diffs = [];\n      accumulateDeepEqualDiffs(a, b, diffs, initialPathString, {\n        detailed: detailed\n      });\n      return diffs;\n    } catch (error) {\n      if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {\n        // warn on circular references, don't crash.\n        // browsers throw different errors name and messages:\n        // chrome/safari: \"RangeError\", \"Maximum call stack size exceeded\"\n        // firefox: \"InternalError\", too much recursion\"\n        // edge: \"Error\", \"Out of stack space\"\n        // eslint-disable-next-line no-console\n        console.warn('Warning: why-did-you-render couldn\\'t handle circular references in props.', error.name, error.message);\n        return false;\n      }\n\n      throw error;\n    }\n  }\n\n  function printDiff(value1, value2, _ref) {\n    var pathString = _ref.pathString,\n        consoleLog = _ref.consoleLog;\n    var diffs = calculateDeepEqualDiffs(value1, value2, pathString, {\n      detailed: true\n    });\n    var keysLength = Math.max.apply(Math, _toConsumableArray(diffs.map(function (diff) {\n      return diff.pathString.length;\n    }))) + 2;\n    Object.entries(lodash.groupBy(lodash.sortBy(diffs, 'pathString'), 'diffType')).forEach(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          diffType = _ref3[0],\n          diffs = _ref3[1];\n\n      consoleLog(\"%c\".concat(diffTypesDescriptions[diffType], \":\"), 'text-decoration: underline; color: blue;');\n      diffs.forEach(function (diff) {\n        consoleLog(\"\".concat(diff.pathString, \":\").padEnd(keysLength, ' '), diff.prevValue);\n      });\n    });\n  }\n\n  var moreInfoUrl = 'http://bit.ly/wdyr02';\n  var moreInfoHooksUrl = 'http://bit.ly/wdyr3';\n  var inHotReload = false;\n\n  function shouldLog(reason, Component) {\n    if (inHotReload) {\n      return false;\n    }\n\n    if (wdyrStore.options.logOnDifferentValues) {\n      return true;\n    }\n\n    if (Component.whyDidYouRender && Component.whyDidYouRender.logOnDifferentValues) {\n      return true;\n    }\n\n    var hasDifferentValues = reason.propsDifferences && reason.propsDifferences.some(function (diff) {\n      return diff.diffType === diffTypes.different;\n    }) || reason.stateDifferences && reason.stateDifferences.some(function (diff) {\n      return diff.diffType === diffTypes.different;\n    }) || reason.hookDifferences && reason.hookDifferences.some(function (diff) {\n      return diff.diffType === diffTypes.different;\n    });\n    return !hasDifferentValues;\n  }\n\n  function logDifference(_ref) {\n    var Component = _ref.Component,\n        displayName = _ref.displayName,\n        hookName = _ref.hookName,\n        prefixMessage = _ref.prefixMessage,\n        diffObjType = _ref.diffObjType,\n        differences = _ref.differences,\n        values = _ref.values;\n\n    if (differences && differences.length > 0) {\n      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), \"\".concat(prefixMessage, \" of \").concat(diffObjType, \" changes:\"));\n      differences.forEach(function (_ref2) {\n        var pathString = _ref2.pathString,\n            diffType = _ref2.diffType,\n            prevValue = _ref2.prevValue,\n            nextValue = _ref2.nextValue;\n\n        function diffFn() {\n          printDiff(prevValue, nextValue, {\n            pathString: pathString,\n            consoleLog: wdyrStore.options.consoleLog\n          });\n        }\n\n        wdyrStore.options.consoleGroup(\"%c\".concat(diffObjType === 'hook' ? \"[hook \".concat(hookName, \" result]\") : \"\".concat(diffObjType, \".\"), \"%c\").concat(pathString, \"%c\"), \"color:\".concat(wdyrStore.options.diffNameColor, \";\"), \"color:\".concat(wdyrStore.options.diffPathColor, \";\"), 'color:default;');\n        wdyrStore.options.consoleLog(\"\".concat(diffTypesDescriptions[diffType], \". (more info at \").concat(hookName ? moreInfoHooksUrl : moreInfoUrl, \")\"));\n        wdyrStore.options.consoleLog(_defineProperty({}, \"prev \".concat(pathString), prevValue), '!==', _defineProperty({}, \"next \".concat(pathString), nextValue));\n\n        if (diffType === diffTypes.deepEquals) {\n          wdyrStore.options.consoleLog({\n            'For detailed diff, right click the following fn, save as global, and run: ': diffFn\n          });\n        }\n\n        wdyrStore.options.consoleGroupEnd();\n      });\n    } else if (differences) {\n      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), \"\".concat(prefixMessage, \" the \").concat(diffObjType, \" object itself changed but its values are all equal.\"), diffObjType === 'props' ? 'This could have been avoided by making the component pure, or by preventing its father from re-rendering.' : 'This usually means this component called setState when no changes in its state actually occurred.', \"More info at \".concat(moreInfoUrl));\n      wdyrStore.options.consoleLog(\"prev \".concat(diffObjType, \":\"), values.prev, ' !== ', values.next, \":next \".concat(diffObjType));\n    }\n  }\n\n  function defaultNotifier(updateInfo) {\n    var Component = updateInfo.Component,\n        displayName = updateInfo.displayName,\n        hookName = updateInfo.hookName,\n        prevProps = updateInfo.prevProps,\n        prevState = updateInfo.prevState,\n        prevHook = updateInfo.prevHook,\n        nextProps = updateInfo.nextProps,\n        nextState = updateInfo.nextState,\n        nextHook = updateInfo.nextHook,\n        reason = updateInfo.reason;\n\n    if (!shouldLog(reason, Component, wdyrStore.options)) {\n      return;\n    }\n\n    wdyrStore.options.consoleGroup(\"%c\".concat(displayName), \"color: \".concat(wdyrStore.options.titleColor, \";\"));\n    var prefixMessage = 'Re-rendered because';\n\n    if (reason.propsDifferences) {\n      logDifference({\n        Component: Component,\n        displayName: displayName,\n        prefixMessage: prefixMessage,\n        diffObjType: 'props',\n        differences: reason.propsDifferences,\n        values: {\n          prev: prevProps,\n          next: nextProps\n        }\n      });\n      prefixMessage = 'And because';\n    }\n\n    if (reason.stateDifferences) {\n      logDifference({\n        Component: Component,\n        displayName: displayName,\n        prefixMessage: prefixMessage,\n        diffObjType: 'state',\n        differences: reason.stateDifferences,\n        values: {\n          prev: prevState,\n          next: nextState\n        }\n      });\n    }\n\n    if (reason.hookDifferences) {\n      logDifference({\n        Component: Component,\n        displayName: displayName,\n        prefixMessage: prefixMessage,\n        diffObjType: 'hook',\n        differences: reason.hookDifferences,\n        values: {\n          prev: prevHook,\n          next: nextHook\n        },\n        hookName: hookName\n      });\n    }\n\n    if (reason.propsDifferences && reason.ownerDifferences) {\n      var prevOwnerData = wdyrStore.ownerDataMap.get(prevProps);\n      var nextOwnerData = wdyrStore.ownerDataMap.get(nextProps);\n      wdyrStore.options.consoleGroup(\"Rendered by \".concat(nextOwnerData.displayName));\n      var _prefixMessage = 'Re-rendered because';\n\n      if (reason.ownerDifferences.propsDifferences) {\n        logDifference({\n          Component: nextOwnerData.Component,\n          displayName: nextOwnerData.displayName,\n          prefixMessage: _prefixMessage,\n          diffObjType: 'props',\n          differences: reason.ownerDifferences.propsDifferences,\n          values: {\n            prev: prevOwnerData.props,\n            next: nextOwnerData.props\n          }\n        });\n        _prefixMessage = 'And because';\n      }\n\n      if (reason.ownerDifferences.stateDifferences) {\n        logDifference({\n          Component: nextOwnerData.Component,\n          displayName: nextOwnerData.displayName,\n          prefixMessage: _prefixMessage,\n          diffObjType: 'state',\n          differences: reason.ownerDifferences.stateDifferences,\n          values: {\n            prev: prevOwnerData.state,\n            next: nextOwnerData.state\n          }\n        });\n      }\n\n      if (reason.ownerDifferences.hookDifferences) {\n        reason.ownerDifferences.hookDifferences.forEach(function (_ref3, i) {\n          var hookName = _ref3.hookName,\n              differences = _ref3.differences;\n          return logDifference({\n            Component: nextOwnerData.Component,\n            displayName: nextOwnerData.displayName,\n            prefixMessage: _prefixMessage,\n            diffObjType: 'hook',\n            differences: differences,\n            values: {\n              prev: prevOwnerData.hooks[i].result,\n              next: nextOwnerData.hooks[i].result\n            },\n            hookName: hookName\n          });\n        });\n      }\n\n      wdyrStore.options.consoleGroupEnd();\n    }\n\n    if (!reason.propsDifferences && !reason.stateDifferences && !reason.hookDifferences) {\n      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), 'Re-rendered although props and state objects are the same.', 'This usually means there was a call to this.forceUpdate() inside the component.', \"more info at \".concat(moreInfoUrl));\n    }\n\n    wdyrStore.options.consoleGroupEnd();\n  }\n  function createDefaultNotifier(hotReloadBufferMs) {\n    if (hotReloadBufferMs) {\n      if (false) {}\n    }\n\n    return defaultNotifier;\n  }\n\n  var emptyFn = function emptyFn() {};\n\n  function normalizeOptions() {\n    var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var consoleGroup = console.group;\n    var consoleGroupEnd = console.groupEnd;\n\n    if (userOptions.collapseGroups) {\n      consoleGroup = console.groupCollapsed;\n    } else if (userOptions.onlyLogs) {\n      consoleGroup = console.log;\n      consoleGroupEnd = emptyFn;\n    }\n\n    var notifier = userOptions.notifier || createDefaultNotifier('hotReloadBufferMs' in userOptions ? userOptions.hotReloadBufferMs : 500);\n    return _objectSpread2({\n      include: null,\n      exclude: null,\n      notifier: notifier,\n      onlyLogs: false,\n      consoleLog: console.log,\n      consoleGroup: consoleGroup,\n      consoleGroupEnd: consoleGroupEnd,\n      logOnDifferentValues: false,\n      logOwnerReasons: true,\n      trackHooks: true,\n      titleColor: '#058',\n      diffNameColor: 'blue',\n      diffPathColor: 'red',\n      trackExtraHooks: [],\n      trackAllPureComponents: false\n    }, userOptions);\n  }\n\n  function getDisplayName(type) {\n    return type.displayName || type.name || type.type && getDisplayName(type.type) || type.render && getDisplayName(type.render) || (lodash.isString(type) ? type : 'Unknown');\n  }\n\n  function getDefaultProps(type) {\n    return type.defaultProps || type.type && getDefaultProps(type.type) || type.render && getDefaultProps(type.render) || {};\n  }\n\n  var emptyObject = {};\n  function findObjectsDifferences(userPrevObj, userNextObj) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref$shallow = _ref.shallow,\n        shallow = _ref$shallow === void 0 ? true : _ref$shallow;\n\n    if (userPrevObj === userNextObj) {\n      return false;\n    }\n\n    if (!shallow) {\n      return calculateDeepEqualDiffs(userPrevObj, userNextObj);\n    }\n\n    var prevObj = userPrevObj || emptyObject;\n    var nextObj = userNextObj || emptyObject;\n    var keysOfBothObjects = Object.keys(_objectSpread2(_objectSpread2({}, prevObj), nextObj));\n    return lodash.reduce(keysOfBothObjects, function (result, key) {\n      var deepEqualDiffs = calculateDeepEqualDiffs(prevObj[key], nextObj[key], key);\n\n      if (deepEqualDiffs) {\n        result = [].concat(_toConsumableArray(result), _toConsumableArray(deepEqualDiffs));\n      }\n\n      return result;\n    }, []);\n  }\n\n  function getOwnerDifferences(_ref) {\n    var prevOwnerData = _ref.prevOwnerData,\n        nextOwnerData = _ref.nextOwnerData;\n\n    if (!prevOwnerData || !nextOwnerData) {\n      return false;\n    } // in strict mode prevOwnerData might be twice as lengthy because of double renders\n\n\n    var prevOwnerDataHooks = prevOwnerData.hooks.length === nextOwnerData.hooks.length * 2 ? prevOwnerData.hooks.slice(prevOwnerData.hooks.length / 2) : prevOwnerData.hooks;\n    var hookDifferences = prevOwnerDataHooks.map(function (_ref2, i) {\n      var hookName = _ref2.hookName,\n          result = _ref2.result;\n      return {\n        hookName: hookName,\n        differences: findObjectsDifferences(result, nextOwnerData.hooks[i].result, {\n          shallow: false\n        })\n      };\n    });\n    return {\n      propsDifferences: findObjectsDifferences(prevOwnerData.props, nextOwnerData.props),\n      stateDifferences: findObjectsDifferences(prevOwnerData.state, nextOwnerData.state),\n      hookDifferences: hookDifferences.length > 0 ? hookDifferences : false\n    };\n  }\n\n  function getUpdateReason(prevProps, prevState, prevHook, nextProps, nextState, nextHook) {\n    var prevOwnerData = wdyrStore.ownerDataMap.get(prevProps);\n    var nextOwnerData = wdyrStore.ownerDataMap.get(nextProps);\n    return {\n      propsDifferences: findObjectsDifferences(prevProps, nextProps),\n      stateDifferences: findObjectsDifferences(prevState, nextState),\n      hookDifferences: findObjectsDifferences(prevHook, nextHook, {\n        shallow: false\n      }),\n      ownerDifferences: getOwnerDifferences({\n        prevOwnerData: prevOwnerData,\n        nextOwnerData: nextOwnerData\n      })\n    };\n  }\n\n  function getUpdateInfo(_ref3) {\n    var Component = _ref3.Component,\n        displayName = _ref3.displayName,\n        hookName = _ref3.hookName,\n        prevProps = _ref3.prevProps,\n        prevState = _ref3.prevState,\n        prevHook = _ref3.prevHook,\n        nextProps = _ref3.nextProps,\n        nextState = _ref3.nextState,\n        nextHook = _ref3.nextHook;\n    return {\n      Component: Component,\n      displayName: displayName,\n      hookName: hookName,\n      prevProps: prevProps,\n      prevState: prevState,\n      prevHook: prevHook,\n      nextProps: nextProps,\n      nextState: nextState,\n      nextHook: nextHook,\n      reason: getUpdateReason(prevProps, prevState, prevHook, nextProps, nextState, nextHook)\n    };\n  }\n\n  // copied from https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactTypeOfMode.js\n  // notice: this is only used for class components. functional components doesn't render twice inside strict mode\n\n  function checkIfInsideAStrictModeTree(reactComponentInstance) {\n    var reactInternalFiber = reactComponentInstance && (reactComponentInstance._reactInternalFiber || reactComponentInstance._reactInternals);\n\n    while (reactInternalFiber) {\n      if (reactInternalFiber.mode & REACT_STRICT_MODE) {\n        return true;\n      }\n\n      reactInternalFiber = reactInternalFiber[\"return\"];\n    }\n\n    return false;\n  }\n  function isReactClassComponent(Component) {\n    return Component.prototype && !!Component.prototype.isReactComponent;\n  }\n  function isMemoComponent(Component) {\n    return Component.$$typeof === REACT_MEMO_TYPE;\n  }\n  function isForwardRefComponent(Component) {\n    return Component.$$typeof === REACT_FORWARD_REF_TYPE;\n  }\n\n  function shouldInclude(displayName) {\n    return wdyrStore.options.include && wdyrStore.options.include.length > 0 && wdyrStore.options.include.some(function (regex) {\n      return regex.test(displayName);\n    });\n  }\n\n  function shouldExclude(displayName) {\n    return wdyrStore.options.exclude && wdyrStore.options.exclude.length > 0 && wdyrStore.options.exclude.some(function (regex) {\n      return regex.test(displayName);\n    });\n  }\n\n  function shouldTrack(Component, _ref) {\n    var isHookChange = _ref.isHookChange;\n    var displayName = getDisplayName(Component);\n\n    if (shouldExclude(displayName)) {\n      return false;\n    }\n\n    if (Component.whyDidYouRender === false) {\n      return false;\n    }\n\n    if (isHookChange && Component.whyDidYouRender && Component.whyDidYouRender.trackHooks === false) {\n      return false;\n    }\n\n    return !!(Component.whyDidYouRender || wdyrStore.options.trackAllPureComponents && (Component && Component.prototype instanceof wdyrStore.React.PureComponent || isMemoComponent(Component)) || shouldInclude(displayName));\n  }\n\n  function patchClassComponent(ClassComponent, _ref) {\n    var displayName = _ref.displayName,\n        defaultProps = _ref.defaultProps;\n\n    var WDYRPatchedClassComponent = /*#__PURE__*/function (_ClassComponent) {\n      _inherits(WDYRPatchedClassComponent, _ClassComponent);\n\n      var _super = _createSuper(WDYRPatchedClassComponent);\n\n      function WDYRPatchedClassComponent(props, context) {\n        var _thisSuper, _this;\n\n        _classCallCheck(this, WDYRPatchedClassComponent);\n\n        _this = _super.call(this, props, context);\n        _this._WDYR = {\n          renderNumber: 0\n        };\n\n        var origRender = _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(WDYRPatchedClassComponent.prototype)), \"render\", _thisSuper) || _this.render; // this probably means that render is an arrow function or this.render.bind(this) was called on the original class\n\n\n        var renderIsABindedFunction = origRender !== ClassComponent.prototype.render;\n\n        if (renderIsABindedFunction) {\n          _this.render = function () {\n            WDYRPatchedClassComponent.prototype.render.apply(_assertThisInitialized(_this));\n            return origRender();\n          };\n        }\n\n        return _this;\n      }\n\n      _createClass(WDYRPatchedClassComponent, [{\n        key: \"render\",\n        value: function render() {\n          this._WDYR.renderNumber++;\n\n          if (!('isStrictMode' in this._WDYR)) {\n            this._WDYR.isStrictMode = checkIfInsideAStrictModeTree(this);\n          } // in strict mode- ignore every other render\n\n\n          if (!(this._WDYR.isStrictMode && this._WDYR.renderNumber % 2 === 1)) {\n            if (this._WDYR.prevProps) {\n              var updateInfo = getUpdateInfo({\n                Component: ClassComponent,\n                displayName: displayName,\n                prevProps: this._WDYR.prevProps,\n                prevState: this._WDYR.prevState,\n                nextProps: this.props,\n                nextState: this.state\n              });\n              wdyrStore.options.notifier(updateInfo);\n            }\n\n            this._WDYR.prevProps = this.props;\n            this._WDYR.prevState = this.state;\n          }\n\n          return _get(_getPrototypeOf(WDYRPatchedClassComponent.prototype), \"render\", this) ? _get(_getPrototypeOf(WDYRPatchedClassComponent.prototype), \"render\", this).call(this) : null;\n        }\n      }]);\n\n      return WDYRPatchedClassComponent;\n    }(ClassComponent);\n\n    try {\n      WDYRPatchedClassComponent.displayName = displayName;\n    } catch (e) {// not crucial if displayName couldn't be set\n    }\n\n    WDYRPatchedClassComponent.defaultProps = defaultProps;\n    lodash.defaults(WDYRPatchedClassComponent, ClassComponent);\n    return WDYRPatchedClassComponent;\n  }\n\n  var getFunctionalComponentFromStringComponent = function getFunctionalComponentFromStringComponent(componentTypeStr) {\n    return function (props) {\n      return wdyrStore.React.createElement(componentTypeStr, props);\n    };\n  };\n\n  function patchFunctionalOrStrComponent(FunctionalOrStringComponent, _ref) {\n    var isPure = _ref.isPure,\n        displayName = _ref.displayName,\n        defaultProps = _ref.defaultProps;\n    var FunctionalComponent = typeof FunctionalOrStringComponent === 'string' ? getFunctionalComponentFromStringComponent(FunctionalOrStringComponent) : FunctionalOrStringComponent;\n\n    function WDYRFunctionalComponent() {\n      var nextProps = arguments[0];\n      var ref = wdyrStore.React.useRef();\n      var prevProps = ref.current;\n      ref.current = nextProps;\n\n      if (prevProps) {\n        var updateInfo = getUpdateInfo({\n          Component: FunctionalComponent,\n          displayName: displayName,\n          prevProps: prevProps,\n          nextProps: nextProps\n        });\n        var notifiedByHooks = !updateInfo.reason.propsDifferences || isPure && updateInfo.reason.propsDifferences.length === 0;\n\n        if (!notifiedByHooks) {\n          wdyrStore.options.notifier(updateInfo);\n        }\n      }\n\n      return FunctionalComponent.apply(void 0, arguments);\n    }\n\n    try {\n      WDYRFunctionalComponent.displayName = displayName;\n    } catch (e) {// not crucial if displayName couldn't be set\n    }\n\n    WDYRFunctionalComponent.defaultProps = defaultProps;\n    WDYRFunctionalComponent.ComponentForHooksTracking = FunctionalComponent;\n    lodash.defaults(WDYRFunctionalComponent, FunctionalComponent);\n    return WDYRFunctionalComponent;\n  }\n\n  function patchMemoComponent(MemoComponent, _ref) {\n    var displayName = _ref.displayName,\n        defaultProps = _ref.defaultProps;\n    var InnerMemoComponent = MemoComponent.type;\n    var isInnerMemoComponentAClassComponent = isReactClassComponent(InnerMemoComponent);\n    var isInnerMemoComponentForwardRefs = isForwardRefComponent(InnerMemoComponent);\n    var isInnerMemoComponentAnotherMemoComponent = isMemoComponent(InnerMemoComponent);\n    var WrappedFunctionalComponent = isInnerMemoComponentForwardRefs ? InnerMemoComponent.render : InnerMemoComponent;\n    var PatchedInnerComponent = isInnerMemoComponentAClassComponent ? patchClassComponent(WrappedFunctionalComponent, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    }) : isInnerMemoComponentAnotherMemoComponent ? patchMemoComponent(WrappedFunctionalComponent, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    }) : patchFunctionalOrStrComponent(WrappedFunctionalComponent, {\n      displayName: displayName,\n      isPure: true\n    });\n\n    try {\n      PatchedInnerComponent.displayName = getDisplayName(WrappedFunctionalComponent);\n    } catch (e) {// not crucial if displayName couldn't be set\n    }\n\n    PatchedInnerComponent.ComponentForHooksTracking = MemoComponent;\n    lodash.defaults(PatchedInnerComponent, WrappedFunctionalComponent);\n    var WDYRMemoizedFunctionalComponent = wdyrStore.React.memo(isInnerMemoComponentForwardRefs ? wdyrStore.React.forwardRef(PatchedInnerComponent) : PatchedInnerComponent, MemoComponent.compare);\n\n    try {\n      WDYRMemoizedFunctionalComponent.displayName = displayName;\n    } catch (e) {// not crucial if displayName couldn't be set\n    }\n\n    WDYRMemoizedFunctionalComponent.defaultProps = defaultProps;\n    lodash.defaults(WDYRMemoizedFunctionalComponent, MemoComponent);\n    return WDYRMemoizedFunctionalComponent;\n  }\n\n  function patchForwardRefComponent(ForwardRefComponent, _ref) {\n    var displayName = _ref.displayName,\n        defaultProps = _ref.defaultProps;\n    var InnerForwardRefComponent = ForwardRefComponent.render;\n    var isInnerComponentMemoized = isMemoComponent(InnerForwardRefComponent);\n    var WrappedFunctionalComponent = isInnerComponentMemoized ? InnerForwardRefComponent.type : InnerForwardRefComponent;\n    var WDYRWrappedByReactForwardRefFunctionalComponent = patchFunctionalOrStrComponent(WrappedFunctionalComponent, {\n      isPure: isInnerComponentMemoized,\n      displayName: displayName\n    });\n    WDYRWrappedByReactForwardRefFunctionalComponent.displayName = getDisplayName(WrappedFunctionalComponent);\n    WDYRWrappedByReactForwardRefFunctionalComponent.ComponentForHooksTracking = WrappedFunctionalComponent;\n    lodash.defaults(WDYRWrappedByReactForwardRefFunctionalComponent, WrappedFunctionalComponent);\n    var WDYRForwardRefFunctionalComponent = wdyrStore.React.forwardRef(isInnerComponentMemoized ? wdyrStore.React.memo(WDYRWrappedByReactForwardRefFunctionalComponent, InnerForwardRefComponent.compare) : WDYRWrappedByReactForwardRefFunctionalComponent);\n\n    try {\n      WDYRForwardRefFunctionalComponent.displayName = displayName;\n    } catch (e) {// not crucial if displayName couldn't be set\n    }\n\n    WDYRForwardRefFunctionalComponent.defaultProps = defaultProps;\n    lodash.defaults(WDYRForwardRefFunctionalComponent, ForwardRefComponent);\n    return WDYRForwardRefFunctionalComponent;\n  }\n\n  var initialHookValue = Symbol('initial-hook-value');\n\n  function trackHookChanges(hookName, _ref, hookResult) {\n    var hookPath = _ref.path;\n    var nextHook = hookPath ? lodash.get(hookResult, hookPath) : hookResult;\n    var renderNumberForTheHook = wdyrStore.React.useRef(true); // TODO: improve\n\n    var isSecondCycleOfRenders = wdyrStore.hooksPerRender[0] && wdyrStore.hooksPerRender[0].renderNumberForTheHook !== renderNumberForTheHook.current;\n\n    if (isSecondCycleOfRenders) {\n      wdyrStore.hooksPerRender = [];\n    }\n\n    wdyrStore.hooksPerRender.push({\n      hookName: hookName,\n      result: nextHook,\n      renderNumberForTheHook: renderNumberForTheHook.current\n    });\n    renderNumberForTheHook.current++;\n    var ComponentHookDispatchedFromInstance = wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;\n    var prevHookRef = wdyrStore.React.useRef(initialHookValue);\n\n    if (!ComponentHookDispatchedFromInstance) {\n      return hookResult;\n    }\n\n    var Component = ComponentHookDispatchedFromInstance.type.ComponentForHooksTracking || ComponentHookDispatchedFromInstance.type;\n    var displayName = getDisplayName(Component);\n    var isShouldTrack = shouldTrack(Component, {\n      isHookChange: true\n    });\n\n    if (!isShouldTrack) {\n      return hookResult;\n    }\n\n    var newPrevHookRef = prevHookRef.current;\n    prevHookRef.current = hookResult;\n\n    if (newPrevHookRef !== initialHookValue) {\n      var notification = getUpdateInfo({\n        Component: Component,\n        displayName: displayName,\n        hookName: hookName,\n        prevHook: hookPath ? lodash.get(newPrevHookRef, hookPath) : newPrevHookRef,\n        nextHook: nextHook\n      });\n\n      if (notification.reason.hookDifferences) {\n        wdyrStore.options.notifier(notification);\n      }\n    }\n\n    return hookResult;\n  }\n\n  function createPatchedComponent(Component, _ref2) {\n    var displayName = _ref2.displayName,\n        defaultProps = _ref2.defaultProps;\n\n    if (isMemoComponent(Component)) {\n      return patchMemoComponent(Component, {\n        displayName: displayName,\n        defaultProps: defaultProps\n      });\n    }\n\n    if (isForwardRefComponent(Component)) {\n      return patchForwardRefComponent(Component, {\n        displayName: displayName,\n        defaultProps: defaultProps\n      });\n    }\n\n    if (isReactClassComponent(Component)) {\n      return patchClassComponent(Component, {\n        displayName: displayName,\n        defaultProps: defaultProps\n      });\n    }\n\n    return patchFunctionalOrStrComponent(Component, {\n      displayName: displayName,\n      defaultProps: defaultProps,\n      isPure: false\n    });\n  }\n\n  function getPatchedComponent(Component, _ref3) {\n    var displayName = _ref3.displayName,\n        defaultProps = _ref3.defaultProps;\n\n    if (wdyrStore.componentsMap.has(Component)) {\n      return wdyrStore.componentsMap.get(Component);\n    }\n\n    var WDYRPatchedComponent = createPatchedComponent(Component, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    });\n    wdyrStore.componentsMap.set(Component, WDYRPatchedComponent);\n    return WDYRPatchedComponent;\n  }\n\n  function getIsSupportedComponentType(Comp) {\n    if (!Comp) {\n      return false;\n    }\n\n    if (isMemoComponent(Comp)) {\n      return getIsSupportedComponentType(Comp.type);\n    }\n\n    if (isForwardRefComponent(Comp)) {\n      return getIsSupportedComponentType(Comp.render);\n    }\n\n    if (typeof Comp === 'function') {\n      return true;\n    }\n  }\n\n  var hooksConfig = {\n    useState: {\n      path: '0'\n    },\n    useReducer: {\n      path: '0'\n    },\n    useContext: undefined,\n    useMemo: {\n      dependenciesPath: '1',\n      dontReport: true\n    },\n    useCallback: {\n      dependenciesPath: '1',\n      dontReport: true\n    }\n  };\n  function storeOwnerData(element) {\n    var OwnerInstance = wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;\n\n    if (OwnerInstance) {\n      var Component = OwnerInstance.type.ComponentForHooksTracking || OwnerInstance.type;\n      var displayName = getDisplayName(Component);\n      var additionalOwnerData = {};\n\n      if (wdyrStore.options.getAdditionalOwnerData) {\n        additionalOwnerData = wdyrStore.options.getAdditionalOwnerData(element);\n      }\n\n      wdyrStore.ownerDataMap.set(element.props, {\n        Component: Component,\n        displayName: displayName,\n        props: OwnerInstance.pendingProps,\n        state: OwnerInstance.stateNode ? OwnerInstance.stateNode.state : null,\n        hooks: wdyrStore.hooksPerRender,\n        additionalOwnerData: additionalOwnerData\n      });\n    }\n  }\n\n  function resetHooksPerRenderIfNeeded() {\n    // Intercept assignments to ReactCurrentOwner.current to reset hooksPerRender\n    var currentOwner = null;\n\n    if (wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) {\n      Object.defineProperty(wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, 'current', {\n        get: function get() {\n          return currentOwner;\n        },\n        set: function set(value) {\n          currentOwner = value;\n          wdyrStore.hooksPerRender = [];\n        }\n      });\n    }\n  }\n\n  function trackHooksIfNeeded() {\n    var hooksSupported = !!wdyrStore.React.useState;\n\n    if (wdyrStore.options.trackHooks && hooksSupported) {\n      var nativeHooks = Object.entries(hooksConfig).map(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            hookName = _ref5[0],\n            hookTrackingConfig = _ref5[1];\n\n        return [wdyrStore.React, hookName, hookTrackingConfig];\n      });\n      var hooksToTrack = [].concat(_toConsumableArray(nativeHooks), _toConsumableArray(wdyrStore.options.trackExtraHooks));\n      hooksToTrack.forEach(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 3),\n            hookParent = _ref7[0],\n            hookName = _ref7[1],\n            _ref7$ = _ref7[2],\n            hookTrackingConfig = _ref7$ === void 0 ? {} : _ref7$;\n\n        var originalHook = hookParent[hookName];\n        var newHookName = hookName[0].toUpperCase() + hookName.slice(1);\n\n        var newHook = function newHook() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          var hookResult = originalHook.call.apply(originalHook, [this].concat(args));\n          var dependenciesPath = hookTrackingConfig.dependenciesPath,\n              dontReport = hookTrackingConfig.dontReport;\n\n          if (dependenciesPath && lodash.isFunction(hookResult)) {\n            dependenciesMap.set(hookResult, {\n              hookName: hookName,\n              deps: lodash.get(args, dependenciesPath)\n            });\n          }\n\n          if (!dontReport) {\n            trackHookChanges(hookName, hookTrackingConfig, hookResult);\n          }\n\n          return hookResult;\n        };\n\n        Object.defineProperty(newHook, 'name', {\n          value: newHookName,\n          writable: false\n        });\n        Object.assign(newHook, {\n          originalHook: originalHook\n        });\n        hookParent[hookName] = newHook;\n      });\n    }\n  }\n\n  function getWDYRType(origType) {\n    var isShouldTrack = getIsSupportedComponentType(origType) && shouldTrack(origType, {\n      isHookChange: false\n    });\n\n    if (!isShouldTrack) {\n      return null;\n    }\n\n    var displayName = origType && origType.whyDidYouRender && origType.whyDidYouRender.customName || getDisplayName(origType);\n    var defaultProps = getDefaultProps(origType);\n    var WDYRPatchedComponent = getPatchedComponent(origType, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    });\n    return WDYRPatchedComponent;\n  }\n  function whyDidYouRender(React, userOptions) {\n    if (React.isWDYR) {\n      return;\n    }\n\n    Object.assign(wdyrStore, {\n      React: React,\n      options: normalizeOptions(userOptions),\n      origCreateElement: React.createElement,\n      origCreateFactory: React.createFactory,\n      origCloneElement: React.cloneElement,\n      componentsMap: new WeakMap()\n    });\n    resetHooksPerRenderIfNeeded();\n\n    React.createElement = function (origType) {\n      var WDYRType = getWDYRType(origType);\n\n      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        rest[_key2 - 1] = arguments[_key2];\n      }\n\n      if (WDYRType) {\n        try {\n          var element = wdyrStore.origCreateElement.apply(React, [WDYRType].concat(rest));\n\n          if (wdyrStore.options.logOwnerReasons) {\n            storeOwnerData(element);\n          }\n\n          return element;\n        } catch (e) {\n          wdyrStore.options.consoleLog('whyDidYouRender error. Please file a bug at https://github.com/welldone-software/why-did-you-render/issues.', {\n            errorInfo: {\n              error: e,\n              componentNameOrComponent: origType,\n              rest: rest,\n              options: wdyrStore.options\n            }\n          });\n        }\n      }\n\n      return wdyrStore.origCreateElement.apply(React, [origType].concat(rest));\n    };\n\n    Object.assign(React.createElement, wdyrStore.origCreateElement);\n\n    React.createFactory = function (type) {\n      var factory = React.createElement.bind(null, type);\n      factory.type = type;\n      return factory;\n    };\n\n    Object.assign(React.createFactory, wdyrStore.origCreateFactory);\n\n    React.cloneElement = function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var element = wdyrStore.origCloneElement.apply(React, args);\n\n      if (wdyrStore.options.logOwnerReasons) {\n        storeOwnerData(element);\n      }\n\n      return element;\n    };\n\n    Object.assign(React.cloneElement, wdyrStore.origCloneElement);\n    trackHooksIfNeeded();\n    React.isWDYR = true;\n\n    React.__REVERT_WHY_DID_YOU_RENDER__ = function () {\n      Object.assign(React, {\n        createElement: wdyrStore.origCreateElement,\n        createFactory: wdyrStore.origCreateFactory,\n        cloneElement: wdyrStore.origCloneElement\n      });\n      wdyrStore.componentsMap = null;\n      var hooksToRevert = [].concat(_toConsumableArray(Object.keys(hooksConfig).map(function (hookName) {\n        return [React, hookName];\n      })), _toConsumableArray(wdyrStore.options.trackExtraHooks));\n      hooksToRevert.forEach(function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            hookParent = _ref9[0],\n            hookName = _ref9[1];\n\n        if (hookParent[hookName].originalHook) {\n          hookParent[hookName] = hookParent[hookName].originalHook;\n        }\n      });\n      delete React.__REVERT_WHY_DID_YOU_RENDER__;\n      delete React.isWDYR;\n    };\n\n    return React;\n  }\n\n  whyDidYouRender.defaultNotifier = defaultNotifier;\n  whyDidYouRender.wdyrStore = wdyrStore;\n  whyDidYouRender.storeOwnerData = storeOwnerData;\n  whyDidYouRender.getWDYRType = getWDYRType;\n  Object.assign(whyDidYouRender, React__namespace);\n\n  return whyDidYouRender;\n\n}));\n//# sourceMappingURL=whyDidYouRender.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9Ad2VsbGRvbmUtc29mdHdhcmUtd2h5LWRpZC15b3UtcmVuZGVyLXZpcnR1YWwtMzNmY2U0NjZiMS8wL2NhY2hlL0B3ZWxsZG9uZS1zb2Z0d2FyZS13aHktZGlkLXlvdS1yZW5kZXItbnBtLTcuMC4xLTMzZDcyNWY4MzAtMGJmYzU5ZjFmOC56aXAvbm9kZV9tb2R1bGVzL0B3ZWxsZG9uZS1zb2Z0d2FyZS93aHktZGlkLXlvdS1yZW5kZXIvZGlzdC93aHlEaWRZb3VSZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RCw0QkFBNEIsbUJBQU8sQ0FBQyxzRkFBTyxHQUFHLG1CQUFPLENBQUMsMEZBQVE7QUFDNUgsRUFBRSxDQUN5STtBQUMzSSxDQUFDLG9DQUFvQzs7QUFFckMsdUNBQXVDLDREQUE0RDs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzMUJBQXMxQjs7QUFFLzRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpR0FBaUcsWUFBWTtBQUM3RztBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLG9PQUFvTyx1REFBdUQsbUJBQW1CO0FBQzlTO0FBQ0EsdURBQXVELG1FQUFtRTs7QUFFMUg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhHQUE4RztBQUM5Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUEwRSxFQUFFLEVBUy9FO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5S0FBeUs7OztBQUd6Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTSxXQUFXO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLFdBQVc7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU0sV0FBVztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sV0FBVztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sV0FBVztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSxhQUFhO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vQHdlbGxkb25lLXNvZnR3YXJlLXdoeS1kaWQteW91LXJlbmRlci12aXJ0dWFsLTMzZmNlNDY2YjEvMC9jYWNoZS9Ad2VsbGRvbmUtc29mdHdhcmUtd2h5LWRpZC15b3UtcmVuZGVyLW5wbS03LjAuMS0zM2Q3MjVmODMwLTBiZmM1OWYxZjguemlwL25vZGVfbW9kdWxlcy9Ad2VsbGRvbmUtc29mdHdhcmUvd2h5LWRpZC15b3UtcmVuZGVyL2Rpc3Qvd2h5RGlkWW91UmVuZGVyLmpzP2EyNjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAd2VsbGRvbmUtc29mdHdhcmUvd2h5LWRpZC15b3UtcmVuZGVyIDcuMC4xXG4gKiBNSVQgTGljZW5zZWRcbiAqIEdlbmVyYXRlZCBieSBWaXRhbGkgWmFpZG1hbiA8dnphaWRtYW5AZ21haWwuY29tPiAoaHR0cHM6Ly9naXRodWIuY29tL3Z6YWlkbWFuKVxuICogR2VuZXJhdGVkIGF0IDIwMjItMDQtMDRcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgncmVhY3QnKSwgcmVxdWlyZSgnbG9kYXNoJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVhY3QnLCAnbG9kYXNoJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLndoeURpZFlvdVJlbmRlciA9IGZhY3RvcnkoZ2xvYmFsLnJlYWN0LCBnbG9iYWwubG9kYXNoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKFJlYWN0LCBsb2Rhc2gpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG4gIH1cblxuICB2YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFJlYWN0KTtcbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4gIHZhciB3ZHlyU3RvcmUgPSB7XG4gICAgLyogVGhlIFJlYWN0IG9iamVjdCB3ZSBwYXRjaCAqL1xuICAgIFJlYWN0OiB1bmRlZmluZWQsXG5cbiAgICAvKiBQcm9jZXNzZWQgdXNlciBvcHRpb25zIGZvciBXRFlSICovXG4gICAgb3B0aW9uczogdW5kZWZpbmVkLFxuXG4gICAgLyogVGhlIG9yaWdpbmFsIFJlYWN0LmNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gKi9cbiAgICBvcmlnQ3JlYXRlRWxlbWVudDogdW5kZWZpbmVkLFxuXG4gICAgLyogVGhlIG9yaWdpbmFsIFJlYWN0LmNyZWF0ZUZhY3RvcnkgZnVuY3Rpb24gKi9cbiAgICBvcmlnQ3JlYXRlRmFjdG9yeTogdW5kZWZpbmVkLFxuXG4gICAgLyogVGhlIG9yaWdpbmFsIFJlYWN0LmNsb25lRWxlbWVudCBmdW5jdGlvbiAqL1xuICAgIG9yaWdDbG9uZUVsZW1lbnQ6IHVuZGVmaW5lZCxcblxuICAgIC8qIEEgd2VhayBtYXAgb2YgYWxsIFJlYWN0IGVsZW1lbnRzIHRvIHRoZWlyIFdEWVIgcGF0Y2hlZCByZWFjdCBlbGVtZW50cyAqL1xuICAgIGNvbXBvbmVudHNNYXA6IG5ldyBXZWFrTWFwKCksXG5cbiAgICAvKiBBIHdlYWsgbWFwIG9mIHByb3BzIHRvIHRoZSBvd25lciBlbGVtZW50IHRoYXQgcGFzc2VkIHRoZW0gKi9cbiAgICBvd25lckRhdGFNYXA6IG5ldyBXZWFrTWFwKCksXG5cbiAgICAvKiBBbiBhcnJheSBvZiBob29rcyB0cmFja2VkIGR1cmluZyBvbmUgcmVuZGVyICovXG4gICAgaG9va3NQZXJSZW5kZXI6IFtdXG4gIH07XG5cbiAgZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICAgIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfSwgX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXQoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gICAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG5cbiAgICB2YXIgX3MsIF9lO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gICAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG5cbiAgICBpZiAoIWl0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHM6IEYsXG4gICAgICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZjogRlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgICAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICAgICAgZXJyO1xuICAgIHJldHVybiB7XG4gICAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGl0ID0gaXQuY2FsbChvKTtcbiAgICAgIH0sXG4gICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfSxcbiAgICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgX2RpZmZUeXBlc0Rlc2NyaXB0aW9uO1xuICB2YXIgZGlmZlR5cGVzID0ge1xuICAgICdkaWZmZXJlbnQnOiAnZGlmZmVyZW50JyxcbiAgICAnZGVlcEVxdWFscyc6ICdkZWVwRXF1YWxzJyxcbiAgICAnZGF0ZSc6ICdkYXRlJyxcbiAgICAncmVnZXgnOiAncmVnZXgnLFxuICAgICdyZWFjdEVsZW1lbnQnOiAncmVhY3RFbGVtZW50JyxcbiAgICAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLFxuICAgICdzYW1lJzogJ3NhbWUnXG4gIH07XG4gIHZhciBkaWZmVHlwZXNEZXNjcmlwdGlvbnMgPSAoX2RpZmZUeXBlc0Rlc2NyaXB0aW9uID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZGlmZlR5cGVzRGVzY3JpcHRpb24sIGRpZmZUeXBlcy5kaWZmZXJlbnQsICdkaWZmZXJlbnQgb2JqZWN0cycpLCBfZGVmaW5lUHJvcGVydHkoX2RpZmZUeXBlc0Rlc2NyaXB0aW9uLCBkaWZmVHlwZXMuZGVlcEVxdWFscywgJ2RpZmZlcmVudCBvYmplY3RzIHRoYXQgYXJlIGVxdWFsIGJ5IHZhbHVlJyksIF9kZWZpbmVQcm9wZXJ0eShfZGlmZlR5cGVzRGVzY3JpcHRpb24sIGRpZmZUeXBlcy5kYXRlLCAnZGlmZmVyZW50IGRhdGUgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIHZhbHVlJyksIF9kZWZpbmVQcm9wZXJ0eShfZGlmZlR5cGVzRGVzY3JpcHRpb24sIGRpZmZUeXBlcy5yZWdleCwgJ2RpZmZlcmVudCByZWd1bGFyIGV4cHJlc3Npb25zIHdpdGggdGhlIHNhbWUgdmFsdWUnKSwgX2RlZmluZVByb3BlcnR5KF9kaWZmVHlwZXNEZXNjcmlwdGlvbiwgZGlmZlR5cGVzLnJlYWN0RWxlbWVudCwgJ2RpZmZlcmVudCBSZWFjdCBlbGVtZW50cyAocmVtZW1iZXIgdGhhdCB0aGUgPGpzeC8+IHN5bnRheCBhbHdheXMgcHJvZHVjZXMgYSAqTkVXKiBpbW11dGFibGUgUmVhY3QgZWxlbWVudCBzbyBhIGNvbXBvbmVudCB0aGF0IHJlY2VpdmVzIDxqc3gvPiBhcyBwcm9wcyBhbHdheXMgcmUtcmVuZGVycyknKSwgX2RlZmluZVByb3BlcnR5KF9kaWZmVHlwZXNEZXNjcmlwdGlvbiwgZGlmZlR5cGVzW1wiZnVuY3Rpb25cIl0sICdkaWZmZXJlbnQgZnVuY3Rpb25zIHdpdGggdGhlIHNhbWUgbmFtZScpLCBfZGVmaW5lUHJvcGVydHkoX2RpZmZUeXBlc0Rlc2NyaXB0aW9uLCBkaWZmVHlwZXMuc2FtZSwgJ3NhbWUgb2JqZWN0cyBieSByZWYgKD09PSknKSwgX2RpZmZUeXBlc0Rlc2NyaXB0aW9uKTsgLy8gY29waWVkIGZyb20gcGFja2FnZXMvc2hhcmVkL1JlYWN0U3ltYm9scy5qcyBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3RcblxuICB2YXIgaGFzU3ltYm9sJDEgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFtcImZvclwiXTtcbiAgdmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCQxID8gU3ltYm9sW1wiZm9yXCJdKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG4gIHZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sJDEgPyBTeW1ib2xbXCJmb3JcIl0oJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG4gIHZhciBSRUFDVF9WRVJTSU9OID0gTnVtYmVyKFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pIHx8IDA7XG4gIHZhciBSRUFDVF9TVFJJQ1RfTU9ERSA9IFJFQUNUX1ZFUlNJT04gPj0gMTggPyA4IDogMTtcblxuICB2YXIgaGFzRWxlbWVudFR5cGUgPSB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7IC8vIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wYWNrYWdlcy9zaGFyZWQvUmVhY3RTeW1ib2xzLmpzXG5cbiAgdmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sW1wiZm9yXCJdO1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sW1wiZm9yXCJdKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbiAgdmFyIGlzUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9OyAvLyBlbmRcblxuXG4gIGZ1bmN0aW9uIHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZSkge1xuICAgIGRpZmZzQWNjdW11bGF0b3IucHVzaCh7XG4gICAgICBkaWZmVHlwZTogZGlmZlR5cGUsXG4gICAgICBwYXRoU3RyaW5nOiBwYXRoU3RyaW5nLFxuICAgICAgcHJldlZhbHVlOiBhLFxuICAgICAgbmV4dFZhbHVlOiBiXG4gICAgfSk7XG4gICAgcmV0dXJuIGRpZmZUeXBlICE9PSBkaWZmVHlwZXMuZGlmZmVyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHZXR0ZXIob2JqLCBwcm9wKSB7XG4gICAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApWydnZXQnXTtcbiAgfVxuXG4gIHZhciBkZXBlbmRlbmNpZXNNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gIGZ1bmN0aW9uIGFjY3VtdWxhdGVEZWVwRXF1YWxEaWZmcyhhLCBiLCBkaWZmc0FjY3VtdWxhdG9yKSB7XG4gICAgdmFyIHBhdGhTdHJpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcnO1xuXG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGV0YWlsZWQgPSBfcmVmLmRldGFpbGVkO1xuXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIGlmIChkZXRhaWxlZCkge1xuICAgICAgICB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLnNhbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgIHJldHVybiB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGxvZGFzaC5pc0FycmF5KGEpICYmIGxvZGFzaC5pc0FycmF5KGIpKSB7XG4gICAgICB2YXIgYXJyYXlMZW5ndGggPSBhLmxlbmd0aDtcblxuICAgICAgaWYgKGFycmF5TGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJhY2tEaWZmKF90b0NvbnN1bWFibGVBcnJheShhKSwgX3RvQ29uc3VtYWJsZUFycmF5KGIpLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycmF5SXRlbURpZmZzID0gW107XG4gICAgICB2YXIgbnVtYmVyT2ZEZWVwRXF1YWxzSXRlbXMgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gYXJyYXlMZW5ndGg7IGktLTsgaSA+IDApIHtcbiAgICAgICAgdmFyIGRpZmZFcXVhbHMgPSBhY2N1bXVsYXRlRGVlcEVxdWFsRGlmZnMoYVtpXSwgYltpXSwgYXJyYXlJdGVtRGlmZnMsIFwiXCIuY29uY2F0KHBhdGhTdHJpbmcsIFwiW1wiKS5jb25jYXQoaSwgXCJdXCIpLCB7XG4gICAgICAgICAgZGV0YWlsZWQ6IGRldGFpbGVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkaWZmRXF1YWxzKSB7XG4gICAgICAgICAgbnVtYmVyT2ZEZWVwRXF1YWxzSXRlbXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGV0YWlsZWQgfHwgbnVtYmVyT2ZEZWVwRXF1YWxzSXRlbXMgIT09IGFycmF5TGVuZ3RoKSB7XG4gICAgICAgIGRpZmZzQWNjdW11bGF0b3IucHVzaC5hcHBseShkaWZmc0FjY3VtdWxhdG9yLCBhcnJheUl0ZW1EaWZmcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXJPZkRlZXBFcXVhbHNJdGVtcyA9PT0gYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrRGlmZihfdG9Db25zdW1hYmxlQXJyYXkoYSksIF90b0NvbnN1bWFibGVBcnJheShiKSwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRlZXBFcXVhbHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhY2tEaWZmKF90b0NvbnN1bWFibGVBcnJheShhKSwgX3RvQ29uc3VtYWJsZUFycmF5KGIpLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICB9XG5cbiAgICBpZiAobG9kYXNoLmlzU2V0KGEpICYmIGxvZGFzaC5pc1NldChiKSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiB0cmFja0RpZmYobmV3IFNldChhKSwgbmV3IFNldChiKSwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdmFsQSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKCFiLmhhcyh2YWxBKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrRGlmZihuZXcgU2V0KGEpLCBuZXcgU2V0KGIpLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYWNrRGlmZihuZXcgU2V0KGEpLCBuZXcgU2V0KGIpLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGVlcEVxdWFscyk7XG4gICAgfVxuXG4gICAgaWYgKGxvZGFzaC5pc0RhdGUoYSkgJiYgbG9kYXNoLmlzRGF0ZShiKSkge1xuICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA/IHRyYWNrRGlmZihuZXcgRGF0ZShhKSwgbmV3IERhdGUoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kYXRlKSA6IHRyYWNrRGlmZihuZXcgRGF0ZShhKSwgbmV3IERhdGUoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChsb2Rhc2guaXNSZWdFeHAoYSkgJiYgbG9kYXNoLmlzUmVnRXhwKGIpKSB7XG4gICAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCkgPyB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLnJlZ2V4KSA6IHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzRWxlbWVudFR5cGUgJiYgYSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgYiBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVhY3RFbGVtZW50KGEpICYmIGlzUmVhY3RFbGVtZW50KGIpKSB7XG4gICAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlYWN0RWxlbWVudFByb3BzQXJlRGVlcEVxdWFsID0gYWNjdW11bGF0ZURlZXBFcXVhbERpZmZzKGEucHJvcHMsIGIucHJvcHMsIFtdLCBcIlwiLmNvbmNhdChwYXRoU3RyaW5nLCBcIi5wcm9wc1wiKSwge1xuICAgICAgICBkZXRhaWxlZDogZGV0YWlsZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlYWN0RWxlbWVudFByb3BzQXJlRGVlcEVxdWFsID8gdHJhY2tEaWZmKGEsIGIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5yZWFjdEVsZW1lbnQpIDogdHJhY2tEaWZmKGEsIGIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChsb2Rhc2guaXNGdW5jdGlvbihhKSAmJiBsb2Rhc2guaXNGdW5jdGlvbihiKSkge1xuICAgICAgaWYgKGEubmFtZSAhPT0gYi5uYW1lKSB7XG4gICAgICAgIHJldHVybiB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhRGVwZW5kZW5jaWVzT2JqID0gZGVwZW5kZW5jaWVzTWFwLmdldChhKTtcbiAgICAgIHZhciBiRGVwZW5kZW5jaWVzT2JqID0gZGVwZW5kZW5jaWVzTWFwLmdldChiKTtcblxuICAgICAgaWYgKGFEZXBlbmRlbmNpZXNPYmogJiYgYkRlcGVuZGVuY2llc09iaikge1xuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzQXJlRGVlcEVxdWFsID0gYWNjdW11bGF0ZURlZXBFcXVhbERpZmZzKGFEZXBlbmRlbmNpZXNPYmouZGVwcywgYkRlcGVuZGVuY2llc09iai5kZXBzLCBkaWZmc0FjY3VtdWxhdG9yLCBcIlwiLmNvbmNhdChwYXRoU3RyaW5nLCBcIjpwYXJlbnQtaG9vay1cIikuY29uY2F0KGFEZXBlbmRlbmNpZXNPYmouaG9va05hbWUsIFwiLWRlcHNcIiksIHtcbiAgICAgICAgICBkZXRhaWxlZDogZGV0YWlsZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNBcmVEZWVwRXF1YWwgPyB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzW1wiZnVuY3Rpb25cIl0pIDogdHJhY2tEaWZmKGEsIGIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhY2tEaWZmKGEsIGIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlc1tcImZ1bmN0aW9uXCJdKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihiKSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpIHtcbiAgICAgIHZhciBhS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGEpO1xuICAgICAgdmFyIGJLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYik7XG4gICAgICB2YXIgYWxsS2V5cyA9IGxvZGFzaC51bmlxKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYUtleXMpLCBfdG9Db25zdW1hYmxlQXJyYXkoYktleXMpKSk7XG4gICAgICB2YXIgY2xvbmVkQSA9IGxvZGFzaC5pc1BsYWluT2JqZWN0KGEpID8gX29iamVjdFNwcmVhZDIoe30sIGEpIDogYTtcbiAgICAgIHZhciBjbG9uZWRCID0gbG9kYXNoLmlzUGxhaW5PYmplY3QoYikgPyBfb2JqZWN0U3ByZWFkMih7fSwgYikgOiBiO1xuXG4gICAgICBpZiAoYWxsS2V5cy5sZW5ndGggIT09IGFLZXlzLmxlbmd0aCB8fCBhbGxLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cmFja0RpZmYoY2xvbmVkQSwgY2xvbmVkQiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxldmFudEtleXMgPSBhbGxLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIGRvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9ycyBhcmUgaWRlbnRpY2FsLlxuICAgICAgICBpZiAoa2V5ID09PSAnc3RhY2snICYmIGxvZGFzaC5pc0Vycm9yKGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIGdldHRlcnMgY2hlY2tpbmcgaXMgY2F1c2luZyB0b28gbXVjaCBwcm9ibGVtcyBiZWNhdXNlIG9mIGhvdyBpdCdzIHVzZWQgaW4ganMuXG4gICAgICAgIC8vIG5vdCBvbmx5IGdldHRlcnMgY2FuIHRocm93IGVycm9ycywgdGhleSBhbHNvIGNhdXNlIHNpZGUgZWZmZWN0cyBpbiBtYW55IGNhc2VzLlxuXG5cbiAgICAgICAgaWYgKGlzR2V0dGVyKGEsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGtleXNMZW5ndGggPSByZWxldmFudEtleXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IGtleXNMZW5ndGg7IF9pLS07IF9pID4gMCkge1xuICAgICAgICBpZiAoIWxvZGFzaC5oYXMoYiwgcmVsZXZhbnRLZXlzW19pXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tEaWZmKGNsb25lZEEsIGNsb25lZEIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3RWYWx1ZXNEaWZmcyA9IFtdO1xuICAgICAgdmFyIG51bWJlck9mRGVlcEVxdWFsc09iamVjdFZhbHVlcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IGtleXNMZW5ndGg7IF9pMi0tOyBfaTIgPiAwKSB7XG4gICAgICAgIHZhciBrZXkgPSByZWxldmFudEtleXNbX2kyXTtcbiAgICAgICAgdmFyIGRlZXBFcXVhbHMgPSBhY2N1bXVsYXRlRGVlcEVxdWFsRGlmZnMoYVtrZXldLCBiW2tleV0sIG9iamVjdFZhbHVlc0RpZmZzLCBcIlwiLmNvbmNhdChwYXRoU3RyaW5nLCBcIi5cIikuY29uY2F0KGtleSksIHtcbiAgICAgICAgICBkZXRhaWxlZDogZGV0YWlsZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRlZXBFcXVhbHMpIHtcbiAgICAgICAgICBudW1iZXJPZkRlZXBFcXVhbHNPYmplY3RWYWx1ZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGV0YWlsZWQgfHwgbnVtYmVyT2ZEZWVwRXF1YWxzT2JqZWN0VmFsdWVzICE9PSBrZXlzTGVuZ3RoKSB7XG4gICAgICAgIGRpZmZzQWNjdW11bGF0b3IucHVzaC5hcHBseShkaWZmc0FjY3VtdWxhdG9yLCBvYmplY3RWYWx1ZXNEaWZmcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXJPZkRlZXBFcXVhbHNPYmplY3RWYWx1ZXMgPT09IGtleXNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrRGlmZihjbG9uZWRBLCBjbG9uZWRCLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGVlcEVxdWFscyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFja0RpZmYoY2xvbmVkQSwgY2xvbmVkQiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURlZXBFcXVhbERpZmZzKGEsIGIsIGluaXRpYWxQYXRoU3RyaW5nKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fSxcbiAgICAgICAgX3JlZjIkZGV0YWlsZWQgPSBfcmVmMi5kZXRhaWxlZCxcbiAgICAgICAgZGV0YWlsZWQgPSBfcmVmMiRkZXRhaWxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRkZXRhaWxlZDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgZGlmZnMgPSBbXTtcbiAgICAgIGFjY3VtdWxhdGVEZWVwRXF1YWxEaWZmcyhhLCBiLCBkaWZmcywgaW5pdGlhbFBhdGhTdHJpbmcsIHtcbiAgICAgICAgZGV0YWlsZWQ6IGRldGFpbGVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkaWZmcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvc3RhY2t8cmVjdXJzaW9uL2kpIHx8IGVycm9yLm51bWJlciA9PT0gLTIxNDY4MjgyNjApIHtcbiAgICAgICAgLy8gd2FybiBvbiBjaXJjdWxhciByZWZlcmVuY2VzLCBkb24ndCBjcmFzaC5cbiAgICAgICAgLy8gYnJvd3NlcnMgdGhyb3cgZGlmZmVyZW50IGVycm9ycyBuYW1lIGFuZCBtZXNzYWdlczpcbiAgICAgICAgLy8gY2hyb21lL3NhZmFyaTogXCJSYW5nZUVycm9yXCIsIFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIlxuICAgICAgICAvLyBmaXJlZm94OiBcIkludGVybmFsRXJyb3JcIiwgdG9vIG11Y2ggcmVjdXJzaW9uXCJcbiAgICAgICAgLy8gZWRnZTogXCJFcnJvclwiLCBcIk91dCBvZiBzdGFjayBzcGFjZVwiXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogd2h5LWRpZC15b3UtcmVuZGVyIGNvdWxkblxcJ3QgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gcHJvcHMuJywgZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnREaWZmKHZhbHVlMSwgdmFsdWUyLCBfcmVmKSB7XG4gICAgdmFyIHBhdGhTdHJpbmcgPSBfcmVmLnBhdGhTdHJpbmcsXG4gICAgICAgIGNvbnNvbGVMb2cgPSBfcmVmLmNvbnNvbGVMb2c7XG4gICAgdmFyIGRpZmZzID0gY2FsY3VsYXRlRGVlcEVxdWFsRGlmZnModmFsdWUxLCB2YWx1ZTIsIHBhdGhTdHJpbmcsIHtcbiAgICAgIGRldGFpbGVkOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIGtleXNMZW5ndGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoZGlmZnMubWFwKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICByZXR1cm4gZGlmZi5wYXRoU3RyaW5nLmxlbmd0aDtcbiAgICB9KSkpICsgMjtcbiAgICBPYmplY3QuZW50cmllcyhsb2Rhc2guZ3JvdXBCeShsb2Rhc2guc29ydEJ5KGRpZmZzLCAncGF0aFN0cmluZycpLCAnZGlmZlR5cGUnKSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBfcmVmMyA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgICAgICBkaWZmVHlwZSA9IF9yZWYzWzBdLFxuICAgICAgICAgIGRpZmZzID0gX3JlZjNbMV07XG5cbiAgICAgIGNvbnNvbGVMb2coXCIlY1wiLmNvbmNhdChkaWZmVHlwZXNEZXNjcmlwdGlvbnNbZGlmZlR5cGVdLCBcIjpcIiksICd0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgY29sb3I6IGJsdWU7Jyk7XG4gICAgICBkaWZmcy5mb3JFYWNoKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICAgIGNvbnNvbGVMb2coXCJcIi5jb25jYXQoZGlmZi5wYXRoU3RyaW5nLCBcIjpcIikucGFkRW5kKGtleXNMZW5ndGgsICcgJyksIGRpZmYucHJldlZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1vcmVJbmZvVXJsID0gJ2h0dHA6Ly9iaXQubHkvd2R5cjAyJztcbiAgdmFyIG1vcmVJbmZvSG9va3NVcmwgPSAnaHR0cDovL2JpdC5seS93ZHlyMyc7XG4gIHZhciBpbkhvdFJlbG9hZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNob3VsZExvZyhyZWFzb24sIENvbXBvbmVudCkge1xuICAgIGlmIChpbkhvdFJlbG9hZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh3ZHlyU3RvcmUub3B0aW9ucy5sb2dPbkRpZmZlcmVudFZhbHVlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKENvbXBvbmVudC53aHlEaWRZb3VSZW5kZXIgJiYgQ29tcG9uZW50LndoeURpZFlvdVJlbmRlci5sb2dPbkRpZmZlcmVudFZhbHVlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGhhc0RpZmZlcmVudFZhbHVlcyA9IHJlYXNvbi5wcm9wc0RpZmZlcmVuY2VzICYmIHJlYXNvbi5wcm9wc0RpZmZlcmVuY2VzLnNvbWUoZnVuY3Rpb24gKGRpZmYpIHtcbiAgICAgIHJldHVybiBkaWZmLmRpZmZUeXBlID09PSBkaWZmVHlwZXMuZGlmZmVyZW50O1xuICAgIH0pIHx8IHJlYXNvbi5zdGF0ZURpZmZlcmVuY2VzICYmIHJlYXNvbi5zdGF0ZURpZmZlcmVuY2VzLnNvbWUoZnVuY3Rpb24gKGRpZmYpIHtcbiAgICAgIHJldHVybiBkaWZmLmRpZmZUeXBlID09PSBkaWZmVHlwZXMuZGlmZmVyZW50O1xuICAgIH0pIHx8IHJlYXNvbi5ob29rRGlmZmVyZW5jZXMgJiYgcmVhc29uLmhvb2tEaWZmZXJlbmNlcy5zb21lKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICByZXR1cm4gZGlmZi5kaWZmVHlwZSA9PT0gZGlmZlR5cGVzLmRpZmZlcmVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gIWhhc0RpZmZlcmVudFZhbHVlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0RpZmZlcmVuY2UoX3JlZikge1xuICAgIHZhciBDb21wb25lbnQgPSBfcmVmLkNvbXBvbmVudCxcbiAgICAgICAgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgICBob29rTmFtZSA9IF9yZWYuaG9va05hbWUsXG4gICAgICAgIHByZWZpeE1lc3NhZ2UgPSBfcmVmLnByZWZpeE1lc3NhZ2UsXG4gICAgICAgIGRpZmZPYmpUeXBlID0gX3JlZi5kaWZmT2JqVHlwZSxcbiAgICAgICAgZGlmZmVyZW5jZXMgPSBfcmVmLmRpZmZlcmVuY2VzLFxuICAgICAgICB2YWx1ZXMgPSBfcmVmLnZhbHVlcztcblxuICAgIGlmIChkaWZmZXJlbmNlcyAmJiBkaWZmZXJlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nKF9kZWZpbmVQcm9wZXJ0eSh7fSwgZGlzcGxheU5hbWUsIENvbXBvbmVudCksIFwiXCIuY29uY2F0KHByZWZpeE1lc3NhZ2UsIFwiIG9mIFwiKS5jb25jYXQoZGlmZk9ialR5cGUsIFwiIGNoYW5nZXM6XCIpKTtcbiAgICAgIGRpZmZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gX3JlZjIucGF0aFN0cmluZyxcbiAgICAgICAgICAgIGRpZmZUeXBlID0gX3JlZjIuZGlmZlR5cGUsXG4gICAgICAgICAgICBwcmV2VmFsdWUgPSBfcmVmMi5wcmV2VmFsdWUsXG4gICAgICAgICAgICBuZXh0VmFsdWUgPSBfcmVmMi5uZXh0VmFsdWU7XG5cbiAgICAgICAgZnVuY3Rpb24gZGlmZkZuKCkge1xuICAgICAgICAgIHByaW50RGlmZihwcmV2VmFsdWUsIG5leHRWYWx1ZSwge1xuICAgICAgICAgICAgcGF0aFN0cmluZzogcGF0aFN0cmluZyxcbiAgICAgICAgICAgIGNvbnNvbGVMb2c6IHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVMb2dcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVHcm91cChcIiVjXCIuY29uY2F0KGRpZmZPYmpUeXBlID09PSAnaG9vaycgPyBcIltob29rIFwiLmNvbmNhdChob29rTmFtZSwgXCIgcmVzdWx0XVwiKSA6IFwiXCIuY29uY2F0KGRpZmZPYmpUeXBlLCBcIi5cIiksIFwiJWNcIikuY29uY2F0KHBhdGhTdHJpbmcsIFwiJWNcIiksIFwiY29sb3I6XCIuY29uY2F0KHdkeXJTdG9yZS5vcHRpb25zLmRpZmZOYW1lQ29sb3IsIFwiO1wiKSwgXCJjb2xvcjpcIi5jb25jYXQod2R5clN0b3JlLm9wdGlvbnMuZGlmZlBhdGhDb2xvciwgXCI7XCIpLCAnY29sb3I6ZGVmYXVsdDsnKTtcbiAgICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUxvZyhcIlwiLmNvbmNhdChkaWZmVHlwZXNEZXNjcmlwdGlvbnNbZGlmZlR5cGVdLCBcIi4gKG1vcmUgaW5mbyBhdCBcIikuY29uY2F0KGhvb2tOYW1lID8gbW9yZUluZm9Ib29rc1VybCA6IG1vcmVJbmZvVXJsLCBcIilcIikpO1xuICAgICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nKF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwcmV2IFwiLmNvbmNhdChwYXRoU3RyaW5nKSwgcHJldlZhbHVlKSwgJyE9PScsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJuZXh0IFwiLmNvbmNhdChwYXRoU3RyaW5nKSwgbmV4dFZhbHVlKSk7XG5cbiAgICAgICAgaWYgKGRpZmZUeXBlID09PSBkaWZmVHlwZXMuZGVlcEVxdWFscykge1xuICAgICAgICAgIHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVMb2coe1xuICAgICAgICAgICAgJ0ZvciBkZXRhaWxlZCBkaWZmLCByaWdodCBjbGljayB0aGUgZm9sbG93aW5nIGZuLCBzYXZlIGFzIGdsb2JhbCwgYW5kIHJ1bjogJzogZGlmZkZuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlR3JvdXBFbmQoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGlmZmVyZW5jZXMpIHtcbiAgICAgIHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVMb2coX2RlZmluZVByb3BlcnR5KHt9LCBkaXNwbGF5TmFtZSwgQ29tcG9uZW50KSwgXCJcIi5jb25jYXQocHJlZml4TWVzc2FnZSwgXCIgdGhlIFwiKS5jb25jYXQoZGlmZk9ialR5cGUsIFwiIG9iamVjdCBpdHNlbGYgY2hhbmdlZCBidXQgaXRzIHZhbHVlcyBhcmUgYWxsIGVxdWFsLlwiKSwgZGlmZk9ialR5cGUgPT09ICdwcm9wcycgPyAnVGhpcyBjb3VsZCBoYXZlIGJlZW4gYXZvaWRlZCBieSBtYWtpbmcgdGhlIGNvbXBvbmVudCBwdXJlLCBvciBieSBwcmV2ZW50aW5nIGl0cyBmYXRoZXIgZnJvbSByZS1yZW5kZXJpbmcuJyA6ICdUaGlzIHVzdWFsbHkgbWVhbnMgdGhpcyBjb21wb25lbnQgY2FsbGVkIHNldFN0YXRlIHdoZW4gbm8gY2hhbmdlcyBpbiBpdHMgc3RhdGUgYWN0dWFsbHkgb2NjdXJyZWQuJywgXCJNb3JlIGluZm8gYXQgXCIuY29uY2F0KG1vcmVJbmZvVXJsKSk7XG4gICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nKFwicHJldiBcIi5jb25jYXQoZGlmZk9ialR5cGUsIFwiOlwiKSwgdmFsdWVzLnByZXYsICcgIT09ICcsIHZhbHVlcy5uZXh0LCBcIjpuZXh0IFwiLmNvbmNhdChkaWZmT2JqVHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHROb3RpZmllcih1cGRhdGVJbmZvKSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHVwZGF0ZUluZm8uQ29tcG9uZW50LFxuICAgICAgICBkaXNwbGF5TmFtZSA9IHVwZGF0ZUluZm8uZGlzcGxheU5hbWUsXG4gICAgICAgIGhvb2tOYW1lID0gdXBkYXRlSW5mby5ob29rTmFtZSxcbiAgICAgICAgcHJldlByb3BzID0gdXBkYXRlSW5mby5wcmV2UHJvcHMsXG4gICAgICAgIHByZXZTdGF0ZSA9IHVwZGF0ZUluZm8ucHJldlN0YXRlLFxuICAgICAgICBwcmV2SG9vayA9IHVwZGF0ZUluZm8ucHJldkhvb2ssXG4gICAgICAgIG5leHRQcm9wcyA9IHVwZGF0ZUluZm8ubmV4dFByb3BzLFxuICAgICAgICBuZXh0U3RhdGUgPSB1cGRhdGVJbmZvLm5leHRTdGF0ZSxcbiAgICAgICAgbmV4dEhvb2sgPSB1cGRhdGVJbmZvLm5leHRIb29rLFxuICAgICAgICByZWFzb24gPSB1cGRhdGVJbmZvLnJlYXNvbjtcblxuICAgIGlmICghc2hvdWxkTG9nKHJlYXNvbiwgQ29tcG9uZW50LCB3ZHlyU3RvcmUub3B0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlR3JvdXAoXCIlY1wiLmNvbmNhdChkaXNwbGF5TmFtZSksIFwiY29sb3I6IFwiLmNvbmNhdCh3ZHlyU3RvcmUub3B0aW9ucy50aXRsZUNvbG9yLCBcIjtcIikpO1xuICAgIHZhciBwcmVmaXhNZXNzYWdlID0gJ1JlLXJlbmRlcmVkIGJlY2F1c2UnO1xuXG4gICAgaWYgKHJlYXNvbi5wcm9wc0RpZmZlcmVuY2VzKSB7XG4gICAgICBsb2dEaWZmZXJlbmNlKHtcbiAgICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgcHJlZml4TWVzc2FnZTogcHJlZml4TWVzc2FnZSxcbiAgICAgICAgZGlmZk9ialR5cGU6ICdwcm9wcycsXG4gICAgICAgIGRpZmZlcmVuY2VzOiByZWFzb24ucHJvcHNEaWZmZXJlbmNlcyxcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgcHJldjogcHJldlByb3BzLFxuICAgICAgICAgIG5leHQ6IG5leHRQcm9wc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHByZWZpeE1lc3NhZ2UgPSAnQW5kIGJlY2F1c2UnO1xuICAgIH1cblxuICAgIGlmIChyZWFzb24uc3RhdGVEaWZmZXJlbmNlcykge1xuICAgICAgbG9nRGlmZmVyZW5jZSh7XG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuICAgICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIHByZWZpeE1lc3NhZ2U6IHByZWZpeE1lc3NhZ2UsXG4gICAgICAgIGRpZmZPYmpUeXBlOiAnc3RhdGUnLFxuICAgICAgICBkaWZmZXJlbmNlczogcmVhc29uLnN0YXRlRGlmZmVyZW5jZXMsXG4gICAgICAgIHZhbHVlczoge1xuICAgICAgICAgIHByZXY6IHByZXZTdGF0ZSxcbiAgICAgICAgICBuZXh0OiBuZXh0U3RhdGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5ob29rRGlmZmVyZW5jZXMpIHtcbiAgICAgIGxvZ0RpZmZlcmVuY2Uoe1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBwcmVmaXhNZXNzYWdlOiBwcmVmaXhNZXNzYWdlLFxuICAgICAgICBkaWZmT2JqVHlwZTogJ2hvb2snLFxuICAgICAgICBkaWZmZXJlbmNlczogcmVhc29uLmhvb2tEaWZmZXJlbmNlcyxcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgcHJldjogcHJldkhvb2ssXG4gICAgICAgICAgbmV4dDogbmV4dEhvb2tcbiAgICAgICAgfSxcbiAgICAgICAgaG9va05hbWU6IGhvb2tOYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVhc29uLnByb3BzRGlmZmVyZW5jZXMgJiYgcmVhc29uLm93bmVyRGlmZmVyZW5jZXMpIHtcbiAgICAgIHZhciBwcmV2T3duZXJEYXRhID0gd2R5clN0b3JlLm93bmVyRGF0YU1hcC5nZXQocHJldlByb3BzKTtcbiAgICAgIHZhciBuZXh0T3duZXJEYXRhID0gd2R5clN0b3JlLm93bmVyRGF0YU1hcC5nZXQobmV4dFByb3BzKTtcbiAgICAgIHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVHcm91cChcIlJlbmRlcmVkIGJ5IFwiLmNvbmNhdChuZXh0T3duZXJEYXRhLmRpc3BsYXlOYW1lKSk7XG4gICAgICB2YXIgX3ByZWZpeE1lc3NhZ2UgPSAnUmUtcmVuZGVyZWQgYmVjYXVzZSc7XG5cbiAgICAgIGlmIChyZWFzb24ub3duZXJEaWZmZXJlbmNlcy5wcm9wc0RpZmZlcmVuY2VzKSB7XG4gICAgICAgIGxvZ0RpZmZlcmVuY2Uoe1xuICAgICAgICAgIENvbXBvbmVudDogbmV4dE93bmVyRGF0YS5Db21wb25lbnQsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IG5leHRPd25lckRhdGEuZGlzcGxheU5hbWUsXG4gICAgICAgICAgcHJlZml4TWVzc2FnZTogX3ByZWZpeE1lc3NhZ2UsXG4gICAgICAgICAgZGlmZk9ialR5cGU6ICdwcm9wcycsXG4gICAgICAgICAgZGlmZmVyZW5jZXM6IHJlYXNvbi5vd25lckRpZmZlcmVuY2VzLnByb3BzRGlmZmVyZW5jZXMsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBwcmV2OiBwcmV2T3duZXJEYXRhLnByb3BzLFxuICAgICAgICAgICAgbmV4dDogbmV4dE93bmVyRGF0YS5wcm9wc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF9wcmVmaXhNZXNzYWdlID0gJ0FuZCBiZWNhdXNlJztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYXNvbi5vd25lckRpZmZlcmVuY2VzLnN0YXRlRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgbG9nRGlmZmVyZW5jZSh7XG4gICAgICAgICAgQ29tcG9uZW50OiBuZXh0T3duZXJEYXRhLkNvbXBvbmVudCxcbiAgICAgICAgICBkaXNwbGF5TmFtZTogbmV4dE93bmVyRGF0YS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICBwcmVmaXhNZXNzYWdlOiBfcHJlZml4TWVzc2FnZSxcbiAgICAgICAgICBkaWZmT2JqVHlwZTogJ3N0YXRlJyxcbiAgICAgICAgICBkaWZmZXJlbmNlczogcmVhc29uLm93bmVyRGlmZmVyZW5jZXMuc3RhdGVEaWZmZXJlbmNlcyxcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHByZXY6IHByZXZPd25lckRhdGEuc3RhdGUsXG4gICAgICAgICAgICBuZXh0OiBuZXh0T3duZXJEYXRhLnN0YXRlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYXNvbi5vd25lckRpZmZlcmVuY2VzLmhvb2tEaWZmZXJlbmNlcykge1xuICAgICAgICByZWFzb24ub3duZXJEaWZmZXJlbmNlcy5ob29rRGlmZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMsIGkpIHtcbiAgICAgICAgICB2YXIgaG9va05hbWUgPSBfcmVmMy5ob29rTmFtZSxcbiAgICAgICAgICAgICAgZGlmZmVyZW5jZXMgPSBfcmVmMy5kaWZmZXJlbmNlcztcbiAgICAgICAgICByZXR1cm4gbG9nRGlmZmVyZW5jZSh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IG5leHRPd25lckRhdGEuQ29tcG9uZW50LFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5leHRPd25lckRhdGEuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICBwcmVmaXhNZXNzYWdlOiBfcHJlZml4TWVzc2FnZSxcbiAgICAgICAgICAgIGRpZmZPYmpUeXBlOiAnaG9vaycsXG4gICAgICAgICAgICBkaWZmZXJlbmNlczogZGlmZmVyZW5jZXMsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgcHJldjogcHJldk93bmVyRGF0YS5ob29rc1tpXS5yZXN1bHQsXG4gICAgICAgICAgICAgIG5leHQ6IG5leHRPd25lckRhdGEuaG9va3NbaV0ucmVzdWx0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaG9va05hbWU6IGhvb2tOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlR3JvdXBFbmQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlYXNvbi5wcm9wc0RpZmZlcmVuY2VzICYmICFyZWFzb24uc3RhdGVEaWZmZXJlbmNlcyAmJiAhcmVhc29uLmhvb2tEaWZmZXJlbmNlcykge1xuICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUxvZyhfZGVmaW5lUHJvcGVydHkoe30sIGRpc3BsYXlOYW1lLCBDb21wb25lbnQpLCAnUmUtcmVuZGVyZWQgYWx0aG91Z2ggcHJvcHMgYW5kIHN0YXRlIG9iamVjdHMgYXJlIHRoZSBzYW1lLicsICdUaGlzIHVzdWFsbHkgbWVhbnMgdGhlcmUgd2FzIGEgY2FsbCB0byB0aGlzLmZvcmNlVXBkYXRlKCkgaW5zaWRlIHRoZSBjb21wb25lbnQuJywgXCJtb3JlIGluZm8gYXQgXCIuY29uY2F0KG1vcmVJbmZvVXJsKSk7XG4gICAgfVxuXG4gICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUdyb3VwRW5kKCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE5vdGlmaWVyKGhvdFJlbG9hZEJ1ZmZlck1zKSB7XG4gICAgaWYgKGhvdFJlbG9hZEJ1ZmZlck1zKSB7XG4gICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhvdCAmJiBtb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIpIHtcbiAgICAgICAgbW9kdWxlLmhvdC5hZGRTdGF0dXNIYW5kbGVyKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgIGluSG90UmVsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpbkhvdFJlbG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgaG90UmVsb2FkQnVmZmVyTXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHROb3RpZmllcjtcbiAgfVxuXG4gIHZhciBlbXB0eUZuID0gZnVuY3Rpb24gZW1wdHlGbigpIHt9O1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMoKSB7XG4gICAgdmFyIHVzZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgY29uc29sZUdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICB2YXIgY29uc29sZUdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcblxuICAgIGlmICh1c2VyT3B0aW9ucy5jb2xsYXBzZUdyb3Vwcykge1xuICAgICAgY29uc29sZUdyb3VwID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICB9IGVsc2UgaWYgKHVzZXJPcHRpb25zLm9ubHlMb2dzKSB7XG4gICAgICBjb25zb2xlR3JvdXAgPSBjb25zb2xlLmxvZztcbiAgICAgIGNvbnNvbGVHcm91cEVuZCA9IGVtcHR5Rm47XG4gICAgfVxuXG4gICAgdmFyIG5vdGlmaWVyID0gdXNlck9wdGlvbnMubm90aWZpZXIgfHwgY3JlYXRlRGVmYXVsdE5vdGlmaWVyKCdob3RSZWxvYWRCdWZmZXJNcycgaW4gdXNlck9wdGlvbnMgPyB1c2VyT3B0aW9ucy5ob3RSZWxvYWRCdWZmZXJNcyA6IDUwMCk7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGluY2x1ZGU6IG51bGwsXG4gICAgICBleGNsdWRlOiBudWxsLFxuICAgICAgbm90aWZpZXI6IG5vdGlmaWVyLFxuICAgICAgb25seUxvZ3M6IGZhbHNlLFxuICAgICAgY29uc29sZUxvZzogY29uc29sZS5sb2csXG4gICAgICBjb25zb2xlR3JvdXA6IGNvbnNvbGVHcm91cCxcbiAgICAgIGNvbnNvbGVHcm91cEVuZDogY29uc29sZUdyb3VwRW5kLFxuICAgICAgbG9nT25EaWZmZXJlbnRWYWx1ZXM6IGZhbHNlLFxuICAgICAgbG9nT3duZXJSZWFzb25zOiB0cnVlLFxuICAgICAgdHJhY2tIb29rczogdHJ1ZSxcbiAgICAgIHRpdGxlQ29sb3I6ICcjMDU4JyxcbiAgICAgIGRpZmZOYW1lQ29sb3I6ICdibHVlJyxcbiAgICAgIGRpZmZQYXRoQ29sb3I6ICdyZWQnLFxuICAgICAgdHJhY2tFeHRyYUhvb2tzOiBbXSxcbiAgICAgIHRyYWNrQWxsUHVyZUNvbXBvbmVudHM6IGZhbHNlXG4gICAgfSwgdXNlck9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUodHlwZSkge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCB0eXBlLnR5cGUgJiYgZ2V0RGlzcGxheU5hbWUodHlwZS50eXBlKSB8fCB0eXBlLnJlbmRlciAmJiBnZXREaXNwbGF5TmFtZSh0eXBlLnJlbmRlcikgfHwgKGxvZGFzaC5pc1N0cmluZyh0eXBlKSA/IHR5cGUgOiAnVW5rbm93bicpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5kZWZhdWx0UHJvcHMgfHwgdHlwZS50eXBlICYmIGdldERlZmF1bHRQcm9wcyh0eXBlLnR5cGUpIHx8IHR5cGUucmVuZGVyICYmIGdldERlZmF1bHRQcm9wcyh0eXBlLnJlbmRlcikgfHwge307XG4gIH1cblxuICB2YXIgZW1wdHlPYmplY3QgPSB7fTtcbiAgZnVuY3Rpb24gZmluZE9iamVjdHNEaWZmZXJlbmNlcyh1c2VyUHJldk9iaiwgdXNlck5leHRPYmopIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgIF9yZWYkc2hhbGxvdyA9IF9yZWYuc2hhbGxvdyxcbiAgICAgICAgc2hhbGxvdyA9IF9yZWYkc2hhbGxvdyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkc2hhbGxvdztcblxuICAgIGlmICh1c2VyUHJldk9iaiA9PT0gdXNlck5leHRPYmopIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgIHJldHVybiBjYWxjdWxhdGVEZWVwRXF1YWxEaWZmcyh1c2VyUHJldk9iaiwgdXNlck5leHRPYmopO1xuICAgIH1cblxuICAgIHZhciBwcmV2T2JqID0gdXNlclByZXZPYmogfHwgZW1wdHlPYmplY3Q7XG4gICAgdmFyIG5leHRPYmogPSB1c2VyTmV4dE9iaiB8fCBlbXB0eU9iamVjdDtcbiAgICB2YXIga2V5c09mQm90aE9iamVjdHMgPSBPYmplY3Qua2V5cyhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcHJldk9iaiksIG5leHRPYmopKTtcbiAgICByZXR1cm4gbG9kYXNoLnJlZHVjZShrZXlzT2ZCb3RoT2JqZWN0cywgZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICB2YXIgZGVlcEVxdWFsRGlmZnMgPSBjYWxjdWxhdGVEZWVwRXF1YWxEaWZmcyhwcmV2T2JqW2tleV0sIG5leHRPYmpba2V5XSwga2V5KTtcblxuICAgICAgaWYgKGRlZXBFcXVhbERpZmZzKSB7XG4gICAgICAgIHJlc3VsdCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0KSwgX3RvQ29uc3VtYWJsZUFycmF5KGRlZXBFcXVhbERpZmZzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3duZXJEaWZmZXJlbmNlcyhfcmVmKSB7XG4gICAgdmFyIHByZXZPd25lckRhdGEgPSBfcmVmLnByZXZPd25lckRhdGEsXG4gICAgICAgIG5leHRPd25lckRhdGEgPSBfcmVmLm5leHRPd25lckRhdGE7XG5cbiAgICBpZiAoIXByZXZPd25lckRhdGEgfHwgIW5leHRPd25lckRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGluIHN0cmljdCBtb2RlIHByZXZPd25lckRhdGEgbWlnaHQgYmUgdHdpY2UgYXMgbGVuZ3RoeSBiZWNhdXNlIG9mIGRvdWJsZSByZW5kZXJzXG5cblxuICAgIHZhciBwcmV2T3duZXJEYXRhSG9va3MgPSBwcmV2T3duZXJEYXRhLmhvb2tzLmxlbmd0aCA9PT0gbmV4dE93bmVyRGF0YS5ob29rcy5sZW5ndGggKiAyID8gcHJldk93bmVyRGF0YS5ob29rcy5zbGljZShwcmV2T3duZXJEYXRhLmhvb2tzLmxlbmd0aCAvIDIpIDogcHJldk93bmVyRGF0YS5ob29rcztcbiAgICB2YXIgaG9va0RpZmZlcmVuY2VzID0gcHJldk93bmVyRGF0YUhvb2tzLm1hcChmdW5jdGlvbiAoX3JlZjIsIGkpIHtcbiAgICAgIHZhciBob29rTmFtZSA9IF9yZWYyLmhvb2tOYW1lLFxuICAgICAgICAgIHJlc3VsdCA9IF9yZWYyLnJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhvb2tOYW1lOiBob29rTmFtZSxcbiAgICAgICAgZGlmZmVyZW5jZXM6IGZpbmRPYmplY3RzRGlmZmVyZW5jZXMocmVzdWx0LCBuZXh0T3duZXJEYXRhLmhvb2tzW2ldLnJlc3VsdCwge1xuICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wc0RpZmZlcmVuY2VzOiBmaW5kT2JqZWN0c0RpZmZlcmVuY2VzKHByZXZPd25lckRhdGEucHJvcHMsIG5leHRPd25lckRhdGEucHJvcHMpLFxuICAgICAgc3RhdGVEaWZmZXJlbmNlczogZmluZE9iamVjdHNEaWZmZXJlbmNlcyhwcmV2T3duZXJEYXRhLnN0YXRlLCBuZXh0T3duZXJEYXRhLnN0YXRlKSxcbiAgICAgIGhvb2tEaWZmZXJlbmNlczogaG9va0RpZmZlcmVuY2VzLmxlbmd0aCA+IDAgPyBob29rRGlmZmVyZW5jZXMgOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRVcGRhdGVSZWFzb24ocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZIb29rLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dEhvb2spIHtcbiAgICB2YXIgcHJldk93bmVyRGF0YSA9IHdkeXJTdG9yZS5vd25lckRhdGFNYXAuZ2V0KHByZXZQcm9wcyk7XG4gICAgdmFyIG5leHRPd25lckRhdGEgPSB3ZHlyU3RvcmUub3duZXJEYXRhTWFwLmdldChuZXh0UHJvcHMpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wc0RpZmZlcmVuY2VzOiBmaW5kT2JqZWN0c0RpZmZlcmVuY2VzKHByZXZQcm9wcywgbmV4dFByb3BzKSxcbiAgICAgIHN0YXRlRGlmZmVyZW5jZXM6IGZpbmRPYmplY3RzRGlmZmVyZW5jZXMocHJldlN0YXRlLCBuZXh0U3RhdGUpLFxuICAgICAgaG9va0RpZmZlcmVuY2VzOiBmaW5kT2JqZWN0c0RpZmZlcmVuY2VzKHByZXZIb29rLCBuZXh0SG9vaywge1xuICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgfSksXG4gICAgICBvd25lckRpZmZlcmVuY2VzOiBnZXRPd25lckRpZmZlcmVuY2VzKHtcbiAgICAgICAgcHJldk93bmVyRGF0YTogcHJldk93bmVyRGF0YSxcbiAgICAgICAgbmV4dE93bmVyRGF0YTogbmV4dE93bmVyRGF0YVxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlSW5mbyhfcmVmMykge1xuICAgIHZhciBDb21wb25lbnQgPSBfcmVmMy5Db21wb25lbnQsXG4gICAgICAgIGRpc3BsYXlOYW1lID0gX3JlZjMuZGlzcGxheU5hbWUsXG4gICAgICAgIGhvb2tOYW1lID0gX3JlZjMuaG9va05hbWUsXG4gICAgICAgIHByZXZQcm9wcyA9IF9yZWYzLnByZXZQcm9wcyxcbiAgICAgICAgcHJldlN0YXRlID0gX3JlZjMucHJldlN0YXRlLFxuICAgICAgICBwcmV2SG9vayA9IF9yZWYzLnByZXZIb29rLFxuICAgICAgICBuZXh0UHJvcHMgPSBfcmVmMy5uZXh0UHJvcHMsXG4gICAgICAgIG5leHRTdGF0ZSA9IF9yZWYzLm5leHRTdGF0ZSxcbiAgICAgICAgbmV4dEhvb2sgPSBfcmVmMy5uZXh0SG9vaztcbiAgICByZXR1cm4ge1xuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBob29rTmFtZTogaG9va05hbWUsXG4gICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZTogcHJldlN0YXRlLFxuICAgICAgcHJldkhvb2s6IHByZXZIb29rLFxuICAgICAgbmV4dFByb3BzOiBuZXh0UHJvcHMsXG4gICAgICBuZXh0U3RhdGU6IG5leHRTdGF0ZSxcbiAgICAgIG5leHRIb29rOiBuZXh0SG9vayxcbiAgICAgIHJlYXNvbjogZ2V0VXBkYXRlUmVhc29uKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2SG9vaywgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRIb29rKVxuICAgIH07XG4gIH1cblxuICAvLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RUeXBlT2ZNb2RlLmpzXG4gIC8vIG5vdGljZTogdGhpcyBpcyBvbmx5IHVzZWQgZm9yIGNsYXNzIGNvbXBvbmVudHMuIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkb2Vzbid0IHJlbmRlciB0d2ljZSBpbnNpZGUgc3RyaWN0IG1vZGVcblxuICBmdW5jdGlvbiBjaGVja0lmSW5zaWRlQVN0cmljdE1vZGVUcmVlKHJlYWN0Q29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICB2YXIgcmVhY3RJbnRlcm5hbEZpYmVyID0gcmVhY3RDb21wb25lbnRJbnN0YW5jZSAmJiAocmVhY3RDb21wb25lbnRJbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEZpYmVyIHx8IHJlYWN0Q29tcG9uZW50SW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxzKTtcblxuICAgIHdoaWxlIChyZWFjdEludGVybmFsRmliZXIpIHtcbiAgICAgIGlmIChyZWFjdEludGVybmFsRmliZXIubW9kZSAmIFJFQUNUX1NUUklDVF9NT0RFKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZWFjdEludGVybmFsRmliZXIgPSByZWFjdEludGVybmFsRmliZXJbXCJyZXR1cm5cIl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVhY3RDbGFzc0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZSAmJiAhIUNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbiAgfVxuICBmdW5jdGlvbiBpc01lbW9Db21wb25lbnQoQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFO1xuICB9XG4gIGZ1bmN0aW9uIGlzRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50LiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW5jbHVkZShkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiB3ZHlyU3RvcmUub3B0aW9ucy5pbmNsdWRlICYmIHdkeXJTdG9yZS5vcHRpb25zLmluY2x1ZGUubGVuZ3RoID4gMCAmJiB3ZHlyU3RvcmUub3B0aW9ucy5pbmNsdWRlLnNvbWUoZnVuY3Rpb24gKHJlZ2V4KSB7XG4gICAgICByZXR1cm4gcmVnZXgudGVzdChkaXNwbGF5TmFtZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRFeGNsdWRlKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIHdkeXJTdG9yZS5vcHRpb25zLmV4Y2x1ZGUgJiYgd2R5clN0b3JlLm9wdGlvbnMuZXhjbHVkZS5sZW5ndGggPiAwICYmIHdkeXJTdG9yZS5vcHRpb25zLmV4Y2x1ZGUuc29tZShmdW5jdGlvbiAocmVnZXgpIHtcbiAgICAgIHJldHVybiByZWdleC50ZXN0KGRpc3BsYXlOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFRyYWNrKENvbXBvbmVudCwgX3JlZikge1xuICAgIHZhciBpc0hvb2tDaGFuZ2UgPSBfcmVmLmlzSG9va0NoYW5nZTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuXG4gICAgaWYgKHNob3VsZEV4Y2x1ZGUoZGlzcGxheU5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKENvbXBvbmVudC53aHlEaWRZb3VSZW5kZXIgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzSG9va0NoYW5nZSAmJiBDb21wb25lbnQud2h5RGlkWW91UmVuZGVyICYmIENvbXBvbmVudC53aHlEaWRZb3VSZW5kZXIudHJhY2tIb29rcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEoQ29tcG9uZW50LndoeURpZFlvdVJlbmRlciB8fCB3ZHlyU3RvcmUub3B0aW9ucy50cmFja0FsbFB1cmVDb21wb25lbnRzICYmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIHdkeXJTdG9yZS5SZWFjdC5QdXJlQ29tcG9uZW50IHx8IGlzTWVtb0NvbXBvbmVudChDb21wb25lbnQpKSB8fCBzaG91bGRJbmNsdWRlKGRpc3BsYXlOYW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaENsYXNzQ29tcG9uZW50KENsYXNzQ29tcG9uZW50LCBfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgZGVmYXVsdFByb3BzID0gX3JlZi5kZWZhdWx0UHJvcHM7XG5cbiAgICB2YXIgV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NsYXNzQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHMoV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudCwgX0NsYXNzQ29tcG9uZW50KTtcblxuICAgICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihXRFlSUGF0Y2hlZENsYXNzQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXNTdXBlciwgX3RoaXM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQpO1xuXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBfdGhpcy5fV0RZUiA9IHtcbiAgICAgICAgICByZW5kZXJOdW1iZXI6IDBcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb3JpZ1JlbmRlciA9IF9nZXQoKF90aGlzU3VwZXIgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgX2dldFByb3RvdHlwZU9mKFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQucHJvdG90eXBlKSksIFwicmVuZGVyXCIsIF90aGlzU3VwZXIpIHx8IF90aGlzLnJlbmRlcjsgLy8gdGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHJlbmRlciBpcyBhbiBhcnJvdyBmdW5jdGlvbiBvciB0aGlzLnJlbmRlci5iaW5kKHRoaXMpIHdhcyBjYWxsZWQgb24gdGhlIG9yaWdpbmFsIGNsYXNzXG5cblxuICAgICAgICB2YXIgcmVuZGVySXNBQmluZGVkRnVuY3Rpb24gPSBvcmlnUmVuZGVyICE9PSBDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyO1xuXG4gICAgICAgIGlmIChyZW5kZXJJc0FCaW5kZWRGdW5jdGlvbikge1xuICAgICAgICAgIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlci5hcHBseShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ1JlbmRlcigpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhXRFlSUGF0Y2hlZENsYXNzQ29tcG9uZW50LCBbe1xuICAgICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgdGhpcy5fV0RZUi5yZW5kZXJOdW1iZXIrKztcblxuICAgICAgICAgIGlmICghKCdpc1N0cmljdE1vZGUnIGluIHRoaXMuX1dEWVIpKSB7XG4gICAgICAgICAgICB0aGlzLl9XRFlSLmlzU3RyaWN0TW9kZSA9IGNoZWNrSWZJbnNpZGVBU3RyaWN0TW9kZVRyZWUodGhpcyk7XG4gICAgICAgICAgfSAvLyBpbiBzdHJpY3QgbW9kZS0gaWdub3JlIGV2ZXJ5IG90aGVyIHJlbmRlclxuXG5cbiAgICAgICAgICBpZiAoISh0aGlzLl9XRFlSLmlzU3RyaWN0TW9kZSAmJiB0aGlzLl9XRFlSLnJlbmRlck51bWJlciAlIDIgPT09IDEpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fV0RZUi5wcmV2UHJvcHMpIHtcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZUluZm8gPSBnZXRVcGRhdGVJbmZvKHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQ6IENsYXNzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHRoaXMuX1dEWVIucHJldlByb3BzLFxuICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogdGhpcy5fV0RZUi5wcmV2U3RhdGUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZTogdGhpcy5zdGF0ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd2R5clN0b3JlLm9wdGlvbnMubm90aWZpZXIodXBkYXRlSW5mbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX1dEWVIucHJldlByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX1dEWVIucHJldlN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUpLCBcInJlbmRlclwiLCB0aGlzKSA/IF9nZXQoX2dldFByb3RvdHlwZU9mKFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQucHJvdG90eXBlKSwgXCJyZW5kZXJcIiwgdGhpcykuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQ7XG4gICAgfShDbGFzc0NvbXBvbmVudCk7XG5cbiAgICB0cnkge1xuICAgICAgV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIH0gY2F0Y2ggKGUpIHsvLyBub3QgY3J1Y2lhbCBpZiBkaXNwbGF5TmFtZSBjb3VsZG4ndCBiZSBzZXRcbiAgICB9XG5cbiAgICBXRFlSUGF0Y2hlZENsYXNzQ29tcG9uZW50LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiAgICBsb2Rhc2guZGVmYXVsdHMoV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudCwgQ2xhc3NDb21wb25lbnQpO1xuICAgIHJldHVybiBXRFlSUGF0Y2hlZENsYXNzQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIGdldEZ1bmN0aW9uYWxDb21wb25lbnRGcm9tU3RyaW5nQ29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0RnVuY3Rpb25hbENvbXBvbmVudEZyb21TdHJpbmdDb21wb25lbnQoY29tcG9uZW50VHlwZVN0cikge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHJldHVybiB3ZHlyU3RvcmUuUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnRUeXBlU3RyLCBwcm9wcyk7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXRjaEZ1bmN0aW9uYWxPclN0ckNvbXBvbmVudChGdW5jdGlvbmFsT3JTdHJpbmdDb21wb25lbnQsIF9yZWYpIHtcbiAgICB2YXIgaXNQdXJlID0gX3JlZi5pc1B1cmUsXG4gICAgICAgIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgZGVmYXVsdFByb3BzID0gX3JlZi5kZWZhdWx0UHJvcHM7XG4gICAgdmFyIEZ1bmN0aW9uYWxDb21wb25lbnQgPSB0eXBlb2YgRnVuY3Rpb25hbE9yU3RyaW5nQ29tcG9uZW50ID09PSAnc3RyaW5nJyA/IGdldEZ1bmN0aW9uYWxDb21wb25lbnRGcm9tU3RyaW5nQ29tcG9uZW50KEZ1bmN0aW9uYWxPclN0cmluZ0NvbXBvbmVudCkgOiBGdW5jdGlvbmFsT3JTdHJpbmdDb21wb25lbnQ7XG5cbiAgICBmdW5jdGlvbiBXRFlSRnVuY3Rpb25hbENvbXBvbmVudCgpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcmVmID0gd2R5clN0b3JlLlJlYWN0LnVzZVJlZigpO1xuICAgICAgdmFyIHByZXZQcm9wcyA9IHJlZi5jdXJyZW50O1xuICAgICAgcmVmLmN1cnJlbnQgPSBuZXh0UHJvcHM7XG5cbiAgICAgIGlmIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZUluZm8gPSBnZXRVcGRhdGVJbmZvKHtcbiAgICAgICAgICBDb21wb25lbnQ6IEZ1bmN0aW9uYWxDb21wb25lbnQsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgIG5leHRQcm9wczogbmV4dFByb3BzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm90aWZpZWRCeUhvb2tzID0gIXVwZGF0ZUluZm8ucmVhc29uLnByb3BzRGlmZmVyZW5jZXMgfHwgaXNQdXJlICYmIHVwZGF0ZUluZm8ucmVhc29uLnByb3BzRGlmZmVyZW5jZXMubGVuZ3RoID09PSAwO1xuXG4gICAgICAgIGlmICghbm90aWZpZWRCeUhvb2tzKSB7XG4gICAgICAgICAgd2R5clN0b3JlLm9wdGlvbnMubm90aWZpZXIodXBkYXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEZ1bmN0aW9uYWxDb21wb25lbnQuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBXRFlSRnVuY3Rpb25hbENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIH0gY2F0Y2ggKGUpIHsvLyBub3QgY3J1Y2lhbCBpZiBkaXNwbGF5TmFtZSBjb3VsZG4ndCBiZSBzZXRcbiAgICB9XG5cbiAgICBXRFlSRnVuY3Rpb25hbENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gICAgV0RZUkZ1bmN0aW9uYWxDb21wb25lbnQuQ29tcG9uZW50Rm9ySG9va3NUcmFja2luZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgbG9kYXNoLmRlZmF1bHRzKFdEWVJGdW5jdGlvbmFsQ29tcG9uZW50LCBGdW5jdGlvbmFsQ29tcG9uZW50KTtcbiAgICByZXR1cm4gV0RZUkZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaE1lbW9Db21wb25lbnQoTWVtb0NvbXBvbmVudCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWUsXG4gICAgICAgIGRlZmF1bHRQcm9wcyA9IF9yZWYuZGVmYXVsdFByb3BzO1xuICAgIHZhciBJbm5lck1lbW9Db21wb25lbnQgPSBNZW1vQ29tcG9uZW50LnR5cGU7XG4gICAgdmFyIGlzSW5uZXJNZW1vQ29tcG9uZW50QUNsYXNzQ29tcG9uZW50ID0gaXNSZWFjdENsYXNzQ29tcG9uZW50KElubmVyTWVtb0NvbXBvbmVudCk7XG4gICAgdmFyIGlzSW5uZXJNZW1vQ29tcG9uZW50Rm9yd2FyZFJlZnMgPSBpc0ZvcndhcmRSZWZDb21wb25lbnQoSW5uZXJNZW1vQ29tcG9uZW50KTtcbiAgICB2YXIgaXNJbm5lck1lbW9Db21wb25lbnRBbm90aGVyTWVtb0NvbXBvbmVudCA9IGlzTWVtb0NvbXBvbmVudChJbm5lck1lbW9Db21wb25lbnQpO1xuICAgIHZhciBXcmFwcGVkRnVuY3Rpb25hbENvbXBvbmVudCA9IGlzSW5uZXJNZW1vQ29tcG9uZW50Rm9yd2FyZFJlZnMgPyBJbm5lck1lbW9Db21wb25lbnQucmVuZGVyIDogSW5uZXJNZW1vQ29tcG9uZW50O1xuICAgIHZhciBQYXRjaGVkSW5uZXJDb21wb25lbnQgPSBpc0lubmVyTWVtb0NvbXBvbmVudEFDbGFzc0NvbXBvbmVudCA/IHBhdGNoQ2xhc3NDb21wb25lbnQoV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQsIHtcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIGRlZmF1bHRQcm9wczogZGVmYXVsdFByb3BzXG4gICAgfSkgOiBpc0lubmVyTWVtb0NvbXBvbmVudEFub3RoZXJNZW1vQ29tcG9uZW50ID8gcGF0Y2hNZW1vQ29tcG9uZW50KFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50LCB7XG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICAgIH0pIDogcGF0Y2hGdW5jdGlvbmFsT3JTdHJDb21wb25lbnQoV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQsIHtcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIGlzUHVyZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIFBhdGNoZWRJbm5lckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50KTtcbiAgICB9IGNhdGNoIChlKSB7Ly8gbm90IGNydWNpYWwgaWYgZGlzcGxheU5hbWUgY291bGRuJ3QgYmUgc2V0XG4gICAgfVxuXG4gICAgUGF0Y2hlZElubmVyQ29tcG9uZW50LkNvbXBvbmVudEZvckhvb2tzVHJhY2tpbmcgPSBNZW1vQ29tcG9uZW50O1xuICAgIGxvZGFzaC5kZWZhdWx0cyhQYXRjaGVkSW5uZXJDb21wb25lbnQsIFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50KTtcbiAgICB2YXIgV0RZUk1lbW9pemVkRnVuY3Rpb25hbENvbXBvbmVudCA9IHdkeXJTdG9yZS5SZWFjdC5tZW1vKGlzSW5uZXJNZW1vQ29tcG9uZW50Rm9yd2FyZFJlZnMgPyB3ZHlyU3RvcmUuUmVhY3QuZm9yd2FyZFJlZihQYXRjaGVkSW5uZXJDb21wb25lbnQpIDogUGF0Y2hlZElubmVyQ29tcG9uZW50LCBNZW1vQ29tcG9uZW50LmNvbXBhcmUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIFdEWVJNZW1vaXplZEZ1bmN0aW9uYWxDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICB9IGNhdGNoIChlKSB7Ly8gbm90IGNydWNpYWwgaWYgZGlzcGxheU5hbWUgY291bGRuJ3QgYmUgc2V0XG4gICAgfVxuXG4gICAgV0RZUk1lbW9pemVkRnVuY3Rpb25hbENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzKFdEWVJNZW1vaXplZEZ1bmN0aW9uYWxDb21wb25lbnQsIE1lbW9Db21wb25lbnQpO1xuICAgIHJldHVybiBXRFlSTWVtb2l6ZWRGdW5jdGlvbmFsQ29tcG9uZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hGb3J3YXJkUmVmQ29tcG9uZW50KEZvcndhcmRSZWZDb21wb25lbnQsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgICBkZWZhdWx0UHJvcHMgPSBfcmVmLmRlZmF1bHRQcm9wcztcbiAgICB2YXIgSW5uZXJGb3J3YXJkUmVmQ29tcG9uZW50ID0gRm9yd2FyZFJlZkNvbXBvbmVudC5yZW5kZXI7XG4gICAgdmFyIGlzSW5uZXJDb21wb25lbnRNZW1vaXplZCA9IGlzTWVtb0NvbXBvbmVudChJbm5lckZvcndhcmRSZWZDb21wb25lbnQpO1xuICAgIHZhciBXcmFwcGVkRnVuY3Rpb25hbENvbXBvbmVudCA9IGlzSW5uZXJDb21wb25lbnRNZW1vaXplZCA/IElubmVyRm9yd2FyZFJlZkNvbXBvbmVudC50eXBlIDogSW5uZXJGb3J3YXJkUmVmQ29tcG9uZW50O1xuICAgIHZhciBXRFlSV3JhcHBlZEJ5UmVhY3RGb3J3YXJkUmVmRnVuY3Rpb25hbENvbXBvbmVudCA9IHBhdGNoRnVuY3Rpb25hbE9yU3RyQ29tcG9uZW50KFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50LCB7XG4gICAgICBpc1B1cmU6IGlzSW5uZXJDb21wb25lbnRNZW1vaXplZCxcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZVxuICAgIH0pO1xuICAgIFdEWVJXcmFwcGVkQnlSZWFjdEZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQpO1xuICAgIFdEWVJXcmFwcGVkQnlSZWFjdEZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50LkNvbXBvbmVudEZvckhvb2tzVHJhY2tpbmcgPSBXcmFwcGVkRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICBsb2Rhc2guZGVmYXVsdHMoV0RZUldyYXBwZWRCeVJlYWN0Rm9yd2FyZFJlZkZ1bmN0aW9uYWxDb21wb25lbnQsIFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50KTtcbiAgICB2YXIgV0RZUkZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50ID0gd2R5clN0b3JlLlJlYWN0LmZvcndhcmRSZWYoaXNJbm5lckNvbXBvbmVudE1lbW9pemVkID8gd2R5clN0b3JlLlJlYWN0Lm1lbW8oV0RZUldyYXBwZWRCeVJlYWN0Rm9yd2FyZFJlZkZ1bmN0aW9uYWxDb21wb25lbnQsIElubmVyRm9yd2FyZFJlZkNvbXBvbmVudC5jb21wYXJlKSA6IFdEWVJXcmFwcGVkQnlSZWFjdEZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50KTtcblxuICAgIHRyeSB7XG4gICAgICBXRFlSRm9yd2FyZFJlZkZ1bmN0aW9uYWxDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICB9IGNhdGNoIChlKSB7Ly8gbm90IGNydWNpYWwgaWYgZGlzcGxheU5hbWUgY291bGRuJ3QgYmUgc2V0XG4gICAgfVxuXG4gICAgV0RZUkZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiAgICBsb2Rhc2guZGVmYXVsdHMoV0RZUkZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50LCBGb3J3YXJkUmVmQ29tcG9uZW50KTtcbiAgICByZXR1cm4gV0RZUkZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIGluaXRpYWxIb29rVmFsdWUgPSBTeW1ib2woJ2luaXRpYWwtaG9vay12YWx1ZScpO1xuXG4gIGZ1bmN0aW9uIHRyYWNrSG9va0NoYW5nZXMoaG9va05hbWUsIF9yZWYsIGhvb2tSZXN1bHQpIHtcbiAgICB2YXIgaG9va1BhdGggPSBfcmVmLnBhdGg7XG4gICAgdmFyIG5leHRIb29rID0gaG9va1BhdGggPyBsb2Rhc2guZ2V0KGhvb2tSZXN1bHQsIGhvb2tQYXRoKSA6IGhvb2tSZXN1bHQ7XG4gICAgdmFyIHJlbmRlck51bWJlckZvclRoZUhvb2sgPSB3ZHlyU3RvcmUuUmVhY3QudXNlUmVmKHRydWUpOyAvLyBUT0RPOiBpbXByb3ZlXG5cbiAgICB2YXIgaXNTZWNvbmRDeWNsZU9mUmVuZGVycyA9IHdkeXJTdG9yZS5ob29rc1BlclJlbmRlclswXSAmJiB3ZHlyU3RvcmUuaG9va3NQZXJSZW5kZXJbMF0ucmVuZGVyTnVtYmVyRm9yVGhlSG9vayAhPT0gcmVuZGVyTnVtYmVyRm9yVGhlSG9vay5jdXJyZW50O1xuXG4gICAgaWYgKGlzU2Vjb25kQ3ljbGVPZlJlbmRlcnMpIHtcbiAgICAgIHdkeXJTdG9yZS5ob29rc1BlclJlbmRlciA9IFtdO1xuICAgIH1cblxuICAgIHdkeXJTdG9yZS5ob29rc1BlclJlbmRlci5wdXNoKHtcbiAgICAgIGhvb2tOYW1lOiBob29rTmFtZSxcbiAgICAgIHJlc3VsdDogbmV4dEhvb2ssXG4gICAgICByZW5kZXJOdW1iZXJGb3JUaGVIb29rOiByZW5kZXJOdW1iZXJGb3JUaGVIb29rLmN1cnJlbnRcbiAgICB9KTtcbiAgICByZW5kZXJOdW1iZXJGb3JUaGVIb29rLmN1cnJlbnQrKztcbiAgICB2YXIgQ29tcG9uZW50SG9va0Rpc3BhdGNoZWRGcm9tSW5zdGFuY2UgPSB3ZHlyU3RvcmUuUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgJiYgd2R5clN0b3JlLlJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZIb29rUmVmID0gd2R5clN0b3JlLlJlYWN0LnVzZVJlZihpbml0aWFsSG9va1ZhbHVlKTtcblxuICAgIGlmICghQ29tcG9uZW50SG9va0Rpc3BhdGNoZWRGcm9tSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBob29rUmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBDb21wb25lbnQgPSBDb21wb25lbnRIb29rRGlzcGF0Y2hlZEZyb21JbnN0YW5jZS50eXBlLkNvbXBvbmVudEZvckhvb2tzVHJhY2tpbmcgfHwgQ29tcG9uZW50SG9va0Rpc3BhdGNoZWRGcm9tSW5zdGFuY2UudHlwZTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuICAgIHZhciBpc1Nob3VsZFRyYWNrID0gc2hvdWxkVHJhY2soQ29tcG9uZW50LCB7XG4gICAgICBpc0hvb2tDaGFuZ2U6IHRydWVcbiAgICB9KTtcblxuICAgIGlmICghaXNTaG91bGRUcmFjaykge1xuICAgICAgcmV0dXJuIGhvb2tSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld1ByZXZIb29rUmVmID0gcHJldkhvb2tSZWYuY3VycmVudDtcbiAgICBwcmV2SG9va1JlZi5jdXJyZW50ID0gaG9va1Jlc3VsdDtcblxuICAgIGlmIChuZXdQcmV2SG9va1JlZiAhPT0gaW5pdGlhbEhvb2tWYWx1ZSkge1xuICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IGdldFVwZGF0ZUluZm8oe1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBob29rTmFtZTogaG9va05hbWUsXG4gICAgICAgIHByZXZIb29rOiBob29rUGF0aCA/IGxvZGFzaC5nZXQobmV3UHJldkhvb2tSZWYsIGhvb2tQYXRoKSA6IG5ld1ByZXZIb29rUmVmLFxuICAgICAgICBuZXh0SG9vazogbmV4dEhvb2tcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobm90aWZpY2F0aW9uLnJlYXNvbi5ob29rRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgd2R5clN0b3JlLm9wdGlvbnMubm90aWZpZXIobm90aWZpY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9va1Jlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoZWRDb21wb25lbnQoQ29tcG9uZW50LCBfcmVmMikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYyLmRpc3BsYXlOYW1lLFxuICAgICAgICBkZWZhdWx0UHJvcHMgPSBfcmVmMi5kZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgIHJldHVybiBwYXRjaE1lbW9Db21wb25lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBkZWZhdWx0UHJvcHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0ZvcndhcmRSZWZDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHBhdGNoRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQsIHtcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVhY3RDbGFzc0NvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gcGF0Y2hDbGFzc0NvbXBvbmVudChDb21wb25lbnQsIHtcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoRnVuY3Rpb25hbE9yU3RyQ29tcG9uZW50KENvbXBvbmVudCwge1xuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgZGVmYXVsdFByb3BzOiBkZWZhdWx0UHJvcHMsXG4gICAgICBpc1B1cmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXRjaGVkQ29tcG9uZW50KENvbXBvbmVudCwgX3JlZjMpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmMy5kaXNwbGF5TmFtZSxcbiAgICAgICAgZGVmYXVsdFByb3BzID0gX3JlZjMuZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKHdkeXJTdG9yZS5jb21wb25lbnRzTWFwLmhhcyhDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gd2R5clN0b3JlLmNvbXBvbmVudHNNYXAuZ2V0KENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgdmFyIFdEWVJQYXRjaGVkQ29tcG9uZW50ID0gY3JlYXRlUGF0Y2hlZENvbXBvbmVudChDb21wb25lbnQsIHtcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIGRlZmF1bHRQcm9wczogZGVmYXVsdFByb3BzXG4gICAgfSk7XG4gICAgd2R5clN0b3JlLmNvbXBvbmVudHNNYXAuc2V0KENvbXBvbmVudCwgV0RZUlBhdGNoZWRDb21wb25lbnQpO1xuICAgIHJldHVybiBXRFlSUGF0Y2hlZENvbXBvbmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzU3VwcG9ydGVkQ29tcG9uZW50VHlwZShDb21wKSB7XG4gICAgaWYgKCFDb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzTWVtb0NvbXBvbmVudChDb21wKSkge1xuICAgICAgcmV0dXJuIGdldElzU3VwcG9ydGVkQ29tcG9uZW50VHlwZShDb21wLnR5cGUpO1xuICAgIH1cblxuICAgIGlmIChpc0ZvcndhcmRSZWZDb21wb25lbnQoQ29tcCkpIHtcbiAgICAgIHJldHVybiBnZXRJc1N1cHBvcnRlZENvbXBvbmVudFR5cGUoQ29tcC5yZW5kZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhvb2tzQ29uZmlnID0ge1xuICAgIHVzZVN0YXRlOiB7XG4gICAgICBwYXRoOiAnMCdcbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IHtcbiAgICAgIHBhdGg6ICcwJ1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogdW5kZWZpbmVkLFxuICAgIHVzZU1lbW86IHtcbiAgICAgIGRlcGVuZGVuY2llc1BhdGg6ICcxJyxcbiAgICAgIGRvbnRSZXBvcnQ6IHRydWVcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiB7XG4gICAgICBkZXBlbmRlbmNpZXNQYXRoOiAnMScsXG4gICAgICBkb250UmVwb3J0OiB0cnVlXG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBzdG9yZU93bmVyRGF0YShlbGVtZW50KSB7XG4gICAgdmFyIE93bmVySW5zdGFuY2UgPSB3ZHlyU3RvcmUuUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuICAgIGlmIChPd25lckluc3RhbmNlKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gT3duZXJJbnN0YW5jZS50eXBlLkNvbXBvbmVudEZvckhvb2tzVHJhY2tpbmcgfHwgT3duZXJJbnN0YW5jZS50eXBlO1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KTtcbiAgICAgIHZhciBhZGRpdGlvbmFsT3duZXJEYXRhID0ge307XG5cbiAgICAgIGlmICh3ZHlyU3RvcmUub3B0aW9ucy5nZXRBZGRpdGlvbmFsT3duZXJEYXRhKSB7XG4gICAgICAgIGFkZGl0aW9uYWxPd25lckRhdGEgPSB3ZHlyU3RvcmUub3B0aW9ucy5nZXRBZGRpdGlvbmFsT3duZXJEYXRhKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB3ZHlyU3RvcmUub3duZXJEYXRhTWFwLnNldChlbGVtZW50LnByb3BzLCB7XG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuICAgICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIHByb3BzOiBPd25lckluc3RhbmNlLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgc3RhdGU6IE93bmVySW5zdGFuY2Uuc3RhdGVOb2RlID8gT3duZXJJbnN0YW5jZS5zdGF0ZU5vZGUuc3RhdGUgOiBudWxsLFxuICAgICAgICBob29rczogd2R5clN0b3JlLmhvb2tzUGVyUmVuZGVyLFxuICAgICAgICBhZGRpdGlvbmFsT3duZXJEYXRhOiBhZGRpdGlvbmFsT3duZXJEYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEhvb2tzUGVyUmVuZGVySWZOZWVkZWQoKSB7XG4gICAgLy8gSW50ZXJjZXB0IGFzc2lnbm1lbnRzIHRvIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgdG8gcmVzZXQgaG9va3NQZXJSZW5kZXJcbiAgICB2YXIgY3VycmVudE93bmVyID0gbnVsbDtcblxuICAgIGlmICh3ZHlyU3RvcmUuUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3ZHlyU3RvcmUuUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsICdjdXJyZW50Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudE93bmVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGN1cnJlbnRPd25lciA9IHZhbHVlO1xuICAgICAgICAgIHdkeXJTdG9yZS5ob29rc1BlclJlbmRlciA9IFtdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmFja0hvb2tzSWZOZWVkZWQoKSB7XG4gICAgdmFyIGhvb2tzU3VwcG9ydGVkID0gISF3ZHlyU3RvcmUuUmVhY3QudXNlU3RhdGU7XG5cbiAgICBpZiAod2R5clN0b3JlLm9wdGlvbnMudHJhY2tIb29rcyAmJiBob29rc1N1cHBvcnRlZCkge1xuICAgICAgdmFyIG5hdGl2ZUhvb2tzID0gT2JqZWN0LmVudHJpZXMoaG9va3NDb25maWcpLm1hcChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDIpLFxuICAgICAgICAgICAgaG9va05hbWUgPSBfcmVmNVswXSxcbiAgICAgICAgICAgIGhvb2tUcmFja2luZ0NvbmZpZyA9IF9yZWY1WzFdO1xuXG4gICAgICAgIHJldHVybiBbd2R5clN0b3JlLlJlYWN0LCBob29rTmFtZSwgaG9va1RyYWNraW5nQ29uZmlnXTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGhvb2tzVG9UcmFjayA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobmF0aXZlSG9va3MpLCBfdG9Db25zdW1hYmxlQXJyYXkod2R5clN0b3JlLm9wdGlvbnMudHJhY2tFeHRyYUhvb2tzKSk7XG4gICAgICBob29rc1RvVHJhY2suZm9yRWFjaChmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgICAgdmFyIF9yZWY3ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjYsIDMpLFxuICAgICAgICAgICAgaG9va1BhcmVudCA9IF9yZWY3WzBdLFxuICAgICAgICAgICAgaG9va05hbWUgPSBfcmVmN1sxXSxcbiAgICAgICAgICAgIF9yZWY3JCA9IF9yZWY3WzJdLFxuICAgICAgICAgICAgaG9va1RyYWNraW5nQ29uZmlnID0gX3JlZjckID09PSB2b2lkIDAgPyB7fSA6IF9yZWY3JDtcblxuICAgICAgICB2YXIgb3JpZ2luYWxIb29rID0gaG9va1BhcmVudFtob29rTmFtZV07XG4gICAgICAgIHZhciBuZXdIb29rTmFtZSA9IGhvb2tOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBob29rTmFtZS5zbGljZSgxKTtcblxuICAgICAgICB2YXIgbmV3SG9vayA9IGZ1bmN0aW9uIG5ld0hvb2soKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBob29rUmVzdWx0ID0gb3JpZ2luYWxIb29rLmNhbGwuYXBwbHkob3JpZ2luYWxIb29rLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzUGF0aCA9IGhvb2tUcmFja2luZ0NvbmZpZy5kZXBlbmRlbmNpZXNQYXRoLFxuICAgICAgICAgICAgICBkb250UmVwb3J0ID0gaG9va1RyYWNraW5nQ29uZmlnLmRvbnRSZXBvcnQ7XG5cbiAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzUGF0aCAmJiBsb2Rhc2guaXNGdW5jdGlvbihob29rUmVzdWx0KSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzTWFwLnNldChob29rUmVzdWx0LCB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lOiBob29rTmFtZSxcbiAgICAgICAgICAgICAgZGVwczogbG9kYXNoLmdldChhcmdzLCBkZXBlbmRlbmNpZXNQYXRoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFkb250UmVwb3J0KSB7XG4gICAgICAgICAgICB0cmFja0hvb2tDaGFuZ2VzKGhvb2tOYW1lLCBob29rVHJhY2tpbmdDb25maWcsIGhvb2tSZXN1bHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBob29rUmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdIb29rLCAnbmFtZScsIHtcbiAgICAgICAgICB2YWx1ZTogbmV3SG9va05hbWUsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuYXNzaWduKG5ld0hvb2ssIHtcbiAgICAgICAgICBvcmlnaW5hbEhvb2s6IG9yaWdpbmFsSG9va1xuICAgICAgICB9KTtcbiAgICAgICAgaG9va1BhcmVudFtob29rTmFtZV0gPSBuZXdIb29rO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V0RZUlR5cGUob3JpZ1R5cGUpIHtcbiAgICB2YXIgaXNTaG91bGRUcmFjayA9IGdldElzU3VwcG9ydGVkQ29tcG9uZW50VHlwZShvcmlnVHlwZSkgJiYgc2hvdWxkVHJhY2sob3JpZ1R5cGUsIHtcbiAgICAgIGlzSG9va0NoYW5nZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmICghaXNTaG91bGRUcmFjaykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGRpc3BsYXlOYW1lID0gb3JpZ1R5cGUgJiYgb3JpZ1R5cGUud2h5RGlkWW91UmVuZGVyICYmIG9yaWdUeXBlLndoeURpZFlvdVJlbmRlci5jdXN0b21OYW1lIHx8IGdldERpc3BsYXlOYW1lKG9yaWdUeXBlKTtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzKG9yaWdUeXBlKTtcbiAgICB2YXIgV0RZUlBhdGNoZWRDb21wb25lbnQgPSBnZXRQYXRjaGVkQ29tcG9uZW50KG9yaWdUeXBlLCB7XG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICAgIH0pO1xuICAgIHJldHVybiBXRFlSUGF0Y2hlZENvbXBvbmVudDtcbiAgfVxuICBmdW5jdGlvbiB3aHlEaWRZb3VSZW5kZXIoUmVhY3QsIHVzZXJPcHRpb25zKSB7XG4gICAgaWYgKFJlYWN0LmlzV0RZUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24od2R5clN0b3JlLCB7XG4gICAgICBSZWFjdDogUmVhY3QsXG4gICAgICBvcHRpb25zOiBub3JtYWxpemVPcHRpb25zKHVzZXJPcHRpb25zKSxcbiAgICAgIG9yaWdDcmVhdGVFbGVtZW50OiBSZWFjdC5jcmVhdGVFbGVtZW50LFxuICAgICAgb3JpZ0NyZWF0ZUZhY3Rvcnk6IFJlYWN0LmNyZWF0ZUZhY3RvcnksXG4gICAgICBvcmlnQ2xvbmVFbGVtZW50OiBSZWFjdC5jbG9uZUVsZW1lbnQsXG4gICAgICBjb21wb25lbnRzTWFwOiBuZXcgV2Vha01hcCgpXG4gICAgfSk7XG4gICAgcmVzZXRIb29rc1BlclJlbmRlcklmTmVlZGVkKCk7XG5cbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKG9yaWdUeXBlKSB7XG4gICAgICB2YXIgV0RZUlR5cGUgPSBnZXRXRFlSVHlwZShvcmlnVHlwZSk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHJlc3RbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGlmIChXRFlSVHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2R5clN0b3JlLm9yaWdDcmVhdGVFbGVtZW50LmFwcGx5KFJlYWN0LCBbV0RZUlR5cGVdLmNvbmNhdChyZXN0KSk7XG5cbiAgICAgICAgICBpZiAod2R5clN0b3JlLm9wdGlvbnMubG9nT3duZXJSZWFzb25zKSB7XG4gICAgICAgICAgICBzdG9yZU93bmVyRGF0YShlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVMb2coJ3doeURpZFlvdVJlbmRlciBlcnJvci4gUGxlYXNlIGZpbGUgYSBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL3dlbGxkb25lLXNvZnR3YXJlL3doeS1kaWQteW91LXJlbmRlci9pc3N1ZXMuJywge1xuICAgICAgICAgICAgZXJyb3JJbmZvOiB7XG4gICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lT3JDb21wb25lbnQ6IG9yaWdUeXBlLFxuICAgICAgICAgICAgICByZXN0OiByZXN0LFxuICAgICAgICAgICAgICBvcHRpb25zOiB3ZHlyU3RvcmUub3B0aW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3ZHlyU3RvcmUub3JpZ0NyZWF0ZUVsZW1lbnQuYXBwbHkoUmVhY3QsIFtvcmlnVHlwZV0uY29uY2F0KHJlc3QpKTtcbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbihSZWFjdC5jcmVhdGVFbGVtZW50LCB3ZHlyU3RvcmUub3JpZ0NyZWF0ZUVsZW1lbnQpO1xuXG4gICAgUmVhY3QuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgZmFjdG9yeSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAgIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbihSZWFjdC5jcmVhdGVGYWN0b3J5LCB3ZHlyU3RvcmUub3JpZ0NyZWF0ZUZhY3RvcnkpO1xuXG4gICAgUmVhY3QuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB3ZHlyU3RvcmUub3JpZ0Nsb25lRWxlbWVudC5hcHBseShSZWFjdCwgYXJncyk7XG5cbiAgICAgIGlmICh3ZHlyU3RvcmUub3B0aW9ucy5sb2dPd25lclJlYXNvbnMpIHtcbiAgICAgICAgc3RvcmVPd25lckRhdGEoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKFJlYWN0LmNsb25lRWxlbWVudCwgd2R5clN0b3JlLm9yaWdDbG9uZUVsZW1lbnQpO1xuICAgIHRyYWNrSG9va3NJZk5lZWRlZCgpO1xuICAgIFJlYWN0LmlzV0RZUiA9IHRydWU7XG5cbiAgICBSZWFjdC5fX1JFVkVSVF9XSFlfRElEX1lPVV9SRU5ERVJfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oUmVhY3QsIHtcbiAgICAgICAgY3JlYXRlRWxlbWVudDogd2R5clN0b3JlLm9yaWdDcmVhdGVFbGVtZW50LFxuICAgICAgICBjcmVhdGVGYWN0b3J5OiB3ZHlyU3RvcmUub3JpZ0NyZWF0ZUZhY3RvcnksXG4gICAgICAgIGNsb25lRWxlbWVudDogd2R5clN0b3JlLm9yaWdDbG9uZUVsZW1lbnRcbiAgICAgIH0pO1xuICAgICAgd2R5clN0b3JlLmNvbXBvbmVudHNNYXAgPSBudWxsO1xuICAgICAgdmFyIGhvb2tzVG9SZXZlcnQgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5rZXlzKGhvb2tzQ29uZmlnKS5tYXAoZnVuY3Rpb24gKGhvb2tOYW1lKSB7XG4gICAgICAgIHJldHVybiBbUmVhY3QsIGhvb2tOYW1lXTtcbiAgICAgIH0pKSwgX3RvQ29uc3VtYWJsZUFycmF5KHdkeXJTdG9yZS5vcHRpb25zLnRyYWNrRXh0cmFIb29rcykpO1xuICAgICAgaG9va3NUb1JldmVydC5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmOCkge1xuICAgICAgICB2YXIgX3JlZjkgPSBfc2xpY2VkVG9BcnJheShfcmVmOCwgMiksXG4gICAgICAgICAgICBob29rUGFyZW50ID0gX3JlZjlbMF0sXG4gICAgICAgICAgICBob29rTmFtZSA9IF9yZWY5WzFdO1xuXG4gICAgICAgIGlmIChob29rUGFyZW50W2hvb2tOYW1lXS5vcmlnaW5hbEhvb2spIHtcbiAgICAgICAgICBob29rUGFyZW50W2hvb2tOYW1lXSA9IGhvb2tQYXJlbnRbaG9va05hbWVdLm9yaWdpbmFsSG9vaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgUmVhY3QuX19SRVZFUlRfV0hZX0RJRF9ZT1VfUkVOREVSX187XG4gICAgICBkZWxldGUgUmVhY3QuaXNXRFlSO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3Q7XG4gIH1cblxuICB3aHlEaWRZb3VSZW5kZXIuZGVmYXVsdE5vdGlmaWVyID0gZGVmYXVsdE5vdGlmaWVyO1xuICB3aHlEaWRZb3VSZW5kZXIud2R5clN0b3JlID0gd2R5clN0b3JlO1xuICB3aHlEaWRZb3VSZW5kZXIuc3RvcmVPd25lckRhdGEgPSBzdG9yZU93bmVyRGF0YTtcbiAgd2h5RGlkWW91UmVuZGVyLmdldFdEWVJUeXBlID0gZ2V0V0RZUlR5cGU7XG4gIE9iamVjdC5hc3NpZ24od2h5RGlkWW91UmVuZGVyLCBSZWFjdF9fbmFtZXNwYWNlKTtcblxuICByZXR1cm4gd2h5RGlkWW91UmVuZGVyO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aHlEaWRZb3VSZW5kZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/@welldone-software-why-did-you-render-virtual-33fce466b1/0/cache/@welldone-software-why-did-you-render-npm-7.0.1-33d725f830-0bfc59f1f8.zip/node_modules/@welldone-software/why-did-you-render/dist/whyDidYouRender.js\n");

/***/ })

}]);