/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["visjs-network"],{

/***/ "./.yarn/cache/visjs-network-npm-4.25.0-2e90efaeed-40bfcbbf2b.zip/node_modules/visjs-network/dist/vis.js":
/***/ (function(module) {

eval("/**\n * vis.js\n * https://github.com/almende/vis\n *\n * A dynamic, browser-based visualization library.\n *\n * @version 4.25.0\n * @date    2018-09-20\n *\n * @license\n * Copyright (C) 2011-2017 Almende B.V, http://almende.com\n *\n * Vis.js is dual licensed under both\n *\n * * The Apache 2.0 License\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * and\n *\n * * The MIT License\n *   http://opensource.org/licenses/MIT\n *\n * Vis.js may be distributed under either license.\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_1040__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1040__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_1040__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_1040__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_1040__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_1040__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_1040__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_1040__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_1040__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_1040__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_1040__(__nested_webpack_require_1040__.s = 85);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3604__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _defineProperty = __nested_webpack_require_3604__(130);\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_4566__) {\n\n\"use strict\";\n\n\nvar _getIterator2 = __nested_webpack_require_4566__(58);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _create = __nested_webpack_require_4566__(31);\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _keys = __nested_webpack_require_4566__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _typeof2 = __nested_webpack_require_4566__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// utility functions\n\n// first check if moment.js is already loaded in the browser window, if so,\n// use this instance. Else, load via commonjs.\n\nvar moment = __nested_webpack_require_4566__(71);\nvar uuid = __nested_webpack_require_4566__(119);\n\n/**\n * Test whether given object is a number\n * @param {*} object\n * @return {Boolean} isNumber\n */\nexports.isNumber = function (object) {\n  return object instanceof Number || typeof object == 'number';\n};\n\n/**\n * Remove everything in the DOM object\n * @param {Element} DOMobject\n */\nexports.recursiveDOMDelete = function (DOMobject) {\n  if (DOMobject) {\n    while (DOMobject.hasChildNodes() === true) {\n      exports.recursiveDOMDelete(DOMobject.firstChild);\n      DOMobject.removeChild(DOMobject.firstChild);\n    }\n  }\n};\n\n/**\n * Test whether given object is a string\n * @param {*} object\n * @return {Boolean} isString\n */\nexports.isString = function (object) {\n  return object instanceof String || typeof object == 'string';\n};\n\n/**\n * Test whether given object is a Date, or a String containing a Date\n * @param {Date | String} object\n * @return {Boolean} isDate\n */\nexports.isDate = function (object) {\n  if (object instanceof Date) {\n    return true;\n  } else if (exports.isString(object)) {\n    // test whether this string contains a date\n    var match = ASPDateRegex.exec(object);\n    if (match) {\n      return true;\n    } else if (!isNaN(Date.parse(object))) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Create a UUID\n * @return {string} uuid\n */\nexports.randomUUID = function () {\n  return uuid.v4();\n};\n\n/**\n * Copy property from b to a if property present in a.\n * If property in b explicitly set to null, delete it if `allowDeletion` set.\n *\n * Internal helper routine, should not be exported. Not added to `exports` for that reason.\n *\n * @param {object} a  target object\n * @param {object} b  source object\n * @param {string} prop  name of property to copy to a\n * @param {boolean} allowDeletion  if true, delete property in a if explicitly set to null in b\n * @private\n */\nfunction copyOrDelete(a, b, prop, allowDeletion) {\n  var doDeletion = false;\n  if (allowDeletion === true) {\n    doDeletion = b[prop] === null && a[prop] !== undefined;\n  }\n\n  if (doDeletion) {\n    delete a[prop];\n  } else {\n    a[prop] = b[prop]; // Remember, this is a reference copy!\n  }\n}\n\n/**\n * Fill an object with a possibly partially defined other object.\n *\n * Only copies values for the properties already present in a.\n * That means an object is not created on a property if only the b object has it.\n *\n * @param {object} a\n * @param {object} b\n * @param {boolean} [allowDeletion=false]  if true, delete properties in a that are explicitly set to null in b\n */\nexports.fillIfDefined = function (a, b) {\n  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // NOTE: iteration of properties of a\n  // NOTE: prototype properties iterated over as well\n  for (var prop in a) {\n    if (b[prop] !== undefined) {\n      if (b[prop] === null || (0, _typeof3['default'])(b[prop]) !== 'object') {\n        // Note: typeof null === 'object'\n        copyOrDelete(a, b, prop, allowDeletion);\n      } else {\n        if ((0, _typeof3['default'])(a[prop]) === 'object') {\n          exports.fillIfDefined(a[prop], b[prop], allowDeletion);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Extend object a with the properties of object b or a series of objects\n * Only properties with defined values are copied\n * @param {Object} a\n * @param {...Object} b\n * @return {Object} a\n */\nexports.extend = function (a /* b */) {\n  // eslint-disable-line no-unused-vars\n  for (var i = 1; i < arguments.length; i++) {\n    var other = arguments[i];\n    for (var prop in other) {\n      if (other.hasOwnProperty(prop)) {\n        a[prop] = other[prop];\n      }\n    }\n  }\n  return a;\n};\n\n/**\n * Extend object a with selected properties of object b or a series of objects\n * Only properties with defined values are copied\n * @param {Array.<string>} props\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n */\nexports.selectiveExtend = function (props, a /* b */) {\n  // eslint-disable-line no-unused-vars\n  if (!Array.isArray(props)) {\n    throw new Error('Array with property names expected as first argument');\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    var other = arguments[i];\n\n    for (var p = 0; p < props.length; p++) {\n      var prop = props[p];\n      if (other && other.hasOwnProperty(prop)) {\n        a[prop] = other[prop];\n      }\n    }\n  }\n  return a;\n};\n\n/**\n * Extend object a with selected properties of object b.\n * Only properties with defined values are copied.\n *\n * **Note:** Previous version of this routine implied that multiple source objects\n *           could be used; however, the implementation was **wrong**.\n *           Since multiple (>1) sources weren't used anywhere in the `vis.js` code,\n *           this has been removed\n *\n * @param {Array.<string>} props names of first-level properties to copy over\n * @param {object} a  target object\n * @param {object} b  source object\n * @param {boolean} [allowDeletion=false]  if true, delete property in a if explicitly set to null in b\n * @returns {Object} a\n */\nexports.selectiveDeepExtend = function (props, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  // TODO: add support for Arrays to deepExtend\n  if (Array.isArray(b)) {\n    throw new TypeError('Arrays are not supported by deepExtend');\n  }\n\n  for (var p = 0; p < props.length; p++) {\n    var prop = props[p];\n    if (b.hasOwnProperty(prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n        if (a[prop].constructor === Object) {\n          exports.deepExtend(a[prop], b[prop], false, allowDeletion);\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (Array.isArray(b[prop])) {\n        throw new TypeError('Arrays are not supported by deepExtend');\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n};\n\n/**\n * Extend object `a` with properties of object `b`, ignoring properties which are explicitly\n * specified to be excluded.\n *\n * The properties of `b` are considered for copying.\n * Properties which are themselves objects are are also extended.\n * Only properties with defined values are copied\n *\n * @param {Array.<string>} propsToExclude  names of properties which should *not* be copied\n * @param {Object}                      a  object to extend\n * @param {Object}                      b  object to take properties from for extension\n * @param {boolean} [allowDeletion=false]  if true, delete properties in a that are explicitly set to null in b\n * @return {Object} a\n */\nexports.selectiveNotDeepExtend = function (propsToExclude, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  // TODO: add support for Arrays to deepExtend\n  // NOTE: array properties have an else-below; apparently, there is a problem here.\n  if (Array.isArray(b)) {\n    throw new TypeError('Arrays are not supported by deepExtend');\n  }\n\n  for (var prop in b) {\n    if (!b.hasOwnProperty(prop)) continue; // Handle local properties only\n    if (propsToExclude.indexOf(prop) !== -1) continue; // In exclusion list, skip\n\n    if (b[prop] && b[prop].constructor === Object) {\n      if (a[prop] === undefined) {\n        a[prop] = {};\n      }\n      if (a[prop].constructor === Object) {\n        exports.deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    } else if (Array.isArray(b[prop])) {\n      a[prop] = [];\n      for (var i = 0; i < b[prop].length; i++) {\n        a[prop].push(b[prop][i]);\n      }\n    } else {\n      copyOrDelete(a, b, prop, allowDeletion);\n    }\n  }\n\n  return a;\n};\n\n/**\n * Deep extend an object a with the properties of object b\n *\n * @param {Object} a\n * @param {Object} b\n * @param {boolean} [protoExtend=false]  If true, the prototype values will also be extended.\n *                          (ie. the options objects that inherit from others will also get the inherited options)\n * @param {boolean} [allowDeletion=false] If true, the values of fields that are null will be deleted\n * @returns {Object}\n */\nexports.deepExtend = function (a, b) {\n  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  for (var prop in b) {\n    if (b.hasOwnProperty(prop) || protoExtend === true) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n        if (a[prop].constructor === Object) {\n          exports.deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (Array.isArray(b[prop])) {\n        a[prop] = [];\n        for (var i = 0; i < b[prop].length; i++) {\n          a[prop].push(b[prop][i]);\n        }\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n};\n\n/**\n * Test whether all elements in two arrays are equal.\n * @param {Array} a\n * @param {Array} b\n * @return {boolean} Returns true if both arrays have the same length and same\n *                   elements.\n */\nexports.equalArray = function (a, b) {\n  if (a.length != b.length) return false;\n\n  for (var i = 0, len = a.length; i < len; i++) {\n    if (a[i] != b[i]) return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert an object to another type\n * @param {boolean | number | string | Date | Moment | Null | undefined} object\n * @param {string | undefined} type   Name of the type. Available types:\n *                                    'Boolean', 'Number', 'String',\n *                                    'Date', 'Moment', ISODate', 'ASPDate'.\n * @return {*} object\n * @throws Error\n */\nexports.convert = function (object, type) {\n  var match;\n\n  if (object === undefined) {\n    return undefined;\n  }\n  if (object === null) {\n    return null;\n  }\n\n  if (!type) {\n    return object;\n  }\n  if (!(typeof type === 'string') && !(type instanceof String)) {\n    throw new Error('Type must be a string');\n  }\n\n  //noinspection FallthroughInSwitchStatementJS\n  switch (type) {\n    case 'boolean':\n    case 'Boolean':\n      return Boolean(object);\n\n    case 'number':\n    case 'Number':\n      if (exports.isString(object) && !isNaN(Date.parse(object))) {\n        return moment(object).valueOf();\n      } else {\n        return Number(object.valueOf());\n      }\n    case 'string':\n    case 'String':\n      return String(object);\n\n    case 'Date':\n      if (exports.isNumber(object)) {\n        return new Date(object);\n      }\n      if (object instanceof Date) {\n        return new Date(object.valueOf());\n      } else if (moment.isMoment(object)) {\n        return new Date(object.valueOf());\n      }\n      if (exports.isString(object)) {\n        match = ASPDateRegex.exec(object);\n        if (match) {\n          // object is an ASP date\n          return new Date(Number(match[1])); // parse number\n        } else {\n          return moment(new Date(object)).toDate(); // parse string\n        }\n      } else {\n        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');\n      }\n\n    case 'Moment':\n      if (exports.isNumber(object)) {\n        return moment(object);\n      }\n      if (object instanceof Date) {\n        return moment(object.valueOf());\n      } else if (moment.isMoment(object)) {\n        return moment(object);\n      }\n      if (exports.isString(object)) {\n        match = ASPDateRegex.exec(object);\n        if (match) {\n          // object is an ASP date\n          return moment(Number(match[1])); // parse number\n        } else {\n          return moment(object); // parse string\n        }\n      } else {\n        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');\n      }\n\n    case 'ISODate':\n      if (exports.isNumber(object)) {\n        return new Date(object);\n      } else if (object instanceof Date) {\n        return object.toISOString();\n      } else if (moment.isMoment(object)) {\n        return object.toDate().toISOString();\n      } else if (exports.isString(object)) {\n        match = ASPDateRegex.exec(object);\n        if (match) {\n          // object is an ASP date\n          return new Date(Number(match[1])).toISOString(); // parse number\n        } else {\n          return moment(object).format(); // ISO 8601\n        }\n      } else {\n        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');\n      }\n\n    case 'ASPDate':\n      if (exports.isNumber(object)) {\n        return '/Date(' + object + ')/';\n      } else if (object instanceof Date) {\n        return '/Date(' + object.valueOf() + ')/';\n      } else if (exports.isString(object)) {\n        match = ASPDateRegex.exec(object);\n        var value;\n        if (match) {\n          // object is an ASP date\n          value = new Date(Number(match[1])).valueOf(); // parse number\n        } else {\n          value = new Date(object).valueOf(); // parse string\n        }\n        return '/Date(' + value + ')/';\n      } else {\n        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');\n      }\n\n    default:\n      throw new Error('Unknown type \"' + type + '\"');\n  }\n};\n\n// parse ASP.Net Date pattern,\n// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'\n// code from http://momentjs.com/\nvar ASPDateRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n/**\n * Get the type of an object, for example exports.getType([]) returns 'Array'\n * @param {*} object\n * @return {string} type\n */\nexports.getType = function (object) {\n  var type = typeof object === 'undefined' ? 'undefined' : (0, _typeof3['default'])(object);\n\n  if (type == 'object') {\n    if (object === null) {\n      return 'null';\n    }\n    if (object instanceof Boolean) {\n      return 'Boolean';\n    }\n    if (object instanceof Number) {\n      return 'Number';\n    }\n    if (object instanceof String) {\n      return 'String';\n    }\n    if (Array.isArray(object)) {\n      return 'Array';\n    }\n    if (object instanceof Date) {\n      return 'Date';\n    }\n    return 'Object';\n  } else if (type == 'number') {\n    return 'Number';\n  } else if (type == 'boolean') {\n    return 'Boolean';\n  } else if (type == 'string') {\n    return 'String';\n  } else if (type === undefined) {\n    return 'undefined';\n  }\n\n  return type;\n};\n\n/**\n * Used to extend an array and copy it. This is used to propagate paths recursively.\n *\n * @param {Array} arr\n * @param {*} newValue\n * @returns {Array}\n */\nexports.copyAndExtendArray = function (arr, newValue) {\n  var newArr = [];\n  for (var i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.push(newValue);\n  return newArr;\n};\n\n/**\n * Used to extend an array and copy it. This is used to propagate paths recursively.\n *\n * @param {Array} arr\n * @returns {Array}\n */\nexports.copyArray = function (arr) {\n  var newArr = [];\n  for (var i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  return newArr;\n};\n\n/**\n * Retrieve the absolute left value of a DOM element\n * @param {Element} elem        A dom element, for example a div\n * @return {number} left        The absolute left position of this element\n *                              in the browser page.\n */\nexports.getAbsoluteLeft = function (elem) {\n  return elem.getBoundingClientRect().left;\n};\n\nexports.getAbsoluteRight = function (elem) {\n  return elem.getBoundingClientRect().right;\n};\n\n/**\n * Retrieve the absolute top value of a DOM element\n * @param {Element} elem        A dom element, for example a div\n * @return {number} top        The absolute top position of this element\n *                              in the browser page.\n */\nexports.getAbsoluteTop = function (elem) {\n  return elem.getBoundingClientRect().top;\n};\n\n/**\n * add a className to the given elements style\n * @param {Element} elem\n * @param {string} classNames\n */\nexports.addClassName = function (elem, classNames) {\n  var classes = elem.className.split(' ');\n  var newClasses = classNames.split(' ');\n  classes = classes.concat(newClasses.filter(function (className) {\n    return classes.indexOf(className) < 0;\n  }));\n  elem.className = classes.join(' ');\n};\n\n/**\n * add a className to the given elements style\n * @param {Element} elem\n * @param {string} classNames\n */\nexports.removeClassName = function (elem, classNames) {\n  var classes = elem.className.split(' ');\n  var oldClasses = classNames.split(' ');\n  classes = classes.filter(function (className) {\n    return oldClasses.indexOf(className) < 0;\n  });\n  elem.className = classes.join(' ');\n};\n\n/**\n * For each method for both arrays and objects.\n * In case of an array, the built-in Array.forEach() is applied. (**No, it's not!**)\n * In case of an Object, the method loops over all properties of the object.\n * @param {Object | Array} object   An Object or Array\n * @param {function} callback       Callback method, called for each item in\n *                                  the object or array with three parameters:\n *                                  callback(value, index, object)\n */\nexports.forEach = function (object, callback) {\n  var i, len;\n  if (Array.isArray(object)) {\n    // array\n    for (i = 0, len = object.length; i < len; i++) {\n      callback(object[i], i, object);\n    }\n  } else {\n    // object\n    for (i in object) {\n      if (object.hasOwnProperty(i)) {\n        callback(object[i], i, object);\n      }\n    }\n  }\n};\n\n/**\n * Convert an object into an array: all objects properties are put into the\n * array. The resulting array is unordered.\n * @param {Object} object\n * @returns {Array} array\n */\nexports.toArray = function (object) {\n  var array = [];\n\n  for (var prop in object) {\n    if (object.hasOwnProperty(prop)) array.push(object[prop]);\n  }\n\n  return array;\n};\n\n/**\n * Update a property in an object\n * @param {Object} object\n * @param {string} key\n * @param {*} value\n * @return {Boolean} changed\n */\nexports.updateProperty = function (object, key, value) {\n  if (object[key] !== value) {\n    object[key] = value;\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Throttle the given function to be only executed once per animation frame\n * @param {function} fn\n * @returns {function} Returns the throttled function\n */\nexports.throttle = function (fn) {\n  var scheduled = false;\n\n  return function throttled() {\n    if (!scheduled) {\n      scheduled = true;\n      requestAnimationFrame(function () {\n        scheduled = false;\n        fn();\n      });\n    }\n  };\n};\n\n/**\n * Add and event listener. Works for all browsers\n * @param {Element}     element    An html element\n * @param {string}      action     The action, for example \"click\",\n *                                 without the prefix \"on\"\n * @param {function}    listener   The callback function to be executed\n * @param {boolean}     [useCapture]\n */\nexports.addEventListener = function (element, action, listener, useCapture) {\n  if (element.addEventListener) {\n    if (useCapture === undefined) useCapture = false;\n\n    if (action === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0) {\n      action = 'DOMMouseScroll'; // For Firefox\n    }\n\n    element.addEventListener(action, listener, useCapture);\n  } else {\n    element.attachEvent('on' + action, listener); // IE browsers\n  }\n};\n\n/**\n * Remove an event listener from an element\n * @param {Element}     element         An html dom element\n * @param {string}      action          The name of the event, for example \"mousedown\"\n * @param {function}    listener        The listener function\n * @param {boolean}     [useCapture]\n */\nexports.removeEventListener = function (element, action, listener, useCapture) {\n  if (element.removeEventListener) {\n    // non-IE browsers\n    if (useCapture === undefined) useCapture = false;\n\n    if (action === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0) {\n      action = 'DOMMouseScroll'; // For Firefox\n    }\n\n    element.removeEventListener(action, listener, useCapture);\n  } else {\n    // IE browsers\n    element.detachEvent('on' + action, listener);\n  }\n};\n\n/**\n * Cancels the event if it is cancelable, without stopping further propagation of the event.\n * @param {Event} event\n */\nexports.preventDefault = function (event) {\n  if (!event) event = window.event;\n\n  if (event.preventDefault) {\n    event.preventDefault(); // non-IE browsers\n  } else {\n    event.returnValue = false; // IE browsers\n  }\n};\n\n/**\n * Get HTML element which is the target of the event\n * @param {Event} event\n * @return {Element} target element\n */\nexports.getTarget = function (event) {\n  // code from http://www.quirksmode.org/js/events_properties.html\n  if (!event) {\n    event = window.event;\n  }\n\n  var target;\n\n  if (event.target) {\n    target = event.target;\n  } else if (event.srcElement) {\n    target = event.srcElement;\n  }\n\n  if (target.nodeType != undefined && target.nodeType == 3) {\n    // defeat Safari bug\n    target = target.parentNode;\n  }\n\n  return target;\n};\n\n/**\n * Check if given element contains given parent somewhere in the DOM tree\n * @param {Element} element\n * @param {Element} parent\n * @returns {boolean}\n */\nexports.hasParent = function (element, parent) {\n  var e = element;\n\n  while (e) {\n    if (e === parent) {\n      return true;\n    }\n    e = e.parentNode;\n  }\n\n  return false;\n};\n\nexports.option = {};\n\n/**\n * Convert a value into a boolean\n * @param {Boolean | function | undefined} value\n * @param {boolean} [defaultValue]\n * @returns {Boolean} bool\n */\nexports.option.asBoolean = function (value, defaultValue) {\n  if (typeof value == 'function') {\n    value = value();\n  }\n\n  if (value != null) {\n    return value != false;\n  }\n\n  return defaultValue || null;\n};\n\n/**\n * Convert a value into a number\n * @param {Boolean | function | undefined} value\n * @param {number} [defaultValue]\n * @returns {number} number\n */\nexports.option.asNumber = function (value, defaultValue) {\n  if (typeof value == 'function') {\n    value = value();\n  }\n\n  if (value != null) {\n    return Number(value) || defaultValue || null;\n  }\n\n  return defaultValue || null;\n};\n\n/**\n * Convert a value into a string\n * @param {string | function | undefined} value\n * @param {string} [defaultValue]\n * @returns {String} str\n */\nexports.option.asString = function (value, defaultValue) {\n  if (typeof value == 'function') {\n    value = value();\n  }\n\n  if (value != null) {\n    return String(value);\n  }\n\n  return defaultValue || null;\n};\n\n/**\n * Convert a size or location into a string with pixels or a percentage\n * @param {string | number | function | undefined} value\n * @param {string} [defaultValue]\n * @returns {String} size\n */\nexports.option.asSize = function (value, defaultValue) {\n  if (typeof value == 'function') {\n    value = value();\n  }\n\n  if (exports.isString(value)) {\n    return value;\n  } else if (exports.isNumber(value)) {\n    return value + 'px';\n  } else {\n    return defaultValue || null;\n  }\n};\n\n/**\n * Convert a value into a DOM element\n * @param {HTMLElement | function | undefined} value\n * @param {HTMLElement} [defaultValue]\n * @returns {HTMLElement | null} dom\n */\nexports.option.asElement = function (value, defaultValue) {\n  if (typeof value == 'function') {\n    value = value();\n  }\n\n  return value || defaultValue || null;\n};\n\n/**\n * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n *\n * @param {string} hex\n * @returns {{r: *, g: *, b: *}} | 255 range\n */\nexports.hexToRGB = function (hex) {\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n  var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.replace(shorthandRegex, function (m, r, g, b) {\n    return r + r + g + g + b + b;\n  });\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n};\n\n/**\n * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.\n * @param {string} color\n * @param {number} opacity\n * @returns {String}\n */\nexports.overrideOpacity = function (color, opacity) {\n  var rgb;\n  if (color.indexOf('rgba') != -1) {\n    return color;\n  } else if (color.indexOf('rgb') != -1) {\n    rgb = color.substr(color.indexOf('(') + 1).replace(')', '').split(',');\n    return 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + opacity + ')';\n  } else {\n    rgb = exports.hexToRGB(color);\n    if (rgb == null) {\n      return color;\n    } else {\n      return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + opacity + ')';\n    }\n  }\n};\n\n/**\n *\n * @param {number} red     0 -- 255\n * @param {number} green   0 -- 255\n * @param {number} blue    0 -- 255\n * @returns {String}\n * @constructor\n */\nexports.RGBToHex = function (red, green, blue) {\n  return '#' + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);\n};\n\n/**\n * Parse a color property into an object with border, background, and\n * highlight colors\n * @param {Object | String} color\n * @return {Object} colorObject\n */\nexports.parseColor = function (color) {\n  var c;\n  if (exports.isString(color) === true) {\n    if (exports.isValidRGB(color) === true) {\n      var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {\n        return parseInt(value);\n      });\n      color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);\n    }\n    if (exports.isValidHex(color) === true) {\n      var hsv = exports.hexToHSV(color);\n      var lighterColorHSV = {\n        h: hsv.h,\n        s: hsv.s * 0.8,\n        v: Math.min(1, hsv.v * 1.02)\n      };\n      var darkerColorHSV = {\n        h: hsv.h,\n        s: Math.min(1, hsv.s * 1.25),\n        v: hsv.v * 0.8\n      };\n      var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);\n      var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);\n      c = {\n        background: color,\n        border: darkerColorHex,\n        highlight: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        },\n        hover: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        }\n      };\n    } else {\n      c = {\n        background: color,\n        border: color,\n        highlight: {\n          background: color,\n          border: color\n        },\n        hover: {\n          background: color,\n          border: color\n        }\n      };\n    }\n  } else {\n    c = {};\n    c.background = color.background || undefined;\n    c.border = color.border || undefined;\n\n    if (exports.isString(color.highlight)) {\n      c.highlight = {\n        border: color.highlight,\n        background: color.highlight\n      };\n    } else {\n      c.highlight = {};\n      c.highlight.background = color.highlight && color.highlight.background || undefined;\n      c.highlight.border = color.highlight && color.highlight.border || undefined;\n    }\n\n    if (exports.isString(color.hover)) {\n      c.hover = {\n        border: color.hover,\n        background: color.hover\n      };\n    } else {\n      c.hover = {};\n      c.hover.background = color.hover && color.hover.background || undefined;\n      c.hover.border = color.hover && color.hover.border || undefined;\n    }\n  }\n\n  return c;\n};\n\n/**\n * http://www.javascripter.net/faq/rgb2hsv.htm\n *\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @returns {{h: number, s: number, v: number}}\n * @constructor\n */\nexports.RGBToHSV = function (red, green, blue) {\n  red = red / 255;\n  green = green / 255;\n  blue = blue / 255;\n  var minRGB = Math.min(red, Math.min(green, blue));\n  var maxRGB = Math.max(red, Math.max(green, blue));\n\n  // Black-gray-white\n  if (minRGB == maxRGB) {\n    return { h: 0, s: 0, v: minRGB };\n  }\n\n  // Colors other than black-gray-white:\n  var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;\n  var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;\n  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;\n  var saturation = (maxRGB - minRGB) / maxRGB;\n  var value = maxRGB;\n  return { h: hue, s: saturation, v: value };\n};\n\nvar cssUtil = {\n  // split a string with css styles into an object with key/values\n  split: function split(cssText) {\n    var styles = {};\n\n    cssText.split(';').forEach(function (style) {\n      if (style.trim() != '') {\n        var parts = style.split(':');\n        var key = parts[0].trim();\n        var value = parts[1].trim();\n        styles[key] = value;\n      }\n    });\n\n    return styles;\n  },\n\n  // build a css text string from an object with key/values\n  join: function join(styles) {\n    return (0, _keys2['default'])(styles).map(function (key) {\n      return key + ': ' + styles[key];\n    }).join('; ');\n  }\n\n  /**\n   * Append a string with css styles to an element\n   * @param {Element} element\n   * @param {string} cssText\n   */\n};exports.addCssText = function (element, cssText) {\n  var currentStyles = cssUtil.split(element.style.cssText);\n  var newStyles = cssUtil.split(cssText);\n  var styles = exports.extend(currentStyles, newStyles);\n\n  element.style.cssText = cssUtil.join(styles);\n};\n\n/**\n * Remove a string with css styles from an element\n * @param {Element} element\n * @param {string} cssText\n */\nexports.removeCssText = function (element, cssText) {\n  var styles = cssUtil.split(element.style.cssText);\n  var removeStyles = cssUtil.split(cssText);\n\n  for (var key in removeStyles) {\n    if (removeStyles.hasOwnProperty(key)) {\n      delete styles[key];\n    }\n  }\n\n  element.style.cssText = cssUtil.join(styles);\n};\n\n/**\n * https://gist.github.com/mjijackson/5311256\n * @param {number} h\n * @param {number} s\n * @param {number} v\n * @returns {{r: number, g: number, b: number}}\n * @constructor\n */\nexports.HSVToRGB = function (h, s, v) {\n  var r, g, b;\n\n  var i = Math.floor(h * 6);\n  var f = h * 6 - i;\n  var p = v * (1 - s);\n  var q = v * (1 - f * s);\n  var t = v * (1 - (1 - f) * s);\n\n  switch (i % 6) {\n    case 0:\n      ;r = v, g = t, b = p;\n      break;\n    case 1:\n      ;r = q, g = v, b = p;\n      break;\n    case 2:\n      ;r = p, g = v, b = t;\n      break;\n    case 3:\n      ;r = p, g = q, b = v;\n      break;\n    case 4:\n      ;r = t, g = p, b = v;\n      break;\n    case 5:\n      ;r = v, g = p, b = q;\n      break;\n  }\n\n  return {\n    r: Math.floor(r * 255),\n    g: Math.floor(g * 255),\n    b: Math.floor(b * 255)\n  };\n};\n\nexports.HSVToHex = function (h, s, v) {\n  var rgb = exports.HSVToRGB(h, s, v);\n  return exports.RGBToHex(rgb.r, rgb.g, rgb.b);\n};\n\nexports.hexToHSV = function (hex) {\n  var rgb = exports.hexToRGB(hex);\n  return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);\n};\n\nexports.isValidHex = function (hex) {\n  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);\n  return isOk;\n};\n\nexports.isValidRGB = function (rgb) {\n  rgb = rgb.replace(' ', '');\n  var isOk = /rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)/i.test(rgb);\n  return isOk;\n};\nexports.isValidRGBA = function (rgba) {\n  rgba = rgba.replace(' ', '');\n  var isOk = /rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),(.{1,3})\\)/i.test(rgba);\n  return isOk;\n};\n\n/**\n * This recursively redirects the prototype of JSON objects to the referenceObject\n * This is used for default options.\n *\n * @param {Array.<string>} fields\n * @param {Object} referenceObject\n * @returns {*}\n */\nexports.selectiveBridgeObject = function (fields, referenceObject) {\n  if (referenceObject !== null && (typeof referenceObject === 'undefined' ? 'undefined' : (0, _typeof3['default'])(referenceObject)) === 'object') {\n    // !!! typeof null === 'object'\n    var objectTo = (0, _create2['default'])(referenceObject);\n    for (var i = 0; i < fields.length; i++) {\n      if (referenceObject.hasOwnProperty(fields[i])) {\n        if ((0, _typeof3['default'])(referenceObject[fields[i]]) == 'object') {\n          objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);\n        }\n      }\n    }\n    return objectTo;\n  } else {\n    return null;\n  }\n};\n\n/**\n * This recursively redirects the prototype of JSON objects to the referenceObject\n * This is used for default options.\n *\n * @param {Object} referenceObject\n * @returns {*}\n */\nexports.bridgeObject = function (referenceObject) {\n  if (referenceObject !== null && (typeof referenceObject === 'undefined' ? 'undefined' : (0, _typeof3['default'])(referenceObject)) === 'object') {\n    // !!! typeof null === 'object'\n    var objectTo = (0, _create2['default'])(referenceObject);\n    if (referenceObject instanceof Element) {\n      // Avoid bridging DOM objects\n      objectTo = referenceObject;\n    } else {\n      objectTo = (0, _create2['default'])(referenceObject);\n      for (var i in referenceObject) {\n        if (referenceObject.hasOwnProperty(i)) {\n          if ((0, _typeof3['default'])(referenceObject[i]) == 'object') {\n            objectTo[i] = exports.bridgeObject(referenceObject[i]);\n          }\n        }\n      }\n    }\n    return objectTo;\n  } else {\n    return null;\n  }\n};\n\n/**\n * This method provides a stable sort implementation, very fast for presorted data\n *\n * @param {Array} a the array\n * @param {function} compare an order comparator\n * @returns {Array}\n */\nexports.insertSort = function (a, compare) {\n  for (var i = 0; i < a.length; i++) {\n    var k = a[i];\n    for (var j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {\n      a[j] = a[j - 1];\n    }\n    a[j] = k;\n  }\n  return a;\n};\n\n/**\n * This is used to set the options of subobjects in the options object.\n *\n * A requirement of these subobjects is that they have an 'enabled' element\n * which is optional for the user but mandatory for the program.\n *\n * The added value here of the merge is that option 'enabled' is set as required.\n *\n *\n * @param {object} mergeTarget   | either this.options or the options used for the groups.\n * @param {object} options       | options\n * @param {string} option        | option key in the options argument\n * @param {object} globalOptions | global options, passed in to determine value of option 'enabled'\n */\nexports.mergeOptions = function (mergeTarget, options, option) {\n  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  // Local helpers\n  var isPresent = function isPresent(obj) {\n    return obj !== null && obj !== undefined;\n  };\n\n  var isObject = function isObject(obj) {\n    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3['default'])(obj)) === 'object';\n  };\n\n  // https://stackoverflow.com/a/34491287/1223531\n  var isEmpty = function isEmpty(obj) {\n    for (var x in obj) {\n      if (obj.hasOwnProperty(x)) return false;\n    }\n    return true;\n  };\n\n  // Guards\n  if (!isObject(mergeTarget)) {\n    throw new Error('Parameter mergeTarget must be an object');\n  }\n\n  if (!isObject(options)) {\n    throw new Error('Parameter options must be an object');\n  }\n\n  if (!isPresent(option)) {\n    throw new Error('Parameter option must have a value');\n  }\n\n  if (!isObject(globalOptions)) {\n    throw new Error('Parameter globalOptions must be an object');\n  }\n\n  //\n  // Actual merge routine, separated from main logic\n  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.\n  //\n  var doMerge = function doMerge(target, options, option) {\n    if (!isObject(target[option])) {\n      target[option] = {};\n    }\n\n    var src = options[option];\n    var dst = target[option];\n    for (var prop in src) {\n      if (src.hasOwnProperty(prop)) {\n        dst[prop] = src[prop];\n      }\n    }\n  };\n\n  // Local initialization\n  var srcOption = options[option];\n  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);\n  var globalOption = globalPassed ? globalOptions[option] : undefined;\n  var globalEnabled = globalOption ? globalOption.enabled : undefined;\n\n  /////////////////////////////////////////\n  // Main routine\n  /////////////////////////////////////////\n  if (srcOption === undefined) {\n    return; // Nothing to do\n  }\n\n  if (typeof srcOption === 'boolean') {\n    if (!isObject(mergeTarget[option])) {\n      mergeTarget[option] = {};\n    }\n\n    mergeTarget[option].enabled = srcOption;\n    return;\n  }\n\n  if (srcOption === null && !isObject(mergeTarget[option])) {\n    // If possible, explicit copy from globals\n    if (isPresent(globalOption)) {\n      mergeTarget[option] = (0, _create2['default'])(globalOption);\n    } else {\n      return; // Nothing to do\n    }\n  }\n\n  if (!isObject(srcOption)) {\n    return;\n  }\n\n  //\n  // Ensure that 'enabled' is properly set. It is required internally\n  // Note that the value from options will always overwrite the existing value\n  //\n  var enabled = true; // default value\n\n  if (srcOption.enabled !== undefined) {\n    enabled = srcOption.enabled;\n  } else {\n    // Take from globals, if present\n    if (globalEnabled !== undefined) {\n      enabled = globalOption.enabled;\n    }\n  }\n\n  doMerge(mergeTarget, options, option);\n  mergeTarget[option].enabled = enabled;\n};\n\n/**\n * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses\n * this function will then iterate in both directions over this sorted list to find all visible items.\n *\n * @param {Item[]} orderedItems       | Items ordered by start\n * @param {function} comparator       | -1 is lower, 0 is equal, 1 is higher\n * @param {string} field\n * @param {string} field2\n * @returns {number}\n * @private\n */\nexports.binarySearchCustom = function (orderedItems, comparator, field, field2) {\n  var maxIterations = 10000;\n  var iteration = 0;\n  var low = 0;\n  var high = orderedItems.length - 1;\n\n  while (low <= high && iteration < maxIterations) {\n    var middle = Math.floor((low + high) / 2);\n\n    var item = orderedItems[middle];\n    var value = field2 === undefined ? item[field] : item[field][field2];\n\n    var searchResult = comparator(value);\n    if (searchResult == 0) {\n      // jihaa, found a visible item!\n      return middle;\n    } else if (searchResult == -1) {\n      // it is too small --> increase low\n      low = middle + 1;\n    } else {\n      // it is too big --> decrease high\n      high = middle - 1;\n    }\n\n    iteration++;\n  }\n\n  return -1;\n};\n\n/**\n * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of\n * two values, we return either the one before or the one after, depending on user input\n * If it is found, we return the index, else -1.\n *\n * @param {Array} orderedItems\n * @param {{start: number, end: number}} target\n * @param {string} field\n * @param {string} sidePreference   'before' or 'after'\n * @param {function} comparator an optional comparator, returning -1,0,1 for <,==,>.\n * @returns {number}\n * @private\n */\nexports.binarySearchValue = function (orderedItems, target, field, sidePreference, comparator) {\n  var maxIterations = 10000;\n  var iteration = 0;\n  var low = 0;\n  var high = orderedItems.length - 1;\n  var prevValue, value, nextValue, middle;\n\n  comparator = comparator != undefined ? comparator : function (a, b) {\n    return a == b ? 0 : a < b ? -1 : 1;\n  };\n\n  while (low <= high && iteration < maxIterations) {\n    // get a new guess\n    middle = Math.floor(0.5 * (high + low));\n    prevValue = orderedItems[Math.max(0, middle - 1)][field];\n    value = orderedItems[middle][field];\n    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];\n\n    if (comparator(value, target) == 0) {\n      // we found the target\n      return middle;\n    } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {\n      // target is in between of the previous and the current\n      return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;\n    } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {\n      // target is in between of the current and the next\n      return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);\n    } else {\n      // didnt find the target, we need to change our boundaries.\n      if (comparator(value, target) < 0) {\n        // it is too small --> increase low\n        low = middle + 1;\n      } else {\n        // it is too big --> decrease high\n        high = middle - 1;\n      }\n    }\n    iteration++;\n  }\n\n  // didnt find anything. Return -1.\n  return -1;\n};\n\n/*\n * Easing Functions - inspired from http://gizma.com/easing/\n * only considering the t value for the range [0, 1] => [0, 1]\n * https://gist.github.com/gre/1650294\n */\nexports.easingFunctions = {\n  // no easing, no acceleration\n  linear: function linear(t) {\n    return t;\n  },\n  // accelerating from zero velocity\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  // decelerating to zero velocity\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  // acceleration until halfway, then deceleration\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n  // accelerating from zero velocity\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  // decelerating to zero velocity\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t + 1;\n  },\n  // acceleration until halfway, then deceleration\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  },\n  // accelerating from zero velocity\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  // decelerating to zero velocity\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  // acceleration until halfway, then deceleration\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  // accelerating from zero velocity\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  // decelerating to zero velocity\n  easeOutQuint: function easeOutQuint(t) {\n    return 1 + --t * t * t * t * t;\n  },\n  // acceleration until halfway, then deceleration\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n  }\n};\n\nexports.getScrollBarWidth = function () {\n  var inner = document.createElement('p');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  var outer = document.createElement('div');\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.left = '0px';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '200px';\n  outer.style.height = '150px';\n  outer.style.overflow = 'hidden';\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n  var w1 = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  var w2 = inner.offsetWidth;\n  if (w1 == w2) w2 = outer.clientWidth;\n\n  document.body.removeChild(outer);\n\n  return w1 - w2;\n};\n\nexports.topMost = function (pile, accessors) {\n  var candidate = void 0;\n  if (!Array.isArray(accessors)) {\n    accessors = [accessors];\n  }\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator3['default'])(pile), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var member = _step.value;\n\n      if (member) {\n        candidate = member[accessors[0]];\n        for (var i = 1; i < accessors.length; i++) {\n          if (candidate) {\n            candidate = candidate[accessors[i]];\n          }\n        }\n        if (typeof candidate != 'undefined') {\n          break;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return candidate;\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_49405__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_49405__(145), __esModule: true };\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_49557__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _typeof2 = __nested_webpack_require_49557__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_50171__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _setPrototypeOf = __nested_webpack_require_50171__(147);\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nvar _create = __nested_webpack_require_50171__(31);\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = __nested_webpack_require_50171__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_51498__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _iterator = __nested_webpack_require_51498__(104);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = __nested_webpack_require_51498__(106);\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_52628__) {\n\nvar store = __nested_webpack_require_52628__(44)('wks');\nvar uid = __nested_webpack_require_52628__(29);\nvar Symbol = __nested_webpack_require_52628__(10).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __nested_webpack_require_53075__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_53075__(102), __esModule: true };\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __nested_webpack_require_53654__) {\n\nvar global = __nested_webpack_require_53654__(10);\nvar core = __nested_webpack_require_53654__(6);\nvar ctx = __nested_webpack_require_53654__(61);\nvar hide = __nested_webpack_require_53654__(19);\nvar has = __nested_webpack_require_53654__(14);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && has(exports, key)) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __nested_webpack_require_56105__) {\n\nvar anObject = __nested_webpack_require_56105__(20);\nvar IE8_DOM_DEFINE = __nested_webpack_require_56105__(62);\nvar toPrimitive = __nested_webpack_require_56105__(40);\nvar dP = Object.defineProperty;\n\nexports.f = __nested_webpack_require_56105__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __nested_webpack_require_56773__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__nested_webpack_require_56773__(22)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_57216__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _isIterable2 = __nested_webpack_require_57216__(136);\n\nvar _isIterable3 = _interopRequireDefault(_isIterable2);\n\nvar _getIterator2 = __nested_webpack_require_57216__(58);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if ((0, _isIterable3.default)(Object(arr))) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __nested_webpack_require_58479__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof2 = __nested_webpack_require_58479__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _classCallCheck2 = __nested_webpack_require_58479__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_58479__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * The Base class for all Nodes.\n */\nvar NodeBase = function () {\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function NodeBase(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, NodeBase);\n\n    this.body = body;\n    this.labelModule = labelModule;\n    this.setOptions(options);\n    this.top = undefined;\n    this.left = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.radius = undefined;\n    this.margin = undefined;\n    this.refreshNeeded = true;\n    this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(NodeBase, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     *\n     * @param {Label} labelModule\n     * @private\n     */\n\n  }, {\n    key: '_setMargins',\n    value: function _setMargins(labelModule) {\n      this.margin = {};\n      if (this.options.margin) {\n        if ((0, _typeof3['default'])(this.options.margin) == 'object') {\n          this.margin.top = this.options.margin.top;\n          this.margin.right = this.options.margin.right;\n          this.margin.bottom = this.options.margin.bottom;\n          this.margin.left = this.options.margin.left;\n        } else {\n          this.margin.top = this.options.margin;\n          this.margin.right = this.options.margin;\n          this.margin.bottom = this.options.margin;\n          this.margin.left = this.options.margin;\n        }\n      }\n      labelModule.adjustSizes(this.margin);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_distanceToBorder',\n    value: function _distanceToBorder(ctx, angle) {\n      var borderWidth = this.options.borderWidth;\n      this.resize(ctx);\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'enableShadow',\n    value: function enableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'disableShadow',\n    value: function disableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = 'rgba(0,0,0,0)';\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'enableBorderDashes',\n    value: function enableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var dashes = values.borderDashes;\n          if (dashes === true) {\n            dashes = [5, 15];\n          }\n          ctx.setLineDash(dashes);\n        } else {\n          console.warn('setLineDash is not supported in this browser. The dashed borders cannot be used.');\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'disableBorderDashes',\n    value: function disableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([0]);\n        } else {\n          console.warn('setLineDash is not supported in this browser. The dashed borders cannot be used.');\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n\n    /**\n     * Determine if the shape of a node needs to be recalculated.\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     * @protected\n     */\n\n  }, {\n    key: 'needsRefresh',\n    value: function needsRefresh(selected, hover) {\n      if (this.refreshNeeded === true) {\n        // This is probably not the best location to reset this member.\n        // However, in the current logic, it is the most convenient one.\n        this.refreshNeeded = false;\n        return true;\n      }\n\n      return this.width === undefined || this.labelModule.differentState(selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'initContextForDraw',\n    value: function initContextForDraw(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale;\n\n      ctx.lineWidth = Math.min(this.width, borderWidth);\n      ctx.strokeStyle = values.borderColor;\n      ctx.fillStyle = values.color;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'performStroke',\n    value: function performStroke(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale;\n\n      //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.\n      ctx.save();\n      // if borders are zero width, they will be drawn with width 1 by default. This prevents that\n      if (borderWidth > 0) {\n        this.enableBorderDashes(ctx, values);\n        //draw the border\n        ctx.stroke();\n        //disable dashed border for other elements\n        this.disableBorderDashes(ctx, values);\n      }\n      ctx.restore();\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'performFill',\n    value: function performFill(ctx, values) {\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      // draw the background\n      ctx.fill();\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n\n      this.performStroke(ctx, values);\n    }\n\n    /**\n     *\n     * @param {number} margin\n     * @private\n     */\n\n  }, {\n    key: '_addBoundingBoxMargin',\n    value: function _addBoundingBoxMargin(margin) {\n      this.boundingBox.left -= margin;\n      this.boundingBox.top -= margin;\n      this.boundingBox.bottom += margin;\n      this.boundingBox.right += margin;\n    }\n\n    /**\n     * Actual implementation of this method call.\n     *\n     * Doing it like this makes it easier to override\n     * in the child classes.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n\n  }, {\n    key: '_updateBoundingBox',\n    value: function _updateBoundingBox(x, y, ctx, selected, hover) {\n      if (ctx !== undefined) {\n        this.resize(ctx, selected, hover);\n      }\n\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n    }\n\n    /**\n     * Default implementation of this method call.\n     * This acts as a stub which can be overridden.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n    }\n\n    /**\n     * Determine the dimensions to use for nodes with an internal label\n     *\n     * Currently, these are: Circle, Ellipse, Database, Box\n     * The other nodes have external labels, and will not call this method\n     *\n     * If there is no label, decent default values are supplied.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} [selected]\n     * @param {boolean} [hover]\n     * @returns {{width:number, height:number}}\n     */\n\n  }, {\n    key: 'getDimensionsFromLabel',\n    value: function getDimensionsFromLabel(ctx, selected, hover) {\n      // NOTE: previously 'textSize' was not put in 'this' for Ellipse\n      // TODO: examine the consequences.\n      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n      var width = this.textSize.width;\n      var height = this.textSize.height;\n\n      var DEFAULT_SIZE = 14;\n      if (width === 0) {\n        // This happens when there is no label text set\n        width = DEFAULT_SIZE; // use a decent default\n        height = DEFAULT_SIZE; // if width zero, then height also always zero\n      }\n\n      return { width: width, height: height };\n    }\n  }]);\n  return NodeBase;\n}();\n\nexports['default'] = NodeBase;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_68154__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_68154__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_68154__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_68154__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_68154__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_68154__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _NodeBase2 = __nested_webpack_require_68154__(16);\n\nvar _NodeBase3 = _interopRequireDefault(_NodeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Base class for constructing Node/Cluster Shapes.\n *\n * @extends NodeBase\n */\nvar ShapeBase = function (_NodeBase) {\n  (0, _inherits3['default'])(ShapeBase, _NodeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function ShapeBase(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, ShapeBase);\n    return (0, _possibleConstructorReturn3['default'])(this, (ShapeBase.__proto__ || (0, _getPrototypeOf2['default'])(ShapeBase)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   * @param {Object} [values={size: this.options.size}]\n   */\n\n\n  (0, _createClass3['default'])(ShapeBase, [{\n    key: 'resize',\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { size: this.options.size };\n\n      if (this.needsRefresh(selected, hover)) {\n        this.labelModule.getTextSize(ctx, selected, hover);\n        var size = 2 * values.size;\n        this.width = size;\n        this.height = size;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} shape\n     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     * @private\n     */\n\n  }, {\n    key: '_drawShape',\n    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover, values);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      this.initContextForDraw(ctx, values);\n      ctx[shape](x, y, values.size);\n      this.performFill(ctx, values);\n\n      if (this.options.icon !== undefined) {\n        if (this.options.icon.code !== undefined) {\n          ctx.font = (selected ? 'bold ' : '') + this.height / 2 + 'px ' + (this.options.icon.face || 'FontAwesome');\n          ctx.fillStyle = this.options.icon.color || 'black';\n          ctx.textAlign = 'center';\n          ctx.textBaseline = 'middle';\n          ctx.fillText(this.options.icon.code, x, y);\n        }\n      }\n\n      if (this.options.label !== undefined) {\n        // Need to call following here in order to ensure value for `this.labelModule.size.height`\n        this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, 'hanging');\n        var yLabel = y + 0.5 * this.height + 0.5 * this.labelModule.size.height;\n        this.labelModule.draw(ctx, x, yLabel, selected, hover, 'hanging');\n      }\n\n      this.updateBoundingBox(x, y);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);\n      }\n    }\n  }]);\n  return ShapeBase;\n}(_NodeBase3['default']);\n\nexports['default'] = ShapeBase;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_72961__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __nested_webpack_require_72961__(59);\nvar defined = __nested_webpack_require_72961__(39);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_73260__) {\n\nvar dP = __nested_webpack_require_73260__(12);\nvar createDesc = __nested_webpack_require_73260__(28);\nmodule.exports = __nested_webpack_require_73260__(13) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_73618__) {\n\nvar isObject = __nested_webpack_require_73618__(21);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_74178__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_74178__(123), __esModule: true };\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_74331__) {\n\n\"use strict\";\n\n\n/**\n * Setup a mock hammer.js object, for unit testing.\n *\n * Inspiration: https://github.com/uber/deck.gl/pull/658\n *\n * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}\n */\nfunction hammerMock() {\n  var noop = function noop() {};\n\n  return {\n    on: noop,\n    off: noop,\n    destroy: noop,\n    emit: noop,\n\n    //eslint-disable-next-line no-unused-vars\n    get: function get(m) {\n      return {\n        set: noop\n      };\n    }\n  };\n}\n\nif (typeof window !== 'undefined') {\n  var propagating = __nested_webpack_require_74331__(127);\n  var Hammer = window['Hammer'] || __nested_webpack_require_74331__(128);\n  module.exports = propagating(Hammer, {\n    preventDefault: 'mouse'\n  });\n} else {\n  module.exports = function () {\n    // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.\n    return hammerMock();\n  };\n}\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_75352__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __nested_webpack_require_75352__(65);\nvar enumBugKeys = __nested_webpack_require_75352__(45);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\nmodule.exports = true;\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __nested_webpack_require_76166__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __nested_webpack_require_76166__(39);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __nested_webpack_require_76378__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_76378__(100), __esModule: true };\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\nexports.f = {}.propertyIsEnumerable;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __nested_webpack_require_76625__) {\n\n\"use strict\";\n\n\nvar _stringify = __nested_webpack_require_76625__(23);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _typeof2 = __nested_webpack_require_76625__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _keys = __nested_webpack_require_76625__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_76625__(2);\nvar Queue = __nested_webpack_require_76625__(72);\n\n/**\n * DataSet\n * // TODO: add a DataSet constructor DataSet(data, options)\n *\n * Usage:\n *     var dataSet = new DataSet({\n *         fieldId: '_id',\n *         type: {\n *             // ...\n *         }\n *     });\n *\n *     dataSet.add(item);\n *     dataSet.add(data);\n *     dataSet.update(item);\n *     dataSet.update(data);\n *     dataSet.remove(id);\n *     dataSet.remove(ids);\n *     var data = dataSet.get();\n *     var data = dataSet.get(id);\n *     var data = dataSet.get(ids);\n *     var data = dataSet.get(ids, options, data);\n *     dataSet.clear();\n *\n * A data set can:\n * - add/remove/update data\n * - gives triggers upon changes in the data\n * - can  import/export data in various data formats\n *\n * @param {Array} [data]    Optional array with initial data\n * @param {Object} [options]   Available options:\n *                             {string} fieldId Field name of the id in the\n *                                              items, 'id' by default.\n *                             {Object.<string, string} type\n *                                              A map with field names as key,\n *                                              and the field type as value.\n *                             {Object} queue   Queue changes to the DataSet,\n *                                              flush them all at once.\n *                                              Queue options:\n *                                              - {number} delay  Delay in ms, null by default\n *                                              - {number} max    Maximum number of entries in the queue, Infinity by default\n * @constructor DataSet\n */\nfunction DataSet(data, options) {\n  // correctly read optional arguments\n  if (data && !Array.isArray(data)) {\n    options = data;\n    data = null;\n  }\n\n  this._options = options || {};\n  this._data = {}; // map with data indexed by id\n  this.length = 0; // number of items in the DataSet\n  this._fieldId = this._options.fieldId || 'id'; // name of the field containing id\n  this._type = {}; // internal field types (NOTE: this can differ from this._options.type)\n\n  // all variants of a Date are internally stored as Date, so we can convert\n  // from everything to everything (also from ISODate to Number for example)\n  if (this._options.type) {\n    var fields = (0, _keys2['default'])(this._options.type);\n    for (var i = 0, len = fields.length; i < len; i++) {\n      var field = fields[i];\n      var value = this._options.type[field];\n      if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {\n        this._type[field] = 'Date';\n      } else {\n        this._type[field] = value;\n      }\n    }\n  }\n\n  this._subscribers = {}; // event subscribers\n\n  // add initial data when provided\n  if (data) {\n    this.add(data);\n  }\n\n  this.setOptions(options);\n}\n\n/**\n * @param {Object} options   Available options:\n *                             {Object} queue   Queue changes to the DataSet,\n *                                              flush them all at once.\n *                                              Queue options:\n *                                              - {number} delay  Delay in ms, null by default\n *                                              - {number} max    Maximum number of entries in the queue, Infinity by default\n */\nDataSet.prototype.setOptions = function (options) {\n  if (options && options.queue !== undefined) {\n    if (options.queue === false) {\n      // delete queue if loaded\n      if (this._queue) {\n        this._queue.destroy();\n        delete this._queue;\n      }\n    } else {\n      // create queue and update its options\n      if (!this._queue) {\n        this._queue = Queue.extend(this, {\n          replace: ['add', 'update', 'remove']\n        });\n      }\n\n      if ((0, _typeof3['default'])(options.queue) === 'object') {\n        this._queue.setOptions(options.queue);\n      }\n    }\n  }\n};\n\n/**\n * Subscribe to an event, add an event listener\n * @param {string} event        Event name. Available events: 'add', 'update',\n *                              'remove'\n * @param {function} callback   Callback method. Called with three parameters:\n *                                  {string} event\n *                                  {Object | null} params\n *                                  {string | number} senderId\n */\nDataSet.prototype.on = function (event, callback) {\n  var subscribers = this._subscribers[event];\n  if (!subscribers) {\n    subscribers = [];\n    this._subscribers[event] = subscribers;\n  }\n\n  subscribers.push({\n    callback: callback\n  });\n};\n\n/**\n * Unsubscribe from an event, remove an event listener\n * @param {string} event\n * @param {function} callback\n */\nDataSet.prototype.off = function (event, callback) {\n  var subscribers = this._subscribers[event];\n  if (subscribers) {\n    this._subscribers[event] = subscribers.filter(function (listener) {\n      return listener.callback != callback;\n    });\n  }\n};\n\n/**\n * Trigger an event\n * @param {string} event\n * @param {Object | null} params\n * @param {string} [senderId]       Optional id of the sender.\n * @private\n */\nDataSet.prototype._trigger = function (event, params, senderId) {\n  if (event == '*') {\n    throw new Error('Cannot trigger event *');\n  }\n\n  var subscribers = [];\n  if (event in this._subscribers) {\n    subscribers = subscribers.concat(this._subscribers[event]);\n  }\n  if ('*' in this._subscribers) {\n    subscribers = subscribers.concat(this._subscribers['*']);\n  }\n\n  for (var i = 0, len = subscribers.length; i < len; i++) {\n    var subscriber = subscribers[i];\n    if (subscriber.callback) {\n      subscriber.callback(event, params, senderId || null);\n    }\n  }\n};\n\n/**\n * Add data.\n * Adding an item will fail when there already is an item with the same id.\n * @param {Object | Array} data\n * @param {string} [senderId] Optional sender id\n * @return {Array.<string|number>} addedIds      Array with the ids of the added items\n */\nDataSet.prototype.add = function (data, senderId) {\n  var addedIds = [],\n      id,\n      me = this;\n\n  if (Array.isArray(data)) {\n    // Array\n    for (var i = 0, len = data.length; i < len; i++) {\n      id = me._addItem(data[i]);\n      addedIds.push(id);\n    }\n  } else if (data && (typeof data === 'undefined' ? 'undefined' : (0, _typeof3['default'])(data)) === 'object') {\n    // Single item\n    id = me._addItem(data);\n    addedIds.push(id);\n  } else {\n    throw new Error('Unknown dataType');\n  }\n\n  if (addedIds.length) {\n    this._trigger('add', { items: addedIds }, senderId);\n  }\n\n  return addedIds;\n};\n\n/**\n * Update existing items. When an item does not exist, it will be created\n * @param {Object | Array} data\n * @param {string} [senderId] Optional sender id\n * @return {Array.<string|number>} updatedIds     The ids of the added or updated items\n * @throws {Error} Unknown Datatype\n */\nDataSet.prototype.update = function (data, senderId) {\n  var addedIds = [];\n  var updatedIds = [];\n  var oldData = [];\n  var updatedData = [];\n  var me = this;\n  var fieldId = me._fieldId;\n\n  var addOrUpdate = function addOrUpdate(item) {\n    var id = item[fieldId];\n    if (me._data[id]) {\n      var oldItem = util.extend({}, me._data[id]);\n      // update item\n      id = me._updateItem(item);\n      updatedIds.push(id);\n      updatedData.push(item);\n      oldData.push(oldItem);\n    } else {\n      // add new item\n      id = me._addItem(item);\n      addedIds.push(id);\n    }\n  };\n\n  if (Array.isArray(data)) {\n    // Array\n    for (var i = 0, len = data.length; i < len; i++) {\n      if (data[i] && (0, _typeof3['default'])(data[i]) === 'object') {\n        addOrUpdate(data[i]);\n      } else {\n        console.warn('Ignoring input item, which is not an object at index ' + i);\n      }\n    }\n  } else if (data && (typeof data === 'undefined' ? 'undefined' : (0, _typeof3['default'])(data)) === 'object') {\n    // Single item\n    addOrUpdate(data);\n  } else {\n    throw new Error('Unknown dataType');\n  }\n\n  if (addedIds.length) {\n    this._trigger('add', { items: addedIds }, senderId);\n  }\n  if (updatedIds.length) {\n    var props = { items: updatedIds, oldData: oldData, data: updatedData\n      // TODO: remove deprecated property 'data' some day\n      //Object.defineProperty(props, 'data', {\n      //  'get': (function() {\n      //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');\n      //    return updatedData;\n      //  }).bind(this)\n      //});\n    };this._trigger('update', props, senderId);\n  }\n\n  return addedIds.concat(updatedIds);\n};\n\n// prettier-ignore\n/**\n * Get a data item or multiple items.\n *\n * Usage:\n *\n *     get()\n *     get(options: Object)\n *\n *     get(id: number | string)\n *     get(id: number | string, options: Object)\n *\n *     get(ids: number[] | string[])\n *     get(ids: number[] | string[], options: Object)\n *\n * Where:\n *\n * {number | string} id         The id of an item\n * {number[] | string{}} ids    An array with ids of items\n * {Object} options             An Object with options. Available options:\n * {string} [returnType]        Type of data to be returned.\n *                              Can be 'Array' (default) or 'Object'.\n * {Object.<string, string>} [type]\n * {string[]} [fields]          field names to be returned\n * {function} [filter]          filter items\n * {string | function} [order]  Order the items by a field name or custom sort function.\n * @param {Array} args\n * @returns {DataSet}\n * @throws Error\n */\nDataSet.prototype.get = function (args) {\n  // eslint-disable-line no-unused-vars\n  var me = this;\n\n  // parse the arguments\n  var id, ids, options;\n  var firstType = util.getType(arguments[0]);\n  if (firstType == 'String' || firstType == 'Number') {\n    // get(id [, options])\n    id = arguments[0];\n    options = arguments[1];\n  } else if (firstType == 'Array') {\n    // get(ids [, options])\n    ids = arguments[0];\n    options = arguments[1];\n  } else {\n    // get([, options])\n    options = arguments[0];\n  }\n\n  // determine the return type\n  var returnType;\n  if (options && options.returnType) {\n    var allowedValues = ['Array', 'Object'];\n    returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;\n  } else {\n    returnType = 'Array';\n  }\n\n  // build options\n  var type = options && options.type || this._options.type;\n  var filter = options && options.filter;\n  var items = [],\n      item,\n      itemIds,\n      itemId,\n      i,\n      len;\n\n  // convert items\n  if (id != undefined) {\n    // return a single item\n    item = me._getItem(id, type);\n    if (item && filter && !filter(item)) {\n      item = null;\n    }\n  } else if (ids != undefined) {\n    // return a subset of items\n    for (i = 0, len = ids.length; i < len; i++) {\n      item = me._getItem(ids[i], type);\n      if (!filter || filter(item)) {\n        items.push(item);\n      }\n    }\n  } else {\n    // return all items\n    itemIds = (0, _keys2['default'])(this._data);\n    for (i = 0, len = itemIds.length; i < len; i++) {\n      itemId = itemIds[i];\n      item = me._getItem(itemId, type);\n      if (!filter || filter(item)) {\n        items.push(item);\n      }\n    }\n  }\n\n  // order the results\n  if (options && options.order && id == undefined) {\n    this._sort(items, options.order);\n  }\n\n  // filter fields of the items\n  if (options && options.fields) {\n    var fields = options.fields;\n    if (id != undefined) {\n      item = this._filterFields(item, fields);\n    } else {\n      for (i = 0, len = items.length; i < len; i++) {\n        items[i] = this._filterFields(items[i], fields);\n      }\n    }\n  }\n\n  // return the results\n  if (returnType == 'Object') {\n    var result = {},\n        resultant;\n    for (i = 0, len = items.length; i < len; i++) {\n      resultant = items[i];\n      result[resultant.id] = resultant;\n    }\n    return result;\n  } else {\n    if (id != undefined) {\n      // a single item\n      return item;\n    } else {\n      // just return our array\n      return items;\n    }\n  }\n};\n\n/**\n * Get ids of all items or from a filtered set of items.\n * @param {Object} [options]    An Object with options. Available options:\n *                              {function} [filter] filter items\n *                              {string | function} [order] Order the items by\n *                                  a field name or custom sort function.\n * @return {Array.<string|number>} ids\n */\nDataSet.prototype.getIds = function (options) {\n  var data = this._data,\n      filter = options && options.filter,\n      order = options && options.order,\n      type = options && options.type || this._options.type,\n      itemIds = (0, _keys2['default'])(data),\n      i,\n      len,\n      id,\n      item,\n      items,\n      ids = [];\n\n  if (filter) {\n    // get filtered items\n    if (order) {\n      // create ordered list\n      items = [];\n      for (i = 0, len = itemIds.length; i < len; i++) {\n        id = itemIds[i];\n        item = this._getItem(id, type);\n        if (filter(item)) {\n          items.push(item);\n        }\n      }\n\n      this._sort(items, order);\n\n      for (i = 0, len = items.length; i < len; i++) {\n        ids.push(items[i][this._fieldId]);\n      }\n    } else {\n      // create unordered list\n      for (i = 0, len = itemIds.length; i < len; i++) {\n        id = itemIds[i];\n        item = this._getItem(id, type);\n        if (filter(item)) {\n          ids.push(item[this._fieldId]);\n        }\n      }\n    }\n  } else {\n    // get all items\n    if (order) {\n      // create an ordered list\n      items = [];\n      for (i = 0, len = itemIds.length; i < len; i++) {\n        id = itemIds[i];\n        items.push(data[id]);\n      }\n\n      this._sort(items, order);\n\n      for (i = 0, len = items.length; i < len; i++) {\n        ids.push(items[i][this._fieldId]);\n      }\n    } else {\n      // create unordered list\n      for (i = 0, len = itemIds.length; i < len; i++) {\n        id = itemIds[i];\n        item = data[id];\n        ids.push(item[this._fieldId]);\n      }\n    }\n  }\n\n  return ids;\n};\n\n/**\n * Returns the DataSet itself. Is overwritten for example by the DataView,\n * which returns the DataSet it is connected to instead.\n * @returns {DataSet}\n */\nDataSet.prototype.getDataSet = function () {\n  return this;\n};\n\n/**\n * Execute a callback function for every item in the dataset.\n * @param {function} callback\n * @param {Object} [options]    Available options:\n *                              {Object.<string, string>} [type]\n *                              {string[]} [fields] filter fields\n *                              {function} [filter] filter items\n *                              {string | function} [order] Order the items by\n *                                  a field name or custom sort function.\n */\nDataSet.prototype.forEach = function (callback, options) {\n  var filter = options && options.filter,\n      type = options && options.type || this._options.type,\n      data = this._data,\n      itemIds = (0, _keys2['default'])(data),\n      i,\n      len,\n      item,\n      id;\n\n  if (options && options.order) {\n    // execute forEach on ordered list\n    var items = this.get(options);\n\n    for (i = 0, len = items.length; i < len; i++) {\n      item = items[i];\n      id = item[this._fieldId];\n      callback(item, id);\n    }\n  } else {\n    // unordered\n    for (i = 0, len = itemIds.length; i < len; i++) {\n      id = itemIds[i];\n      item = this._getItem(id, type);\n      if (!filter || filter(item)) {\n        callback(item, id);\n      }\n    }\n  }\n};\n\n/**\n * Map every item in the dataset.\n * @param {function} callback\n * @param {Object} [options]    Available options:\n *                              {Object.<string, string>} [type]\n *                              {string[]} [fields] filter fields\n *                              {function} [filter] filter items\n *                              {string | function} [order] Order the items by\n *                                  a field name or custom sort function.\n * @return {Object[]} mappedItems\n */\nDataSet.prototype.map = function (callback, options) {\n  var filter = options && options.filter,\n      type = options && options.type || this._options.type,\n      mappedItems = [],\n      data = this._data,\n      itemIds = (0, _keys2['default'])(data),\n      i,\n      len,\n      id,\n      item;\n\n  // convert and filter items\n  for (i = 0, len = itemIds.length; i < len; i++) {\n    id = itemIds[i];\n    item = this._getItem(id, type);\n    if (!filter || filter(item)) {\n      mappedItems.push(callback(item, id));\n    }\n  }\n\n  // order items\n  if (options && options.order) {\n    this._sort(mappedItems, options.order);\n  }\n\n  return mappedItems;\n};\n\n/**\n * Filter the fields of an item\n * @param {Object | null} item\n * @param {string[]} fields     Field names\n * @return {Object | null} filteredItem or null if no item is provided\n * @private\n */\nDataSet.prototype._filterFields = function (item, fields) {\n  if (!item) {\n    // item is null\n    return item;\n  }\n\n  var filteredItem = {},\n      itemFields = (0, _keys2['default'])(item),\n      len = itemFields.length,\n      i,\n      field;\n\n  if (Array.isArray(fields)) {\n    for (i = 0; i < len; i++) {\n      field = itemFields[i];\n      if (fields.indexOf(field) != -1) {\n        filteredItem[field] = item[field];\n      }\n    }\n  } else {\n    for (i = 0; i < len; i++) {\n      field = itemFields[i];\n      if (fields.hasOwnProperty(field)) {\n        filteredItem[fields[field]] = item[field];\n      }\n    }\n  }\n\n  return filteredItem;\n};\n\n/**\n * Sort the provided array with items\n * @param {Object[]} items\n * @param {string | function} order      A field name or custom sort function.\n * @private\n */\nDataSet.prototype._sort = function (items, order) {\n  if (util.isString(order)) {\n    // order by provided field name\n    var name = order; // field name\n    items.sort(function (a, b) {\n      var av = a[name];\n      var bv = b[name];\n      return av > bv ? 1 : av < bv ? -1 : 0;\n    });\n  } else if (typeof order === 'function') {\n    // order by sort function\n    items.sort(order);\n  }\n  // TODO: extend order by an Object {field:string, direction:string}\n  //       where direction can be 'asc' or 'desc'\n  else {\n      throw new TypeError('Order must be a function or a string');\n    }\n};\n\n/**\n * Remove an object by pointer or by id\n * @param {string | number | Object | Array.<string|number>} id Object or id, or an array with\n *                                              objects or ids to be removed\n * @param {string} [senderId] Optional sender id\n * @return {Array.<string|number>} removedIds\n */\nDataSet.prototype.remove = function (id, senderId) {\n  var removedIds = [],\n      removedItems = [],\n      ids = [],\n      i,\n      len,\n      itemId,\n      item;\n\n  // force everything to be an array for simplicity\n  ids = Array.isArray(id) ? id : [id];\n\n  for (i = 0, len = ids.length; i < len; i++) {\n    item = this._remove(ids[i]);\n    if (item) {\n      itemId = item[this._fieldId];\n      if (itemId != undefined) {\n        removedIds.push(itemId);\n        removedItems.push(item);\n      }\n    }\n  }\n\n  if (removedIds.length) {\n    this._trigger('remove', { items: removedIds, oldData: removedItems }, senderId);\n  }\n\n  return removedIds;\n};\n\n/**\n * Remove an item by its id\n * @param {number | string | Object} id   id or item\n * @returns {number | string | null} id\n * @private\n */\nDataSet.prototype._remove = function (id) {\n  var item, ident;\n\n  // confirm the id to use based on the args type\n  if (util.isNumber(id) || util.isString(id)) {\n    ident = id;\n  } else if (id && (typeof id === 'undefined' ? 'undefined' : (0, _typeof3['default'])(id)) === 'object') {\n    ident = id[this._fieldId]; // look for the identifier field using _fieldId\n  }\n\n  // do the remove if the item is found\n  if (ident !== undefined && this._data[ident]) {\n    item = this._data[ident];\n    delete this._data[ident];\n    this.length--;\n    return item;\n  }\n  return null;\n};\n\n/**\n * Clear the data\n * @param {string} [senderId] Optional sender id\n * @return {Array.<string|number>} removedIds    The ids of all removed items\n */\nDataSet.prototype.clear = function (senderId) {\n  var i, len;\n  var ids = (0, _keys2['default'])(this._data);\n  var items = [];\n\n  for (i = 0, len = ids.length; i < len; i++) {\n    items.push(this._data[ids[i]]);\n  }\n\n  this._data = {};\n  this.length = 0;\n\n  this._trigger('remove', { items: ids, oldData: items }, senderId);\n\n  return ids;\n};\n\n/**\n * Find the item with maximum value of a specified field\n * @param {string} field\n * @return {Object | null} item  Item containing max value, or null if no items\n */\nDataSet.prototype.max = function (field) {\n  var data = this._data,\n      itemIds = (0, _keys2['default'])(data),\n      max = null,\n      maxField = null,\n      i,\n      len;\n\n  for (i = 0, len = itemIds.length; i < len; i++) {\n    var id = itemIds[i];\n    var item = data[id];\n    var itemField = item[field];\n    if (itemField != null && (!max || itemField > maxField)) {\n      max = item;\n      maxField = itemField;\n    }\n  }\n\n  return max;\n};\n\n/**\n * Find the item with minimum value of a specified field\n * @param {string} field\n * @return {Object | null} item  Item containing max value, or null if no items\n */\nDataSet.prototype.min = function (field) {\n  var data = this._data,\n      itemIds = (0, _keys2['default'])(data),\n      min = null,\n      minField = null,\n      i,\n      len;\n\n  for (i = 0, len = itemIds.length; i < len; i++) {\n    var id = itemIds[i];\n    var item = data[id];\n    var itemField = item[field];\n    if (itemField != null && (!min || itemField < minField)) {\n      min = item;\n      minField = itemField;\n    }\n  }\n\n  return min;\n};\n\n/**\n * Find all distinct values of a specified field\n * @param {string} field\n * @return {Array} values  Array containing all distinct values. If data items\n *                         do not contain the specified field are ignored.\n *                         The returned array is unordered.\n */\nDataSet.prototype.distinct = function (field) {\n  var data = this._data;\n  var itemIds = (0, _keys2['default'])(data);\n  var values = [];\n  var fieldType = this._options.type && this._options.type[field] || null;\n  var count = 0;\n  var i, j, len;\n\n  for (i = 0, len = itemIds.length; i < len; i++) {\n    var id = itemIds[i];\n    var item = data[id];\n    var value = item[field];\n    var exists = false;\n    for (j = 0; j < count; j++) {\n      if (values[j] == value) {\n        exists = true;\n        break;\n      }\n    }\n    if (!exists && value !== undefined) {\n      values[count] = value;\n      count++;\n    }\n  }\n\n  if (fieldType) {\n    for (i = 0, len = values.length; i < len; i++) {\n      values[i] = util.convert(values[i], fieldType);\n    }\n  }\n\n  return values;\n};\n\n/**\n * Add a single item. Will fail when an item with the same id already exists.\n * @param {Object} item\n * @return {string} id\n * @private\n */\nDataSet.prototype._addItem = function (item) {\n  var id = item[this._fieldId];\n\n  if (id != undefined) {\n    // check whether this id is already taken\n    if (this._data[id]) {\n      // item already exists\n      throw new Error('Cannot add item: item with id ' + id + ' already exists');\n    }\n  } else {\n    // generate an id\n    id = util.randomUUID();\n    item[this._fieldId] = id;\n  }\n\n  var d = {},\n      fields = (0, _keys2['default'])(item),\n      i,\n      len;\n  for (i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    var fieldType = this._type[field]; // type may be undefined\n    d[field] = util.convert(item[field], fieldType);\n  }\n  this._data[id] = d;\n  this.length++;\n\n  return id;\n};\n\n/**\n * Get an item. Fields can be converted to a specific type\n * @param {string} id\n * @param {Object.<string, string>} [types]  field types to convert\n * @return {Object | null} item\n * @private\n */\nDataSet.prototype._getItem = function (id, types) {\n  var field, value, i, len;\n\n  // get the item from the dataset\n  var raw = this._data[id];\n  if (!raw) {\n    return null;\n  }\n\n  // convert the items field types\n  var converted = {},\n      fields = (0, _keys2['default'])(raw);\n\n  if (types) {\n    for (i = 0, len = fields.length; i < len; i++) {\n      field = fields[i];\n      value = raw[field];\n      converted[field] = util.convert(value, types[field]);\n    }\n  } else {\n    // no field types specified, no converting needed\n    for (i = 0, len = fields.length; i < len; i++) {\n      field = fields[i];\n      value = raw[field];\n      converted[field] = value;\n    }\n  }\n\n  if (!converted[this._fieldId]) {\n    converted[this._fieldId] = raw.id;\n  }\n\n  return converted;\n};\n\n/**\n * Update a single item: merge with existing item.\n * Will fail when the item has no id, or when there does not exist an item\n * with the same id.\n * @param {Object} item\n * @return {string} id\n * @private\n */\nDataSet.prototype._updateItem = function (item) {\n  var id = item[this._fieldId];\n  if (id == undefined) {\n    throw new Error('Cannot update item: item has no id (item: ' + (0, _stringify2['default'])(item) + ')');\n  }\n  var d = this._data[id];\n  if (!d) {\n    // item doesn't exist\n    throw new Error('Cannot update item: no item with id ' + id + ' found');\n  }\n\n  // merge with current item\n  var fields = (0, _keys2['default'])(item);\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    var fieldType = this._type[field]; // type may be undefined\n    d[field] = util.convert(item[field], fieldType);\n  }\n\n  return id;\n};\n\nmodule.exports = DataSet;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __nested_webpack_require_102692__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_102692__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_102692__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_102692__(2);\n\nvar Label = __nested_webpack_require_102692__(77)['default'];\nvar ComponentUtil = __nested_webpack_require_102692__(35)['default'];\nvar Box = __nested_webpack_require_102692__(144)['default'];\nvar Circle = __nested_webpack_require_102692__(151)['default'];\nvar CircularImage = __nested_webpack_require_102692__(152)['default'];\nvar Database = __nested_webpack_require_102692__(153)['default'];\nvar Diamond = __nested_webpack_require_102692__(154)['default'];\nvar Dot = __nested_webpack_require_102692__(155)['default'];\nvar Ellipse = __nested_webpack_require_102692__(156)['default'];\nvar Icon = __nested_webpack_require_102692__(157)['default'];\nvar Image = __nested_webpack_require_102692__(158)['default'];\nvar Square = __nested_webpack_require_102692__(159)['default'];\nvar Hexagon = __nested_webpack_require_102692__(160)['default'];\nvar Star = __nested_webpack_require_102692__(161)['default'];\nvar Text = __nested_webpack_require_102692__(162)['default'];\nvar Triangle = __nested_webpack_require_102692__(163)['default'];\nvar TriangleDown = __nested_webpack_require_102692__(164)['default'];\n\nvar _require = __nested_webpack_require_102692__(54),\n    printStyle = _require.printStyle;\n\n/**\n * A node. A node can be connected to other nodes via one or multiple edges.\n */\n\n\nvar Node = function () {\n  /**\n   *\n   * @param {object} options An object containing options for the node. All\n   *                            options are optional, except for the id.\n   *                              {number} id     Id of the node. Required\n   *                              {string} label  Text label for the node\n   *                              {number} x      Horizontal position of the node\n   *                              {number} y      Vertical position of the node\n   *                              {string} shape  Node shape\n   *                              {string} image  An image url\n   *                              {string} title  A title text, can be HTML\n   *                              {anytype} group A group name or number\n   *\n   * @param {Object} body               Shared state of current network instance\n   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image\n   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options\n   * @param {Object} globalOptions      Current global node options; these serve as defaults for the node instance\n   * @param {Object} defaultOptions     Global default options for nodes; note that this is also the prototype\n   *                                    for parameter `globalOptions`.\n   */\n  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    (0, _classCallCheck3['default'])(this, Node);\n\n    this.options = util.bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n\n    this.edges = []; // all edges connected to this node\n\n    // set defaults for the options\n    this.id = undefined;\n    this.imagelist = imagelist;\n    this.grouplist = grouplist;\n\n    // state options\n    this.x = undefined;\n    this.y = undefined;\n    this.baseSize = this.options.size;\n    this.baseFontSize = this.options.font.size;\n    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate\n    this.selected = false;\n    this.hover = false;\n\n    this.labelModule = new Label(this.body, this.options, false /* Not edge label */\n    );\n    this.setOptions(options);\n  }\n\n  /**\n   * Attach a edge to the node\n   * @param {Edge} edge\n   */\n\n\n  (0, _createClass3['default'])(Node, [{\n    key: 'attachEdge',\n    value: function attachEdge(edge) {\n      if (this.edges.indexOf(edge) === -1) {\n        this.edges.push(edge);\n      }\n    }\n\n    /**\n     * Detach a edge from the node\n     *\n     * @param {Edge} edge\n     */\n\n  }, {\n    key: 'detachEdge',\n    value: function detachEdge(edge) {\n      var index = this.edges.indexOf(edge);\n      if (index != -1) {\n        this.edges.splice(index, 1);\n      }\n    }\n\n    /**\n     * Set or overwrite options for the node\n     *\n     * @param {Object} options an object with options\n     * @returns {null|boolean}\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      var currentShape = this.options.shape;\n      if (!options) {\n        return; // Note that the return value will be 'undefined'! This is OK.\n      }\n\n      // basic options\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n\n      if (this.id === undefined) {\n        throw new Error('Node must have an id');\n      }\n\n      Node.checkMass(options, this.id);\n\n      // set these options locally\n      // clear x and y positions\n      if (options.x !== undefined) {\n        if (options.x === null) {\n          this.x = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.x = parseInt(options.x);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options.y !== undefined) {\n        if (options.y === null) {\n          this.y = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.y = parseInt(options.y);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options.size !== undefined) {\n        this.baseSize = options.size;\n      }\n      if (options.value !== undefined) {\n        options.value = parseFloat(options.value);\n      }\n\n      // this transforms all shorthands into fully defined options\n      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);\n\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = ComponentUtil.choosify('node', pile);\n\n      this._load_images();\n      this.updateLabelModule(options);\n      this.updateShape(currentShape);\n\n      return options.hidden !== undefined || options.physics !== undefined;\n    }\n\n    /**\n     * Load the images from the options, for the nodes that need them.\n     *\n     * Images are always loaded, even if they are not used in the current shape.\n     * The user may switch to an image shape later on.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_load_images',\n    value: function _load_images() {\n      if (this.options.shape === 'circularImage' || this.options.shape === 'image') {\n        if (this.options.image === undefined) {\n          throw new Error(\"Option image must be defined for node type '\" + this.options.shape + \"'\");\n        }\n      }\n\n      if (this.options.image === undefined) {\n        return;\n      }\n\n      if (this.imagelist === undefined) {\n        throw new Error('Internal Error: No images provided');\n      }\n\n      if (typeof this.options.image === 'string') {\n        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);\n      } else {\n        if (this.options.image.unselected === undefined) {\n          throw new Error('No unselected image provided');\n        }\n\n        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);\n\n        if (this.options.image.selected !== undefined) {\n          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);\n        } else {\n          this.imageObjAlt = undefined;\n        }\n      }\n    }\n\n    /**\n     * Copy group option values into the node options.\n     *\n     * The group options override the global node options, so the copy of group options\n     *  must happen *after* the global node options have been set.\n     *\n     * This method must also be called also if the global node options have changed and the group options did not.\n     *\n     * @param {Object} parentOptions\n     * @param {Object} newOptions  new values for the options, currently only passed in for check\n     * @param {Object} groupList\n     */\n\n  }, {\n    key: 'getFormattingValues',\n\n\n    /**\n     *\n     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}\n     */\n    value: function getFormattingValues() {\n      var values = {\n        color: this.options.color.background,\n        borderWidth: this.options.borderWidth,\n        borderColor: this.options.color.border,\n        size: this.options.size,\n        borderDashes: this.options.shapeProperties.borderDashes,\n        borderRadius: this.options.shapeProperties.borderRadius,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            values.borderWidth *= 2;\n            values.color = this.options.color.highlight.background;\n            values.borderColor = this.options.color.highlight.border;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            values.color = this.options.color.hover.background;\n            values.borderColor = this.options.color.hover.border;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === 'function') {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n      }\n      return values;\n    }\n\n    /**\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'updateLabelModule',\n    value: function updateLabelModule(options) {\n      if (this.options.label === undefined || this.options.label === null) {\n        this.options.label = '';\n      }\n\n      Node.updateGroupOptions(this.options, options, this.grouplist);\n\n      //\n      // Note:The prototype chain for this.options is:\n      //\n      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions\n      //                 (also: this.globalOptions)\n      //\n      // Note that the prototypes are mentioned explicitly in the pile list below;\n      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.\n      // This is a good indication that the prototype usage of options is deficient.\n      //\n      var currentGroup = this.grouplist.get(this.options.group, false);\n      var pile = [options, // new options\n      this.options, // current node options, see comment above for prototype\n      currentGroup, // group options, if any\n      this.globalOptions, // Currently set global node options\n      this.defaultOptions // Default global node options\n      ];\n      this.labelModule.update(this.options, pile);\n\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n\n    /**\n     *\n     * @param {string} currentShape\n     */\n\n  }, {\n    key: 'updateShape',\n    value: function updateShape(currentShape) {\n      if (currentShape === this.options.shape && this.shape) {\n        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);\n      } else {\n        // choose draw method depending on the shape\n        switch (this.options.shape) {\n          case 'box':\n            this.shape = new Box(this.options, this.body, this.labelModule);\n            break;\n          case 'circle':\n            this.shape = new Circle(this.options, this.body, this.labelModule);\n            break;\n          case 'circularImage':\n            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case 'database':\n            this.shape = new Database(this.options, this.body, this.labelModule);\n            break;\n          case 'diamond':\n            this.shape = new Diamond(this.options, this.body, this.labelModule);\n            break;\n          case 'dot':\n            this.shape = new Dot(this.options, this.body, this.labelModule);\n            break;\n          case 'ellipse':\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n          case 'icon':\n            this.shape = new Icon(this.options, this.body, this.labelModule);\n            break;\n          case 'image':\n            this.shape = new Image(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case 'square':\n            this.shape = new Square(this.options, this.body, this.labelModule);\n            break;\n          case 'hexagon':\n            this.shape = new Hexagon(this.options, this.body, this.labelModule);\n            break;\n          case 'star':\n            this.shape = new Star(this.options, this.body, this.labelModule);\n            break;\n          case 'text':\n            this.shape = new Text(this.options, this.body, this.labelModule);\n            break;\n          case 'triangle':\n            this.shape = new Triangle(this.options, this.body, this.labelModule);\n            break;\n          case 'triangleDown':\n            this.shape = new TriangleDown(this.options, this.body, this.labelModule);\n            break;\n          default:\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n        }\n      }\n      this.needsRefresh();\n    }\n\n    /**\n     * select this node\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {\n      this.selected = true;\n      this.needsRefresh();\n    }\n\n    /**\n     * unselect this node\n     */\n\n  }, {\n    key: 'unselect',\n    value: function unselect() {\n      this.selected = false;\n      this.needsRefresh();\n    }\n\n    /**\n     * Reset the calculated size of the node, forces it to recalculate its size\n     */\n\n  }, {\n    key: 'needsRefresh',\n    value: function needsRefresh() {\n      this.shape.refreshNeeded = true;\n    }\n\n    /**\n     * get the title of this node.\n     * @return {string} title    The title of the node, or undefined when no title\n     *                           has been set.\n     */\n\n  }, {\n    key: 'getTitle',\n    value: function getTitle() {\n      return this.options.title;\n    }\n\n    /**\n     * Calculate the distance to the border of the Node\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {number} angle        Angle in radians\n     * @returns {number} distance   Distance to the border in pixels\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this.shape.distanceToBorder(ctx, angle);\n    }\n\n    /**\n     * Check if this node has a fixed x and y position\n     * @return {boolean}      true if fixed, false if not\n     */\n\n  }, {\n    key: 'isFixed',\n    value: function isFixed() {\n      return this.options.fixed.x && this.options.fixed.y;\n    }\n\n    /**\n     * check if this node is selecte\n     * @return {boolean} selected   True if node is selected, else false\n     */\n\n  }, {\n    key: 'isSelected',\n    value: function isSelected() {\n      return this.selected;\n    }\n\n    /**\n     * Retrieve the value of the node. Can be undefined\n     * @return {number} value\n     */\n\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.options.value;\n    }\n\n    /**\n     * Get the current dimensions of the label\n     *\n     * @return {rect}\n     */\n\n  }, {\n    key: 'getLabelSize',\n    value: function getLabelSize() {\n      return this.labelModule.size();\n    }\n\n    /**\n     * Adjust the value range of the node. The node will adjust it's size\n     * based on its value.\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n\n  }, {\n    key: 'setValueRange',\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var sizeDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.size = this.options.scaling.min + scale * sizeDiff;\n      } else {\n        this.options.size = this.baseSize;\n        this.options.font.size = this.baseFontSize;\n      }\n\n      this.updateLabelModule();\n    }\n\n    /**\n     * Draw this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n      this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values);\n    }\n\n    /**\n     * Update the bounding box of the shape\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(ctx) {\n      this.shape.updateBoundingBox(this.x, this.y, ctx);\n    }\n\n    /**\n     * Recalculate the size of this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: 'resize',\n    value: function resize(ctx) {\n      var values = this.getFormattingValues();\n      this.shape.resize(ctx, this.selected, this.hover, values);\n    }\n\n    /**\n     * Determine all visual elements of this node instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point\n     */\n\n  }, {\n    key: 'getItemsOnPoint',\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n\n      if (this.labelModule.visible()) {\n        if (ComponentUtil.pointInRect(this.labelModule.getSize(), point)) {\n          ret.push({ nodeId: this.id, labelId: 0 });\n        }\n      }\n\n      if (ComponentUtil.pointInRect(this.shape.boundingBox, point)) {\n        ret.push({ nodeId: this.id });\n      }\n\n      return ret;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     * @param {Object} obj   an object with parameters left, top, right, bottom\n     * @return {boolean}     True if location is located on node\n     */\n\n  }, {\n    key: 'isOverlappingWith',\n    value: function isOverlappingWith(obj) {\n      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     * @param {Object} obj   an object with parameters left, top, right, bottom\n     * @return {boolean}     True if location is located on node\n     */\n\n  }, {\n    key: 'isBoundingBoxOverlappingWith',\n    value: function isBoundingBoxOverlappingWith(obj) {\n      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;\n    }\n\n    /**\n     * Check valid values for mass\n     *\n     * The mass may not be negative or zero. If it is, reset to 1\n     *\n     * @param {object} options\n     * @param {Node.id} id\n     * @static\n     */\n\n  }], [{\n    key: 'updateGroupOptions',\n    value: function updateGroupOptions(parentOptions, newOptions, groupList) {\n      if (groupList === undefined) return; // No groups, nothing to do\n\n      var group = parentOptions.group;\n\n      // paranoia: the selected group is already merged into node options, check.\n      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {\n        throw new Error(\"updateGroupOptions: group values in options don't match.\");\n      }\n\n      var hasGroup = typeof group === 'number' || typeof group === 'string' && group != '';\n      if (!hasGroup) return; // current node has no group, no need to merge\n\n      var groupObj = groupList.get(group);\n\n      // Skip merging of group font options into parent; these are required to be distinct for labels\n      // Also skip mergin of color IF it is already defined in the node itself. This is to avoid the color of the\n      // group overriding the color set at the node level\n      // TODO: It might not be a good idea either to merge the rest of the options, investigate this.\n      var skipProperties = ['font'];\n      if (newOptions !== undefined && newOptions.color !== undefined && newOptions.color != null) skipProperties.push('color');\n      util.selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);\n\n      // the color object needs to be completely defined.\n      // Since groups can partially overwrite the colors, we parse it again, just in case.\n      parentOptions.color = util.parseColor(parentOptions.color);\n    }\n\n    /**\n     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.\n     * Static so it can also be used by the handler.\n     *\n     * @param {Object} parentOptions\n     * @param {Object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {Object} [globalOptions={}]\n     * @param {Object} [groupList]\n     * @static\n     */\n\n  }, {\n    key: 'parseOptions',\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var groupList = arguments[4];\n\n      var fields = ['color', 'fixed', 'shadow'];\n      util.selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n\n      Node.checkMass(newOptions);\n\n      // merge the shadow options into the parent.\n      util.mergeOptions(parentOptions, newOptions, 'shadow', globalOptions);\n\n      // individual shape newOptions\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var parsedColor = util.parseColor(newOptions.color);\n        util.fillIfDefined(parentOptions.color, parsedColor);\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options\n      }\n\n      // handle the fixed options\n      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {\n        if (typeof newOptions.fixed === 'boolean') {\n          parentOptions.fixed.x = newOptions.fixed;\n          parentOptions.fixed.y = newOptions.fixed;\n        } else {\n          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === 'boolean') {\n            parentOptions.fixed.x = newOptions.fixed.x;\n          }\n          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === 'boolean') {\n            parentOptions.fixed.y = newOptions.fixed.y;\n          }\n        }\n      }\n\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n\n      Node.updateGroupOptions(parentOptions, newOptions, groupList);\n\n      // handle the scaling options, specifically the label part\n      if (newOptions.scaling !== undefined) {\n        util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', globalOptions.scaling);\n      }\n    }\n  }, {\n    key: 'checkMass',\n    value: function checkMass(options, id) {\n      if (options.mass !== undefined && options.mass <= 0) {\n        var strId = '';\n        if (id !== undefined) {\n          strId = ' in node id: ' + id;\n        }\n        console.log('%cNegative or zero mass disallowed' + strId + ', setting mass to 1.', printStyle);\n        options.mass = 1;\n      }\n    }\n  }]);\n  return Node;\n}();\n\nexports['default'] = Node;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __nested_webpack_require_127443__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof2 = __nested_webpack_require_127443__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _classCallCheck2 = __nested_webpack_require_127443__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_127443__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_127443__(2);\n\n/**\n * Helper functions for components\n * @class\n */\n\nvar ComponentUtil = function () {\n  function ComponentUtil() {\n    (0, _classCallCheck3['default'])(this, ComponentUtil);\n  }\n\n  (0, _createClass3['default'])(ComponentUtil, null, [{\n    key: 'choosify',\n\n    /**\n     * Determine values to use for (sub)options of 'chosen'.\n     *\n     * This option is either a boolean or an object whose values should be examined further.\n     * The relevant structures are:\n     *\n     * - chosen: <boolean value>\n     * - chosen: { subOption: <boolean or function> }\n     *\n     * Where subOption is 'node', 'edge' or 'label'.\n     *\n     * The intention of this method appears to be to set a specific priority to the options;\n     * Since most properties are either bridged or merged into the local options objects, there\n     * is not much point in handling them separately.\n     * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we\n     *       should be able to get rid of this method.\n     *\n     * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'\n     * @param {Object}  pile       array of options objects to consider\n     *\n     * @return {boolean|function}  value for passed subOption of 'chosen' to use\n     */\n    value: function choosify(subOption, pile) {\n      // allowed values for subOption\n      var allowed = ['node', 'edge', 'label'];\n      var value = true;\n\n      var chosen = util.topMost(pile, 'chosen');\n      if (typeof chosen === 'boolean') {\n        value = chosen;\n      } else if ((typeof chosen === 'undefined' ? 'undefined' : (0, _typeof3['default'])(chosen)) === 'object') {\n        if (allowed.indexOf(subOption) === -1) {\n          throw new Error(\"choosify: subOption '\" + subOption + \"' should be one of \" + \"'\" + allowed.join(\"', '\") + \"'\");\n        }\n\n        var chosenEdge = util.topMost(pile, ['chosen', subOption]);\n        if (typeof chosenEdge === 'boolean' || typeof chosenEdge === 'function') {\n          value = chosenEdge;\n        }\n      }\n\n      return value;\n    }\n\n    /**\n     * Check if the point falls within the given rectangle.\n     *\n     * @param {rect} rect\n     * @param {point} point\n     * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.\n     * @returns {boolean}  true if point within rectangle, false otherwise\n     * @static\n     */\n\n  }, {\n    key: 'pointInRect',\n    value: function pointInRect(rect, point, rotationPoint) {\n      if (rect.width <= 0 || rect.height <= 0) {\n        return false; // early out\n      }\n\n      if (rotationPoint !== undefined) {\n        // Rotate the point the same amount as the rectangle\n        var tmp = {\n          x: point.x - rotationPoint.x,\n          y: point.y - rotationPoint.y\n        };\n\n        if (rotationPoint.angle !== 0) {\n          // In order to get the coordinates the same, you need to\n          // rotate in the reverse direction\n          var angle = -rotationPoint.angle;\n\n          var tmp2 = {\n            x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,\n            y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y\n          };\n          point = tmp2;\n        } else {\n          point = tmp;\n        }\n\n        // Note that if a rotation is specified, the rectangle coordinates\n        // are **not* the full canvas coordinates. They are relative to the\n        // rotationPoint. Hence, the point coordinates need not be translated\n        // back in this case.\n      }\n\n      var right = rect.x + rect.width;\n      var bottom = rect.y + rect.width;\n\n      return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;\n    }\n\n    /**\n     * Check if given value is acceptable as a label text.\n     *\n     * @param {*} text value to check; can be anything at this point\n     * @returns {boolean} true if valid label value, false otherwise\n     */\n\n  }, {\n    key: 'isValidLabel',\n    value: function isValidLabel(text) {\n      // Note that this is quite strict: types that *might* be converted to string are disallowed\n      return typeof text === 'string' && text !== '';\n    }\n  }]);\n  return ComponentUtil;\n}();\n\nexports['default'] = ComponentUtil;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Register a touch event, taking place before a gesture\n * @param {Hammer} hammer       A hammer instance\n * @param {function} callback   Callback, called as callback(event)\n */\nexports.onTouch = function (hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFirst) {\n      callback(event);\n    }\n  };\n\n  hammer.on('hammer.input', callback.inputHandler);\n};\n\n/**\n * Register a release event, taking place after a gesture\n * @param {Hammer} hammer       A hammer instance\n * @param {function} callback   Callback, called as callback(event)\n * @returns {*}\n */\nexports.onRelease = function (hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFinal) {\n      callback(event);\n    }\n  };\n\n  return hammer.on('hammer.input', callback.inputHandler);\n};\n\n/**\n * Unregister a touch event, taking place before a gesture\n * @param {Hammer} hammer       A hammer instance\n * @param {function} callback   Callback, called as callback(event)\n */\nexports.offTouch = function (hammer, callback) {\n  hammer.off('hammer.input', callback.inputHandler);\n};\n\n/**\n * Unregister a release event, taking place before a gesture\n * @param {Hammer} hammer       A hammer instance\n * @param {function} callback   Callback, called as callback(event)\n */\nexports.offRelease = exports.offTouch;\n\n/**\n * Hack the PinchRecognizer such that it doesn't prevent default behavior\n * for vertical panning.\n *\n * Yeah ... this is quite a hack ... see https://github.com/hammerjs/hammer.js/issues/932\n *\n * @param {Hammer.Pinch} pinchRecognizer\n * @return {Hammer.Pinch} returns the pinchRecognizer\n */\nexports.disablePreventDefaultVertically = function (pinchRecognizer) {\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n\n  pinchRecognizer.getTouchAction = function () {\n    // default method returns [TOUCH_ACTION_NONE]\n    return [TOUCH_ACTION_PAN_Y];\n  };\n\n  return pinchRecognizer;\n};\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __nested_webpack_require_134288__) {\n\n__nested_webpack_require_134288__(87);\nvar global = __nested_webpack_require_134288__(10);\nvar hide = __nested_webpack_require_134288__(19);\nvar Iterators = __nested_webpack_require_134288__(25);\nvar TO_STRING_TAG = __nested_webpack_require_134288__(8)('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __nested_webpack_require_135722__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __nested_webpack_require_135722__(21);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __nested_webpack_require_136455__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __nested_webpack_require_136455__(20);\nvar dPs = __nested_webpack_require_136455__(92);\nvar enumBugKeys = __nested_webpack_require_136455__(45);\nvar IE_PROTO = __nested_webpack_require_136455__(43)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __nested_webpack_require_136455__(63)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __nested_webpack_require_136455__(96).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __nested_webpack_require_138254__) {\n\nvar shared = __nested_webpack_require_138254__(44)('keys');\nvar uid = __nested_webpack_require_138254__(29);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __nested_webpack_require_138500__) {\n\nvar core = __nested_webpack_require_138500__(6);\nvar global = __nested_webpack_require_138500__(10);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __nested_webpack_require_138500__(27) ? 'pure' : 'global',\n  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __nested_webpack_require_139231__) {\n\nvar def = __nested_webpack_require_139231__(12).f;\nvar has = __nested_webpack_require_139231__(14);\nvar TAG = __nested_webpack_require_139231__(8)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __nested_webpack_require_139582__) {\n\n\"use strict\";\n\nvar $at = __nested_webpack_require_139582__(97)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__nested_webpack_require_139582__(60)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __nested_webpack_require_140190__) {\n\nexports.f = __nested_webpack_require_140190__(8);\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __nested_webpack_require_140304__) {\n\nvar global = __nested_webpack_require_140304__(10);\nvar core = __nested_webpack_require_140304__(6);\nvar LIBRARY = __nested_webpack_require_140304__(27);\nvar wksExt = __nested_webpack_require_140304__(48);\nvar defineProperty = __nested_webpack_require_140304__(12).f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __nested_webpack_require_140909__) {\n\n\"use strict\";\n\n\nvar _keys = __nested_webpack_require_140909__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_140909__(2);\nvar DataSet = __nested_webpack_require_140909__(33);\n\n/**\n * DataView\n *\n * a dataview offers a filtered view on a dataset or an other dataview.\n *\n * @param {DataSet | DataView} data\n * @param {Object} [options]   Available options: see method get\n *\n * @constructor DataView\n */\nfunction DataView(data, options) {\n  this._data = null;\n  this._ids = {}; // ids of the items currently in memory (just contains a boolean true)\n  this.length = 0; // number of items in the DataView\n  this._options = options || {};\n  this._fieldId = 'id'; // name of the field containing id\n  this._subscribers = {}; // event subscribers\n\n  var me = this;\n  this.listener = function () {\n    me._onEvent.apply(me, arguments);\n  };\n\n  this.setData(data);\n}\n\n// TODO: implement a function .config() to dynamically update things like configured filter\n// and trigger changes accordingly\n\n/**\n * Set a data source for the view\n * @param {DataSet | DataView} data\n */\nDataView.prototype.setData = function (data) {\n  var ids, id, i, len, items;\n\n  if (this._data) {\n    // unsubscribe from current dataset\n    if (this._data.off) {\n      this._data.off('*', this.listener);\n    }\n\n    // trigger a remove of all items in memory\n    ids = this._data.getIds({ filter: this._options && this._options.filter });\n    items = [];\n\n    for (i = 0, len = ids.length; i < len; i++) {\n      items.push(this._data._data[ids[i]]);\n    }\n\n    this._ids = {};\n    this.length = 0;\n    this._trigger('remove', { items: ids, oldData: items });\n  }\n\n  this._data = data;\n\n  if (this._data) {\n    // update fieldId\n    this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';\n\n    // trigger an add of all added items\n    ids = this._data.getIds({ filter: this._options && this._options.filter });\n    for (i = 0, len = ids.length; i < len; i++) {\n      id = ids[i];\n      this._ids[id] = true;\n    }\n    this.length = ids.length;\n    this._trigger('add', { items: ids });\n\n    // subscribe to new dataset\n    if (this._data.on) {\n      this._data.on('*', this.listener);\n    }\n  }\n};\n\n/**\n * Refresh the DataView. Useful when the DataView has a filter function\n * containing a variable parameter.\n */\nDataView.prototype.refresh = function () {\n  var id, i, len;\n  var ids = this._data.getIds({\n    filter: this._options && this._options.filter\n  }),\n      oldIds = (0, _keys2['default'])(this._ids),\n      newIds = {},\n      addedIds = [],\n      removedIds = [],\n      removedItems = [];\n\n  // check for additions\n  for (i = 0, len = ids.length; i < len; i++) {\n    id = ids[i];\n    newIds[id] = true;\n    if (!this._ids[id]) {\n      addedIds.push(id);\n      this._ids[id] = true;\n    }\n  }\n\n  // check for removals\n  for (i = 0, len = oldIds.length; i < len; i++) {\n    id = oldIds[i];\n    if (!newIds[id]) {\n      removedIds.push(id);\n      removedItems.push(this._data._data[id]);\n      delete this._ids[id];\n    }\n  }\n\n  this.length += addedIds.length - removedIds.length;\n\n  // trigger events\n  if (addedIds.length) {\n    this._trigger('add', { items: addedIds });\n  }\n  if (removedIds.length) {\n    this._trigger('remove', { items: removedIds, oldData: removedItems });\n  }\n};\n\n// prettier-ignore\n/**\n * Get data from the data view\n *\n * Usage:\n *\n *     get()\n *     get(options: Object)\n *     get(options: Object, data: Array | DataTable)\n *\n *     get(id: Number)\n *     get(id: Number, options: Object)\n *     get(id: Number, options: Object, data: Array | DataTable)\n *\n *     get(ids: Number[])\n *     get(ids: Number[], options: Object)\n *     get(ids: Number[], options: Object, data: Array | DataTable)\n *\n * Where:\n *\n * {number | string} id         The id of an item\n * {number[] | string{}} ids    An array with ids of items\n * {Object} options             An Object with options. Available options:\n *                              {string} [type] Type of data to be returned. Can\n *                                              be 'DataTable' or 'Array' (default)\n *                              {Object.<string, string>} [convert]\n *                              {string[]} [fields] field names to be returned\n *                              {function} [filter] filter items\n *                              {string | function} [order] Order the items by\n *                                  a field name or custom sort function.\n * {Array | DataTable} [data]   If provided, items will be appended to this\n *                              array or table. Required in case of Google\n *                              DataTable.\n * @param {Array} args\n * @return {DataSet|DataView}\n */\nDataView.prototype.get = function (args) {\n  // eslint-disable-line no-unused-vars\n  var me = this;\n\n  // parse the arguments\n  var ids, options, data;\n  var firstType = util.getType(arguments[0]);\n  if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {\n    // get(id(s) [, options] [, data])\n    ids = arguments[0]; // can be a single id or an array with ids\n    options = arguments[1];\n    data = arguments[2];\n  } else {\n    // get([, options] [, data])\n    options = arguments[0];\n    data = arguments[1];\n  }\n\n  // extend the options with the default options and provided options\n  var viewOptions = util.extend({}, this._options, options);\n\n  // create a combined filter method when needed\n  if (this._options.filter && options && options.filter) {\n    viewOptions.filter = function (item) {\n      return me._options.filter(item) && options.filter(item);\n    };\n  }\n\n  // build up the call to the linked data set\n  var getArguments = [];\n  if (ids != undefined) {\n    getArguments.push(ids);\n  }\n  getArguments.push(viewOptions);\n  getArguments.push(data);\n\n  return this._data && this._data.get.apply(this._data, getArguments);\n};\n\n/**\n * Get ids of all items or from a filtered set of items.\n * @param {Object} [options]    An Object with options. Available options:\n *                              {function} [filter] filter items\n *                              {string | function} [order] Order the items by\n *                                  a field name or custom sort function.\n * @return {Array.<string|number>} ids\n */\nDataView.prototype.getIds = function (options) {\n  var ids;\n\n  if (this._data) {\n    var defaultFilter = this._options.filter;\n    var filter;\n\n    if (options && options.filter) {\n      if (defaultFilter) {\n        filter = function filter(item) {\n          return defaultFilter(item) && options.filter(item);\n        };\n      } else {\n        filter = options.filter;\n      }\n    } else {\n      filter = defaultFilter;\n    }\n\n    ids = this._data.getIds({\n      filter: filter,\n      order: options && options.order\n    });\n  } else {\n    ids = [];\n  }\n\n  return ids;\n};\n\n/**\n * Map every item in the dataset.\n * @param {function} callback\n * @param {Object} [options]    Available options:\n *                              {Object.<string, string>} [type]\n *                              {string[]} [fields] filter fields\n *                              {function} [filter] filter items\n *                              {string | function} [order] Order the items by\n *                                  a field name or custom sort function.\n * @return {Object[]} mappedItems\n */\nDataView.prototype.map = function (callback, options) {\n  var mappedItems = [];\n  if (this._data) {\n    var defaultFilter = this._options.filter;\n    var filter;\n\n    if (options && options.filter) {\n      if (defaultFilter) {\n        filter = function filter(item) {\n          return defaultFilter(item) && options.filter(item);\n        };\n      } else {\n        filter = options.filter;\n      }\n    } else {\n      filter = defaultFilter;\n    }\n\n    mappedItems = this._data.map(callback, {\n      filter: filter,\n      order: options && options.order\n    });\n  } else {\n    mappedItems = [];\n  }\n\n  return mappedItems;\n};\n\n/**\n * Get the DataSet to which this DataView is connected. In case there is a chain\n * of multiple DataViews, the root DataSet of this chain is returned.\n * @return {DataSet} dataSet\n */\nDataView.prototype.getDataSet = function () {\n  var dataSet = this;\n  while (dataSet instanceof DataView) {\n    dataSet = dataSet._data;\n  }\n  return dataSet || null;\n};\n\n/**\n * Event listener. Will propagate all events from the connected data set to\n * the subscribers of the DataView, but will filter the items and only trigger\n * when there are changes in the filtered data set.\n * @param {string} event\n * @param {Object | null} params\n * @param {string} senderId\n * @private\n */\nDataView.prototype._onEvent = function (event, params, senderId) {\n  var i, len, id, item;\n  var ids = params && params.items;\n  var addedIds = [],\n      updatedIds = [],\n      removedIds = [],\n      oldItems = [],\n      updatedItems = [],\n      removedItems = [];\n\n  if (ids && this._data) {\n    switch (event) {\n      case 'add':\n        // filter the ids of the added items\n        for (i = 0, len = ids.length; i < len; i++) {\n          id = ids[i];\n          item = this.get(id);\n          if (item) {\n            this._ids[id] = true;\n            addedIds.push(id);\n          }\n        }\n\n        break;\n\n      case 'update':\n        // determine the event from the views viewpoint: an updated\n        // item can be added, updated, or removed from this view.\n        for (i = 0, len = ids.length; i < len; i++) {\n          id = ids[i];\n          item = this.get(id);\n\n          if (item) {\n            if (this._ids[id]) {\n              updatedIds.push(id);\n              updatedItems.push(params.data[i]);\n              oldItems.push(params.oldData[i]);\n            } else {\n              this._ids[id] = true;\n              addedIds.push(id);\n            }\n          } else {\n            if (this._ids[id]) {\n              delete this._ids[id];\n              removedIds.push(id);\n              removedItems.push(params.oldData[i]);\n            } else {\n              // nothing interesting for me :-(\n            }\n          }\n        }\n\n        break;\n\n      case 'remove':\n        // filter the ids of the removed items\n        for (i = 0, len = ids.length; i < len; i++) {\n          id = ids[i];\n          if (this._ids[id]) {\n            delete this._ids[id];\n            removedIds.push(id);\n            removedItems.push(params.oldData[i]);\n          }\n        }\n\n        break;\n    }\n\n    this.length += addedIds.length - removedIds.length;\n\n    if (addedIds.length) {\n      this._trigger('add', { items: addedIds }, senderId);\n    }\n    if (updatedIds.length) {\n      this._trigger('update', { items: updatedIds, oldData: oldItems, data: updatedItems }, senderId);\n    }\n    if (removedIds.length) {\n      this._trigger('remove', { items: removedIds, oldData: removedItems }, senderId);\n    }\n  }\n};\n\n// copy subscription functionality from DataSet\nDataView.prototype.on = DataSet.prototype.on;\nDataView.prototype.off = DataSet.prototype.off;\nDataView.prototype._trigger = DataSet.prototype._trigger;\n\n// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)\nDataView.prototype.subscribe = DataView.prototype.on;\nDataView.prototype.unsubscribe = DataView.prototype.off;\n\nmodule.exports = DataView;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n/**\r\n * Created by Alex on 11/6/2014.\r\n */\r\n\r\n// https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60\r\n// if the module has no dependencies, the above pattern can be simplified to\r\n(function (root, factory) {\r\n  if (true) {\r\n    // AMD. Register as an anonymous module.\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {}\r\n}(this, function () {\r\n\r\n  function keycharm(options) {\r\n    var preventDefault = options && options.preventDefault || false;\r\n\r\n    var container = options && options.container || window;\r\n\r\n    var _exportFunctions = {};\r\n    var _bound = {keydown:{}, keyup:{}};\r\n    var _keys = {};\r\n    var i;\r\n\r\n    // a - z\r\n    for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}\r\n    // A - Z\r\n    for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}\r\n    // 0 - 9\r\n    for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}\r\n    // F1 - F12\r\n    for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}\r\n    // num0 - num9\r\n    for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}\r\n\r\n    // numpad misc\r\n    _keys['num*'] = {code:106, shift: false};\r\n    _keys['num+'] = {code:107, shift: false};\r\n    _keys['num-'] = {code:109, shift: false};\r\n    _keys['num/'] = {code:111, shift: false};\r\n    _keys['num.'] = {code:110, shift: false};\r\n    // arrows\r\n    _keys['left']  = {code:37, shift: false};\r\n    _keys['up']    = {code:38, shift: false};\r\n    _keys['right'] = {code:39, shift: false};\r\n    _keys['down']  = {code:40, shift: false};\r\n    // extra keys\r\n    _keys['space'] = {code:32, shift: false};\r\n    _keys['enter'] = {code:13, shift: false};\r\n    _keys['shift'] = {code:16, shift: undefined};\r\n    _keys['esc']   = {code:27, shift: false};\r\n    _keys['backspace'] = {code:8, shift: false};\r\n    _keys['tab']       = {code:9, shift: false};\r\n    _keys['ctrl']      = {code:17, shift: false};\r\n    _keys['alt']       = {code:18, shift: false};\r\n    _keys['delete']    = {code:46, shift: false};\r\n    _keys['pageup']    = {code:33, shift: false};\r\n    _keys['pagedown']  = {code:34, shift: false};\r\n    // symbols\r\n    _keys['=']     = {code:187, shift: false};\r\n    _keys['-']     = {code:189, shift: false};\r\n    _keys[']']     = {code:221, shift: false};\r\n    _keys['[']     = {code:219, shift: false};\r\n\r\n\r\n\r\n    var down = function(event) {handleEvent(event,'keydown');};\r\n    var up = function(event) {handleEvent(event,'keyup');};\r\n\r\n    // handle the actualy bound key with the event\r\n    var handleEvent = function(event,type) {\r\n      if (_bound[type][event.keyCode] !== undefined) {\r\n        var bound = _bound[type][event.keyCode];\r\n        for (var i = 0; i < bound.length; i++) {\r\n          if (bound[i].shift === undefined) {\r\n            bound[i].fn(event);\r\n          }\r\n          else if (bound[i].shift == true && event.shiftKey == true) {\r\n            bound[i].fn(event);\r\n          }\r\n          else if (bound[i].shift == false && event.shiftKey == false) {\r\n            bound[i].fn(event);\r\n          }\r\n        }\r\n\r\n        if (preventDefault == true) {\r\n          event.preventDefault();\r\n        }\r\n      }\r\n    };\r\n\r\n    // bind a key to a callback\r\n    _exportFunctions.bind = function(key, callback, type) {\r\n      if (type === undefined) {\r\n        type = 'keydown';\r\n      }\r\n      if (_keys[key] === undefined) {\r\n        throw new Error(\"unsupported key: \" + key);\r\n      }\r\n      if (_bound[type][_keys[key].code] === undefined) {\r\n        _bound[type][_keys[key].code] = [];\r\n      }\r\n      _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});\r\n    };\r\n\r\n\r\n    // bind all keys to a call back (demo purposes)\r\n    _exportFunctions.bindAll = function(callback, type) {\r\n      if (type === undefined) {\r\n        type = 'keydown';\r\n      }\r\n      for (var key in _keys) {\r\n        if (_keys.hasOwnProperty(key)) {\r\n          _exportFunctions.bind(key,callback,type);\r\n        }\r\n      }\r\n    };\r\n\r\n    // get the key label from an event\r\n    _exportFunctions.getKey = function(event) {\r\n      for (var key in _keys) {\r\n        if (_keys.hasOwnProperty(key)) {\r\n          if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {\r\n            return key;\r\n          }\r\n          else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {\r\n            return key;\r\n          }\r\n          else if (event.keyCode == _keys[key].code && key == 'shift') {\r\n            return key;\r\n          }\r\n        }\r\n      }\r\n      return \"unknown key, currently not supported\";\r\n    };\r\n\r\n    // unbind either a specific callback from a key or all of them (by leaving callback undefined)\r\n    _exportFunctions.unbind = function(key, callback, type) {\r\n      if (type === undefined) {\r\n        type = 'keydown';\r\n      }\r\n      if (_keys[key] === undefined) {\r\n        throw new Error(\"unsupported key: \" + key);\r\n      }\r\n      if (callback !== undefined) {\r\n        var newBindings = [];\r\n        var bound = _bound[type][_keys[key].code];\r\n        if (bound !== undefined) {\r\n          for (var i = 0; i < bound.length; i++) {\r\n            if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {\r\n              newBindings.push(_bound[type][_keys[key].code][i]);\r\n            }\r\n          }\r\n        }\r\n        _bound[type][_keys[key].code] = newBindings;\r\n      }\r\n      else {\r\n        _bound[type][_keys[key].code] = [];\r\n      }\r\n    };\r\n\r\n    // reset all bound variables.\r\n    _exportFunctions.reset = function() {\r\n      _bound = {keydown:{}, keyup:{}};\r\n    };\r\n\r\n    // unbind all listeners and reset all variables.\r\n    _exportFunctions.destroy = function() {\r\n      _bound = {keydown:{}, keyup:{}};\r\n      container.removeEventListener('keydown', down, true);\r\n      container.removeEventListener('keyup', up, true);\r\n    };\r\n\r\n    // create listeners.\r\n    container.addEventListener('keydown',down,true);\r\n    container.addEventListener('keyup',up,true);\r\n\r\n    // return the public functions.\r\n    return _exportFunctions;\r\n  }\r\n\r\n  return keycharm;\r\n}));\r\n\r\n\r\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __nested_webpack_require_159436__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_159436__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_159436__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_159436__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_159436__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_159436__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _NodeBase2 = __nested_webpack_require_159436__(16);\n\nvar _NodeBase3 = _interopRequireDefault(_NodeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * NOTE: This is a bad base class\n *\n * Child classes are:\n *\n *   Image       - uses *only* image methods\n *   Circle      - uses *only* _drawRawCircle\n *   CircleImage - uses all\n *\n * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase\n *       Rename this to ImageBase\n *       Consolidate common code in Image and CircleImage to base class\n *\n * @extends NodeBase\n */\nvar CircleImageBase = function (_NodeBase) {\n  (0, _inherits3['default'])(CircleImageBase, _NodeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function CircleImageBase(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, CircleImageBase);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (CircleImageBase.__proto__ || (0, _getPrototypeOf2['default'])(CircleImageBase)).call(this, options, body, labelModule));\n\n    _this.labelOffset = 0;\n    _this.selected = false;\n    return _this;\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {Object} [imageObj]\n   * @param {Object} [imageObjAlt]\n   */\n\n\n  (0, _createClass3['default'])(CircleImageBase, [{\n    key: 'setOptions',\n    value: function setOptions(options, imageObj, imageObjAlt) {\n      this.options = options;\n\n      if (!(imageObj === undefined && imageObjAlt === undefined)) {\n        this.setImages(imageObj, imageObjAlt);\n      }\n    }\n\n    /**\n     * Set the images for this node.\n     *\n     * The images can be updated after the initial setting of options;\n     * therefore, this method needs to be reentrant.\n     *\n     * For correct working in error cases, it is necessary to properly set\n     * field 'nodes.brokenImage' in the options.\n     *\n     * @param {Image} imageObj  required; main image to show for this node\n     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected\n     */\n\n  }, {\n    key: 'setImages',\n    value: function setImages(imageObj, imageObjAlt) {\n      if (imageObjAlt && this.selected) {\n        this.imageObj = imageObjAlt;\n        this.imageObjAlt = imageObj;\n      } else {\n        this.imageObj = imageObj;\n        this.imageObjAlt = imageObjAlt;\n      }\n    }\n\n    /**\n     * Set selection and switch between the base and the selected image.\n     *\n     * Do the switch only if imageObjAlt exists.\n     *\n     * @param {boolean} selected value of new selected state for current node\n     */\n\n  }, {\n    key: 'switchImages',\n    value: function switchImages(selected) {\n      var selection_changed = selected && !this.selected || !selected && this.selected;\n      this.selected = selected; // Remember new selection\n\n      if (this.imageObjAlt !== undefined && selection_changed) {\n        var imageTmp = this.imageObj;\n        this.imageObj = this.imageObjAlt;\n        this.imageObjAlt = imageTmp;\n      }\n    }\n\n    /**\n     * Adjust the node dimensions for a loaded image.\n     *\n     * Pre: this.imageObj is valid\n     */\n\n  }, {\n    key: '_resizeImage',\n    value: function _resizeImage() {\n      var width, height;\n\n      if (this.options.shapeProperties.useImageSize === false) {\n        // Use the size property\n        var ratio_width = 1;\n        var ratio_height = 1;\n\n        // Only calculate the proper ratio if both width and height not zero\n        if (this.imageObj.width && this.imageObj.height) {\n          if (this.imageObj.width > this.imageObj.height) {\n            ratio_width = this.imageObj.width / this.imageObj.height;\n          } else {\n            ratio_height = this.imageObj.height / this.imageObj.width;\n          }\n        }\n\n        width = this.options.size * 2 * ratio_width;\n        height = this.options.size * 2 * ratio_height;\n      } else {\n        // Use the image size\n        width = this.imageObj.width;\n        height = this.imageObj.height;\n      }\n\n      this.width = width;\n      this.height = height;\n      this.radius = 0.5 * this.width;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {ArrowOptions} values\n     * @private\n     */\n\n  }, {\n    key: '_drawRawCircle',\n    value: function _drawRawCircle(ctx, x, y, values) {\n      this.initContextForDraw(ctx, values);\n      ctx.circle(x, y, values.size);\n      this.performFill(ctx, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     * @private\n     */\n\n  }, {\n    key: '_drawImageAtPosition',\n    value: function _drawImageAtPosition(ctx, values) {\n      if (this.imageObj.width != 0) {\n        // draw the image\n        ctx.globalAlpha = 1.0;\n\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n\n        var factor = 1;\n        if (this.options.shapeProperties.interpolation === true) {\n          factor = this.imageObj.width / this.width / this.body.view.scale;\n        }\n\n        this.imageObj.drawImageAtPosition(ctx, factor, this.left, this.top, this.width, this.height);\n\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n\n  }, {\n    key: '_drawImageLabel',\n    value: function _drawImageLabel(ctx, x, y, selected, hover) {\n      var yLabel;\n      var offset = 0;\n\n      if (this.height !== undefined) {\n        offset = this.height * 0.5;\n        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);\n        if (labelDimensions.lineCount >= 1) {\n          offset += labelDimensions.height / 2;\n        }\n      }\n\n      yLabel = y + offset;\n\n      if (this.options.label) {\n        this.labelOffset = offset;\n      }\n      this.labelModule.draw(ctx, x, yLabel, selected, hover, 'hanging');\n    }\n  }]);\n  return CircleImageBase;\n}(_NodeBase3['default']);\n\nexports['default'] = CircleImageBase;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __nested_webpack_require_166380__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printStyle = undefined;\n\nvar _stringify = __nested_webpack_require_166380__(23);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _typeof2 = __nested_webpack_require_166380__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _keys = __nested_webpack_require_166380__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = __nested_webpack_require_166380__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_166380__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_166380__(2);\n\nvar errorFound = false;\nvar allOptions = void 0;\nvar printStyle = 'background: #FFeeee; color: #dd0000';\n/**\n *  Used to validate options.\n */\n\nvar Validator = function () {\n  /**\n   * @ignore\n   */\n  function Validator() {\n    (0, _classCallCheck3['default'])(this, Validator);\n  }\n\n  /**\n   * Main function to be called\n   * @param {Object} options\n   * @param {Object} referenceOptions\n   * @param {Object} subObject\n   * @returns {boolean}\n   * @static\n   */\n\n\n  (0, _createClass3['default'])(Validator, null, [{\n    key: 'validate',\n    value: function validate(options, referenceOptions, subObject) {\n      errorFound = false;\n      allOptions = referenceOptions;\n      var usedOptions = referenceOptions;\n      if (subObject !== undefined) {\n        usedOptions = referenceOptions[subObject];\n      }\n      Validator.parse(options, usedOptions, []);\n      return errorFound;\n    }\n\n    /**\n     * Will traverse an object recursively and check every value\n     * @param {Object} options\n     * @param {Object} referenceOptions\n     * @param {array} path    | where to look for the actual option\n     * @static\n     */\n\n  }, {\n    key: 'parse',\n    value: function parse(options, referenceOptions, path) {\n      for (var option in options) {\n        if (options.hasOwnProperty(option)) {\n          Validator.check(option, options, referenceOptions, path);\n        }\n      }\n    }\n\n    /**\n     * Check every value. If the value is an object, call the parse function on that object.\n     * @param {string} option\n     * @param {Object} options\n     * @param {Object} referenceOptions\n     * @param {array} path    | where to look for the actual option\n     * @static\n     */\n\n  }, {\n    key: 'check',\n    value: function check(option, options, referenceOptions, path) {\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {\n        Validator.getSuggestion(option, referenceOptions, path);\n        return;\n      }\n\n      var referenceOption = option;\n      var is_object = true;\n\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {\n        // NOTE: This only triggers if the __any__ is in the top level of the options object.\n        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!\n        // TODO: Examine if needed, remove if possible\n\n        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.\n        referenceOption = '__any__';\n\n        // if the any-subgroup is not a predefined object in the configurator,\n        // we do not look deeper into the object.\n        is_object = Validator.getType(options[option]) === 'object';\n      } else {\n        // Since all options in the reference are objects, we can check whether\n        // they are supposed to be the object to look for the __type__ field.\n        // if this is an object, we check if the correct type has been supplied to account for shorthand options.\n      }\n\n      var refOptionObj = referenceOptions[referenceOption];\n      if (is_object && refOptionObj.__type__ !== undefined) {\n        refOptionObj = refOptionObj.__type__;\n      }\n\n      Validator.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);\n    }\n\n    /**\n     *\n     * @param {string}  option           | the option property\n     * @param {Object}  options          | The supplied options object\n     * @param {Object}  referenceOptions | The reference options containing all options and their allowed formats\n     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.\n     * @param {string}  refOptionObj     | This is the type object from the reference options\n     * @param {Array}   path             | where in the object is the option\n     * @static\n     */\n\n  }, {\n    key: 'checkFields',\n    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {\n      var log = function log(message) {\n        console.log('%c' + message + Validator.printLocation(path, option), printStyle);\n      };\n\n      var optionType = Validator.getType(options[option]);\n      var refOptionType = refOptionObj[optionType];\n\n      if (refOptionType !== undefined) {\n        // if the type is correct, we check if it is supposed to be one of a few select values\n        if (Validator.getType(refOptionType) === 'array' && refOptionType.indexOf(options[option]) === -1) {\n          log('Invalid option detected in \"' + option + '\".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not \"' + options[option] + '\". ');\n          errorFound = true;\n        } else if (optionType === 'object' && referenceOption !== '__any__') {\n          path = util.copyAndExtendArray(path, option);\n          Validator.parse(options[option], referenceOptions[referenceOption], path);\n        }\n      } else if (refOptionObj['any'] === undefined) {\n        // type of the field is incorrect and the field cannot be any\n        log('Invalid type received for \"' + option + '\". Expected: ' + Validator.print((0, _keys2['default'])(refOptionObj)) + '. Received [' + optionType + '] \"' + options[option] + '\"');\n        errorFound = true;\n      }\n    }\n\n    /**\n     *\n     * @param {Object|boolean|number|string|Array.<number>|Date|Node|Moment|undefined|null} object\n     * @returns {string}\n     * @static\n     */\n\n  }, {\n    key: 'getType',\n    value: function getType(object) {\n      var type = typeof object === 'undefined' ? 'undefined' : (0, _typeof3['default'])(object);\n\n      if (type === 'object') {\n        if (object === null) {\n          return 'null';\n        }\n        if (object instanceof Boolean) {\n          return 'boolean';\n        }\n        if (object instanceof Number) {\n          return 'number';\n        }\n        if (object instanceof String) {\n          return 'string';\n        }\n        if (Array.isArray(object)) {\n          return 'array';\n        }\n        if (object instanceof Date) {\n          return 'date';\n        }\n        if (object.nodeType !== undefined) {\n          return 'dom';\n        }\n        if (object._isAMomentObject === true) {\n          return 'moment';\n        }\n        return 'object';\n      } else if (type === 'number') {\n        return 'number';\n      } else if (type === 'boolean') {\n        return 'boolean';\n      } else if (type === 'string') {\n        return 'string';\n      } else if (type === undefined) {\n        return 'undefined';\n      }\n      return type;\n    }\n\n    /**\n     * @param {string} option\n     * @param {Object} options\n     * @param {Array.<string>} path\n     * @static\n     */\n\n  }, {\n    key: 'getSuggestion',\n    value: function getSuggestion(option, options, path) {\n      var localSearch = Validator.findInOptions(option, options, path, false);\n      var globalSearch = Validator.findInOptions(option, allOptions, [], true);\n\n      var localSearchThreshold = 8;\n      var globalSearchThreshold = 4;\n\n      var msg = void 0;\n      if (localSearch.indexMatch !== undefined) {\n        msg = ' in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: \"' + localSearch.indexMatch + '\"?\\n\\n';\n      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {\n        msg = ' in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, '');\n      } else if (localSearch.distance <= localSearchThreshold) {\n        msg = '. Did you mean \"' + localSearch.closestMatch + '\"?' + Validator.printLocation(localSearch.path, option);\n      } else {\n        msg = '. Did you mean one of these: ' + Validator.print((0, _keys2['default'])(options)) + Validator.printLocation(path, option);\n      }\n\n      console.log('%cUnknown option detected: \"' + option + '\"' + msg, printStyle);\n      errorFound = true;\n    }\n\n    /**\n     * traverse the options in search for a match.\n     * @param {string} option\n     * @param {Object} options\n     * @param {Array} path    | where to look for the actual option\n     * @param {boolean} [recursive=false]\n     * @returns {{closestMatch: string, path: Array, distance: number}}\n     * @static\n     */\n\n  }, {\n    key: 'findInOptions',\n    value: function findInOptions(option, options, path) {\n      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      var min = 1e9;\n      var closestMatch = '';\n      var closestMatchPath = [];\n      var lowerCaseOption = option.toLowerCase();\n      var indexMatch = undefined;\n      // eslint-disable-next-line guard-for-in\n      for (var op in options) {\n        var distance = void 0;\n        if (options[op].__type__ !== undefined && recursive === true) {\n          var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));\n          if (min > result.distance) {\n            closestMatch = result.closestMatch;\n            closestMatchPath = result.path;\n            min = result.distance;\n            indexMatch = result.indexMatch;\n          }\n        } else {\n          if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {\n            indexMatch = op;\n          }\n          distance = Validator.levenshteinDistance(option, op);\n          if (min > distance) {\n            closestMatch = op;\n            closestMatchPath = util.copyArray(path);\n            min = distance;\n          }\n        }\n      }\n      return {\n        closestMatch: closestMatch,\n        path: closestMatchPath,\n        distance: min,\n        indexMatch: indexMatch\n      };\n    }\n\n    /**\n     * @param {Array.<string>} path\n     * @param {Object} option\n     * @param {string} prefix\n     * @returns {String}\n     * @static\n     */\n\n  }, {\n    key: 'printLocation',\n    value: function printLocation(path, option) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Problem value found at: \\n';\n\n      var str = '\\n\\n' + prefix + 'options = {\\n';\n      for (var i = 0; i < path.length; i++) {\n        for (var j = 0; j < i + 1; j++) {\n          str += '  ';\n        }\n        str += path[i] + ': {\\n';\n      }\n      for (var _j = 0; _j < path.length + 1; _j++) {\n        str += '  ';\n      }\n      str += option + '\\n';\n      for (var _i = 0; _i < path.length + 1; _i++) {\n        for (var _j2 = 0; _j2 < path.length - _i; _j2++) {\n          str += '  ';\n        }\n        str += '}\\n';\n      }\n      return str + '\\n\\n';\n    }\n\n    /**\n     * @param {Object} options\n     * @returns {String}\n     * @static\n     */\n\n  }, {\n    key: 'print',\n    value: function print(options) {\n      return (0, _stringify2['default'])(options).replace(/(\\\")|(\\[)|(\\])|(,\"__type__\")/g, '').replace(/(\\,)/g, ', ');\n    }\n\n    /**\n     *  Compute the edit distance between the two given strings\n     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript\n     *\n     * Copyright (c) 2011 Andrei Mackenzie\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n     *\n     * @param {string} a\n     * @param {string} b\n     * @returns {Array.<Array.<number>>}}\n     * @static\n     */\n\n  }, {\n    key: 'levenshteinDistance',\n    value: function levenshteinDistance(a, b) {\n      if (a.length === 0) return b.length;\n      if (b.length === 0) return a.length;\n\n      var matrix = [];\n\n      // increment along the first column of each row\n      var i;\n      for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n      }\n\n      // increment each column in the first row\n      var j;\n      for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n      }\n\n      // Fill in the rest of the matrix\n      for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n          if (b.charAt(i - 1) == a.charAt(j - 1)) {\n            matrix[i][j] = matrix[i - 1][j - 1];\n          } else {\n            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution\n            Math.min(matrix[i][j - 1] + 1, // insertion\n            matrix[i - 1][j] + 1)); // deletion\n          }\n        }\n      }\n\n      return matrix[b.length][a.length];\n    }\n  }]);\n  return Validator;\n}();\n\nexports['default'] = Validator;\nexports.printStyle = printStyle;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __nested_webpack_require_180531__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = __nested_webpack_require_180531__(23);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _typeof2 = __nested_webpack_require_180531__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _create = __nested_webpack_require_180531__(31);\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _classCallCheck2 = __nested_webpack_require_180531__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_180531__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_180531__(2);\nvar Label = __nested_webpack_require_180531__(77)['default'];\nvar ComponentUtil = __nested_webpack_require_180531__(35)['default'];\nvar CubicBezierEdge = __nested_webpack_require_180531__(166)['default'];\nvar BezierEdgeDynamic = __nested_webpack_require_180531__(168)['default'];\nvar BezierEdgeStatic = __nested_webpack_require_180531__(169)['default'];\nvar StraightEdge = __nested_webpack_require_180531__(170)['default'];\n\n/**\n * An edge connects two nodes and has a specific direction.\n */\n\nvar Edge = function () {\n  /**\n   * @param {Object} options        values specific to this edge, must contain at least 'from' and 'to'\n   * @param {Object} body           shared state from Network instance\n   * @param {Object} globalOptions  options from the EdgesHandler instance\n   * @param {Object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant\n   */\n  function Edge(options, body, globalOptions, defaultOptions) {\n    (0, _classCallCheck3['default'])(this, Edge);\n\n    if (body === undefined) {\n      throw new Error('No body provided');\n    }\n\n    // Since globalOptions is constant in values as well as reference,\n    // Following needs to be done only once.\n\n    this.options = util.bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n\n    // initialize variables\n    this.id = undefined;\n    this.fromId = undefined;\n    this.toId = undefined;\n    this.selected = false;\n    this.hover = false;\n    this.labelDirty = true;\n\n    this.baseWidth = this.options.width;\n    this.baseFontSize = this.options.font.size;\n\n    this.from = undefined; // a node\n    this.to = undefined; // a node\n\n    this.edgeType = undefined;\n\n    this.connected = false;\n\n    this.labelModule = new Label(this.body, this.options, true /* It's an edge label */\n    );\n    this.setOptions(options);\n  }\n\n  /**\n   * Set or overwrite options for the edge\n   * @param {Object} options  an object with options\n   * @returns {null|boolean} null if no options, boolean if date changed\n   */\n\n\n  (0, _createClass3['default'])(Edge, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (!options) {\n        return;\n      }\n\n      Edge.parseOptions(this.options, options, true, this.globalOptions);\n\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n      if (options.from !== undefined) {\n        this.fromId = options.from;\n      }\n      if (options.to !== undefined) {\n        this.toId = options.to;\n      }\n      if (options.title !== undefined) {\n        this.title = options.title;\n      }\n      if (options.value !== undefined) {\n        options.value = parseFloat(options.value);\n      }\n\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = ComponentUtil.choosify('edge', pile);\n\n      // update label Module\n      this.updateLabelModule(options);\n\n      var dataChanged = this.updateEdgeType();\n\n      // if anything has been updates, reset the selection width and the hover width\n      this._setInteractionWidths();\n\n      // A node is connected when it has a from and to node that both exist in the network.body.nodes.\n      this.connect();\n\n      if (options.hidden !== undefined || options.physics !== undefined) {\n        dataChanged = true;\n      }\n\n      return dataChanged;\n    }\n\n    /**\n     *\n     * @param {Object} parentOptions\n     * @param {Object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {Object} [globalOptions={}]\n     * @param {boolean} [copyFromGlobals=false]\n     */\n\n  }, {\n    key: 'getFormattingValues',\n\n\n    /**\n     *\n     * @returns {ArrowOptions}\n     */\n    value: function getFormattingValues() {\n      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;\n      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;\n      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;\n      var inheritsColor = this.options.color.inherit;\n      var values = {\n        toArrow: toArrow,\n        toArrowScale: this.options.arrows.to.scaleFactor,\n        toArrowType: this.options.arrows.to.type,\n        middleArrow: middleArrow,\n        middleArrowScale: this.options.arrows.middle.scaleFactor,\n        middleArrowType: this.options.arrows.middle.type,\n        fromArrow: fromArrow,\n        fromArrowScale: this.options.arrows.from.scaleFactor,\n        fromArrowType: this.options.arrows.from.type,\n        arrowStrikethrough: this.options.arrowStrikethrough,\n        color: inheritsColor ? undefined : this.options.color.color,\n        inheritsColor: inheritsColor,\n        opacity: this.options.color.opacity,\n        hidden: this.options.hidden,\n        length: this.options.length,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y,\n        dashes: this.options.dashes,\n        width: this.options.width,\n        background: this.options.background.enabled,\n        backgroundColor: this.options.background.color,\n        backgroundSize: this.options.background.size,\n        backgroundDashes: this.options.background.dashes\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            var selectedWidth = this.options.selectionWidth;\n            if (typeof selectedWidth === 'function') {\n              values.width = selectedWidth(values.width);\n            } else if (typeof selectedWidth === 'number') {\n              values.width += selectedWidth;\n            }\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.highlight;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            var hoverWidth = this.options.hoverWidth;\n            if (typeof hoverWidth === 'function') {\n              values.width = hoverWidth(values.width);\n            } else if (typeof hoverWidth === 'number') {\n              values.width += hoverWidth;\n            }\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.hover;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === 'function') {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n          if (values.color !== undefined) {\n            values.inheritsColor = false;\n          }\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n        values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n      }\n      return values;\n    }\n\n    /**\n     * update the options in the label module\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'updateLabelModule',\n    value: function updateLabelModule(options) {\n      var pile = [options, this.options, this.globalOptions, // Currently set global edge options\n      this.defaultOptions];\n\n      this.labelModule.update(this.options, pile);\n\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n\n    /**\n     * update the edge type, set the options\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'updateEdgeType',\n    value: function updateEdgeType() {\n      var smooth = this.options.smooth;\n      var dataChanged = false;\n      var changeInType = true;\n      if (this.edgeType !== undefined) {\n        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === 'dynamic' || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === 'cubicBezier' || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== 'dynamic' && smooth.type !== 'cubicBezier' || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {\n          changeInType = false;\n        }\n        if (changeInType === true) {\n          dataChanged = this.cleanup();\n        }\n      }\n      if (changeInType === true) {\n        if (smooth.enabled === true) {\n          if (smooth.type === 'dynamic') {\n            dataChanged = true;\n            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);\n          } else if (smooth.type === 'cubicBezier') {\n            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);\n          } else {\n            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);\n          }\n        } else {\n          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);\n        }\n      } else {\n        // if nothing changes, we just set the options.\n        this.edgeType.setOptions(this.options);\n      }\n      return dataChanged;\n    }\n\n    /**\n     * Connect an edge to its nodes\n     */\n\n  }, {\n    key: 'connect',\n    value: function connect() {\n      this.disconnect();\n\n      this.from = this.body.nodes[this.fromId] || undefined;\n      this.to = this.body.nodes[this.toId] || undefined;\n      this.connected = this.from !== undefined && this.to !== undefined;\n\n      if (this.connected === true) {\n        this.from.attachEdge(this);\n        this.to.attachEdge(this);\n      } else {\n        if (this.from) {\n          this.from.detachEdge(this);\n        }\n        if (this.to) {\n          this.to.detachEdge(this);\n        }\n      }\n\n      this.edgeType.connect();\n    }\n\n    /**\n     * Disconnect an edge from its nodes\n     */\n\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      if (this.from) {\n        this.from.detachEdge(this);\n        this.from = undefined;\n      }\n      if (this.to) {\n        this.to.detachEdge(this);\n        this.to = undefined;\n      }\n\n      this.connected = false;\n    }\n\n    /**\n     * get the title of this edge.\n     * @return {string} title    The title of the edge, or undefined when no title\n     *                           has been set.\n     */\n\n  }, {\n    key: 'getTitle',\n    value: function getTitle() {\n      return this.title;\n    }\n\n    /**\n     * check if this node is selecte\n     * @return {boolean} selected   True if node is selected, else false\n     */\n\n  }, {\n    key: 'isSelected',\n    value: function isSelected() {\n      return this.selected;\n    }\n\n    /**\n     * Retrieve the value of the edge. Can be undefined\n     * @return {number} value\n     */\n\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.options.value;\n    }\n\n    /**\n     * Adjust the value range of the edge. The edge will adjust it's width\n     * based on its value.\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n\n  }, {\n    key: 'setValueRange',\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var widthDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.width = this.options.scaling.min + scale * widthDiff;\n      } else {\n        this.options.width = this.baseWidth;\n        this.options.font.size = this.baseFontSize;\n      }\n\n      this._setInteractionWidths();\n      this.updateLabelModule();\n    }\n\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_setInteractionWidths',\n    value: function _setInteractionWidths() {\n      if (typeof this.options.hoverWidth === 'function') {\n        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);\n      } else {\n        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;\n      }\n      if (typeof this.options.selectionWidth === 'function') {\n        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);\n      } else {\n        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;\n      }\n    }\n\n    /**\n     * Redraw a edge\n     * Draw this edge in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n      if (values.hidden) {\n        return;\n      }\n\n      // get the via node from the edge type\n      var viaNode = this.edgeType.getViaNode();\n      var arrowData = {};\n\n      // restore edge targets to defaults\n      this.edgeType.fromPoint = this.edgeType.from;\n      this.edgeType.toPoint = this.edgeType.to;\n\n      // from and to arrows give a different end point for edges. we set them here\n      if (values.fromArrow) {\n        arrowData.from = this.edgeType.getArrowData(ctx, 'from', viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;\n      }\n      if (values.toArrow) {\n        arrowData.to = this.edgeType.getArrowData(ctx, 'to', viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;\n      }\n\n      // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.\n      if (values.middleArrow) {\n        arrowData.middle = this.edgeType.getArrowData(ctx, 'middle', viaNode, this.selected, this.hover, values);\n      }\n\n      // draw everything\n      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);\n      this.drawArrows(ctx, arrowData, values);\n      this.drawLabel(ctx, viaNode);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Object} arrowData\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'drawArrows',\n    value: function drawArrows(ctx, arrowData, values) {\n      if (values.fromArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);\n      }\n      if (values.middleArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);\n      }\n      if (values.toArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Node} viaNode\n     */\n\n  }, {\n    key: 'drawLabel',\n    value: function drawLabel(ctx, viaNode) {\n      if (this.options.label !== undefined) {\n        // set style\n        var node1 = this.from;\n        var node2 = this.to;\n\n        if (this.labelModule.differentState(this.selected, this.hover)) {\n          this.labelModule.getTextSize(ctx, this.selected, this.hover);\n        }\n\n        if (node1.id != node2.id) {\n          this.labelModule.pointToSelf = false;\n          var point = this.edgeType.getPoint(0.5, viaNode);\n          ctx.save();\n\n          var rotationPoint = this._getRotation(ctx);\n          if (rotationPoint.angle != 0) {\n            ctx.translate(rotationPoint.x, rotationPoint.y);\n            ctx.rotate(rotationPoint.angle);\n          }\n\n          // draw the label\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n\n          /*\n          // Useful debug code: draw a border around the label\n          // This should **not** be enabled in production!\n          var size = this.labelModule.getSize();; // ;; intentional so lint catches it\n          ctx.strokeStyle = \"#ff0000\";\n          ctx.strokeRect(size.left, size.top, size.width, size.height);\n          // End  debug code\n          */\n\n          ctx.restore();\n        } else {\n          // Ignore the orientations.\n          this.labelModule.pointToSelf = true;\n          var x, y;\n          var radius = this.options.selfReferenceSize;\n          if (node1.shape.width > node1.shape.height) {\n            x = node1.x + node1.shape.width * 0.5;\n            y = node1.y - radius;\n          } else {\n            x = node1.x + radius;\n            y = node1.y - node1.shape.height * 0.5;\n          }\n          point = this._pointOnCircle(x, y, radius, 0.125);\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n        }\n      }\n    }\n\n    /**\n     * Determine all visual elements of this edge instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point\n     */\n\n  }, {\n    key: 'getItemsOnPoint',\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n\n      if (this.labelModule.visible()) {\n        var rotationPoint = this._getRotation();\n        if (ComponentUtil.pointInRect(this.labelModule.getSize(), point, rotationPoint)) {\n          ret.push({ edgeId: this.id, labelId: 0 });\n        }\n      }\n\n      var obj = {\n        left: point.x,\n        top: point.y\n      };\n\n      if (this.isOverlappingWith(obj)) {\n        ret.push({ edgeId: this.id });\n      }\n\n      return ret;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     * @param {Object} obj   an object with parameters left, top\n     * @return {boolean}     True if location is located on the edge\n     */\n\n  }, {\n    key: 'isOverlappingWith',\n    value: function isOverlappingWith(obj) {\n      if (this.connected) {\n        var distMax = 10;\n        var xFrom = this.from.x;\n        var yFrom = this.from.y;\n        var xTo = this.to.x;\n        var yTo = this.to.y;\n        var xObj = obj.left;\n        var yObj = obj.top;\n\n        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);\n\n        return dist < distMax;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine the rotation point, if any.\n     *\n     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size\n     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate\n     * @private\n     */\n\n  }, {\n    key: '_getRotation',\n    value: function _getRotation(ctx) {\n      var viaNode = this.edgeType.getViaNode();\n      var point = this.edgeType.getPoint(0.5, viaNode);\n\n      if (ctx !== undefined) {\n        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);\n      }\n\n      var ret = {\n        x: point.x,\n        y: this.labelModule.size.yLine,\n        angle: 0\n      };\n\n      if (!this.labelModule.visible()) {\n        return ret; // Don't even bother doing the atan2, there's nothing to draw\n      }\n\n      if (this.options.font.align === 'horizontal') {\n        return ret; // No need to calculate angle\n      }\n\n      var dy = this.from.y - this.to.y;\n      var dx = this.from.x - this.to.x;\n      var angle = Math.atan2(dy, dx); // radians\n\n      // rotate so that label is readable\n      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {\n        angle += Math.PI;\n      }\n      ret.angle = angle;\n\n      return ret;\n    }\n\n    /**\n     * Get a point on a circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {number} percentage Value between 0 (line start) and 1 (line end)\n     * @return {Object} point\n     * @private\n     */\n\n  }, {\n    key: '_pointOnCircle',\n    value: function _pointOnCircle(x, y, radius, percentage) {\n      var angle = percentage * 2 * Math.PI;\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n\n    /**\n     * Sets selected state to true\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {\n      this.selected = true;\n    }\n\n    /**\n     * Sets selected state to false\n     */\n\n  }, {\n    key: 'unselect',\n    value: function unselect() {\n      this.selected = false;\n    }\n\n    /**\n     * cleans all required things on delete\n     * @returns {*}\n     */\n\n  }, {\n    key: 'cleanup',\n    value: function cleanup() {\n      return this.edgeType.cleanup();\n    }\n\n    /**\n     * Remove edge from the list and perform necessary cleanup.\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove() {\n      this.cleanup();\n      this.disconnect();\n      delete this.body.edges[this.id];\n    }\n\n    /**\n     * Check if both connecting nodes exist\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'endPointsValid',\n    value: function endPointsValid() {\n      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;\n    }\n  }], [{\n    key: 'parseOptions',\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      var fields = ['arrowStrikethrough', 'id', 'from', 'hidden', 'hoverWidth', 'labelHighlightBold', 'length', 'line', 'opacity', 'physics', 'scaling', 'selectionWidth', 'selfReferenceSize', 'to', 'title', 'value', 'width', 'font', 'chosen', 'widthConstraint'];\n\n      // only deep extend the items in the field array. These do not have shorthand.\n      util.selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n\n      // Only copy label if it's a legal value.\n      if (ComponentUtil.isValidLabel(newOptions.label)) {\n        parentOptions.label = newOptions.label;\n      } else {\n        parentOptions.label = undefined;\n      }\n\n      util.mergeOptions(parentOptions, newOptions, 'smooth', globalOptions);\n      util.mergeOptions(parentOptions, newOptions, 'shadow', globalOptions);\n      util.mergeOptions(parentOptions, newOptions, 'background', globalOptions);\n\n      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {\n        parentOptions.dashes = newOptions.dashes;\n      } else if (allowDeletion === true && newOptions.dashes === null) {\n        parentOptions.dashes = (0, _create2['default'])(globalOptions.dashes); // this sets the pointer of the option back to the global option.\n      }\n\n      // set the scaling newOptions\n      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {\n        if (newOptions.scaling.min !== undefined) {\n          parentOptions.scaling.min = newOptions.scaling.min;\n        }\n        if (newOptions.scaling.max !== undefined) {\n          parentOptions.scaling.max = newOptions.scaling.max;\n        }\n        util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', globalOptions.scaling);\n      } else if (allowDeletion === true && newOptions.scaling === null) {\n        parentOptions.scaling = (0, _create2['default'])(globalOptions.scaling); // this sets the pointer of the option back to the global option.\n      }\n\n      // handle multiple input cases for arrows\n      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {\n        if (typeof newOptions.arrows === 'string') {\n          var arrows = newOptions.arrows.toLowerCase();\n          parentOptions.arrows.to.enabled = arrows.indexOf('to') != -1;\n          parentOptions.arrows.middle.enabled = arrows.indexOf('middle') != -1;\n          parentOptions.arrows.from.enabled = arrows.indexOf('from') != -1;\n        } else if ((0, _typeof3['default'])(newOptions.arrows) === 'object') {\n          util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'to', globalOptions.arrows);\n          util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'middle', globalOptions.arrows);\n          util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'from', globalOptions.arrows);\n        } else {\n          throw new Error('The arrow newOptions can only be an object or a string. Refer to the documentation. You used:' + (0, _stringify2['default'])(newOptions.arrows));\n        }\n      } else if (allowDeletion === true && newOptions.arrows === null) {\n        parentOptions.arrows = (0, _create2['default'])(globalOptions.arrows); // this sets the pointer of the option back to the global option.\n      }\n\n      // handle multiple input cases for color\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var fromColor = newOptions.color;\n        var toColor = parentOptions.color;\n\n        // If passed, fill in values from default options - required in the case of no prototype bridging\n        if (copyFromGlobals) {\n          util.deepExtend(toColor, globalOptions.color, false, allowDeletion);\n        } else {\n          // Clear local properties - need to do it like this in order to retain prototype bridges\n          for (var i in toColor) {\n            if (toColor.hasOwnProperty(i)) {\n              delete toColor[i];\n            }\n          }\n        }\n\n        if (util.isString(toColor)) {\n          toColor.color = toColor;\n          toColor.highlight = toColor;\n          toColor.hover = toColor;\n          toColor.inherit = false;\n          if (fromColor.opacity === undefined) {\n            toColor.opacity = 1.0; // set default\n          }\n        } else {\n          var colorsDefined = false;\n          if (fromColor.color !== undefined) {\n            toColor.color = fromColor.color;\n            colorsDefined = true;\n          }\n          if (fromColor.highlight !== undefined) {\n            toColor.highlight = fromColor.highlight;\n            colorsDefined = true;\n          }\n          if (fromColor.hover !== undefined) {\n            toColor.hover = fromColor.hover;\n            colorsDefined = true;\n          }\n          if (fromColor.inherit !== undefined) {\n            toColor.inherit = fromColor.inherit;\n          }\n          if (fromColor.opacity !== undefined) {\n            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));\n          }\n\n          if (colorsDefined === true) {\n            toColor.inherit = false;\n          } else {\n            if (toColor.inherit === undefined) {\n              toColor.inherit = 'from'; // Set default\n            }\n          }\n        }\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options\n      }\n\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n    }\n  }]);\n  return Edge;\n}();\n\nexports['default'] = Edge;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __nested_webpack_require_208434__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_208434__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_208434__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_208434__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_208434__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_208434__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _EdgeBase2 = __nested_webpack_require_208434__(79);\n\nvar _EdgeBase3 = _interopRequireDefault(_EdgeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * The Base Class for all Bezier edges. Bezier curves are used to model smooth\n * gradual curves in paths between nodes.\n *\n * @extends EdgeBase\n */\nvar BezierEdgeBase = function (_EdgeBase) {\n  (0, _inherits3['default'])(BezierEdgeBase, _EdgeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function BezierEdgeBase(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, BezierEdgeBase);\n    return (0, _possibleConstructorReturn3['default'])(this, (BezierEdgeBase.__proto__ || (0, _getPrototypeOf2['default'])(BezierEdgeBase)).call(this, options, body, labelModule));\n  }\n\n  /**\n   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.\n   *\n   * @param {Node} nearNode\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {Node} viaNode\n   * @returns {*}\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(BezierEdgeBase, [{\n    key: '_findBorderPositionBezier',\n    value: function _findBorderPositionBezier(nearNode, ctx) {\n      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();\n\n      var maxIterations = 10;\n      var iteration = 0;\n      var low = 0;\n      var high = 1;\n      var pos, angle, distanceToBorder, distanceToPoint, difference;\n      var threshold = 0.2;\n      var node = this.to;\n      var from = false;\n      if (nearNode.id === this.from.id) {\n        node = this.from;\n        from = true;\n      }\n\n      while (low <= high && iteration < maxIterations) {\n        var middle = (low + high) * 0.5;\n\n        pos = this.getPoint(middle, viaNode);\n        angle = Math.atan2(node.y - pos.y, node.x - pos.x);\n        distanceToBorder = node.distanceToBorder(ctx, angle);\n        distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));\n        difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference < 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (from === false) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (from === false) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n\n        iteration++;\n      }\n      pos.t = middle;\n\n      return pos;\n    }\n\n    /**\n     * Calculate the distance between a point (x3,y3) and a line segment from\n     * (x1,y1) to (x2,y2).\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\n     * @param {number} x1 from x\n     * @param {number} y1 from y\n     * @param {number} x2 to x\n     * @param {number} y2 to y\n     * @param {number} x3 point to check x\n     * @param {number} y3 point to check y\n     * @param {Node} via\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getDistanceToBezierEdge',\n    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var distance = void 0;\n      var i = void 0,\n          t = void 0,\n          x = void 0,\n          y = void 0;\n      var lastX = x1;\n      var lastY = y1;\n      for (i = 1; i < 10; i++) {\n        t = 0.1 * i;\n        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;\n        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;\n        if (i > 0) {\n          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n\n      return minDistance;\n    }\n\n    /**\n     * Draw a bezier curve between two nodes\n     *\n     * The method accepts zero, one or two control points.\n     * Passing zero control points just draws a straight line\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Object}           values   | options for shadow drawing\n     * @param {Object|undefined} viaNode1 | first control point for curve drawing\n     * @param {Object|undefined} viaNode2 | second control point for curve drawing\n     *\n     * @protected\n     */\n\n  }, {\n    key: '_bezierCurve',\n    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {\n      var hasNode1 = viaNode1 !== undefined && viaNode1.x !== undefined;\n      var hasNode2 = viaNode2 !== undefined && viaNode2.x !== undefined;\n\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n\n      if (hasNode1 && hasNode2) {\n        ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);\n      } else if (hasNode1) {\n        ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);\n      } else {\n        // fallback to normal straight edge\n        ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      }\n      // draw a background\n      this.drawBackground(ctx, values);\n\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n\n    /**\n     *\n     * @returns {*|{x, y}|{x: undefined, y: undefined}}\n     */\n\n  }, {\n    key: 'getViaNode',\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }]);\n  return BezierEdgeBase;\n}(_EdgeBase3['default']);\n\nexports['default'] = BezierEdgeBase;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __nested_webpack_require_214899__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_214899__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_214899__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_214899__(2);\n\n/**\n * Utility Class\n */\n\nvar NetworkUtil = function () {\n  /**\n   * @ignore\n   */\n  function NetworkUtil() {\n    (0, _classCallCheck3['default'])(this, NetworkUtil);\n  }\n\n  /**\n   * Find the center position of the network considering the bounding boxes\n   *\n   * @param {Array.<Node>} allNodes\n   * @param {Array.<Node>} [specificNodes=[]]\n   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n   * @static\n   */\n\n\n  (0, _createClass3['default'])(NetworkUtil, null, [{\n    key: 'getRange',\n    value: function getRange(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var minY = 1e9,\n          maxY = -1e9,\n          minX = 1e9,\n          maxX = -1e9,\n          node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.shape.boundingBox.left) {\n            minX = node.shape.boundingBox.left;\n          }\n          if (maxX < node.shape.boundingBox.right) {\n            maxX = node.shape.boundingBox.right;\n          }\n          if (minY > node.shape.boundingBox.top) {\n            minY = node.shape.boundingBox.top;\n          } // top is negative, bottom is positive\n          if (maxY < node.shape.boundingBox.bottom) {\n            maxY = node.shape.boundingBox.bottom;\n          } // top is negative, bottom is positive\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        ;minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };\n    }\n\n    /**\n     * Find the center position of the network\n     *\n     * @param {Array.<Node>} allNodes\n     * @param {Array.<Node>} [specificNodes=[]]\n     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n     * @static\n     */\n\n  }, {\n    key: 'getRangeCore',\n    value: function getRangeCore(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var minY = 1e9,\n          maxY = -1e9,\n          minX = 1e9,\n          maxX = -1e9,\n          node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.x) {\n            minX = node.x;\n          }\n          if (maxX < node.x) {\n            maxX = node.x;\n          }\n          if (minY > node.y) {\n            minY = node.y;\n          } // top is negative, bottom is positive\n          if (maxY < node.y) {\n            maxY = node.y;\n          } // top is negative, bottom is positive\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        ;minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };\n    }\n\n    /**\n     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};\n     * @returns {{x: number, y: number}}\n     * @static\n     */\n\n  }, {\n    key: 'findCenter',\n    value: function findCenter(range) {\n      return {\n        x: 0.5 * (range.maxX + range.minX),\n        y: 0.5 * (range.maxY + range.minY)\n      };\n    }\n\n    /**\n     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.\n     * @param {vis.Item} item\n     * @param {'node'|undefined} type\n     * @returns {{}}\n     * @static\n     */\n\n  }, {\n    key: 'cloneOptions',\n    value: function cloneOptions(item, type) {\n      var clonedOptions = {};\n      if (type === undefined || type === 'node') {\n        util.deepExtend(clonedOptions, item.options, true);\n        clonedOptions.x = item.x;\n        clonedOptions.y = item.y;\n        clonedOptions.amountOfConnections = item.edges.length;\n      } else {\n        util.deepExtend(clonedOptions, item.options, true);\n      }\n      return clonedOptions;\n    }\n  }]);\n  return NetworkUtil;\n}();\n\nexports['default'] = NetworkUtil;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __nested_webpack_require_219462__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_219462__(86), __esModule: true };\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __nested_webpack_require_219614__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __nested_webpack_require_219614__(38);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __nested_webpack_require_219987__) {\n\n\"use strict\";\n\nvar LIBRARY = __nested_webpack_require_219987__(27);\nvar $export = __nested_webpack_require_219987__(11);\nvar redefine = __nested_webpack_require_219987__(64);\nvar hide = __nested_webpack_require_219987__(19);\nvar Iterators = __nested_webpack_require_219987__(25);\nvar $iterCreate = __nested_webpack_require_219987__(91);\nvar setToStringTag = __nested_webpack_require_219987__(46);\nvar getPrototypeOf = __nested_webpack_require_219987__(66);\nvar ITERATOR = __nested_webpack_require_219987__(8)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __nested_webpack_require_222850__) {\n\n// optional / simple context binding\nvar aFunction = __nested_webpack_require_222850__(90);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __nested_webpack_require_223447__) {\n\nmodule.exports = !__nested_webpack_require_223447__(13) && !__nested_webpack_require_223447__(22)(function () {\n  return Object.defineProperty(__nested_webpack_require_223447__(63)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __nested_webpack_require_223725__) {\n\nvar isObject = __nested_webpack_require_223725__(21);\nvar document = __nested_webpack_require_223725__(10).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __nested_webpack_require_224095__) {\n\nmodule.exports = __nested_webpack_require_224095__(19);\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __nested_webpack_require_224215__) {\n\nvar has = __nested_webpack_require_224215__(14);\nvar toIObject = __nested_webpack_require_224215__(18);\nvar arrayIndexOf = __nested_webpack_require_224215__(93)(false);\nvar IE_PROTO = __nested_webpack_require_224215__(43)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __nested_webpack_require_224829__) {\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __nested_webpack_require_224829__(14);\nvar toObject = __nested_webpack_require_224829__(30);\nvar IE_PROTO = __nested_webpack_require_224829__(43)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __nested_webpack_require_225405__) {\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __nested_webpack_require_225405__(38);\nvar TAG = __nested_webpack_require_225405__(8)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __nested_webpack_require_226212__) {\n\n// most Object methods by ES6 should accept primitives\nvar $export = __nested_webpack_require_226212__(11);\nvar core = __nested_webpack_require_226212__(6);\nvar fails = __nested_webpack_require_226212__(22);\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __nested_webpack_require_226671__) {\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __nested_webpack_require_226671__(65);\nvar hiddenKeys = __nested_webpack_require_226671__(45).concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __nested_webpack_require_227022__) {\n\nvar pIE = __nested_webpack_require_227022__(32);\nvar createDesc = __nested_webpack_require_227022__(28);\nvar toIObject = __nested_webpack_require_227022__(18);\nvar toPrimitive = __nested_webpack_require_227022__(40);\nvar has = __nested_webpack_require_227022__(14);\nvar IE8_DOM_DEFINE = __nested_webpack_require_227022__(62);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __nested_webpack_require_227022__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __nested_webpack_require_227667__) {\n\n\"use strict\";\n\n\n// first check if moment.js is already loaded in the browser window, if so,\n// use this instance. Else, load via commonjs.\nmodule.exports = typeof window !== 'undefined' && window['moment'] || __nested_webpack_require_227667__(116);\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * A queue\n * @param {Object} options\n *            Available options:\n *            - delay: number    When provided, the queue will be flushed\n *                               automatically after an inactivity of this delay\n *                               in milliseconds.\n *                               Default value is null.\n *            - max: number      When the queue exceeds the given maximum number\n *                               of entries, the queue is flushed automatically.\n *                               Default value of max is Infinity.\n * @constructor Queue\n */\nfunction Queue(options) {\n  // options\n  this.delay = null;\n  this.max = Infinity;\n\n  // properties\n  this._queue = [];\n  this._timeout = null;\n  this._extended = null;\n\n  this.setOptions(options);\n}\n\n/**\n * Update the configuration of the queue\n * @param {Object} options\n *            Available options:\n *            - delay: number    When provided, the queue will be flushed\n *                               automatically after an inactivity of this delay\n *                               in milliseconds.\n *                               Default value is null.\n *            - max: number      When the queue exceeds the given maximum number\n *                               of entries, the queue is flushed automatically.\n *                               Default value of max is Infinity.\n */\nQueue.prototype.setOptions = function (options) {\n  if (options && typeof options.delay !== 'undefined') {\n    this.delay = options.delay;\n  }\n  if (options && typeof options.max !== 'undefined') {\n    this.max = options.max;\n  }\n\n  this._flushIfNeeded();\n};\n\n/**\n * Extend an object with queuing functionality.\n * The object will be extended with a function flush, and the methods provided\n * in options.replace will be replaced with queued ones.\n * @param {Object} object\n * @param {Object} options\n *            Available options:\n *            - replace: Array.<string>\n *                               A list with method names of the methods\n *                               on the object to be replaced with queued ones.\n *            - delay: number    When provided, the queue will be flushed\n *                               automatically after an inactivity of this delay\n *                               in milliseconds.\n *                               Default value is null.\n *            - max: number      When the queue exceeds the given maximum number\n *                               of entries, the queue is flushed automatically.\n *                               Default value of max is Infinity.\n * @return {Queue} Returns the created queue\n */\nQueue.extend = function (object, options) {\n  var queue = new Queue(options);\n\n  if (object.flush !== undefined) {\n    throw new Error('Target object already has a property flush');\n  }\n  object.flush = function () {\n    queue.flush();\n  };\n\n  var methods = [{\n    name: 'flush',\n    original: undefined\n  }];\n\n  if (options && options.replace) {\n    for (var i = 0; i < options.replace.length; i++) {\n      var name = options.replace[i];\n      methods.push({\n        name: name,\n        original: object[name]\n      });\n      queue.replace(object, name);\n    }\n  }\n\n  queue._extended = {\n    object: object,\n    methods: methods\n  };\n\n  return queue;\n};\n\n/**\n * Destroy the queue. The queue will first flush all queued actions, and in\n * case it has extended an object, will restore the original object.\n */\nQueue.prototype.destroy = function () {\n  this.flush();\n\n  if (this._extended) {\n    var object = this._extended.object;\n    var methods = this._extended.methods;\n    for (var i = 0; i < methods.length; i++) {\n      var method = methods[i];\n      if (method.original) {\n        object[method.name] = method.original;\n      } else {\n        delete object[method.name];\n      }\n    }\n    this._extended = null;\n  }\n};\n\n/**\n * Replace a method on an object with a queued version\n * @param {Object} object   Object having the method\n * @param {string} method   The method name\n */\nQueue.prototype.replace = function (object, method) {\n  var me = this;\n  var original = object[method];\n  if (!original) {\n    throw new Error('Method ' + method + ' undefined');\n  }\n\n  object[method] = function () {\n    // create an Array with the arguments\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    // add this call to the queue\n    me.queue({\n      args: args,\n      fn: original,\n      context: this\n    });\n  };\n};\n\n/**\n * Queue a call\n * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry\n */\nQueue.prototype.queue = function (entry) {\n  if (typeof entry === 'function') {\n    this._queue.push({ fn: entry });\n  } else {\n    this._queue.push(entry);\n  }\n\n  this._flushIfNeeded();\n};\n\n/**\n * Check whether the queue needs to be flushed\n * @private\n */\nQueue.prototype._flushIfNeeded = function () {\n  // flush when the maximum is exceeded.\n  if (this._queue.length > this.max) {\n    this.flush();\n  }\n\n  // flush after a period of inactivity when a delay is configured\n  clearTimeout(this._timeout);\n  if (this.queue.length > 0 && typeof this.delay === 'number') {\n    var me = this;\n    this._timeout = setTimeout(function () {\n      me.flush();\n    }, this.delay);\n  }\n};\n\n/**\n * Flush all queued calls\n */\nQueue.prototype.flush = function () {\n  while (this._queue.length > 0) {\n    var entry = this._queue.shift();\n    entry.fn.apply(entry.context || entry.fn, entry.args || []);\n  }\n};\n\nmodule.exports = Queue;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports) {\n\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __nested_webpack_require_236714__) {\n\n\"use strict\";\n\n\nvar _create = __nested_webpack_require_236714__(31);\n\nvar _create2 = _interopRequireDefault(_create);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Parse a text source containing data in DOT language into a JSON object.\n * The object contains two lists: one with nodes and one with edges.\n *\n * DOT language reference: http://www.graphviz.org/doc/info/lang.html\n *\n * DOT language attributes: http://graphviz.org/content/attrs\n *\n * @param {string} data     Text containing a graph in DOT-notation\n * @return {Object} graph   An object containing two parameters:\n *                          {Object[]} nodes\n *                          {Object[]} edges\n *\n * -------------------------------------------\n * TODO\n * ====\n *\n * For label handling, this is an incomplete implementation. From docs (quote #3015):\n *\n * > the escape sequences \"\\n\", \"\\l\" and \"\\r\" divide the label into lines, centered,\n * > left-justified, and right-justified, respectively.\n *\n * Source: http://www.graphviz.org/content/attrs#kescString\n *\n * > As another aid for readability, dot allows double-quoted strings to span multiple physical\n * > lines using the standard C convention of a backslash immediately preceding a newline\n * > character\n * > In addition, double-quoted strings can be concatenated using a '+' operator.\n * > As HTML strings can contain newline characters, which are used solely for formatting,\n * > the language does not allow escaped newlines or concatenation operators to be used\n * > within them.\n *\n * - Currently, only '\\\\n' is handled\n * - Note that text explicitly says 'labels'; the dot parser currently handles escape\n *   sequences in **all** strings.\n */\nfunction parseDOT(data) {\n  dot = data;\n  return parseGraph();\n}\n\n// mapping of attributes from DOT (the keys) to vis.js (the values)\nvar NODE_ATTR_MAPPING = {\n  fontsize: 'font.size',\n  fontcolor: 'font.color',\n  labelfontcolor: 'font.color',\n  fontname: 'font.face',\n  color: ['color.border', 'color.background'],\n  fillcolor: 'color.background',\n  tooltip: 'title',\n  labeltooltip: 'title'\n};\nvar EDGE_ATTR_MAPPING = (0, _create2['default'])(NODE_ATTR_MAPPING);\nEDGE_ATTR_MAPPING.color = 'color.color';\nEDGE_ATTR_MAPPING.style = 'dashes';\n\n// token types enumeration\nvar TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  IDENTIFIER: 2,\n  UNKNOWN: 3\n\n  // map with all delimiters\n};var DELIMITERS = {\n  '{': true,\n  '}': true,\n  '[': true,\n  ']': true,\n  ';': true,\n  '=': true,\n  ',': true,\n\n  '->': true,\n  '--': true\n};\n\nvar dot = ''; // current dot file\nvar index = 0; // current index in dot file\nvar c = ''; // current token character in expr\nvar token = ''; // current token\nvar tokenType = TOKENTYPE.NULL; // type of the token\n\n/**\n * Get the first character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\nfunction first() {\n  index = 0;\n  c = dot.charAt(0);\n}\n\n/**\n * Get the next character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\nfunction next() {\n  index++;\n  c = dot.charAt(index);\n}\n\n/**\n * Preview the next character from the dot file.\n * @return {string} cNext\n */\nfunction nextPreview() {\n  return dot.charAt(index + 1);\n}\n\nvar regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;\n/**\n * Test whether given character is alphabetic or numeric\n * @param {string} c\n * @return {Boolean} isAlphaNumeric\n */\nfunction isAlphaNumeric(c) {\n  return regexAlphaNumeric.test(c);\n}\n\n/**\n * Merge all options of object b into object b\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n */\nfunction merge(a, b) {\n  if (!a) {\n    a = {};\n  }\n\n  if (b) {\n    for (var name in b) {\n      if (b.hasOwnProperty(name)) {\n        a[name] = b[name];\n      }\n    }\n  }\n  return a;\n}\n\n/**\n * Set a value in an object, where the provided parameter name can be a\n * path with nested parameters. For example:\n *\n *     var obj = {a: 2};\n *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}\n *\n * @param {Object} obj\n * @param {string} path  A parameter name or dot-separated parameter path,\n *                      like \"color.highlight.border\".\n * @param {*} value\n */\nfunction setValue(obj, path, value) {\n  var keys = path.split('.');\n  var o = obj;\n  while (keys.length) {\n    var key = keys.shift();\n    if (keys.length) {\n      // this isn't the end point\n      if (!o[key]) {\n        o[key] = {};\n      }\n      o = o[key];\n    } else {\n      // this is the end point\n      o[key] = value;\n    }\n  }\n}\n\n/**\n * Add a node to a graph object. If there is already a node with\n * the same id, their attributes will be merged.\n * @param {Object} graph\n * @param {Object} node\n */\nfunction addNode(graph, node) {\n  var i, len;\n  var current = null;\n\n  // find root graph (in case of subgraph)\n  var graphs = [graph]; // list with all graphs from current graph to root graph\n  var root = graph;\n  while (root.parent) {\n    graphs.push(root.parent);\n    root = root.parent;\n  }\n\n  // find existing node (at root level) by its id\n  if (root.nodes) {\n    for (i = 0, len = root.nodes.length; i < len; i++) {\n      if (node.id === root.nodes[i].id) {\n        current = root.nodes[i];\n        break;\n      }\n    }\n  }\n\n  if (!current) {\n    // this is a new node\n    current = {\n      id: node.id\n    };\n    if (graph.node) {\n      // clone default attributes\n      current.attr = merge(current.attr, graph.node);\n    }\n  }\n\n  // add node to this (sub)graph and all its parent graphs\n  for (i = graphs.length - 1; i >= 0; i--) {\n    var g = graphs[i];\n\n    if (!g.nodes) {\n      g.nodes = [];\n    }\n    if (g.nodes.indexOf(current) === -1) {\n      g.nodes.push(current);\n    }\n  }\n\n  // merge attributes\n  if (node.attr) {\n    current.attr = merge(current.attr, node.attr);\n  }\n}\n\n/**\n * Add an edge to a graph object\n * @param {Object} graph\n * @param {Object} edge\n */\nfunction addEdge(graph, edge) {\n  if (!graph.edges) {\n    graph.edges = [];\n  }\n  graph.edges.push(edge);\n  if (graph.edge) {\n    var attr = merge({}, graph.edge); // clone default attributes\n    edge.attr = merge(attr, edge.attr); // merge attributes\n  }\n}\n\n/**\n * Create an edge to a graph object\n * @param {Object} graph\n * @param {string | number | Object} from\n * @param {string | number | Object} to\n * @param {string} type\n * @param {Object | null} attr\n * @return {Object} edge\n */\nfunction createEdge(graph, from, to, type, attr) {\n  var edge = {\n    from: from,\n    to: to,\n    type: type\n  };\n\n  if (graph.edge) {\n    edge.attr = merge({}, graph.edge); // clone default attributes\n  }\n  edge.attr = merge(edge.attr || {}, attr); // merge attributes\n\n  // Move arrows attribute from attr to edge temporally created in\n  // parseAttributeList().\n  if (attr != null) {\n    if (attr.hasOwnProperty('arrows')) {\n      edge['arrows'] = { to: { enabled: true, type: attr.arrows.type } };\n      attr['arrows'] = null;\n    }\n  }\n  return edge;\n}\n\n/**\n * Get next token in the current dot file.\n * The token and token type are available as token and tokenType\n */\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = '';\n\n  // skip over whitespaces\n  while (c === ' ' || c === '\\t' || c === '\\n' || c === '\\r') {\n    // space, tab, enter\n    next();\n  }\n\n  do {\n    var isComment = false;\n\n    // skip comment\n    if (c === '#') {\n      // find the previous non-space character\n      var i = index - 1;\n      while (dot.charAt(i) === ' ' || dot.charAt(i) === '\\t') {\n        i--;\n      }\n      if (dot.charAt(i) === '\\n' || dot.charAt(i) === '') {\n        // the # is at the start of a line, this is indeed a line comment\n        while (c != '' && c != '\\n') {\n          next();\n        }\n        isComment = true;\n      }\n    }\n    if (c === '/' && nextPreview() === '/') {\n      // skip line comment\n      while (c != '' && c != '\\n') {\n        next();\n      }\n      isComment = true;\n    }\n    if (c === '/' && nextPreview() === '*') {\n      // skip block comment\n      while (c != '') {\n        if (c === '*' && nextPreview() === '/') {\n          // end of block comment found. skip these last two characters\n          next();\n          next();\n          break;\n        } else {\n          next();\n        }\n      }\n      isComment = true;\n    }\n\n    // skip over whitespaces\n    while (c === ' ' || c === '\\t' || c === '\\n' || c === '\\r') {\n      // space, tab, enter\n      next();\n    }\n  } while (isComment);\n\n  // check for end of dot file\n  if (c === '') {\n    // token is still empty\n    tokenType = TOKENTYPE.DELIMITER;\n    return;\n  }\n\n  // check for delimiters consisting of 2 characters\n  var c2 = c + nextPreview();\n  if (DELIMITERS[c2]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c2;\n    next();\n    next();\n    return;\n  }\n\n  // check for delimiters consisting of 1 character\n  if (DELIMITERS[c]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c;\n    next();\n    return;\n  }\n\n  // check for an identifier (number or string)\n  // TODO: more precise parsing of numbers/strings (and the port separator ':')\n  if (isAlphaNumeric(c) || c === '-') {\n    token += c;\n    next();\n\n    while (isAlphaNumeric(c)) {\n      token += c;\n      next();\n    }\n    if (token === 'false') {\n      token = false; // convert to boolean\n    } else if (token === 'true') {\n      token = true; // convert to boolean\n    } else if (!isNaN(Number(token))) {\n      token = Number(token); // convert to number\n    }\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n\n  // check for a string enclosed by double quotes\n  if (c === '\"') {\n    next();\n    while (c != '' && (c != '\"' || c === '\"' && nextPreview() === '\"')) {\n      if (c === '\"') {\n        // skip the escape character\n        token += c;\n        next();\n      } else if (c === '\\\\' && nextPreview() === 'n') {\n        // Honor a newline escape sequence\n        token += '\\n';\n        next();\n      } else {\n        token += c;\n      }\n      next();\n    }\n    if (c != '\"') {\n      throw newSyntaxError('End of string \" expected');\n    }\n    next();\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n\n  // something unknown is found, wrong characters, a syntax error\n  tokenType = TOKENTYPE.UNKNOWN;\n  while (c != '') {\n    token += c;\n    next();\n  }\n  throw new SyntaxError('Syntax error in part \"' + chop(token, 30) + '\"');\n}\n\n/**\n * Parse a graph.\n * @returns {Object} graph\n */\nfunction parseGraph() {\n  var graph = {};\n\n  first();\n  getToken();\n\n  // optional strict keyword\n  if (token === 'strict') {\n    graph.strict = true;\n    getToken();\n  }\n\n  // graph or digraph keyword\n  if (token === 'graph' || token === 'digraph') {\n    graph.type = token;\n    getToken();\n  }\n\n  // optional graph id\n  if (tokenType === TOKENTYPE.IDENTIFIER) {\n    graph.id = token;\n    getToken();\n  }\n\n  // open angle bracket\n  if (token != '{') {\n    throw newSyntaxError('Angle bracket { expected');\n  }\n  getToken();\n\n  // statements\n  parseStatements(graph);\n\n  // close angle bracket\n  if (token != '}') {\n    throw newSyntaxError('Angle bracket } expected');\n  }\n  getToken();\n\n  // end of file\n  if (token !== '') {\n    throw newSyntaxError('End of file expected');\n  }\n  getToken();\n\n  // remove temporary default options\n  delete graph.node;\n  delete graph.edge;\n  delete graph.graph;\n\n  return graph;\n}\n\n/**\n * Parse a list with statements.\n * @param {Object} graph\n */\nfunction parseStatements(graph) {\n  while (token !== '' && token != '}') {\n    parseStatement(graph);\n    if (token === ';') {\n      getToken();\n    }\n  }\n}\n\n/**\n * Parse a single statement. Can be a an attribute statement, node\n * statement, a series of node statements and edge statements, or a\n * parameter.\n * @param {Object} graph\n */\nfunction parseStatement(graph) {\n  // parse subgraph\n  var subgraph = parseSubgraph(graph);\n  if (subgraph) {\n    // edge statements\n    parseEdge(graph, subgraph);\n\n    return;\n  }\n\n  // parse an attribute statement\n  var attr = parseAttributeStatement(graph);\n  if (attr) {\n    return;\n  }\n\n  // parse node\n  if (tokenType != TOKENTYPE.IDENTIFIER) {\n    throw newSyntaxError('Identifier expected');\n  }\n  var id = token; // id can be a string or a number\n  getToken();\n\n  if (token === '=') {\n    // id statement\n    getToken();\n    if (tokenType != TOKENTYPE.IDENTIFIER) {\n      throw newSyntaxError('Identifier expected');\n    }\n    graph[id] = token;\n    getToken();\n    // TODO: implement comma separated list with \"a_list: ID=ID [','] [a_list] \"\n  } else {\n    parseNodeStatement(graph, id);\n  }\n}\n\n/**\n * Parse a subgraph\n * @param {Object} graph    parent graph object\n * @return {Object | null} subgraph\n */\nfunction parseSubgraph(graph) {\n  var subgraph = null;\n\n  // optional subgraph keyword\n  if (token === 'subgraph') {\n    subgraph = {};\n    subgraph.type = 'subgraph';\n    getToken();\n\n    // optional graph id\n    if (tokenType === TOKENTYPE.IDENTIFIER) {\n      subgraph.id = token;\n      getToken();\n    }\n  }\n\n  // open angle bracket\n  if (token === '{') {\n    getToken();\n\n    if (!subgraph) {\n      subgraph = {};\n    }\n    subgraph.parent = graph;\n    subgraph.node = graph.node;\n    subgraph.edge = graph.edge;\n    subgraph.graph = graph.graph;\n\n    // statements\n    parseStatements(subgraph);\n\n    // close angle bracket\n    if (token != '}') {\n      throw newSyntaxError('Angle bracket } expected');\n    }\n    getToken();\n\n    // remove temporary default options\n    delete subgraph.node;\n    delete subgraph.edge;\n    delete subgraph.graph;\n    delete subgraph.parent;\n\n    // register at the parent graph\n    if (!graph.subgraphs) {\n      graph.subgraphs = [];\n    }\n    graph.subgraphs.push(subgraph);\n  }\n\n  return subgraph;\n}\n\n/**\n * parse an attribute statement like \"node [shape=circle fontSize=16]\".\n * Available keywords are 'node', 'edge', 'graph'.\n * The previous list with default attributes will be replaced\n * @param {Object} graph\n * @returns {String | null} keyword Returns the name of the parsed attribute\n *                                  (node, edge, graph), or null if nothing\n *                                  is parsed.\n */\nfunction parseAttributeStatement(graph) {\n  // attribute statements\n  if (token === 'node') {\n    getToken();\n\n    // node attributes\n    graph.node = parseAttributeList();\n    return 'node';\n  } else if (token === 'edge') {\n    getToken();\n\n    // edge attributes\n    graph.edge = parseAttributeList();\n    return 'edge';\n  } else if (token === 'graph') {\n    getToken();\n\n    // graph attributes\n    graph.graph = parseAttributeList();\n    return 'graph';\n  }\n\n  return null;\n}\n\n/**\n * parse a node statement\n * @param {Object} graph\n * @param {string | number} id\n */\nfunction parseNodeStatement(graph, id) {\n  // node statement\n  var node = {\n    id: id\n  };\n  var attr = parseAttributeList();\n  if (attr) {\n    node.attr = attr;\n  }\n  addNode(graph, node);\n\n  // edge statements\n  parseEdge(graph, id);\n}\n\n/**\n * Parse an edge or a series of edges\n * @param {Object} graph\n * @param {string | number} from        Id of the from node\n */\nfunction parseEdge(graph, from) {\n  while (token === '->' || token === '--') {\n    var to;\n    var type = token;\n    getToken();\n\n    var subgraph = parseSubgraph(graph);\n    if (subgraph) {\n      to = subgraph;\n    } else {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError('Identifier or subgraph expected');\n      }\n      to = token;\n      addNode(graph, {\n        id: to\n      });\n      getToken();\n    }\n\n    // parse edge attributes\n    var attr = parseAttributeList();\n\n    // create edge\n    var edge = createEdge(graph, from, to, type, attr);\n    addEdge(graph, edge);\n\n    from = to;\n  }\n}\n\n/**\n * As explained in [1], graphviz has limitations for combination of\n * arrow[head|tail] and dir. If attribute list includes 'dir',\n * following cases just be supported.\n *   1. both or none + arrowhead, arrowtail\n *   2. forward + arrowhead (arrowtail is not affedted)\n *   3. back + arrowtail (arrowhead is not affected)\n * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note\n *\n * This function is called from parseAttributeList() to parse 'dir'\n * attribute with given 'attr_names' and 'attr_list'.\n * @param {Object} attr_names  Array of attribute names\n * @param {Object} attr_list  Array of objects of attribute set\n * @return {Object} attr_list  Updated attr_list\n */\nfunction parseDirAttribute(attr_names, attr_list) {\n  var i;\n  if (attr_names.includes('dir')) {\n    var idx = {}; // get index of 'arrows' and 'dir'\n    idx.arrows = {};\n    for (i = 0; i < attr_list.length; i++) {\n      if (attr_list[i].name === 'arrows') {\n        if (attr_list[i].value.to != null) {\n          idx.arrows.to = i;\n        } else if (attr_list[i].value.from != null) {\n          idx.arrows.from = i;\n        } else {\n          throw newSyntaxError('Invalid value of arrows');\n        }\n      } else if (attr_list[i].name === 'dir') {\n        idx.dir = i;\n      }\n    }\n\n    // first, add default arrow shape if it is not assigned to avoid error\n    var dir_type = attr_list[idx.dir].value;\n    if (!attr_names.includes('arrows')) {\n      if (dir_type === 'both') {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: 'arrows',\n          value: { to: { enabled: true } }\n        });\n        idx.arrows.to = attr_list.length - 1;\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: 'arrows',\n          value: { from: { enabled: true } }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === 'forward') {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: 'arrows',\n          value: { to: { enabled: true } }\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else if (dir_type === 'back') {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: 'arrows',\n          value: { from: { enabled: true } }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === 'none') {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: 'arrows',\n          value: ''\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else {\n        throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n      }\n    }\n\n    var from_type;\n    var to_type;\n    // update 'arrows' attribute from 'dir'.\n    if (dir_type === 'both') {\n      // both of shapes of 'from' and 'to' are given\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n        };\n        attr_list.splice(idx.arrows.from, 1);\n\n        // shape of 'to' is assigned and use default to 'from'\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = 'arrow';\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n\n          // only shape of 'from' is assigned and use default for 'to'\n        };\n      } else if (idx.arrows.from) {\n        to_type = 'arrow';\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n        };\n      }\n    } else if (dir_type === 'back') {\n      // given both of shapes, but use only 'from'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = '';\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n\n          // given shape of 'to', but does not use it\n        };\n      } else if (idx.arrows.to) {\n        to_type = '';\n        from_type = 'arrow';\n        idx.arrows.from = idx.arrows.to;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n\n          // assign given 'from' shape\n        };\n      } else if (idx.arrows.from) {\n        to_type = '';\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n        };\n      }\n\n      attr_list[idx.arrows.from] = {\n        attr: attr_list[idx.arrows.from].attr,\n        name: attr_list[idx.arrows.from].name,\n        value: {\n          from: {\n            enabled: true,\n            type: attr_list[idx.arrows.from].value.from.type\n          }\n        }\n      };\n    } else if (dir_type === 'none') {\n      var idx_arrow;\n      if (idx.arrows.to) {\n        idx_arrow = idx.arrows.to;\n      } else {\n        idx_arrow = idx.arrows.from;\n      }\n\n      attr_list[idx_arrow] = {\n        attr: attr_list[idx_arrow].attr,\n        name: attr_list[idx_arrow].name,\n        value: ''\n      };\n    } else if (dir_type === 'forward') {\n      // given both of shapes, but use only 'to'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = '';\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n\n          // assign given 'to' shape\n        };\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = '';\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n\n          // given shape of 'from', but does not use it\n        };\n      } else if (idx.arrows.from) {\n        to_type = 'arrow';\n        from_type = '';\n        idx.arrows.to = idx.arrows.from;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: { enabled: true, type: to_type },\n            from: { enabled: true, type: from_type }\n          }\n        };\n      }\n\n      attr_list[idx.arrows.to] = {\n        attr: attr_list[idx.arrows.to].attr,\n        name: attr_list[idx.arrows.to].name,\n        value: {\n          to: {\n            enabled: true,\n            type: attr_list[idx.arrows.to].value.to.type\n          }\n        }\n      };\n    } else {\n      throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n    }\n\n    // remove 'dir' attribute no need anymore\n    attr_list.splice(idx.dir, 1);\n  }\n  return attr_list;\n}\n\n/**\n * Parse a set with attributes,\n * for example [label=\"1.000\", shape=solid]\n * @return {Object | null} attr\n */\nfunction parseAttributeList() {\n  var i;\n  var attr = null;\n\n  // edge styles of dot and vis\n  var edgeStyles = {\n    dashed: true,\n    solid: false,\n    dotted: [1, 5]\n\n    /**\n     * Define arrow types.\n     * vis currently supports types defined in 'arrowTypes'.\n     * Details of arrow shapes are described in\n     * http://www.graphviz.org/content/arrow-shapes\n     */\n  };var arrowTypes = {\n    dot: 'circle',\n    box: 'box',\n    crow: 'crow',\n    curve: 'curve',\n    icurve: 'inv_curve',\n    normal: 'triangle',\n    inv: 'inv_triangle',\n    diamond: 'diamond',\n    tee: 'bar',\n    vee: 'vee'\n\n    /**\n     * 'attr_list' contains attributes for checking if some of them are affected\n     * later. For instance, both of 'arrowhead' and 'dir' (edge style defined\n     * in DOT) make changes to 'arrows' attribute in vis.\n     */\n  };var attr_list = new Array();\n  var attr_names = new Array(); // used for checking the case.\n\n  // parse attributes\n  while (token === '[') {\n    getToken();\n    attr = {};\n    while (token !== '' && token != ']') {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError('Attribute name expected');\n      }\n      var name = token;\n\n      getToken();\n      if (token != '=') {\n        throw newSyntaxError('Equal sign = expected');\n      }\n      getToken();\n\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError('Attribute value expected');\n      }\n      var value = token;\n\n      // convert from dot style to vis\n      if (name === 'style') {\n        value = edgeStyles[value];\n      }\n\n      var arrowType;\n      if (name === 'arrowhead') {\n        arrowType = arrowTypes[value];\n        name = 'arrows';\n        value = { to: { enabled: true, type: arrowType } };\n      }\n\n      if (name === 'arrowtail') {\n        arrowType = arrowTypes[value];\n        name = 'arrows';\n        value = { from: { enabled: true, type: arrowType } };\n      }\n\n      attr_list.push({ attr: attr, name: name, value: value });\n      attr_names.push(name);\n\n      getToken();\n      if (token == ',') {\n        getToken();\n      }\n    }\n\n    if (token != ']') {\n      throw newSyntaxError('Bracket ] expected');\n    }\n    getToken();\n  }\n\n  attr_list = parseDirAttribute(attr_names, attr_list);\n\n  // parse 'penwidth'\n  var nof_attr_list;\n  if (attr_names.includes('penwidth')) {\n    var tmp_attr_list = [];\n\n    nof_attr_list = attr_list.length;\n    for (i = 0; i < nof_attr_list; i++) {\n      // exclude 'width' from attr_list if 'penwidth' exists\n      if (attr_list[i].name !== 'width') {\n        if (attr_list[i].name === 'penwidth') {\n          attr_list[i].name = 'width';\n        }\n        tmp_attr_list.push(attr_list[i]);\n      }\n    }\n    attr_list = tmp_attr_list;\n  }\n\n  nof_attr_list = attr_list.length;\n  for (i = 0; i < nof_attr_list; i++) {\n    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);\n  }\n\n  return attr;\n}\n\n/**\n * Create a syntax error with extra information on current token and index.\n * @param {string} message\n * @returns {SyntaxError} err\n */\nfunction newSyntaxError(message) {\n  return new SyntaxError(message + ', got \"' + chop(token, 30) + '\" (char ' + index + ')');\n}\n\n/**\n * Chop off text after a maximum length\n * @param {string} text\n * @param {number} maxLength\n * @returns {String}\n */\nfunction chop(text, maxLength) {\n  return text.length <= maxLength ? text : text.substr(0, 27) + '...';\n}\n\n/**\n * Execute a function fn for each pair of elements in two arrays\n * @param {Array | *} array1\n * @param {Array | *} array2\n * @param {function} fn\n */\nfunction forEach2(array1, array2, fn) {\n  if (Array.isArray(array1)) {\n    array1.forEach(function (elem1) {\n      if (Array.isArray(array2)) {\n        array2.forEach(function (elem2) {\n          fn(elem1, elem2);\n        });\n      } else {\n        fn(elem1, array2);\n      }\n    });\n  } else {\n    if (Array.isArray(array2)) {\n      array2.forEach(function (elem2) {\n        fn(array1, elem2);\n      });\n    } else {\n      fn(array1, array2);\n    }\n  }\n}\n\n/**\n * Set a nested property on an object\n * When nested objects are missing, they will be created.\n * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}\n * @param {Object} object\n * @param {string} path   A dot separated string like 'font.color'\n * @param {*} value       Value for the property\n * @return {Object} Returns the original object, allows for chaining.\n */\nfunction setProp(object, path, value) {\n  var names = path.split('.');\n  var prop = names.pop();\n\n  // traverse over the nested objects\n  var obj = object;\n  for (var i = 0; i < names.length; i++) {\n    var name = names[i];\n    if (!(name in obj)) {\n      obj[name] = {};\n    }\n    obj = obj[name];\n  }\n\n  // set the property value\n  obj[prop] = value;\n\n  return object;\n}\n\n/**\n * Convert an object with DOT attributes to their vis.js equivalents.\n * @param {Object} attr     Object with DOT attributes\n * @param {Object} mapping\n * @return {Object}         Returns an object with vis.js attributes\n */\nfunction convertAttr(attr, mapping) {\n  var converted = {};\n\n  for (var prop in attr) {\n    if (attr.hasOwnProperty(prop)) {\n      var visProp = mapping[prop];\n      if (Array.isArray(visProp)) {\n        visProp.forEach(function (visPropI) {\n          setProp(converted, visPropI, attr[prop]);\n        });\n      } else if (typeof visProp === 'string') {\n        setProp(converted, visProp, attr[prop]);\n      } else {\n        setProp(converted, prop, attr[prop]);\n      }\n    }\n  }\n\n  return converted;\n}\n\n/**\n * Convert a string containing a graph in DOT language into a map containing\n * with nodes and edges in the format of graph.\n * @param {string} data         Text containing a graph in DOT-notation\n * @return {Object} graphData\n */\nfunction DOTToGraph(data) {\n  // parse the DOT file\n  var dotData = parseDOT(data);\n  var graphData = {\n    nodes: [],\n    edges: [],\n    options: {}\n\n    // copy the nodes\n  };if (dotData.nodes) {\n    dotData.nodes.forEach(function (dotNode) {\n      var graphNode = {\n        id: dotNode.id,\n        label: String(dotNode.label || dotNode.id)\n      };\n      merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));\n      if (graphNode.image) {\n        graphNode.shape = 'image';\n      }\n      graphData.nodes.push(graphNode);\n    });\n  }\n\n  // copy the edges\n  if (dotData.edges) {\n    /**\n     * Convert an edge in DOT format to an edge with VisGraph format\n     * @param {Object} dotEdge\n     * @returns {Object} graphEdge\n     */\n    var convertEdge = function convertEdge(dotEdge) {\n      var graphEdge = {\n        from: dotEdge.from,\n        to: dotEdge.to\n      };\n      merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));\n\n      // Add arrows attribute to default styled arrow.\n      // The reason why default style is not added in parseAttributeList() is\n      // because only default is cleared before here.\n      if (graphEdge.arrows == null && dotEdge.type === '->') {\n        graphEdge.arrows = 'to';\n      }\n\n      return graphEdge;\n    };\n\n    dotData.edges.forEach(function (dotEdge) {\n      var from, to;\n      if (dotEdge.from instanceof Object) {\n        from = dotEdge.from.nodes;\n      } else {\n        from = {\n          id: dotEdge.from\n        };\n      }\n\n      if (dotEdge.to instanceof Object) {\n        to = dotEdge.to.nodes;\n      } else {\n        to = {\n          id: dotEdge.to\n        };\n      }\n\n      if (dotEdge.from instanceof Object && dotEdge.from.edges) {\n        dotEdge.from.edges.forEach(function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n\n      forEach2(from, to, function (from, to) {\n        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);\n        var graphEdge = convertEdge(subEdge);\n        graphData.edges.push(graphEdge);\n      });\n\n      if (dotEdge.to instanceof Object && dotEdge.to.edges) {\n        dotEdge.to.edges.forEach(function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n    });\n  }\n\n  // copy the options\n  if (dotData.attr) {\n    graphData.options = dotData.attr;\n  }\n\n  return graphData;\n}\n\n// exports\nexports.parseDOT = parseDOT;\nexports.DOTToGraph = DOTToGraph;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n *\n * @param {json} gephiJSON\n * @param {obj} optionsObj\n * @returns {{nodes: Array, edges: Array}}\n */\nfunction parseGephi(gephiJSON, optionsObj) {\n  var edges = [];\n  var nodes = [];\n  var options = {\n    edges: {\n      inheritColor: false\n    },\n    nodes: {\n      fixed: false,\n      parseColor: false\n    }\n  };\n\n  if (optionsObj !== undefined) {\n    if (optionsObj.fixed !== undefined) {\n      options.nodes.fixed = optionsObj.fixed;\n    }\n    if (optionsObj.parseColor !== undefined) {\n      options.nodes.parseColor = optionsObj.parseColor;\n    }\n    if (optionsObj.inheritColor !== undefined) {\n      options.edges.inheritColor = optionsObj.inheritColor;\n    }\n  }\n\n  var gEdges = gephiJSON.edges;\n  var gNodes = gephiJSON.nodes;\n  for (var i = 0; i < gEdges.length; i++) {\n    var edge = {};\n    var gEdge = gEdges[i];\n    edge['id'] = gEdge.id;\n    edge['from'] = gEdge.source;\n    edge['to'] = gEdge.target;\n    edge['attributes'] = gEdge.attributes;\n    edge['label'] = gEdge.label;\n    edge['title'] = gEdge.attributes !== undefined ? gEdge.attributes.title : undefined;\n    if (gEdge['type'] === 'Directed') {\n      edge['arrows'] = 'to';\n    }\n    //    edge['value'] = gEdge.attributes !== undefined ? gEdge.attributes.Weight : undefined;\n    //    edge['width'] = edge['value'] !== undefined ? undefined : edgegEdge.size;\n    if (gEdge.color && options.inheritColor === false) {\n      edge['color'] = gEdge.color;\n    }\n    edges.push(edge);\n  }\n\n  for (var j = 0; j < gNodes.length; j++) {\n    var node = {};\n    var gNode = gNodes[j];\n    node['id'] = gNode.id;\n    node['attributes'] = gNode.attributes;\n    node['x'] = gNode.x;\n    node['y'] = gNode.y;\n    node['label'] = gNode.label;\n    node['title'] = gNode.attributes !== undefined ? gNode.attributes.title : gNode.title;\n    if (options.nodes.parseColor === true) {\n      node['color'] = gNode.color;\n    } else {\n      node['color'] = gNode.color !== undefined ? {\n        background: gNode.color,\n        border: gNode.color,\n        highlight: { background: gNode.color, border: gNode.color },\n        hover: { background: gNode.color, border: gNode.color }\n      } : undefined;\n    }\n    node['size'] = gNode.size;\n    node['fixed'] = options.nodes.fixed && gNode.x !== undefined && gNode.y !== undefined;\n    nodes.push(node);\n  }\n\n  return { nodes: nodes, edges: edges };\n}\n\nexports.parseGephi = parseGephi;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __nested_webpack_require_271567__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_271567__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_271567__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _CachedImage = __nested_webpack_require_271567__(133);\n\nvar _CachedImage2 = _interopRequireDefault(_CachedImage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * This callback is a callback that accepts an Image.\n * @callback ImageCallback\n * @param {Image} image\n */\n\n/**\n * This class loads images and keeps them stored.\n *\n * @param {ImageCallback} callback\n */\nvar Images = function () {\n  /**\n   * @param {ImageCallback} callback\n   */\n  function Images(callback) {\n    (0, _classCallCheck3['default'])(this, Images);\n\n    this.images = {};\n    this.imageBroken = {};\n    this.callback = callback;\n  }\n\n  /**\n   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image\n   * @param {string} brokenUrl                Url the broken image to try and load\n   * @param {Image} imageToLoadBrokenUrlOn   The image object\n   */\n\n\n  (0, _createClass3['default'])(Images, [{\n    key: '_tryloadBrokenUrl',\n    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {\n      //If these parameters aren't specified then exit the function because nothing constructive can be done\n      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;\n      if (brokenUrl === undefined) {\n        console.warn('No broken url image defined');\n        return;\n      }\n\n      //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl\n      imageToLoadBrokenUrlOn.onerror = function () {\n        console.error('Could not load brokenImage:', brokenUrl);\n        // cache item will contain empty image, this should be OK for default\n      };\n\n      //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image\n      imageToLoadBrokenUrlOn.image.src = brokenUrl;\n    }\n\n    /**\n     *\n     * @param {vis.Image} imageToRedrawWith\n     * @private\n     */\n\n  }, {\n    key: '_redrawWithImage',\n    value: function _redrawWithImage(imageToRedrawWith) {\n      if (this.callback) {\n        this.callback(imageToRedrawWith);\n      }\n    }\n\n    /**\n     * @param {string} url          Url of the image\n     * @param {string} brokenUrl    Url of an image to use if the url image is not found\n     * @return {Image} img          The image object\n     */\n\n  }, {\n    key: 'load',\n    value: function load(url, brokenUrl) {\n      var _this = this;\n\n      //Try and get the image from the cache, if successful then return the cached image\n      var cachedImage = this.images[url];\n      if (cachedImage) return cachedImage;\n\n      //Create a new image\n      var img = new _CachedImage2['default']();\n\n      // Need to add to cache here, otherwise final return will spawn different copies of the same image,\n      // Also, there will be multiple loads of the same image.\n      this.images[url] = img;\n\n      //Subscribe to the event that is raised if the image loads successfully\n      img.image.onload = function () {\n        // Properly init the cached item and then request a redraw\n        _this._fixImageCoordinates(img.image);\n        img.init();\n        _this._redrawWithImage(img);\n      };\n\n      //Subscribe to the event that is raised if the image fails to load\n      img.image.onerror = function () {\n        console.error('Could not load image:', url);\n        //Try and load the image specified by the brokenUrl using\n        _this._tryloadBrokenUrl(url, brokenUrl, img);\n      };\n\n      //Set the source of the image to the url, this is what actually kicks off the loading of the image\n      img.image.src = url;\n\n      //Return the new image\n      return img;\n    }\n\n    /**\n     * IE11 fix -- thanks dponch!\n     *\n     * Local helper function\n     * @param {vis.Image} imageToCache\n     * @private\n     */\n\n  }, {\n    key: '_fixImageCoordinates',\n    value: function _fixImageCoordinates(imageToCache) {\n      if (imageToCache.width === 0) {\n        document.body.appendChild(imageToCache);\n        imageToCache.width = imageToCache.offsetWidth;\n        imageToCache.height = imageToCache.offsetHeight;\n        document.body.removeChild(imageToCache);\n      }\n    }\n  }]);\n  return Images;\n}();\n\nexports['default'] = Images;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __nested_webpack_require_276340__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = __nested_webpack_require_276340__(15);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _typeof2 = __nested_webpack_require_276340__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _classCallCheck2 = __nested_webpack_require_276340__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_276340__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_276340__(2);\nvar ComponentUtil = __nested_webpack_require_276340__(35)['default'];\nvar LabelSplitter = __nested_webpack_require_276340__(139)['default'];\n\n/**\n * List of special styles for multi-fonts\n * @private\n */\nvar multiFontStyle = ['bold', 'ital', 'boldital', 'mono'];\n\n/**\n * A Label to be used for Nodes or Edges.\n */\n\nvar Label = function () {\n  /**\n   * @param {Object} body\n   * @param {Object} options\n   * @param {boolean} [edgelabel=false]\n   */\n  function Label(body, options) {\n    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    (0, _classCallCheck3['default'])(this, Label);\n\n    this.body = body;\n    this.pointToSelf = false;\n    this.baseSize = undefined;\n    this.fontOptions = {}; // instance variable containing the *instance-local* font options\n    this.setOptions(options);\n    this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 };\n    this.isEdgeLabel = edgelabel;\n  }\n\n  /**\n   * @param {Object} options the options of the parent Node-instance\n   */\n\n\n  (0, _createClass3['default'])(Label, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      this.elementOptions = options; // Reference to the options of the parent Node-instance\n\n      this.initFontOptions(options.font);\n\n      if (ComponentUtil.isValidLabel(options.label)) {\n        this.labelDirty = true;\n      } else {\n        // Bad label! Change the option value to prevent bad stuff happening\n        options.label = '';\n      }\n\n      if (options.font !== undefined && options.font !== null) {\n        // font options can be deleted at various levels\n        if (typeof options.font === 'string') {\n          this.baseSize = this.fontOptions.size;\n        } else if ((0, _typeof3['default'])(options.font) === 'object') {\n          var size = options.font.size;\n\n          if (size !== undefined) {\n            this.baseSize = size;\n          }\n        }\n      }\n    }\n\n    /**\n     * Init the font Options structure.\n     *\n     * Member fontOptions serves as an accumulator for the current font options.\n     * As such, it needs to be completely separated from the node options.\n     *\n     * @param {Object} newFontOptions the new font options to process\n     * @private\n     */\n\n  }, {\n    key: 'initFontOptions',\n    value: function initFontOptions(newFontOptions) {\n      var _this = this;\n\n      // Prepare the multi-font option objects.\n      // These will be filled in propagateFonts(), if required\n      util.forEach(multiFontStyle, function (style) {\n        _this.fontOptions[style] = {};\n      });\n\n      // Handle shorthand option, if present\n      if (Label.parseFontString(this.fontOptions, newFontOptions)) {\n        this.fontOptions.vadjust = 0;\n        return;\n      }\n\n      // Copy over the non-multifont options, if specified\n      util.forEach(newFontOptions, function (prop, n) {\n        if (prop !== undefined && prop !== null && (typeof prop === 'undefined' ? 'undefined' : (0, _typeof3['default'])(prop)) !== 'object') {\n          _this.fontOptions[n] = prop;\n        }\n      });\n    }\n\n    /**\n     * If in-variable is a string, parse it as a font specifier.\n     *\n     * Note that following is not done here and have to be done after the call:\n     * - No number conversion (size)\n     * - Not all font options are set (vadjust, mod)\n     *\n     * @param {Object} outOptions  out-parameter, object in which to store the parse results (if any)\n     * @param {Object} inOptions  font options to parse\n     * @return {boolean} true if font parsed as string, false otherwise\n     * @static\n     */\n\n  }, {\n    key: 'constrain',\n\n\n    /**\n     * Set the width and height constraints based on 'nearest' value\n     *\n     * @param {Array} pile array of option objects to consider\n     * @returns {object} the actual constraint values to use\n     * @private\n     */\n    value: function constrain(pile) {\n      // NOTE: constrainWidth and  constrainHeight never set!\n      // NOTE: for edge labels, only 'maxWdt' set\n      // Node labels can set all the fields\n      var fontOptions = {\n        constrainWidth: false,\n        maxWdt: -1,\n        minWdt: -1,\n        constrainHeight: false,\n        minHgt: -1,\n        valign: 'middle'\n      };\n\n      var widthConstraint = util.topMost(pile, 'widthConstraint');\n      if (typeof widthConstraint === 'number') {\n        fontOptions.maxWdt = Number(widthConstraint);\n        fontOptions.minWdt = Number(widthConstraint);\n      } else if ((typeof widthConstraint === 'undefined' ? 'undefined' : (0, _typeof3['default'])(widthConstraint)) === 'object') {\n        var widthConstraintMaximum = util.topMost(pile, ['widthConstraint', 'maximum']);\n        if (typeof widthConstraintMaximum === 'number') {\n          fontOptions.maxWdt = Number(widthConstraintMaximum);\n        }\n        var widthConstraintMinimum = util.topMost(pile, ['widthConstraint', 'minimum']);\n        if (typeof widthConstraintMinimum === 'number') {\n          fontOptions.minWdt = Number(widthConstraintMinimum);\n        }\n      }\n\n      var heightConstraint = util.topMost(pile, 'heightConstraint');\n      if (typeof heightConstraint === 'number') {\n        fontOptions.minHgt = Number(heightConstraint);\n      } else if ((typeof heightConstraint === 'undefined' ? 'undefined' : (0, _typeof3['default'])(heightConstraint)) === 'object') {\n        var heightConstraintMinimum = util.topMost(pile, ['heightConstraint', 'minimum']);\n        if (typeof heightConstraintMinimum === 'number') {\n          fontOptions.minHgt = Number(heightConstraintMinimum);\n        }\n        var heightConstraintValign = util.topMost(pile, ['heightConstraint', 'valign']);\n        if (typeof heightConstraintValign === 'string') {\n          if (heightConstraintValign === 'top' || heightConstraintValign === 'bottom') {\n            fontOptions.valign = heightConstraintValign;\n          }\n        }\n      }\n\n      return fontOptions;\n    }\n\n    /**\n     * Set options and update internal state\n     *\n     * @param {Object} options  options to set\n     * @param {Array}  pile     array of option objects to consider for option 'chosen'\n     */\n\n  }, {\n    key: 'update',\n    value: function update(options, pile) {\n      this.setOptions(options, true);\n      this.propagateFonts(pile);\n      util.deepExtend(this.fontOptions, this.constrain(pile));\n      this.fontOptions.chooser = ComponentUtil.choosify('label', pile);\n    }\n\n    /**\n     * When margins are set in an element, adjust sizes is called to remove them\n     * from the width/height constraints. This must be done prior to label sizing.\n     *\n     * @param {{top: number, right: number, bottom: number, left: number}} margins\n     */\n\n  }, {\n    key: 'adjustSizes',\n    value: function adjustSizes(margins) {\n      var widthBias = margins ? margins.right + margins.left : 0;\n      if (this.fontOptions.constrainWidth) {\n        this.fontOptions.maxWdt -= widthBias;\n        this.fontOptions.minWdt -= widthBias;\n      }\n      var heightBias = margins ? margins.top + margins.bottom : 0;\n      if (this.fontOptions.constrainHeight) {\n        this.fontOptions.minHgt -= heightBias;\n      }\n    }\n\n    /////////////////////////////////////////////////////////\n    // Methods for handling options piles\n    // Eventually, these will be moved to a separate class\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Add the font members of the passed list of option objects to the pile.\n     *\n     * @param {Pile} dstPile  pile of option objects add to\n     * @param {Pile} srcPile  pile of option objects to take font options from\n     * @private\n     */\n\n  }, {\n    key: 'addFontOptionsToPile',\n    value: function addFontOptionsToPile(dstPile, srcPile) {\n      for (var i = 0; i < srcPile.length; ++i) {\n        this.addFontToPile(dstPile, srcPile[i]);\n      }\n    }\n\n    /**\n     * Add given font option object to the list of objects (the 'pile') to consider for determining\n     * multi-font option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {object} options  instance to add to pile\n     * @private\n     */\n\n  }, {\n    key: 'addFontToPile',\n    value: function addFontToPile(pile, options) {\n      if (options === undefined) return;\n      if (options.font === undefined || options.font === null) return;\n\n      var item = options.font;\n      pile.push(item);\n    }\n\n    /**\n     * Collect all own-property values from the font pile that aren't multi-font option objectss.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @returns {object} object with all current own basic font properties\n     * @private\n     */\n\n  }, {\n    key: 'getBasicOptions',\n    value: function getBasicOptions(pile) {\n      var ret = {};\n\n      // Scans the whole pile to get all options present\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n\n        // Convert shorthand if necessary\n        var tmpShorthand = {};\n        if (Label.parseFontString(tmpShorthand, fontOptions)) {\n          fontOptions = tmpShorthand;\n        }\n\n        util.forEach(fontOptions, function (opt, name) {\n          if (opt === undefined) return; // multi-font option need not be present\n          if (ret.hasOwnProperty(name)) return; // Keep first value we encounter\n\n          if (multiFontStyle.indexOf(name) !== -1) {\n            // Skip multi-font properties but we do need the structure\n            ret[name] = {};\n          } else {\n            ret[name] = opt;\n          }\n        });\n      }\n\n      return ret;\n    }\n\n    /**\n     * Return the value for given option for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * ---------------------------------------------------------------------\n     * ## Traversal of pile for multi-fonts\n     *\n     * The determination of multi-font option values is a special case, because any values not\n     * present in the multi-font options should by definition be taken from the main font options,\n     * i.e. from the current 'parent' object of the multi-font option.\n     *\n     * ### Search order for multi-fonts\n     *\n     * 'bold' used as example:\n     *\n     *   - search in option group 'bold' in local properties\n     *   - search in main font option group in local properties\n     *\n     * ---------------------------------------------------------------------\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the multi-font\n     * @param {string} option  the option to search for, for the given multi-font\n     * @returns {string|number} the value for the given option\n     * @private\n     */\n\n  }, {\n    key: 'getFontOption',\n    value: function getFontOption(pile, multiName, option) {\n      var multiFont = void 0;\n\n      // Search multi font in local properties\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n\n        if (fontOptions.hasOwnProperty(multiName)) {\n          multiFont = fontOptions[multiName];\n          if (multiFont === undefined || multiFont === null) continue;\n\n          // Convert shorthand if necessary\n          // TODO: inefficient to do this conversion every time; find a better way.\n          var tmpShorthand = {};\n          if (Label.parseFontString(tmpShorthand, multiFont)) {\n            multiFont = tmpShorthand;\n          }\n\n          if (multiFont.hasOwnProperty(option)) {\n            return multiFont[option];\n          }\n        }\n      }\n\n      // Option is not mentioned in the multi font options; take it from the parent font options.\n      // These have already been converted with getBasicOptions(), so use the converted values.\n      if (this.fontOptions.hasOwnProperty(option)) {\n        return this.fontOptions[option];\n      }\n\n      // A value **must** be found; you should never get here.\n      throw new Error(\"Did not find value for multi-font for property: '\" + option + \"'\");\n    }\n\n    /**\n     * Return all options values for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the mod-font\n     * @returns {MultiFontOptions}\n     * @private\n     */\n\n  }, {\n    key: 'getFontOptions',\n    value: function getFontOptions(pile, multiName) {\n      var result = {};\n      var optionNames = ['color', 'size', 'face', 'mod', 'vadjust']; // List of allowed options per multi-font\n\n      for (var i = 0; i < optionNames.length; ++i) {\n        var mod = optionNames[i];\n        result[mod] = this.getFontOption(pile, multiName, mod);\n      }\n\n      return result;\n    }\n\n    /////////////////////////////////////////////////////////\n    // End methods for handling options piles\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Collapse the font options for the multi-font to single objects, from\n     * the chain of option objects passed (the 'pile').\n     *\n     * @param {Pile} pile  sequence of option objects to consider.\n     *                     First item in list assumed to be the newly set options.\n     */\n\n  }, {\n    key: 'propagateFonts',\n    value: function propagateFonts(pile) {\n      var _this2 = this;\n\n      var fontPile = []; // sequence of font objects to consider, order important\n\n      // Note that this.elementOptions is not used here.\n      this.addFontOptionsToPile(fontPile, pile);\n      this.fontOptions = this.getBasicOptions(fontPile);\n\n      // We set multifont values even if multi === false, for consistency (things break otherwise)\n\n      var _loop = function _loop(i) {\n        var mod = multiFontStyle[i];\n        var modOptions = _this2.fontOptions[mod];\n        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);\n\n        // Copy over found values\n        util.forEach(tmpMultiFontOptions, function (option, n) {\n          modOptions[n] = option;\n        });\n\n        modOptions.size = Number(modOptions.size);\n        modOptions.vadjust = Number(modOptions.vadjust);\n      };\n\n      for (var i = 0; i < multiFontStyle.length; ++i) {\n        _loop(i);\n      }\n    }\n\n    /**\n     * Main function. This is called from anything that wants to draw a label.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} [baseline='middle']\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover) {\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'middle';\n\n      // if no label, return\n      if (this.elementOptions.label === undefined) return;\n\n      // check if we have to render the label\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return;\n\n      // This ensures that there will not be HUGE letters on screen\n      // by setting an upper limit on the visible text size (regardless of zoomLevel)\n      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {\n        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;\n      }\n\n      // update the size cache if required\n      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);\n      this._drawBackground(ctx);\n      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);\n    }\n\n    /**\n     * Draws the label background\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n\n  }, {\n    key: '_drawBackground',\n    value: function _drawBackground(ctx) {\n      if (this.fontOptions.background !== undefined && this.fontOptions.background !== 'none') {\n        ctx.fillStyle = this.fontOptions.background;\n        var size = this.getSize();\n        ctx.fillRect(size.left, size.top, size.width, size.height);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} [baseline='middle']\n     * @param {number} viewFontSize\n     * @private\n     */\n\n  }, {\n    key: '_drawText',\n    value: function _drawText(ctx, x, y) {\n      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'middle';\n      var viewFontSize = arguments[4];\n\n      ;\n      var _setAlignment2 = this._setAlignment(ctx, x, y, baseline);\n\n      var _setAlignment3 = (0, _slicedToArray3['default'])(_setAlignment2, 2);\n\n      x = _setAlignment3[0];\n      y = _setAlignment3[1];\n\n\n      ctx.textAlign = 'left';\n      x = x - this.size.width / 2; // Shift label 1/2-distance to the left\n      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {\n        if (this.fontOptions.valign === 'top') {\n          y -= (this.size.height - this.size.labelHeight) / 2;\n        }\n        if (this.fontOptions.valign === 'bottom') {\n          y += (this.size.height - this.size.labelHeight) / 2;\n        }\n      }\n\n      // draw the text\n      for (var i = 0; i < this.lineCount; i++) {\n        var line = this.lines[i];\n        if (line && line.blocks) {\n          var width = 0;\n          if (this.isEdgeLabel || this.fontOptions.align === 'center') {\n            width += (this.size.width - line.width) / 2;\n          } else if (this.fontOptions.align === 'right') {\n            width += this.size.width - line.width;\n          }\n          for (var j = 0; j < line.blocks.length; j++) {\n            var block = line.blocks[j];\n            ctx.font = block.font;\n\n            var _getColor2 = this._getColor(block.color, viewFontSize, block.strokeColor),\n                _getColor3 = (0, _slicedToArray3['default'])(_getColor2, 2),\n                fontColor = _getColor3[0],\n                strokeColor = _getColor3[1];\n\n            if (block.strokeWidth > 0) {\n              ctx.lineWidth = block.strokeWidth;\n              ctx.strokeStyle = strokeColor;\n              ctx.lineJoin = 'round';\n            }\n            ctx.fillStyle = fontColor;\n\n            if (block.strokeWidth > 0) {\n              ctx.strokeText(block.text, x + width, y + block.vadjust);\n            }\n            ctx.fillText(block.text, x + width, y + block.vadjust);\n            width += block.width;\n          }\n          y += line.height;\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} baseline\n     * @returns {Array.<number>}\n     * @private\n     */\n\n  }, {\n    key: '_setAlignment',\n    value: function _setAlignment(ctx, x, y, baseline) {\n      // check for label alignment (for edges)\n      // TODO: make alignment for nodes\n      if (this.isEdgeLabel && this.fontOptions.align !== 'horizontal' && this.pointToSelf === false) {\n        x = 0;\n        y = 0;\n\n        var lineMargin = 2;\n        if (this.fontOptions.align === 'top') {\n          ctx.textBaseline = 'alphabetic';\n          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers\n        } else if (this.fontOptions.align === 'bottom') {\n          ctx.textBaseline = 'hanging';\n          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers\n        } else {\n          ctx.textBaseline = 'middle';\n        }\n      } else {\n        ctx.textBaseline = baseline;\n      }\n      return [x, y];\n    }\n\n    /**\n     * fade in when relative scale is between threshold and threshold - 1.\n     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.\n     *\n     * @param {string} color  The font color to use\n     * @param {number} viewFontSize\n     * @param {string} initialStrokeColor\n     * @returns {Array.<string>} An array containing the font color and stroke color\n     * @private\n     */\n\n  }, {\n    key: '_getColor',\n    value: function _getColor(color, viewFontSize, initialStrokeColor) {\n      var fontColor = color || '#000000';\n      var strokeColor = initialStrokeColor || '#ffffff';\n      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {\n        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));\n        fontColor = util.overrideOpacity(fontColor, opacity);\n        strokeColor = util.overrideOpacity(strokeColor, opacity);\n      }\n      return [fontColor, strokeColor];\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {{width: number, height: number}}\n     */\n\n  }, {\n    key: 'getTextSize',\n    value: function getTextSize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      this._processLabel(ctx, selected, hover);\n      return {\n        width: this.size.width,\n        height: this.size.height,\n        lineCount: this.lineCount\n      };\n    }\n\n    /**\n     * Get the current dimensions of the label\n     *\n     * @return {rect}\n     */\n\n  }, {\n    key: 'getSize',\n    value: function getSize() {\n      var lineMargin = 2;\n      var x = this.size.left; // default values which might be overridden below\n      var y = this.size.top - 0.5 * lineMargin; // idem\n\n      if (this.isEdgeLabel) {\n        var x2 = -this.size.width * 0.5;\n\n        switch (this.fontOptions.align) {\n          case 'middle':\n            x = x2;\n            y = -this.size.height * 0.5;\n            break;\n          case 'top':\n            x = x2;\n            y = -(this.size.height + lineMargin);\n            break;\n          case 'bottom':\n            x = x2;\n            y = lineMargin;\n            break;\n        }\n      }\n\n      var ret = {\n        left: x,\n        top: y,\n        width: this.size.width,\n        height: this.size.height\n      };\n\n      return ret;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {'middle'|'hanging'} [baseline='middle']\n     */\n\n  }, {\n    key: 'calculateLabelSize',\n    value: function calculateLabelSize(ctx, selected, hover) {\n      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'middle';\n\n      this._processLabel(ctx, selected, hover);\n      this.size.left = x - this.size.width * 0.5;\n      this.size.top = y - this.size.height * 0.5;\n      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;\n      if (baseline === 'hanging') {\n        this.size.top += 0.5 * this.fontOptions.size;\n        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers\n        this.size.yLine += 4; // distance from node\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} mod\n     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}\n     */\n\n  }, {\n    key: 'getFormattingValues',\n    value: function getFormattingValues(ctx, selected, hover, mod) {\n      var getValue = function getValue(fontOptions, mod, option) {\n        if (mod === 'normal') {\n          if (option === 'mod') return '';\n          return fontOptions[option];\n        }\n\n        if (fontOptions[mod][option] !== undefined) {\n          // Grumbl leaving out test on undefined equals false for \"\"\n          return fontOptions[mod][option];\n        } else {\n          // Take from parent font option\n          return fontOptions[option];\n        }\n      };\n\n      var values = {\n        color: getValue(this.fontOptions, mod, 'color'),\n        size: getValue(this.fontOptions, mod, 'size'),\n        face: getValue(this.fontOptions, mod, 'face'),\n        mod: getValue(this.fontOptions, mod, 'mod'),\n        vadjust: getValue(this.fontOptions, mod, 'vadjust'),\n        strokeWidth: this.fontOptions.strokeWidth,\n        strokeColor: this.fontOptions.strokeColor\n      };\n      if (selected || hover) {\n        if (mod === 'normal' && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {\n          values.mod = 'bold';\n        } else {\n          if (typeof this.fontOptions.chooser === 'function') {\n            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);\n          }\n        }\n      }\n\n      var fontString = '';\n      if (values.mod !== undefined && values.mod !== '') {\n        // safeguard for undefined - this happened\n        fontString += values.mod + ' ';\n      }\n      fontString += values.size + 'px ' + values.face;\n\n      ctx.font = fontString.replace(/\"/g, '');\n      values.font = ctx.font;\n      values.height = values.size;\n      return values;\n    }\n\n    /**\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'differentState',\n    value: function differentState(selected, hover) {\n      return selected !== this.selectedState || hover !== this.hoverState;\n    }\n\n    /**\n     * This explodes the passed text into lines and determines the width, height and number of lines.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} inText  the text to explode\n     * @returns {{width, height, lines}|*}\n     * @private\n     */\n\n  }, {\n    key: '_processLabelText',\n    value: function _processLabelText(ctx, selected, hover, inText) {\n      var splitter = new LabelSplitter(ctx, this, selected, hover);\n      return splitter.process(inText);\n    }\n\n    /**\n     * This explodes the label string into lines and sets the width, height and number of lines.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n\n  }, {\n    key: '_processLabel',\n    value: function _processLabel(ctx, selected, hover) {\n      if (this.labelDirty === false && !this.differentState(selected, hover)) return;\n\n      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);\n\n      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {\n        state.width = this.fontOptions.minWdt;\n      }\n\n      this.size.labelHeight = state.height;\n      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {\n        state.height = this.fontOptions.minHgt;\n      }\n\n      this.lines = state.lines;\n      this.lineCount = state.lines.length;\n      this.size.width = state.width;\n      this.size.height = state.height;\n      this.selectedState = selected;\n      this.hoverState = hover;\n\n      this.labelDirty = false;\n    }\n\n    /**\n     * Check if this label is visible\n     *\n     * @return {boolean} true if this label will be show, false otherwise\n     */\n\n  }, {\n    key: 'visible',\n    value: function visible() {\n      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {\n        return false; // nothing to display\n      }\n\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {\n        return false; // Too small or too far away to show\n      }\n\n      return true;\n    }\n  }], [{\n    key: 'parseFontString',\n    value: function parseFontString(outOptions, inOptions) {\n      if (!inOptions || typeof inOptions !== 'string') return false;\n\n      var newOptionsArray = inOptions.split(' ');\n\n      outOptions.size = newOptionsArray[0].replace('px', '');\n      outOptions.face = newOptionsArray[1];\n      outOptions.color = newOptionsArray[2];\n\n      return true;\n    }\n  }]);\n  return Label;\n}();\n\nexports['default'] = Label;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __nested_webpack_require_305424__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_305424__(141), __esModule: true };\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __nested_webpack_require_305577__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = __nested_webpack_require_305577__(15);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _classCallCheck2 = __nested_webpack_require_305577__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_305577__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_305577__(2);\nvar EndPoints = __nested_webpack_require_305577__(80)['default'];\n\n/**\n * The Base Class for all edges.\n *\n */\n\nvar EdgeBase = function () {\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function EdgeBase(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, EdgeBase);\n\n    this.body = body;\n    this.labelModule = labelModule;\n    this.options = {};\n    this.setOptions(options);\n    this.colorDirty = true;\n    this.color = {};\n    this.selectionWidth = 2;\n    this.hoverWidth = 1.5;\n    this.fromPoint = this.from;\n    this.toPoint = this.to;\n  }\n\n  /**\n   * Connects a node to itself\n   */\n\n\n  (0, _createClass3['default'])(EdgeBase, [{\n    key: 'connect',\n    value: function connect() {\n      this.from = this.body.nodes[this.options.from];\n      this.to = this.body.nodes[this.options.to];\n    }\n\n    /**\n     *\n     * @returns {boolean} always false\n     */\n\n  }, {\n    key: 'cleanup',\n    value: function cleanup() {\n      return false;\n    }\n\n    /**\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      this.options = options;\n      this.from = this.body.nodes[this.options.from];\n      this.to = this.body.nodes[this.options.to];\n      this.id = this.options.id;\n    }\n\n    /**\n     * Redraw a edge as a line\n     * Draw this edge in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {Array} values\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {Node} viaNode\n     * @private\n     */\n\n  }, {\n    key: 'drawLine',\n    value: function drawLine(ctx, values, selected, hover, viaNode) {\n      // set style\n      ctx.strokeStyle = this.getColor(ctx, values, selected, hover);\n      ctx.lineWidth = values.width;\n\n      if (values.dashes !== false) {\n        this._drawDashedLine(ctx, values, viaNode);\n      } else {\n        this._drawLine(ctx, values, viaNode);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {Array} values\n     * @param {Node} viaNode\n     * @param {{x: number, y: number}} [fromPoint]\n     * @param {{x: number, y: number}} [toPoint]\n     * @private\n     */\n\n  }, {\n    key: '_drawLine',\n    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {\n      if (this.from != this.to) {\n        // draw line\n        this._line(ctx, values, viaNode, fromPoint, toPoint);\n      } else {\n        var _getCircleData2 = this._getCircleData(ctx),\n            _getCircleData3 = (0, _slicedToArray3['default'])(_getCircleData2, 3),\n            x = _getCircleData3[0],\n            y = _getCircleData3[1],\n            radius = _getCircleData3[2];\n\n        this._circle(ctx, values, x, y, radius);\n      }\n    }\n\n    // prettier-ignore\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} values\n     * @param {Node} viaNode\n     * @param {{x: number, y: number}} [fromPoint]  TODO: Remove in next major release\n     * @param {{x: number, y: number}} [toPoint]    TODO: Remove in next major release\n     * @private\n     */\n\n  }, {\n    key: '_drawDashedLine',\n    value: function _drawDashedLine(ctx, values, viaNode, fromPoint, toPoint) {\n      // eslint-disable-line no-unused-vars\n      ctx.lineCap = 'round';\n      var pattern = [5, 5];\n      if (Array.isArray(values.dashes) === true) {\n        pattern = values.dashes;\n      }\n\n      // only firefox and chrome support this method, else we use the legacy one.\n      if (ctx.setLineDash !== undefined) {\n        ctx.save();\n\n        // set dash settings for chrome or firefox\n        ctx.setLineDash(pattern);\n        ctx.lineDashOffset = 0;\n\n        // draw the line\n        if (this.from != this.to) {\n          // draw line\n          this._line(ctx, values, viaNode);\n        } else {\n          var _getCircleData4 = this._getCircleData(ctx),\n              _getCircleData5 = (0, _slicedToArray3['default'])(_getCircleData4, 3),\n              x = _getCircleData5[0],\n              y = _getCircleData5[1],\n              radius = _getCircleData5[2];\n\n          this._circle(ctx, values, x, y, radius);\n        }\n\n        // restore the dash settings.\n        ctx.setLineDash([0]);\n        ctx.lineDashOffset = 0;\n        ctx.restore();\n      } else {\n        // unsupporting smooth lines\n        if (this.from != this.to) {\n          // draw line\n          ctx.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, pattern);\n        } else {\n          var _getCircleData6 = this._getCircleData(ctx),\n              _getCircleData7 = (0, _slicedToArray3['default'])(_getCircleData6, 3),\n              _x = _getCircleData7[0],\n              _y = _getCircleData7[1],\n              _radius = _getCircleData7[2];\n\n          this._circle(ctx, values, _x, _y, _radius);\n        }\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n\n        ctx.stroke();\n\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n\n    /**\n     *\n     * @param {Node} nearNode\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Object} options\n     * @returns {{x: number, y: number}}\n     */\n\n  }, {\n    key: 'findBorderPosition',\n    value: function findBorderPosition(nearNode, ctx, options) {\n      if (this.from != this.to) {\n        return this._findBorderPosition(nearNode, ctx, options);\n      } else {\n        return this._findBorderPositionCircle(nearNode, ctx, options);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {{from: ({x: number, y: number, t: number}|*), to: ({x: number, y: number, t: number}|*)}}\n     */\n\n  }, {\n    key: 'findBorderPositions',\n    value: function findBorderPositions(ctx) {\n      var from = {};\n      var to = {};\n      if (this.from != this.to) {\n        from = this._findBorderPosition(this.from, ctx);\n        to = this._findBorderPosition(this.to, ctx);\n      } else {\n        var _getCircleData$slice = this._getCircleData(ctx).slice(0, 2),\n            _getCircleData$slice2 = (0, _slicedToArray3['default'])(_getCircleData$slice, 2),\n            x = _getCircleData$slice2[0],\n            y = _getCircleData$slice2[1];\n\n        from = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: 0.25,\n          high: 0.6,\n          direction: -1\n        });\n        to = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: 0.6,\n          high: 0.8,\n          direction: 1\n        });\n      }\n      return { from: from, to: to };\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {Array.<number>} x, y, radius\n     * @private\n     */\n\n  }, {\n    key: '_getCircleData',\n    value: function _getCircleData(ctx) {\n      var x = void 0,\n          y = void 0;\n      var node = this.from;\n      var radius = this.options.selfReferenceSize;\n\n      if (ctx !== undefined) {\n        if (node.shape.width === undefined) {\n          node.shape.resize(ctx);\n        }\n      }\n\n      // get circle coordinates\n      if (node.shape.width > node.shape.height) {\n        x = node.x + node.shape.width * 0.5;\n        y = node.y - radius;\n      } else {\n        x = node.x + radius;\n        y = node.y - node.shape.height * 0.5;\n      }\n      return [x, y, radius];\n    }\n\n    /**\n     * Get a point on a circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {number} percentage - Value between 0 (line start) and 1 (line end)\n     * @return {Object} point\n     * @private\n     */\n\n  }, {\n    key: '_pointOnCircle',\n    value: function _pointOnCircle(x, y, radius, percentage) {\n      var angle = percentage * 2 * Math.PI;\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n\n    /**\n     * This function uses binary search to look for the point where the circle crosses the border of the node.\n     * @param {Node} node\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Object} options\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: '_findBorderPositionCircle',\n    value: function _findBorderPositionCircle(node, ctx, options) {\n      var x = options.x;\n      var y = options.y;\n      var low = options.low;\n      var high = options.high;\n      var direction = options.direction;\n\n      var maxIterations = 10;\n      var iteration = 0;\n      var radius = this.options.selfReferenceSize;\n      var pos = void 0,\n          angle = void 0,\n          distanceToBorder = void 0,\n          distanceToPoint = void 0,\n          difference = void 0;\n      var threshold = 0.05;\n      var middle = (low + high) * 0.5;\n\n      while (low <= high && iteration < maxIterations) {\n        middle = (low + high) * 0.5;\n\n        pos = this._pointOnCircle(x, y, radius, middle);\n        angle = Math.atan2(node.y - pos.y, node.x - pos.x);\n        distanceToBorder = node.distanceToBorder(ctx, angle);\n        distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));\n        difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference > 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (direction > 0) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (direction > 0) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n        iteration++;\n      }\n      pos.t = middle;\n\n      return pos;\n    }\n\n    /**\n     * Get the line width of the edge. Depends on width and whether one of the\n     * connected nodes is selected.\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {number} width\n     * @private\n     */\n\n  }, {\n    key: 'getLineWidth',\n    value: function getLineWidth(selected, hover) {\n      if (selected === true) {\n        return Math.max(this.selectionWidth, 0.3 / this.body.view.scale);\n      } else {\n        if (hover === true) {\n          return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);\n        } else {\n          return Math.max(this.options.width, 0.3 / this.body.view.scale);\n        }\n      }\n    }\n\n    // prettier-ignore\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     * @param {boolean} selected - Unused\n     * @param {boolean} hover - Unused\n     * @returns {string}\n     */\n\n  }, {\n    key: 'getColor',\n    value: function getColor(ctx, values, selected, hover) {\n      // eslint-disable-line no-unused-vars\n      if (values.inheritsColor !== false) {\n        // when this is a loop edge, just use the 'from' method\n        if (values.inheritsColor === 'both' && this.from.id !== this.to.id) {\n          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);\n          var fromColor = void 0,\n              toColor = void 0;\n          fromColor = this.from.options.color.highlight.border;\n          toColor = this.to.options.color.highlight.border;\n\n          if (this.from.selected === false && this.to.selected === false) {\n            fromColor = util.overrideOpacity(this.from.options.color.border, values.opacity);\n            toColor = util.overrideOpacity(this.to.options.color.border, values.opacity);\n          } else if (this.from.selected === true && this.to.selected === false) {\n            toColor = this.to.options.color.border;\n          } else if (this.from.selected === false && this.to.selected === true) {\n            fromColor = this.from.options.color.border;\n          }\n          grd.addColorStop(0, fromColor);\n          grd.addColorStop(1, toColor);\n\n          // -------------------- this returns -------------------- //\n          return grd;\n        }\n\n        if (values.inheritsColor === 'to') {\n          return util.overrideOpacity(this.to.options.color.border, values.opacity);\n        } else {\n          // \"from\"\n          return util.overrideOpacity(this.from.options.color.border, values.opacity);\n        }\n      } else {\n        return util.overrideOpacity(values.color, values.opacity);\n      }\n    }\n\n    /**\n     * Draw a line from a node to itself, a circle\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} values\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @private\n     */\n\n  }, {\n    key: '_circle',\n    value: function _circle(ctx, values, x, y, radius) {\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n\n      // draw a circle\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, 2 * Math.PI, false);\n      ctx.stroke();\n\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n    }\n\n    // prettier-ignore\n    /**\n     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).\n     * (x3,y3) is the point.\n     *\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\n     *\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Node} via\n     * @param {Array} values\n     * @returns {number}\n     */\n\n  }, {\n    key: 'getDistanceToEdge',\n    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via, values) {\n      // eslint-disable-line no-unused-vars\n      var returnValue = 0;\n      if (this.from != this.to) {\n        returnValue = this._getDistanceToEdge(x1, y1, x2, y2, x3, y3, via);\n      } else {\n        var _getCircleData8 = this._getCircleData(undefined),\n            _getCircleData9 = (0, _slicedToArray3['default'])(_getCircleData8, 3),\n            x = _getCircleData9[0],\n            y = _getCircleData9[1],\n            radius = _getCircleData9[2];\n\n        var dx = x - x3;\n        var dy = y - y3;\n        returnValue = Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);\n      }\n\n      return returnValue;\n    }\n\n    /**\n     *\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getDistanceToLine',\n    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {\n      var px = x2 - x1;\n      var py = y2 - y1;\n      var something = px * px + py * py;\n      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;\n\n      if (u > 1) {\n        u = 1;\n      } else if (u < 0) {\n        u = 0;\n      }\n\n      var x = x1 + u * px;\n      var y = y1 + u * py;\n      var dx = x - x3;\n      var dy = y - y3;\n\n      //# Note: If the actual distance does not matter,\n      //# if you only want to compare what this function\n      //# returns to other results of this function, you\n      //# can just return the squared distance instead\n      //# (i.e. remove the sqrt) to gain a little performance\n\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} position\n     * @param {Node} viaNode\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {Array} values\n     * @returns {{point: *, core: {x: number, y: number}, angle: *, length: number, type: *}}\n     */\n\n  }, {\n    key: 'getArrowData',\n    value: function getArrowData(ctx, position, viaNode, selected, hover, values) {\n      // set lets\n      var angle = void 0;\n      var arrowPoint = void 0;\n      var node1 = void 0;\n      var node2 = void 0;\n      var guideOffset = void 0;\n      var scaleFactor = void 0;\n      var type = void 0;\n      var lineWidth = values.width;\n\n      if (position === 'from') {\n        node1 = this.from;\n        node2 = this.to;\n        guideOffset = 0.1;\n        scaleFactor = values.fromArrowScale;\n        type = values.fromArrowType;\n      } else if (position === 'to') {\n        node1 = this.to;\n        node2 = this.from;\n        guideOffset = -0.1;\n        scaleFactor = values.toArrowScale;\n        type = values.toArrowType;\n      } else {\n        node1 = this.to;\n        node2 = this.from;\n        scaleFactor = values.middleArrowScale;\n        type = values.middleArrowType;\n      }\n\n      // if not connected to itself\n      if (node1 != node2) {\n        if (position !== 'middle') {\n          // draw arrow head\n          if (this.options.smooth.enabled === true) {\n            arrowPoint = this.findBorderPosition(node1, ctx, { via: viaNode });\n            var guidePos = this.getPoint(Math.max(0.0, Math.min(1.0, arrowPoint.t + guideOffset)), viaNode);\n            angle = Math.atan2(arrowPoint.y - guidePos.y, arrowPoint.x - guidePos.x);\n          } else {\n            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n            arrowPoint = this.findBorderPosition(node1, ctx);\n          }\n        } else {\n          angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n          arrowPoint = this.getPoint(0.5, viaNode); // this is 0.6 to account for the size of the arrow.\n        }\n      } else {\n        // draw circle\n        var _getCircleData10 = this._getCircleData(ctx),\n            _getCircleData11 = (0, _slicedToArray3['default'])(_getCircleData10, 3),\n            x = _getCircleData11[0],\n            y = _getCircleData11[1],\n            radius = _getCircleData11[2];\n\n        if (position === 'from') {\n          arrowPoint = this.findBorderPosition(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.25,\n            high: 0.6,\n            direction: -1\n          });\n          angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n        } else if (position === 'to') {\n          arrowPoint = this.findBorderPosition(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.6,\n            high: 1.0,\n            direction: 1\n          });\n          angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;\n        } else {\n          arrowPoint = this._pointOnCircle(x, y, radius, 0.175);\n          angle = 3.9269908169872414; // === 0.175 * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n        }\n      }\n\n      if (position === 'middle' && scaleFactor < 0) lineWidth *= -1; // reversed middle arrow\n      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.\n\n      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);\n      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);\n      var arrowCore = { x: xi, y: yi };\n\n      return {\n        point: arrowPoint,\n        core: arrowCore,\n        angle: angle,\n        length: length,\n        type: type\n      };\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {Object} arrowData\n     */\n\n  }, {\n    key: 'drawArrowHead',\n    value: function drawArrowHead(ctx, values, selected, hover, arrowData) {\n      // set style\n      ctx.strokeStyle = this.getColor(ctx, values, selected, hover);\n      ctx.fillStyle = ctx.strokeStyle;\n      ctx.lineWidth = values.width;\n\n      EndPoints.draw(ctx, arrowData);\n\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      ctx.fill();\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'enableShadow',\n    value: function enableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'disableShadow',\n    value: function disableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = 'rgba(0,0,0,0)';\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values\n     */\n\n  }, {\n    key: 'drawBackground',\n    value: function drawBackground(ctx, values) {\n      if (values.background !== false) {\n        var attrs = ['strokeStyle', 'lineWidth', 'dashes'];\n        var origCtxAttr = {};\n        // save original line attrs\n        attrs.forEach(function (attrname) {\n          origCtxAttr[attrname] = ctx[attrname];\n        });\n\n        ctx.strokeStyle = values.backgroundColor;\n        ctx.lineWidth = values.backgroundSize;\n        this.setStrokeDashed(ctx, values.backgroundDashes);\n\n        ctx.stroke();\n\n        // restore original line attrs\n        attrs.forEach(function (attrname) {\n          ctx[attrname] = origCtxAttr[attrname];\n        });\n        this.setStrokeDashed(ctx, values.dashes);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean|Array} dashes\n     */\n\n  }, {\n    key: 'setStrokeDashed',\n    value: function setStrokeDashed(ctx, dashes) {\n      if (dashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var pattern = [5, 5];\n          if (Array.isArray(dashes) === true) {\n            pattern = dashes;\n          }\n          ctx.setLineDash(pattern);\n        } else {\n          console.warn('setLineDash is not supported in this browser. The dashed stroke cannot be used.');\n        }\n      } else {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([]);\n        } else {\n          console.warn('setLineDash is not supported in this browser. The dashed stroke cannot be used.');\n        }\n      }\n    }\n  }]);\n  return EdgeBase;\n}();\n\nexports['default'] = EdgeBase;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __nested_webpack_require_329252__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_329252__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_329252__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_329252__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classCallCheck2 = __nested_webpack_require_329252__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_329252__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/** ============================================================================\n * Location of all the endpoint drawing routines.\n *\n * Every endpoint has its own drawing routine, which contains an endpoint definition.\n *\n * The endpoint definitions must have the following properies:\n *\n * - (0,0) is the connection point to the node it attaches to\n * - The endpoints are orientated to the positive x-direction\n * - The length of the endpoint is at most 1\n *\n * As long as the endpoint classes remain simple and not too numerous, they will\n * be contained within this module.\n * All classes here except `EndPoints` should be considered as private to this module.\n *\n * -----------------------------------------------------------------------------\n * ### Further Actions\n *\n * After adding a new endpoint here, you also need to do the following things:\n *\n * - Add the new endpoint name to `network/options.js` in array `endPoints`.\n * - Add the new endpoint name to the documentation.\n *   Scan for 'arrows.to.type` and add it to the description.\n * - Add the endpoint to the examples. At the very least, add it to example\n *   `edgeStyles/arrowTypes`.\n * ============================================================================= */\n\n/**\n * Common methods for endpoints\n *\n * @class\n */\nvar EndPoint = function () {\n  function EndPoint() {\n    (0, _classCallCheck3['default'])(this, EndPoint);\n  }\n\n  (0, _createClass3['default'])(EndPoint, null, [{\n    key: 'transform',\n\n    /**\n     * Apply transformation on points for display.\n     *\n     * The following is done:\n     * - rotate by the specified angle\n     * - multiply the (normalized) coordinates by the passed length\n     * - offset by the target coordinates\n     *\n     * @param {Array<Point>} points\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function transform(points, arrowData) {\n      if (!(points instanceof Array)) {\n        points = [points];\n      }\n\n      var x = arrowData.point.x;\n      var y = arrowData.point.y;\n      var angle = arrowData.angle;\n      var length = arrowData.length;\n\n      for (var i = 0; i < points.length; ++i) {\n        var p = points[i];\n        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);\n        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);\n\n        p.x = x + length * xt;\n        p.y = y + length * yt;\n      }\n    }\n\n    /**\n     * Draw a closed path using the given real coordinates.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array.<Point>} points\n     * @static\n     */\n\n  }, {\n    key: 'drawPath',\n    value: function drawPath(ctx, points) {\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for (var i = 1; i < points.length; ++i) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.closePath();\n    }\n  }]);\n  return EndPoint;\n}();\n\n/**\n * Drawing methods for the arrow endpoint.\n * @extends EndPoint\n */\n\n\nvar Arrow = function (_EndPoint) {\n  (0, _inherits3['default'])(Arrow, _EndPoint);\n\n  function Arrow() {\n    (0, _classCallCheck3['default'])(this, Arrow);\n    return (0, _possibleConstructorReturn3['default'])(this, (Arrow.__proto__ || (0, _getPrototypeOf2['default'])(Arrow)).apply(this, arguments));\n  }\n\n  (0, _createClass3['default'])(Arrow, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{ x: 0, y: 0 }, { x: -1, y: 0.3 }, { x: -0.9, y: 0 }, { x: -1, y: -0.3 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return Arrow;\n}(EndPoint);\n\n/**\n * Drawing methods for the crow endpoint.\n * @extends EndPoint\n */\n\n\nvar Crow = function () {\n  function Crow() {\n    (0, _classCallCheck3['default'])(this, Crow);\n  }\n\n  (0, _createClass3['default'])(Crow, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{ x: -1, y: 0 }, { x: 0, y: 0.3 }, { x: -0.4, y: 0 }, { x: 0, y: -0.3 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return Crow;\n}();\n\n/**\n * Drawing methods for the curve endpoint.\n * @extends EndPoint\n */\n\n\nvar Curve = function () {\n  function Curve() {\n    (0, _classCallCheck3['default'])(this, Curve);\n  }\n\n  (0, _createClass3['default'])(Curve, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = { x: -0.4, y: 0 };\n      EndPoint.transform(point, arrowData);\n\n      // Update endpoint style for drawing transparent arc.\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = 'rgba(0, 0, 0, 0)';\n\n      // Define curve endpoint as semicircle.\n      var pi = Math.PI;\n      var start_angle = arrowData.angle - pi / 2;\n      var end_angle = arrowData.angle + pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, start_angle, end_angle, false);\n      ctx.stroke();\n    }\n  }]);\n  return Curve;\n}();\n\n/**\n * Drawing methods for the inverted curve endpoint.\n * @extends EndPoint\n */\n\n\nvar InvertedCurve = function () {\n  function InvertedCurve() {\n    (0, _classCallCheck3['default'])(this, InvertedCurve);\n  }\n\n  (0, _createClass3['default'])(InvertedCurve, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = { x: -0.3, y: 0 };\n      EndPoint.transform(point, arrowData);\n\n      // Update endpoint style for drawing transparent arc.\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = 'rgba(0, 0, 0, 0)';\n\n      // Define inverted curve endpoint as semicircle.\n      var pi = Math.PI;\n      var start_angle = arrowData.angle + pi / 2;\n      var end_angle = arrowData.angle + 3 * pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, start_angle, end_angle, false);\n      ctx.stroke();\n    }\n  }]);\n  return InvertedCurve;\n}();\n\n/**\n * Drawing methods for the trinagle endpoint.\n * @extends EndPoint\n */\n\n\nvar Triangle = function () {\n  function Triangle() {\n    (0, _classCallCheck3['default'])(this, Triangle);\n  }\n\n  (0, _createClass3['default'])(Triangle, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{ x: 0.02, y: 0 }, { x: -1, y: 0.3 }, { x: -1, y: -0.3 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return Triangle;\n}();\n\n/**\n * Drawing methods for the inverted trinagle endpoint.\n * @extends EndPoint\n */\n\n\nvar InvertedTriangle = function () {\n  function InvertedTriangle() {\n    (0, _classCallCheck3['default'])(this, InvertedTriangle);\n  }\n\n  (0, _createClass3['default'])(InvertedTriangle, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{ x: 0, y: 0.3 }, { x: 0, y: -0.3 }, { x: -1, y: 0 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return InvertedTriangle;\n}();\n\n/**\n * Drawing methods for the circle endpoint.\n */\n\n\nvar Circle = function () {\n  function Circle() {\n    (0, _classCallCheck3['default'])(this, Circle);\n  }\n\n  (0, _createClass3['default'])(Circle, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      var point = { x: -0.4, y: 0 };\n\n      EndPoint.transform(point, arrowData);\n      ctx.circle(point.x, point.y, arrowData.length * 0.4);\n    }\n  }]);\n  return Circle;\n}();\n\n/**\n * Drawing methods for the bar endpoint.\n */\n\n\nvar Bar = function () {\n  function Bar() {\n    (0, _classCallCheck3['default'])(this, Bar);\n  }\n\n  (0, _createClass3['default'])(Bar, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      /*\n      var points = [\n        {x:0, y:0.5},\n        {x:0, y:-0.5}\n      ];\n       EndPoint.transform(points, arrowData);\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      ctx.lineTo(points[1].x, points[1].y);\n      ctx.stroke();\n      */\n\n      var points = [{ x: 0, y: 0.5 }, { x: 0, y: -0.5 }, { x: -0.15, y: -0.5 }, { x: -0.15, y: 0.5 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return Bar;\n}();\n\n/**\n * Drawing methods for the box endpoint.\n */\n\n\nvar Box = function () {\n  function Box() {\n    (0, _classCallCheck3['default'])(this, Box);\n  }\n\n  (0, _createClass3['default'])(Box, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      var points = [{ x: 0, y: 0.3 }, { x: 0, y: -0.3 }, { x: -0.6, y: -0.3 }, { x: -0.6, y: 0.3 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return Box;\n}();\n\n/**\n * Drawing methods for the diamond endpoint.\n */\n\n\nvar Diamond = function () {\n  function Diamond() {\n    (0, _classCallCheck3['default'])(this, Diamond);\n  }\n\n  (0, _createClass3['default'])(Diamond, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      var points = [{ x: 0, y: 0 }, { x: -0.5, y: -0.3 }, { x: -1, y: 0 }, { x: -0.5, y: 0.3 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return Diamond;\n}();\n\n/**\n * Drawing methods for the vee endpoint.\n * @extends EndPoint\n */\n\n\nvar Vee = function () {\n  function Vee() {\n    (0, _classCallCheck3['default'])(this, Vee);\n  }\n\n  (0, _createClass3['default'])(Vee, null, [{\n    key: 'draw',\n\n    /**\n     * Draw this shape at the end of a line.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{ x: -1, y: 0.3 }, { x: -0.5, y: 0 }, { x: -1, y: -0.3 }, { x: 0, y: 0 }];\n\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n    }\n  }]);\n  return Vee;\n}();\n\n/**\n * Drawing methods for the endpoints.\n */\n\n\nvar EndPoints = function () {\n  function EndPoints() {\n    (0, _classCallCheck3['default'])(this, EndPoints);\n  }\n\n  (0, _createClass3['default'])(EndPoints, null, [{\n    key: 'draw',\n\n    /**\n     * Draw an endpoint\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowData} arrowData\n     * @static\n     */\n    value: function draw(ctx, arrowData) {\n      var type;\n      if (arrowData.type) {\n        type = arrowData.type.toLowerCase();\n      }\n\n      switch (type) {\n        case 'circle':\n          Circle.draw(ctx, arrowData);\n          break;\n        case 'box':\n          Box.draw(ctx, arrowData);\n          break;\n        case 'crow':\n          Crow.draw(ctx, arrowData);\n          break;\n        case 'curve':\n          Curve.draw(ctx, arrowData);\n          break;\n        case 'diamond':\n          Diamond.draw(ctx, arrowData);\n          break;\n        case 'inv_curve':\n          InvertedCurve.draw(ctx, arrowData);\n          break;\n        case 'triangle':\n          Triangle.draw(ctx, arrowData);\n          break;\n        case 'inv_triangle':\n          InvertedTriangle.draw(ctx, arrowData);\n          break;\n        case 'bar':\n          Bar.draw(ctx, arrowData);\n          break;\n        case 'vee':\n          Vee.draw(ctx, arrowData);\n          break;\n        case 'arrow': // fall-through\n        default:\n          Arrow.draw(ctx, arrowData);\n      }\n    }\n  }]);\n  return EndPoints;\n}();\n\nexports['default'] = EndPoints;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __nested_webpack_require_344088__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_344088__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_344088__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Barnes Hut Solver\n */\nvar BarnesHutSolver = function () {\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function BarnesHutSolver(body, physicsBody, options) {\n    (0, _classCallCheck3['default'])(this, BarnesHutSolver);\n\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.barnesHutTree;\n    this.setOptions(options);\n    this.randomSeed = 5;\n\n    // debug: show grid\n    // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._debug(ctx,'#ff0000')})\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(BarnesHutSolver, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      this.options = options;\n      this.thetaInversed = 1 / this.options.theta;\n\n      // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius\n      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));\n    }\n\n    /**\n     *\n     * @returns {number} random integer\n     */\n\n  }, {\n    key: 'seededRandom',\n    value: function seededRandom() {\n      var x = Math.sin(this.randomSeed++) * 10000;\n      return x - Math.floor(x);\n    }\n\n    /**\n     * This function calculates the forces the nodes apply on each other based on a gravitational model.\n     * The Barnes Hut method is used to speed up this N-body simulation.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'solve',\n    value: function solve() {\n      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {\n        var node = void 0;\n        var nodes = this.body.nodes;\n        var nodeIndices = this.physicsBody.physicsNodeIndices;\n        var nodeCount = nodeIndices.length;\n\n        // create the tree\n        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);\n\n        // for debugging\n        this.barnesHutTree = barnesHutTree;\n\n        // place the nodes one by one recursively\n        for (var i = 0; i < nodeCount; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.options.mass > 0) {\n            // starting with root is irrelevant, it never passes the BarnesHutSolver condition\n            this._getForceContributions(barnesHutTree.root, node);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {Object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: '_getForceContributions',\n    value: function _getForceContributions(parentBranch, node) {\n      this._getForceContribution(parentBranch.children.NW, node);\n      this._getForceContribution(parentBranch.children.NE, node);\n      this._getForceContribution(parentBranch.children.SW, node);\n      this._getForceContribution(parentBranch.children.SE, node);\n    }\n\n    /**\n     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.\n     * If a region contains a single node, we check if it is not itself, then we apply the force.\n     *\n     * @param {Object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: '_getForceContribution',\n    value: function _getForceContribution(parentBranch, node) {\n      // we get no force contribution from an empty region\n      if (parentBranch.childrenCount > 0) {\n        var dx = void 0,\n            dy = void 0,\n            distance = void 0;\n\n        // get the distance from the center of mass to the node.\n        dx = parentBranch.centerOfMass.x - node.x;\n        dy = parentBranch.centerOfMass.y - node.y;\n        distance = Math.sqrt(dx * dx + dy * dy);\n\n        // BarnesHutSolver condition\n        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed\n        // calcSize = 1/s --> d * 1/s > 1/theta = passed\n        if (distance * parentBranch.calcSize > this.thetaInversed) {\n          this._calculateForces(distance, dx, dy, node, parentBranch);\n        } else {\n          // Did not pass the condition, go into children if available\n          if (parentBranch.childrenCount === 4) {\n            this._getForceContributions(parentBranch, node);\n          } else {\n            // parentBranch must have only one node, if it was empty we wouldnt be here\n            if (parentBranch.children.data.id != node.id) {\n              // if it is not self\n              this._calculateForces(distance, dx, dy, node, parentBranch);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Calculate the forces based on the distance.\n     *\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Node} node\n     * @param {Object} parentBranch\n     * @private\n     */\n\n  }, {\n    key: '_calculateForces',\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1;\n        dx = distance;\n      }\n\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n\n      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n\n    /**\n     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.\n     *\n     * @param {Array.<Node>} nodes\n     * @param {Array.<number>} nodeIndices\n     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree\n     * @private\n     */\n\n  }, {\n    key: '_formBarnesHutTree',\n    value: function _formBarnesHutTree(nodes, nodeIndices) {\n      var node = void 0;\n      var nodeCount = nodeIndices.length;\n\n      var minX = nodes[nodeIndices[0]].x;\n      var minY = nodes[nodeIndices[0]].y;\n      var maxX = nodes[nodeIndices[0]].x;\n      var maxY = nodes[nodeIndices[0]].y;\n\n      // get the range of the nodes\n      for (var i = 1; i < nodeCount; i++) {\n        var _node = nodes[nodeIndices[i]];\n        var x = _node.x;\n        var y = _node.y;\n        if (_node.options.mass > 0) {\n          if (x < minX) {\n            minX = x;\n          }\n          if (x > maxX) {\n            maxX = x;\n          }\n          if (y < minY) {\n            minY = y;\n          }\n          if (y > maxY) {\n            maxY = y;\n          }\n        }\n      }\n      // make the range a square\n      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y\n      if (sizeDiff > 0) {\n        minY -= 0.5 * sizeDiff;\n        maxY += 0.5 * sizeDiff;\n      } // xSize > ySize\n      else {\n          minX += 0.5 * sizeDiff;\n          maxX -= 0.5 * sizeDiff;\n        } // xSize < ySize\n\n      var minimumTreeSize = 1e-5;\n      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));\n      var halfRootSize = 0.5 * rootSize;\n      var centerX = 0.5 * (minX + maxX),\n          centerY = 0.5 * (minY + maxY);\n\n      // construct the barnesHutTree\n      var barnesHutTree = {\n        root: {\n          centerOfMass: { x: 0, y: 0 },\n          mass: 0,\n          range: {\n            minX: centerX - halfRootSize,\n            maxX: centerX + halfRootSize,\n            minY: centerY - halfRootSize,\n            maxY: centerY + halfRootSize\n          },\n          size: rootSize,\n          calcSize: 1 / rootSize,\n          children: { data: null },\n          maxWidth: 0,\n          level: 0,\n          childrenCount: 4\n        }\n      };\n      this._splitBranch(barnesHutTree.root);\n\n      // place the nodes one by one recursively\n      for (var _i = 0; _i < nodeCount; _i++) {\n        node = nodes[nodeIndices[_i]];\n        if (node.options.mass > 0) {\n          this._placeInTree(barnesHutTree.root, node);\n        }\n      }\n\n      // make global\n      return barnesHutTree;\n    }\n\n    /**\n     * this updates the mass of a branch. this is increased by adding a node.\n     *\n     * @param {Object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: '_updateBranchMass',\n    value: function _updateBranchMass(parentBranch, node) {\n      var centerOfMass = parentBranch.centerOfMass;\n      var totalMass = parentBranch.mass + node.options.mass;\n      var totalMassInv = 1 / totalMass;\n\n      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;\n      centerOfMass.x *= totalMassInv;\n\n      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;\n      centerOfMass.y *= totalMassInv;\n\n      parentBranch.mass = totalMass;\n      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);\n      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;\n    }\n\n    /**\n     * determine in which branch the node will be placed.\n     *\n     * @param {Object} parentBranch\n     * @param {Node} node\n     * @param {boolean} skipMassUpdate\n     * @private\n     */\n\n  }, {\n    key: '_placeInTree',\n    value: function _placeInTree(parentBranch, node, skipMassUpdate) {\n      if (skipMassUpdate != true || skipMassUpdate === undefined) {\n        // update the mass of the branch.\n        this._updateBranchMass(parentBranch, node);\n      }\n\n      var range = parentBranch.children.NW.range;\n      var region = void 0;\n      if (range.maxX > node.x) {\n        // in NW or SW\n        if (range.maxY > node.y) {\n          region = 'NW';\n        } else {\n          region = 'SW';\n        }\n      } else {\n        // in NE or SE\n        if (range.maxY > node.y) {\n          region = 'NE';\n        } else {\n          region = 'SE';\n        }\n      }\n\n      this._placeInRegion(parentBranch, node, region);\n    }\n\n    /**\n     * actually place the node in a region (or branch)\n     *\n     * @param {Object} parentBranch\n     * @param {Node} node\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n\n  }, {\n    key: '_placeInRegion',\n    value: function _placeInRegion(parentBranch, node, region) {\n      var children = parentBranch.children[region];\n\n      switch (children.childrenCount) {\n        case 0:\n          // place node here\n          children.children.data = node;\n          children.childrenCount = 1;\n          this._updateBranchMass(children, node);\n          break;\n        case 1:\n          // convert into children\n          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)\n          // we move one node a little bit and we do not put it in the tree.\n          if (children.children.data.x === node.x && children.children.data.y === node.y) {\n            node.x += this.seededRandom();\n            node.y += this.seededRandom();\n          } else {\n            this._splitBranch(children);\n            this._placeInTree(children, node);\n          }\n          break;\n        case 4:\n          // place in branch\n          this._placeInTree(children, node);\n          break;\n      }\n    }\n\n    /**\n     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch\n     * after the split is complete.\n     *\n     * @param {Object} parentBranch\n     * @private\n     */\n\n  }, {\n    key: '_splitBranch',\n    value: function _splitBranch(parentBranch) {\n      // if the branch is shaded with a node, replace the node in the new subset.\n      var containedNode = null;\n      if (parentBranch.childrenCount === 1) {\n        containedNode = parentBranch.children.data;\n        parentBranch.mass = 0;\n        parentBranch.centerOfMass.x = 0;\n        parentBranch.centerOfMass.y = 0;\n      }\n      parentBranch.childrenCount = 4;\n      parentBranch.children.data = null;\n      this._insertRegion(parentBranch, 'NW');\n      this._insertRegion(parentBranch, 'NE');\n      this._insertRegion(parentBranch, 'SW');\n      this._insertRegion(parentBranch, 'SE');\n\n      if (containedNode != null) {\n        this._placeInTree(parentBranch, containedNode);\n      }\n    }\n\n    /**\n     * This function subdivides the region into four new segments.\n     * Specifically, this inserts a single new segment.\n     * It fills the children section of the parentBranch\n     *\n     * @param {Object} parentBranch\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n\n  }, {\n    key: '_insertRegion',\n    value: function _insertRegion(parentBranch, region) {\n      var minX = void 0,\n          maxX = void 0,\n          minY = void 0,\n          maxY = void 0;\n      var childSize = 0.5 * parentBranch.size;\n      switch (region) {\n        case 'NW':\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case 'NE':\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case 'SW':\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n        case 'SE':\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n      }\n\n      parentBranch.children[region] = {\n        centerOfMass: { x: 0, y: 0 },\n        mass: 0,\n        range: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },\n        size: 0.5 * parentBranch.size,\n        calcSize: 2 * parentBranch.calcSize,\n        children: { data: null },\n        maxWidth: 0,\n        level: parentBranch.level + 1,\n        childrenCount: 0\n      };\n    }\n\n    //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * This function is for debugging purposed, it draws the tree.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n\n  }, {\n    key: '_debug',\n    value: function _debug(ctx, color) {\n      if (this.barnesHutTree !== undefined) {\n        ctx.lineWidth = 1;\n\n        this._drawBranch(this.barnesHutTree.root, ctx, color);\n      }\n    }\n\n    /**\n     * This function is for debugging purposes. It draws the branches recursively.\n     *\n     * @param {Object} branch\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n\n  }, {\n    key: '_drawBranch',\n    value: function _drawBranch(branch, ctx, color) {\n      if (color === undefined) {\n        color = '#FF0000';\n      }\n\n      if (branch.childrenCount === 4) {\n        this._drawBranch(branch.children.NW, ctx);\n        this._drawBranch(branch.children.NE, ctx);\n        this._drawBranch(branch.children.SE, ctx);\n        this._drawBranch(branch.children.SW, ctx);\n      }\n      ctx.strokeStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.minY);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.maxY);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.maxY);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.minY);\n      ctx.stroke();\n\n      /*\n       if (branch.mass > 0) {\n       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);\n       ctx.stroke();\n       }\n       */\n    }\n  }]);\n  return BarnesHutSolver;\n}();\n\nexports['default'] = BarnesHutSolver;\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __nested_webpack_require_361002__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_361002__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_361002__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Central Gravity Solver\n */\nvar CentralGravitySolver = function () {\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function CentralGravitySolver(body, physicsBody, options) {\n    (0, _classCallCheck3[\"default\"])(this, CentralGravitySolver);\n\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3[\"default\"])(CentralGravitySolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * Calculates forces for each node\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx = void 0,\n          dy = void 0,\n          distance = void 0,\n          node = void 0;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        node = nodes[nodeId];\n        dx = -node.x;\n        dy = -node.y;\n        distance = Math.sqrt(dx * dx + dy * dy);\n\n        this._calculateForces(distance, dx, dy, forces, node);\n      }\n    }\n\n    /**\n     * Calculate the forces based on the distance.\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Object<Node.id, vis.Node>} forces\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;\n      forces[node.id].x = dx * gravityForce;\n      forces[node.id].y = dy * gravityForce;\n    }\n  }]);\n  return CentralGravitySolver;\n}();\n\nexports[\"default\"] = CentralGravitySolver;\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __nested_webpack_require_363422__) {\n\nmodule.exports = __nested_webpack_require_363422__(188);\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This object contains all possible options. It will check if the types are correct, if required if the option is one\n * of the allowed values.\n *\n * __any__ means that the name of the property does not matter.\n * __type__ is a required field for all objects and contains the allowed types of all objects\n */\nvar string = 'string';\nvar bool = 'boolean';\nvar number = 'number';\nvar array = 'array';\nvar object = 'object'; // should only be in a __type__ property\nvar dom = 'dom';\nvar any = 'any';\n\n// List of endpoints\nvar endPoints = ['arrow', 'circle', 'bar'];\n\nvar allOptions = {\n  configure: {\n    enabled: { boolean: bool },\n    filter: { boolean: bool, string: string, array: array, 'function': 'function' },\n    container: { dom: dom },\n    showButton: { boolean: bool },\n    __type__: { object: object, boolean: bool, string: string, array: array, 'function': 'function' }\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: { boolean: bool },\n        scaleFactor: { number: number },\n        type: { string: endPoints },\n        __type__: { object: object, boolean: bool }\n      },\n      middle: {\n        enabled: { boolean: bool },\n        scaleFactor: { number: number },\n        type: { string: endPoints },\n        __type__: { object: object, boolean: bool }\n      },\n      from: {\n        enabled: { boolean: bool },\n        scaleFactor: { number: number },\n        type: { string: endPoints },\n        __type__: { object: object, boolean: bool }\n      },\n      __type__: { string: ['from', 'to', 'middle'], object: object }\n    },\n    arrowStrikethrough: { boolean: bool },\n    background: {\n      enabled: { boolean: bool },\n      color: { string: string },\n      size: { number: number },\n      dashes: { boolean: bool, array: array },\n      __type__: { object: object, boolean: bool }\n    },\n    chosen: {\n      label: { boolean: bool, 'function': 'function' },\n      edge: { boolean: bool, 'function': 'function' },\n      __type__: { object: object, boolean: bool }\n    },\n    color: {\n      color: { string: string },\n      highlight: { string: string },\n      hover: { string: string },\n      inherit: { string: ['from', 'to', 'both'], boolean: bool },\n      opacity: { number: number },\n      __type__: { object: object, string: string }\n    },\n    dashes: { boolean: bool, array: array },\n    font: {\n      color: { string: string },\n      size: { number: number }, // px\n      face: { string: string },\n      background: { string: string },\n      strokeWidth: { number: number }, // px\n      strokeColor: { string: string },\n      align: { string: ['horizontal', 'top', 'middle', 'bottom'] },\n      vadjust: { number: number },\n      multi: { boolean: bool, string: string },\n      bold: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      boldital: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      ital: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      mono: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      __type__: { object: object, string: string }\n    },\n    hidden: { boolean: bool },\n    hoverWidth: { 'function': 'function', number: number },\n    label: { string: string, undefined: 'undefined' },\n    labelHighlightBold: { boolean: bool },\n    length: { number: number, undefined: 'undefined' },\n    physics: { boolean: bool },\n    scaling: {\n      min: { number: number },\n      max: { number: number },\n      label: {\n        enabled: { boolean: bool },\n        min: { number: number },\n        max: { number: number },\n        maxVisible: { number: number },\n        drawThreshold: { number: number },\n        __type__: { object: object, boolean: bool }\n      },\n      customScalingFunction: { 'function': 'function' },\n      __type__: { object: object }\n    },\n    selectionWidth: { 'function': 'function', number: number },\n    selfReferenceSize: { number: number },\n    shadow: {\n      enabled: { boolean: bool },\n      color: { string: string },\n      size: { number: number },\n      x: { number: number },\n      y: { number: number },\n      __type__: { object: object, boolean: bool }\n    },\n    smooth: {\n      enabled: { boolean: bool },\n      type: {\n        string: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier']\n      },\n      roundness: { number: number },\n      forceDirection: {\n        string: ['horizontal', 'vertical', 'none'],\n        boolean: bool\n      },\n      __type__: { object: object, boolean: bool }\n    },\n    title: { string: string, undefined: 'undefined' },\n    width: { number: number },\n    widthConstraint: {\n      maximum: { number: number },\n      __type__: { object: object, boolean: bool, number: number }\n    },\n    value: { number: number, undefined: 'undefined' },\n    __type__: { object: object }\n  },\n  groups: {\n    useDefaultGroups: { boolean: bool },\n    __any__: 'get from nodes, will be overwritten below',\n    __type__: { object: object }\n  },\n  interaction: {\n    dragNodes: { boolean: bool },\n    dragView: { boolean: bool },\n    hideEdgesOnDrag: { boolean: bool },\n    hideEdgesOnZoom: { boolean: bool },\n    hideNodesOnDrag: { boolean: bool },\n    hover: { boolean: bool },\n    keyboard: {\n      enabled: { boolean: bool },\n      speed: {\n        x: { number: number },\n        y: { number: number },\n        zoom: { number: number },\n        __type__: { object: object }\n      },\n      bindToWindow: { boolean: bool },\n      __type__: { object: object, boolean: bool }\n    },\n    multiselect: { boolean: bool },\n    navigationButtons: { boolean: bool },\n    selectable: { boolean: bool },\n    selectConnectedEdges: { boolean: bool },\n    hoverConnectedEdges: { boolean: bool },\n    tooltipDelay: { number: number },\n    zoomView: { boolean: bool },\n    zoomSpeed: { number: number },\n    __type__: { object: object }\n  },\n  layout: {\n    randomSeed: { undefined: 'undefined', number: number },\n    improvedLayout: { boolean: bool },\n    hierarchical: {\n      enabled: { boolean: bool },\n      levelSeparation: { number: number },\n      nodeSpacing: { number: number },\n      treeSpacing: { number: number },\n      blockShifting: { boolean: bool },\n      edgeMinimization: { boolean: bool },\n      parentCentralization: { boolean: bool },\n      direction: { string: ['UD', 'DU', 'LR', 'RL'] }, // UD, DU, LR, RL\n      sortMethod: { string: ['hubsize', 'directed'] }, // hubsize, directed\n      __type__: { object: object, boolean: bool }\n    },\n    __type__: { object: object }\n  },\n  manipulation: {\n    enabled: { boolean: bool },\n    initiallyActive: { boolean: bool },\n    addNode: { boolean: bool, 'function': 'function' },\n    addEdge: { boolean: bool, 'function': 'function' },\n    editNode: { 'function': 'function' },\n    editEdge: {\n      editWithoutDrag: { 'function': 'function' },\n      __type__: { object: object, boolean: bool, 'function': 'function' }\n    },\n    deleteNode: { boolean: bool, 'function': 'function' },\n    deleteEdge: { boolean: bool, 'function': 'function' },\n    controlNodeStyle: 'get from nodes, will be overwritten below',\n    __type__: { object: object, boolean: bool }\n  },\n  nodes: {\n    borderWidth: { number: number },\n    borderWidthSelected: { number: number, undefined: 'undefined' },\n    brokenImage: { string: string, undefined: 'undefined' },\n    chosen: {\n      label: { boolean: bool, 'function': 'function' },\n      node: { boolean: bool, 'function': 'function' },\n      __type__: { object: object, boolean: bool }\n    },\n    color: {\n      border: { string: string },\n      background: { string: string },\n      highlight: {\n        border: { string: string },\n        background: { string: string },\n        __type__: { object: object, string: string }\n      },\n      hover: {\n        border: { string: string },\n        background: { string: string },\n        __type__: { object: object, string: string }\n      },\n      __type__: { object: object, string: string }\n    },\n    fixed: {\n      x: { boolean: bool },\n      y: { boolean: bool },\n      __type__: { object: object, boolean: bool }\n    },\n    font: {\n      align: { string: string },\n      color: { string: string },\n      size: { number: number }, // px\n      face: { string: string },\n      background: { string: string },\n      strokeWidth: { number: number }, // px\n      strokeColor: { string: string },\n      vadjust: { number: number },\n      multi: { boolean: bool, string: string },\n      bold: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      boldital: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      ital: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      mono: {\n        color: { string: string },\n        size: { number: number }, // px\n        face: { string: string },\n        mod: { string: string },\n        vadjust: { number: number },\n        __type__: { object: object, string: string }\n      },\n      __type__: { object: object, string: string }\n    },\n    group: { string: string, number: number, undefined: 'undefined' },\n    heightConstraint: {\n      minimum: { number: number },\n      valign: { string: string },\n      __type__: { object: object, boolean: bool, number: number }\n    },\n    hidden: { boolean: bool },\n    icon: {\n      face: { string: string },\n      code: { string: string }, //'\\uf007',\n      size: { number: number }, //50,\n      color: { string: string },\n      __type__: { object: object }\n    },\n    id: { string: string, number: number },\n    image: {\n      selected: { string: string, undefined: 'undefined' }, // --> URL\n      unselected: { string: string, undefined: 'undefined' }, // --> URL\n      __type__: { object: object, string: string }\n    },\n    label: { string: string, undefined: 'undefined' },\n    labelHighlightBold: { boolean: bool },\n    level: { number: number, undefined: 'undefined' },\n    margin: {\n      top: { number: number },\n      right: { number: number },\n      bottom: { number: number },\n      left: { number: number },\n      __type__: { object: object, number: number }\n    },\n    mass: { number: number },\n    physics: { boolean: bool },\n    scaling: {\n      min: { number: number },\n      max: { number: number },\n      label: {\n        enabled: { boolean: bool },\n        min: { number: number },\n        max: { number: number },\n        maxVisible: { number: number },\n        drawThreshold: { number: number },\n        __type__: { object: object, boolean: bool }\n      },\n      customScalingFunction: { 'function': 'function' },\n      __type__: { object: object }\n    },\n    shadow: {\n      enabled: { boolean: bool },\n      color: { string: string },\n      size: { number: number },\n      x: { number: number },\n      y: { number: number },\n      __type__: { object: object, boolean: bool }\n    },\n    shape: {\n      string: ['ellipse', 'circle', 'database', 'box', 'text', 'image', 'circularImage', 'diamond', 'dot', 'star', 'triangle', 'triangleDown', 'square', 'icon', 'hexagon']\n    },\n    shapeProperties: {\n      borderDashes: { boolean: bool, array: array },\n      borderRadius: { number: number },\n      interpolation: { boolean: bool },\n      useImageSize: { boolean: bool },\n      useBorderWithImage: { boolean: bool },\n      __type__: { object: object }\n    },\n    size: { number: number },\n    title: { string: string, dom: dom, undefined: 'undefined' },\n    value: { number: number, undefined: 'undefined' },\n    widthConstraint: {\n      minimum: { number: number },\n      maximum: { number: number },\n      __type__: { object: object, boolean: bool, number: number }\n    },\n    x: { number: number },\n    y: { number: number },\n    __type__: { object: object }\n  },\n  physics: {\n    enabled: { boolean: bool },\n    barnesHut: {\n      gravitationalConstant: { number: number },\n      centralGravity: { number: number },\n      springLength: { number: number },\n      springConstant: { number: number },\n      damping: { number: number },\n      avoidOverlap: { number: number },\n      __type__: { object: object }\n    },\n    forceAtlas2Based: {\n      gravitationalConstant: { number: number },\n      centralGravity: { number: number },\n      springLength: { number: number },\n      springConstant: { number: number },\n      damping: { number: number },\n      avoidOverlap: { number: number },\n      __type__: { object: object }\n    },\n    repulsion: {\n      centralGravity: { number: number },\n      springLength: { number: number },\n      springConstant: { number: number },\n      nodeDistance: { number: number },\n      damping: { number: number },\n      __type__: { object: object }\n    },\n    hierarchicalRepulsion: {\n      centralGravity: { number: number },\n      springLength: { number: number },\n      springConstant: { number: number },\n      nodeDistance: { number: number },\n      damping: { number: number },\n      __type__: { object: object }\n    },\n    maxVelocity: { number: number },\n    minVelocity: { number: number }, // px/s\n    solver: {\n      string: ['barnesHut', 'repulsion', 'hierarchicalRepulsion', 'forceAtlas2Based']\n    },\n    stabilization: {\n      enabled: { boolean: bool },\n      iterations: { number: number }, // maximum number of iteration to stabilize\n      updateInterval: { number: number },\n      onlyDynamicEdges: { boolean: bool },\n      fit: { boolean: bool },\n      __type__: { object: object, boolean: bool }\n    },\n    timestep: { number: number },\n    adaptiveTimestep: { boolean: bool },\n    __type__: { object: object, boolean: bool }\n  },\n\n  //globals :\n  autoResize: { boolean: bool },\n  clickToUse: { boolean: bool },\n  locale: { string: string },\n  locales: {\n    __any__: { any: any },\n    __type__: { object: object }\n  },\n  height: { string: string },\n  width: { string: string },\n  __type__: { object: object }\n};\n\nallOptions.groups.__any__ = allOptions.nodes;\nallOptions.manipulation.controlNodeStyle = allOptions.nodes;\n\nvar configureOptions = {\n  nodes: {\n    borderWidth: [1, 0, 10, 1],\n    borderWidthSelected: [2, 0, 10, 1],\n    color: {\n      border: ['color', '#2B7CE9'],\n      background: ['color', '#97C2FC'],\n      highlight: {\n        border: ['color', '#2B7CE9'],\n        background: ['color', '#D2E5FF']\n      },\n      hover: {\n        border: ['color', '#2B7CE9'],\n        background: ['color', '#D2E5FF']\n      }\n    },\n    fixed: {\n      x: false,\n      y: false\n    },\n    font: {\n      color: ['color', '#343434'],\n      size: [14, 0, 100, 1], // px\n      face: ['arial', 'verdana', 'tahoma'],\n      background: ['color', 'none'],\n      strokeWidth: [0, 0, 50, 1], // px\n      strokeColor: ['color', '#ffffff']\n    },\n    //group: 'string',\n    hidden: false,\n    labelHighlightBold: true,\n    //icon: {\n    //  face: 'string',  //'FontAwesome',\n    //  code: 'string',  //'\\uf007',\n    //  size: [50, 0, 200, 1],  //50,\n    //  color: ['color','#2B7CE9']   //'#aa00ff'\n    //},\n    //image: 'string', // --> URL\n    physics: true,\n    scaling: {\n      min: [10, 0, 200, 1],\n      max: [30, 0, 200, 1],\n      label: {\n        enabled: false,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    shadow: {\n      enabled: false,\n      color: 'rgba(0,0,0,0.5)',\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    shape: ['ellipse', 'box', 'circle', 'database', 'diamond', 'dot', 'square', 'star', 'text', 'triangle', 'triangleDown', 'hexagon'],\n    shapeProperties: {\n      borderDashes: false,\n      borderRadius: [6, 0, 20, 1],\n      interpolation: true,\n      useImageSize: false\n    },\n    size: [25, 0, 200, 1]\n  },\n  edges: {\n    arrows: {\n      to: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' },\n      middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' },\n      from: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' }\n    },\n    arrowStrikethrough: true,\n    color: {\n      color: ['color', '#848484'],\n      highlight: ['color', '#848484'],\n      hover: ['color', '#848484'],\n      inherit: ['from', 'to', 'both', true, false],\n      opacity: [1, 0, 1, 0.05]\n    },\n    dashes: false,\n    font: {\n      color: ['color', '#343434'],\n      size: [14, 0, 100, 1], // px\n      face: ['arial', 'verdana', 'tahoma'],\n      background: ['color', 'none'],\n      strokeWidth: [2, 0, 50, 1], // px\n      strokeColor: ['color', '#ffffff'],\n      align: ['horizontal', 'top', 'middle', 'bottom']\n    },\n    hidden: false,\n    hoverWidth: [1.5, 0, 5, 0.1],\n    labelHighlightBold: true,\n    physics: true,\n    scaling: {\n      min: [1, 0, 100, 1],\n      max: [15, 0, 100, 1],\n      label: {\n        enabled: true,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    selectionWidth: [1.5, 0, 5, 0.1],\n    selfReferenceSize: [20, 0, 200, 1],\n    shadow: {\n      enabled: false,\n      color: 'rgba(0,0,0,0.5)',\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    smooth: {\n      enabled: true,\n      type: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'],\n      forceDirection: ['horizontal', 'vertical', 'none'],\n      roundness: [0.5, 0, 1, 0.05]\n    },\n    width: [1, 0, 30, 1]\n  },\n  layout: {\n    //randomSeed: [0, 0, 500, 1],\n    //improvedLayout: true,\n    hierarchical: {\n      enabled: false,\n      levelSeparation: [150, 20, 500, 5],\n      nodeSpacing: [100, 20, 500, 5],\n      treeSpacing: [200, 20, 500, 5],\n      blockShifting: true,\n      edgeMinimization: true,\n      parentCentralization: true,\n      direction: ['UD', 'DU', 'LR', 'RL'], // UD, DU, LR, RL\n      sortMethod: ['hubsize', 'directed'] // hubsize, directed\n    }\n  },\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hideEdgesOnDrag: false,\n    hideEdgesOnZoom: false,\n    hideNodesOnDrag: false,\n    hover: false,\n    keyboard: {\n      enabled: false,\n      speed: {\n        x: [10, 0, 40, 1],\n        y: [10, 0, 40, 1],\n        zoom: [0.02, 0, 0.1, 0.005]\n      },\n      bindToWindow: true\n    },\n    multiselect: false,\n    navigationButtons: false,\n    selectable: true,\n    selectConnectedEdges: true,\n    hoverConnectedEdges: true,\n    tooltipDelay: [300, 0, 1000, 25],\n    zoomView: true,\n    zoomSpeed: 1\n  },\n  manipulation: {\n    enabled: false,\n    initiallyActive: false\n  },\n  physics: {\n    enabled: true,\n    barnesHut: {\n      //theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-2000, -30000, 0, 50],\n      centralGravity: [0.3, 0, 10, 0.05],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.04, 0, 1.2, 0.005],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    forceAtlas2Based: {\n      //theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-50, -500, 0, 1],\n      centralGravity: [0.01, 0, 1, 0.005],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.08, 0, 1.2, 0.005],\n      damping: [0.4, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    repulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [200, 0, 500, 5],\n      springConstant: [0.05, 0, 1.2, 0.005],\n      nodeDistance: [100, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01]\n    },\n    hierarchicalRepulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [100, 0, 500, 5],\n      springConstant: [0.01, 0, 1.2, 0.005],\n      nodeDistance: [120, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01]\n    },\n    maxVelocity: [50, 0, 150, 1],\n    minVelocity: [0.1, 0.01, 0.5, 0.01],\n    solver: ['barnesHut', 'forceAtlas2Based', 'repulsion', 'hierarchicalRepulsion'],\n    timestep: [0.5, 0.01, 1, 0.01]\n    //adaptiveTimestep: true\n  }\n};\n\nexports.allOptions = allOptions;\nexports.configureOptions = configureOptions;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __nested_webpack_require_384874__) {\n\n\"use strict\";\n\n\nvar util = __nested_webpack_require_384874__(2);\n\n// Network\nutil.extend(exports, __nested_webpack_require_384874__(121));\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __nested_webpack_require_385062__) {\n\n__nested_webpack_require_385062__(37);\n__nested_webpack_require_385062__(47);\nmodule.exports = __nested_webpack_require_385062__(98);\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __nested_webpack_require_385232__) {\n\n\"use strict\";\n\nvar addToUnscopables = __nested_webpack_require_385232__(88);\nvar step = __nested_webpack_require_385232__(89);\nvar Iterators = __nested_webpack_require_385232__(25);\nvar toIObject = __nested_webpack_require_385232__(18);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __nested_webpack_require_385232__(60)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports) {\n\nmodule.exports = function () { /* empty */ };\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __nested_webpack_require_386843__) {\n\n\"use strict\";\n\nvar create = __nested_webpack_require_386843__(41);\nvar descriptor = __nested_webpack_require_386843__(28);\nvar setToStringTag = __nested_webpack_require_386843__(46);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__nested_webpack_require_386843__(19)(IteratorPrototype, __nested_webpack_require_386843__(8)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __nested_webpack_require_387442__) {\n\nvar dP = __nested_webpack_require_387442__(12);\nvar anObject = __nested_webpack_require_387442__(20);\nvar getKeys = __nested_webpack_require_387442__(26);\n\nmodule.exports = __nested_webpack_require_387442__(13) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __nested_webpack_require_387920__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __nested_webpack_require_387920__(18);\nvar toLength = __nested_webpack_require_387920__(94);\nvar toAbsoluteIndex = __nested_webpack_require_387920__(95);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __nested_webpack_require_388913__) {\n\n// 7.1.15 ToLength\nvar toInteger = __nested_webpack_require_388913__(42);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __nested_webpack_require_389205__) {\n\nvar toInteger = __nested_webpack_require_389205__(42);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __nested_webpack_require_389505__) {\n\nvar document = __nested_webpack_require_389505__(10).document;\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __nested_webpack_require_389687__) {\n\nvar toInteger = __nested_webpack_require_389687__(42);\nvar defined = __nested_webpack_require_389687__(39);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __nested_webpack_require_390386__) {\n\nvar anObject = __nested_webpack_require_390386__(20);\nvar get = __nested_webpack_require_390386__(99);\nmodule.exports = __nested_webpack_require_390386__(6).getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __nested_webpack_require_390750__) {\n\nvar classof = __nested_webpack_require_390750__(67);\nvar ITERATOR = __nested_webpack_require_390750__(8)('iterator');\nvar Iterators = __nested_webpack_require_390750__(25);\nmodule.exports = __nested_webpack_require_390750__(6).getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __nested_webpack_require_391137__) {\n\n__nested_webpack_require_391137__(101);\nvar $Object = __nested_webpack_require_391137__(6).Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __nested_webpack_require_391362__) {\n\nvar $export = __nested_webpack_require_391362__(11);\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __nested_webpack_require_391362__(41) });\n\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __nested_webpack_require_391602__) {\n\n__nested_webpack_require_391602__(103);\nmodule.exports = __nested_webpack_require_391602__(6).Object.keys;\n\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __nested_webpack_require_391760__) {\n\n// 19.1.2.14 Object.keys(O)\nvar toObject = __nested_webpack_require_391760__(30);\nvar $keys = __nested_webpack_require_391760__(26);\n\n__nested_webpack_require_391760__(68)('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __nested_webpack_require_392061__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_392061__(105), __esModule: true };\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __nested_webpack_require_392215__) {\n\n__nested_webpack_require_392215__(47);\n__nested_webpack_require_392215__(37);\nmodule.exports = __nested_webpack_require_392215__(48).f('iterator');\n\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __nested_webpack_require_392400__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_392400__(107), __esModule: true };\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __nested_webpack_require_392554__) {\n\n__nested_webpack_require_392554__(108);\n__nested_webpack_require_392554__(113);\n__nested_webpack_require_392554__(114);\n__nested_webpack_require_392554__(115);\nmodule.exports = __nested_webpack_require_392554__(6).Symbol;\n\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __nested_webpack_require_392785__) {\n\n\"use strict\";\n\n// ECMAScript 6 symbols shim\nvar global = __nested_webpack_require_392785__(10);\nvar has = __nested_webpack_require_392785__(14);\nvar DESCRIPTORS = __nested_webpack_require_392785__(13);\nvar $export = __nested_webpack_require_392785__(11);\nvar redefine = __nested_webpack_require_392785__(64);\nvar META = __nested_webpack_require_392785__(109).KEY;\nvar $fails = __nested_webpack_require_392785__(22);\nvar shared = __nested_webpack_require_392785__(44);\nvar setToStringTag = __nested_webpack_require_392785__(46);\nvar uid = __nested_webpack_require_392785__(29);\nvar wks = __nested_webpack_require_392785__(8);\nvar wksExt = __nested_webpack_require_392785__(48);\nvar wksDefine = __nested_webpack_require_392785__(49);\nvar enumKeys = __nested_webpack_require_392785__(110);\nvar isArray = __nested_webpack_require_392785__(111);\nvar anObject = __nested_webpack_require_392785__(20);\nvar isObject = __nested_webpack_require_392785__(21);\nvar toIObject = __nested_webpack_require_392785__(18);\nvar toPrimitive = __nested_webpack_require_392785__(40);\nvar createDesc = __nested_webpack_require_392785__(28);\nvar _create = __nested_webpack_require_392785__(41);\nvar gOPNExt = __nested_webpack_require_392785__(112);\nvar $GOPD = __nested_webpack_require_392785__(70);\nvar $DP = __nested_webpack_require_392785__(12);\nvar $keys = __nested_webpack_require_392785__(26);\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  __nested_webpack_require_392785__(69).f = gOPNExt.f = $getOwnPropertyNames;\n  __nested_webpack_require_392785__(32).f = $propertyIsEnumerable;\n  __nested_webpack_require_392785__(50).f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !__nested_webpack_require_392785__(27)) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __nested_webpack_require_392785__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __nested_webpack_require_401728__) {\n\nvar META = __nested_webpack_require_401728__(29)('meta');\nvar isObject = __nested_webpack_require_401728__(21);\nvar has = __nested_webpack_require_401728__(14);\nvar setDesc = __nested_webpack_require_401728__(12).f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !__nested_webpack_require_401728__(22)(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __nested_webpack_require_403381__) {\n\n// all enumerable object keys, includes symbols\nvar getKeys = __nested_webpack_require_403381__(26);\nvar gOPS = __nested_webpack_require_403381__(50);\nvar pIE = __nested_webpack_require_403381__(32);\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __nested_webpack_require_403924__) {\n\n// 7.2.2 IsArray(argument)\nvar cof = __nested_webpack_require_403924__(38);\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __nested_webpack_require_404156__) {\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __nested_webpack_require_404156__(18);\nvar gOPN = __nested_webpack_require_404156__(69).f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __nested_webpack_require_404894__) {\n\n__nested_webpack_require_404894__(49)('asyncIterator');\n\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __nested_webpack_require_405015__) {\n\n__nested_webpack_require_405015__(49)('observable');\n\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __nested_webpack_require_405133__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js\n\n;(function (global, factory) {\n      true ? module.exports = factory() :\n    0\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return (Object.getOwnPropertyNames(obj).length === 0);\n        } else {\n            var k;\n            for (k in obj) {\n                if (obj.hasOwnProperty(k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false,\n            parsedDateParts : [],\n            meridiem        : null,\n            rfc2822         : false,\n            weekdayMismatch : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            var isNowValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            }\n            else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n                (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [];\n                var arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n                            arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (isFunction(prop)) {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig, prop) &&\n                    !hasOwnProp(childConfig, prop) &&\n                    isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (isFunction(output)) ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit: u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '', i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n    var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK = 7;\n    var WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? '' + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit) {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            }\n            else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet (units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months :\n                this._months['standalone'];\n        }\n        return isArray(this._months) ? this._months[m.month()] :\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n    function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n    function createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m, format) {\n        if (!m) {\n            return isArray(this._weekdays) ? this._weekdays :\n                this._weekdays['standalone'];\n        }\n        return isArray(this._weekdays) ? this._weekdays[m.day()] :\n            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n            shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom, '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n\n    // internal storage for locale config files\n    var locales = {};\n    var localeFamilies = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && (typeof module !== 'undefined') &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                var aliasedRequire = require;\n                !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"./locale\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {}\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n            else {\n                if ((typeof console !==  'undefined') && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n                        'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            // MERGE\n            tmpLocale = loadLocale(name);\n            if (tmpLocale != null) {\n                parentConfig = tmpLocale._config;\n            }\n            config = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n            locale.parentLocale = locales[name];\n            locales[name] = locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat, tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10);\n            var m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\n        if (match) {\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            // console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex', getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        }  else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input) && isObjectEmpty(input)) ||\n                (isArray(input) && input.length === 0)) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other < this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other > this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m) {\n        for (var key in m) {\n            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n\n        var unitHasDecimal = false;\n        for (var i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound (number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // FORMATTING\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher);\n\n        if (matches === null) {\n            return null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ?\n          0 :\n          parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            }\n            else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (isNumber(input)) {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])                         * sign,\n                h  : toInt(match[HOUR])                         * sign,\n                m  : toInt(match[MINUTE])                       * sign,\n                s  : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n        } else if (!!(match = isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4], sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6], sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n    function calendar$1 (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n        inclusivity = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n    }\n\n    function isSame (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n    function isSameOrAfter (input, units) {\n        return this.isSame(input, units) || this.isAfter(input,units);\n    }\n\n    function isSameOrBefore (input, units) {\n        return this.isSame(input, units) || this.isBefore(input,units);\n    }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n            output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year': output = monthDiff(this, that) / 12; break;\n            case 'month': output = monthDiff(this, that); break;\n            case 'quarter': output = monthDiff(this, that) / 3; break;\n            case 'second': output = (this - that) / 1e3; break; // 1000\n            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default: output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true;\n        var m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect () {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n        var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        var suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n            case 'year':\n                this.month(0);\n                /* falls through */\n            case 'quarter':\n            case 'month':\n                this.date(1);\n                /* falls through */\n            case 'week':\n            case 'isoWeek':\n            case 'day':\n            case 'date':\n                this.hours(0);\n                /* falls through */\n            case 'hour':\n                this.minutes(0);\n                /* falls through */\n            case 'minute':\n                this.seconds(0);\n                /* falls through */\n            case 'second':\n                this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n\n        // 'date' is an alias for 'day', so it should be considered as such.\n        if (units === 'date') {\n            units = 'day';\n        }\n\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function valueOf () {\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2 () {\n        return isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input,\n                this.week(),\n                this.weekday(),\n                this.localeData()._week.dow,\n                this.localeData()._week.doy);\n    }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n          locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add               = add;\n    proto.calendar          = calendar$1;\n    proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf             = endOf;\n    proto.format            = format;\n    proto.from              = from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n    proto.toNow             = toNow;\n    proto.get               = stringGet;\n    proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n    proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n    proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n    proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n    proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData        = localeData;\n    proto.max               = prototypeMax;\n    proto.min               = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n    proto.set               = stringSet;\n    proto.startOf           = startOf;\n    proto.subtract          = subtract;\n    proto.toArray           = toArray;\n    proto.toObject          = toObject;\n    proto.toDate            = toDate;\n    proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n    proto.toJSON            = toJSON;\n    proto.toString          = toString;\n    proto.unix              = unix;\n    proto.valueOf           = valueOf;\n    proto.creationData      = creationData;\n    proto.year       = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear    = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month       = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week           = proto.weeks        = getSetWeek;\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear    = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.date       = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n    proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear  = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset            = getSetOffset;\n    proto.utc                  = setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone            = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              = isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                = isUtc;\n    proto.isUTC                = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n    proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n    proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      = preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture      = pastFuture;\n    proto$1.set             = set;\n\n    proto$1.months            =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n    proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex       = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays       =        localeWeekdays;\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n    proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl (localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n    var mathAbs = Math.abs;\n\n    function abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function clone$1 () {\n        return createDuration(this);\n    }\n\n    function get$2 (units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        ss: 44,         // a few seconds to seconds\n        s : 45,         // seconds to minute\n        m : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d : 26,         // days to month\n        M : 11          // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n        var duration = createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n                seconds < thresholds.s   && ['ss', seconds] ||\n                minutes <= 1             && ['m']           ||\n                minutes < thresholds.m   && ['mm', minutes] ||\n                hours   <= 1             && ['h']           ||\n                hours   < thresholds.h   && ['hh', hours]   ||\n                days    <= 1             && ['d']           ||\n                days    < thresholds.d   && ['dd', days]    ||\n                months  <= 1             && ['M']           ||\n                months  < thresholds.M   && ['MM', months]  ||\n                years   <= 1             && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding (roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof(roundingFunction) === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n        var output = relativeTime$1(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return ((x > 0) - (x < 0)) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000;\n        var days         = abs$1(this._days);\n        var months       = abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        var totalSign = total < 0 ? '-' : '';\n        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return totalSign + 'P' +\n            (Y ? ymSign + Y + 'Y' : '') +\n            (M ? ymSign + M + 'M' : '') +\n            (D ? daysSign + D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? hmsSign + h + 'H' : '') +\n            (m ? hmsSign + m + 'M' : '') +\n            (s ? hmsSign + s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid        = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            = add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      = asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        = asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n    proto$2.asMonths       = asMonths;\n    proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n    proto$2._bubble        = bubble;\n    proto$2.clone          = clone$1;\n    proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n    proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n    proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks          = weeks;\n    proto$2.months         = months;\n    proto$2.years          = years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n    proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n    proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n    // Side effect imports\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    hooks.version = '2.22.2';\n\n    setHookCallback(createLocal);\n\n    hooks.fn                    = proto;\n    hooks.min                   = min;\n    hooks.max                   = max;\n    hooks.now                   = now;\n    hooks.utc                   = createUTC;\n    hooks.unix                  = createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                = isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid               = createInvalid;\n    hooks.duration              = createDuration;\n    hooks.isMoment              = isMoment;\n    hooks.weekdays              = listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData            = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort           = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n    hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          = updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort         = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n    hooks.prototype             = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n        TIME: 'HH:mm',                                  // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\n        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_405133__(117)(module)))\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports) {\n\nfunction webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 118;\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __nested_webpack_require_553149__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n/* eslint-disable require-jsdoc */\n\nvar _rng;\n\nvar globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;\n\nif (globalVar && globalVar.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  _rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!_rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var _rnds = new Array(16);\n  _rng = function _rng() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\n//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\n\n//var _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = buf && offset || 0,\n      ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {\n    if (ii < 16) {\n      // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0,\n      bth = _byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0,\n    _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_553149__(120)))\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __nested_webpack_require_559973__) {\n\n\"use strict\";\n\n\n// utils\nexports.util = __nested_webpack_require_559973__(2);\nexports.DOMutil = __nested_webpack_require_559973__(122);\n\n// data\nexports.DataSet = __nested_webpack_require_559973__(33);\nexports.DataView = __nested_webpack_require_559973__(51);\nexports.Queue = __nested_webpack_require_559973__(72);\n\n// Network\nexports.Network = __nested_webpack_require_559973__(124);\nexports.network = {\n  Images: __nested_webpack_require_559973__(76),\n  dotparser: __nested_webpack_require_559973__(74),\n  gephiParser: __nested_webpack_require_559973__(75),\n  allOptions: __nested_webpack_require_559973__(84)\n};\nexports.network.convertDot = function (input) {\n  return exports.network.dotparser.DOTToGraph(input);\n};\nexports.network.convertGephi = function (input, options) {\n  return exports.network.gephiParser.parseGephi(input, options);\n};\n\n// bundled external libraries\nexports.moment = __nested_webpack_require_559973__(71);\nexports.Hammer = __nested_webpack_require_559973__(24);\nexports.keycharm = __nested_webpack_require_559973__(52);\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// DOM utility methods\n\n/**\n * this prepares the JSON container for allocating SVG elements\n * @param {Object} JSONcontainer\n * @private\n */\nexports.prepareElements = function (JSONcontainer) {\n  // cleanup the redundant svgElements;\n  for (var elementType in JSONcontainer) {\n    if (JSONcontainer.hasOwnProperty(elementType)) {\n      JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;\n      JSONcontainer[elementType].used = [];\n    }\n  }\n};\n\n/**\n * this cleans up all the unused SVG elements. By asking for the parentNode, we only need to supply the JSON container from\n * which to remove the redundant elements.\n *\n * @param {Object} JSONcontainer\n * @private\n */\nexports.cleanupElements = function (JSONcontainer) {\n  // cleanup the redundant svgElements;\n  for (var elementType in JSONcontainer) {\n    if (JSONcontainer.hasOwnProperty(elementType)) {\n      if (JSONcontainer[elementType].redundant) {\n        for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {\n          JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);\n        }\n        JSONcontainer[elementType].redundant = [];\n      }\n    }\n  }\n};\n\n/**\n * Ensures that all elements are removed first up so they can be recreated cleanly\n * @param {Object} JSONcontainer\n */\nexports.resetElements = function (JSONcontainer) {\n  exports.prepareElements(JSONcontainer);\n  exports.cleanupElements(JSONcontainer);\n  exports.prepareElements(JSONcontainer);\n};\n\n/**\n * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer\n * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.\n *\n * @param {string} elementType\n * @param {Object} JSONcontainer\n * @param {Object} svgContainer\n * @returns {Element}\n * @private\n */\nexports.getSVGElement = function (elementType, JSONcontainer, svgContainer) {\n  var element;\n  // allocate SVG element, if it doesnt yet exist, create one.\n  if (JSONcontainer.hasOwnProperty(elementType)) {\n    // this element has been created before\n    // check if there is an redundant element\n    if (JSONcontainer[elementType].redundant.length > 0) {\n      element = JSONcontainer[elementType].redundant[0];\n      JSONcontainer[elementType].redundant.shift();\n    } else {\n      // create a new element and add it to the SVG\n      element = document.createElementNS('http://www.w3.org/2000/svg', elementType);\n      svgContainer.appendChild(element);\n    }\n  } else {\n    // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.\n    element = document.createElementNS('http://www.w3.org/2000/svg', elementType);\n    JSONcontainer[elementType] = { used: [], redundant: [] };\n    svgContainer.appendChild(element);\n  }\n  JSONcontainer[elementType].used.push(element);\n  return element;\n};\n\n/**\n * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer\n * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.\n *\n * @param {string} elementType\n * @param {Object} JSONcontainer\n * @param {Element} DOMContainer\n * @param {Element} insertBefore\n * @returns {*}\n */\nexports.getDOMElement = function (elementType, JSONcontainer, DOMContainer, insertBefore) {\n  var element;\n  // allocate DOM element, if it doesnt yet exist, create one.\n  if (JSONcontainer.hasOwnProperty(elementType)) {\n    // this element has been created before\n    // check if there is an redundant element\n    if (JSONcontainer[elementType].redundant.length > 0) {\n      element = JSONcontainer[elementType].redundant[0];\n      JSONcontainer[elementType].redundant.shift();\n    } else {\n      // create a new element and add it to the SVG\n      element = document.createElement(elementType);\n      if (insertBefore !== undefined) {\n        DOMContainer.insertBefore(element, insertBefore);\n      } else {\n        DOMContainer.appendChild(element);\n      }\n    }\n  } else {\n    // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.\n    element = document.createElement(elementType);\n    JSONcontainer[elementType] = { used: [], redundant: [] };\n    if (insertBefore !== undefined) {\n      DOMContainer.insertBefore(element, insertBefore);\n    } else {\n      DOMContainer.appendChild(element);\n    }\n  }\n  JSONcontainer[elementType].used.push(element);\n  return element;\n};\n\n/**\n * Draw a point object. This is a separate function because it can also be called by the legend.\n * The reason the JSONcontainer and the target SVG svgContainer have to be supplied is so the legend can use these functions\n * as well.\n *\n * @param {number} x\n * @param {number} y\n * @param {Object} groupTemplate: A template containing the necessary information to draw the datapoint e.g., {style: 'circle', size: 5, className: 'className' }\n * @param {Object} JSONcontainer\n * @param {Object} svgContainer\n * @param {Object} labelObj\n * @returns {vis.PointItem}\n */\nexports.drawPoint = function (x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {\n  var point;\n  if (groupTemplate.style == 'circle') {\n    point = exports.getSVGElement('circle', JSONcontainer, svgContainer);\n    point.setAttributeNS(null, 'cx', x);\n    point.setAttributeNS(null, 'cy', y);\n    point.setAttributeNS(null, 'r', 0.5 * groupTemplate.size);\n  } else {\n    point = exports.getSVGElement('rect', JSONcontainer, svgContainer);\n    point.setAttributeNS(null, 'x', x - 0.5 * groupTemplate.size);\n    point.setAttributeNS(null, 'y', y - 0.5 * groupTemplate.size);\n    point.setAttributeNS(null, 'width', groupTemplate.size);\n    point.setAttributeNS(null, 'height', groupTemplate.size);\n  }\n\n  if (groupTemplate.styles !== undefined) {\n    point.setAttributeNS(null, 'style', groupTemplate.styles);\n  }\n  point.setAttributeNS(null, 'class', groupTemplate.className + ' vis-point');\n  //handle label\n\n  if (labelObj) {\n    var label = exports.getSVGElement('text', JSONcontainer, svgContainer);\n    if (labelObj.xOffset) {\n      x = x + labelObj.xOffset;\n    }\n\n    if (labelObj.yOffset) {\n      y = y + labelObj.yOffset;\n    }\n    if (labelObj.content) {\n      label.textContent = labelObj.content;\n    }\n\n    if (labelObj.className) {\n      label.setAttributeNS(null, 'class', labelObj.className + ' vis-label');\n    }\n    label.setAttributeNS(null, 'x', x);\n    label.setAttributeNS(null, 'y', y);\n  }\n\n  return point;\n};\n\n/**\n * draw a bar SVG element centered on the X coordinate\n *\n * @param {number} x\n * @param {number} y\n * @param {number} width\n * @param {number} height\n * @param {string} className\n * @param {Object} JSONcontainer\n * @param {Object} svgContainer\n * @param {string} style\n */\nexports.drawBar = function (x, y, width, height, className, JSONcontainer, svgContainer, style) {\n  if (height != 0) {\n    if (height < 0) {\n      height *= -1;\n      y -= height;\n    }\n    var rect = exports.getSVGElement('rect', JSONcontainer, svgContainer);\n    rect.setAttributeNS(null, 'x', x - 0.5 * width);\n    rect.setAttributeNS(null, 'y', y);\n    rect.setAttributeNS(null, 'width', width);\n    rect.setAttributeNS(null, 'height', height);\n    rect.setAttributeNS(null, 'class', className);\n    if (style) {\n      rect.setAttributeNS(null, 'style', style);\n    }\n  }\n};\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __nested_webpack_require_568470__) {\n\nvar core = __nested_webpack_require_568470__(6);\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __nested_webpack_require_568787__) {\n\n\"use strict\";\n\n\n// Load custom shapes into CanvasRenderingContext2D\n__nested_webpack_require_568787__(125);\n\nvar Emitter = __nested_webpack_require_568787__(73);\nvar util = __nested_webpack_require_568787__(2);\nvar dotparser = __nested_webpack_require_568787__(74);\nvar gephiParser = __nested_webpack_require_568787__(75);\nvar Activator = __nested_webpack_require_568787__(126);\nvar locales = __nested_webpack_require_568787__(129);\n\nvar Images = __nested_webpack_require_568787__(76)['default'];\nvar Groups = __nested_webpack_require_568787__(134)['default'];\nvar NodesHandler = __nested_webpack_require_568787__(135)['default'];\nvar EdgesHandler = __nested_webpack_require_568787__(165)['default'];\nvar PhysicsEngine = __nested_webpack_require_568787__(171)['default'];\nvar ClusterEngine = __nested_webpack_require_568787__(178)['default'];\nvar CanvasRenderer = __nested_webpack_require_568787__(180)['default'];\nvar Canvas = __nested_webpack_require_568787__(181)['default'];\nvar View = __nested_webpack_require_568787__(182)['default'];\nvar InteractionHandler = __nested_webpack_require_568787__(183)['default'];\nvar SelectionHandler = __nested_webpack_require_568787__(186)['default'];\nvar LayoutEngine = __nested_webpack_require_568787__(187)['default'];\nvar ManipulationSystem = __nested_webpack_require_568787__(190)['default'];\nvar Configurator = __nested_webpack_require_568787__(191)['default'];\nvar Validator = __nested_webpack_require_568787__(54)['default'];\n\nvar _require = __nested_webpack_require_568787__(54),\n    printStyle = _require.printStyle;\n\nvar _require2 = __nested_webpack_require_568787__(84),\n    allOptions = _require2.allOptions,\n    configureOptions = _require2.configureOptions;\n\nvar KamadaKawai = __nested_webpack_require_568787__(193)['default'];\n\n/**\n * Create a network visualization, displaying nodes and edges.\n *\n * @param {Element} container   The DOM element in which the Network will\n *                                  be created. Normally a div element.\n * @param {Object} data         An object containing parameters\n *                              {Array} nodes\n *                              {Array} edges\n * @param {Object} options      Options\n * @constructor Network\n */\nfunction Network(container, data, options) {\n  var _this = this;\n\n  if (!(this instanceof Network)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  // set constant values\n  this.options = {};\n  this.defaultOptions = {\n    locale: 'en',\n    locales: locales,\n    clickToUse: false\n  };\n  util.extend(this.options, this.defaultOptions);\n\n  /**\n   * Containers for nodes and edges.\n   *\n   * 'edges' and 'nodes' contain the full definitions of all the network elements.\n   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.\n   *\n   * The distinction is important, because a defined node need not be active, i.e.\n   * visible on the canvas. This happens in particular when clusters are defined, in\n   * that case there will be nodes and edges not displayed.\n   * The bottom line is that all code with actions related to visibility, *must* use\n   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.\n   */\n  this.body = {\n    container: container,\n\n    // See comment above for following fields\n    nodes: {},\n    nodeIndices: [],\n    edges: {},\n    edgeIndices: [],\n\n    emitter: {\n      on: this.on.bind(this),\n      off: this.off.bind(this),\n      emit: this.emit.bind(this),\n      once: this.once.bind(this)\n    },\n    eventListeners: {\n      onTap: function onTap() {},\n      onTouch: function onTouch() {},\n      onDoubleTap: function onDoubleTap() {},\n      onHold: function onHold() {},\n      onDragStart: function onDragStart() {},\n      onDrag: function onDrag() {},\n      onDragEnd: function onDragEnd() {},\n      onMouseWheel: function onMouseWheel() {},\n      onPinch: function onPinch() {},\n      onMouseMove: function onMouseMove() {},\n      onRelease: function onRelease() {},\n      onContext: function onContext() {}\n    },\n    data: {\n      nodes: null, // A DataSet or DataView\n      edges: null // A DataSet or DataView\n    },\n    functions: {\n      createNode: function createNode() {},\n      createEdge: function createEdge() {},\n      getPointer: function getPointer() {}\n    },\n    modules: {},\n    view: {\n      scale: 1,\n      translation: { x: 0, y: 0 }\n    }\n\n    // bind the event listeners\n  };this.bindEventListeners();\n\n  // setting up all modules\n  this.images = new Images(function () {\n    return _this.body.emitter.emit('_requestRedraw');\n  }); // object with images\n  this.groups = new Groups(); // object with groups\n  this.canvas = new Canvas(this.body); // DOM handler\n  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler\n  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key\n  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms\n  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into\n  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations\n  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout\n  this.clustering = new ClusterEngine(this.body); // clustering api\n  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler); // data manipulation system\n\n  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options\n  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options\n\n  this.body.modules['kamadaKawai'] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.\n  this.body.modules['clustering'] = this.clustering;\n\n  // create the DOM elements\n  this.canvas._create();\n\n  // apply options\n  this.setOptions(options);\n\n  // load data (the disable start variable will be the same as the enabled clustering)\n  this.setData(data);\n}\n\n// Extend Network with an Emitter mixin\nEmitter(Network.prototype);\n\n/**\n * Set options\n * @param {Object} options\n */\nNetwork.prototype.setOptions = function (options) {\n  var _this2 = this;\n\n  if (options === null) {\n    options = undefined; // This ensures that options handling doesn't crash in the handling\n  }\n\n  if (options !== undefined) {\n    var errorFound = Validator.validate(options, allOptions);\n    if (errorFound === true) {\n      console.log('%cErrors have been found in the supplied options object.', printStyle);\n    }\n\n    // copy the global fields over\n    var fields = ['locale', 'locales', 'clickToUse'];\n    util.selectiveDeepExtend(fields, this.options, options);\n\n    // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.\n    options = this.layoutEngine.setOptions(options.layout, options);\n\n    this.canvas.setOptions(options); // options for canvas are in globals\n\n    // pass the options to the modules\n    this.groups.setOptions(options.groups);\n    this.nodesHandler.setOptions(options.nodes);\n    this.edgesHandler.setOptions(options.edges);\n    this.physics.setOptions(options.physics);\n    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals\n\n    this.interactionHandler.setOptions(options.interaction);\n    this.renderer.setOptions(options.interaction); // options for rendering are in interaction\n    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction\n\n    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.\n    if (options.groups !== undefined) {\n      this.body.emitter.emit('refreshNodes');\n    }\n    // these two do not have options at the moment, here for completeness\n    //this.view.setOptions(options.view);\n    //this.clustering.setOptions(options.clustering);\n\n    if ('configure' in options) {\n      if (!this.configurator) {\n        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio);\n      }\n\n      this.configurator.setOptions(options.configure);\n    }\n\n    // if the configuration system is enabled, copy all options and put them into the config system\n    if (this.configurator && this.configurator.options.enabled === true) {\n      var networkOptions = {\n        nodes: {},\n        edges: {},\n        layout: {},\n        interaction: {},\n        manipulation: {},\n        physics: {},\n        global: {}\n      };\n      util.deepExtend(networkOptions.nodes, this.nodesHandler.options);\n      util.deepExtend(networkOptions.edges, this.edgesHandler.options);\n      util.deepExtend(networkOptions.layout, this.layoutEngine.options);\n      // load the selectionHandler and render default options in to the interaction group\n      util.deepExtend(networkOptions.interaction, this.selectionHandler.options);\n      util.deepExtend(networkOptions.interaction, this.renderer.options);\n\n      util.deepExtend(networkOptions.interaction, this.interactionHandler.options);\n      util.deepExtend(networkOptions.manipulation, this.manipulation.options);\n      util.deepExtend(networkOptions.physics, this.physics.options);\n\n      // load globals into the global object\n      util.deepExtend(networkOptions.global, this.canvas.options);\n      util.deepExtend(networkOptions.global, this.options);\n\n      this.configurator.setModuleOptions(networkOptions);\n    }\n\n    // handle network global options\n    if (options.clickToUse !== undefined) {\n      if (options.clickToUse === true) {\n        if (this.activator === undefined) {\n          this.activator = new Activator(this.canvas.frame);\n          this.activator.on('change', function () {\n            _this2.body.emitter.emit('activate');\n          });\n        }\n      } else {\n        if (this.activator !== undefined) {\n          this.activator.destroy();\n          delete this.activator;\n        }\n        this.body.emitter.emit('activate');\n      }\n    } else {\n      this.body.emitter.emit('activate');\n    }\n\n    this.canvas.setSize();\n    // start the physics simulation. Can be safely called multiple times.\n    this.body.emitter.emit('startSimulation');\n  }\n};\n\n/**\n * Update the visible nodes and edges list with the most recent node state.\n *\n * Visible nodes are stored in this.body.nodeIndices.\n * Visible edges are stored in this.body.edgeIndices.\n * A node or edges is visible if it is not hidden or clustered.\n *\n * @private\n */\nNetwork.prototype._updateVisibleIndices = function () {\n  var nodes = this.body.nodes;\n  var edges = this.body.edges;\n  this.body.nodeIndices = [];\n  this.body.edgeIndices = [];\n\n  for (var nodeId in nodes) {\n    if (nodes.hasOwnProperty(nodeId)) {\n      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {\n        this.body.nodeIndices.push(nodes[nodeId].id);\n      }\n    }\n  }\n\n  for (var edgeId in edges) {\n    if (edges.hasOwnProperty(edgeId)) {\n      var edge = edges[edgeId];\n\n      // It can happen that this is executed *after* a node edge has been removed,\n      // but *before* the edge itself has been removed. Taking this into account.\n      var fromNode = nodes[edge.fromId];\n      var toNode = nodes[edge.toId];\n      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;\n\n      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && // Also hidden if any of its connecting nodes are hidden\n      toNode.options.hidden === false; // idem\n\n      if (isVisible) {\n        this.body.edgeIndices.push(edge.id);\n      }\n    }\n  }\n};\n\n/**\n * Bind all events\n */\nNetwork.prototype.bindEventListeners = function () {\n  var _this3 = this;\n\n  // This event will trigger a rebuilding of the cache everything.\n  // Used when nodes or edges have been added or removed.\n  this.body.emitter.on('_dataChanged', function () {\n    _this3.edgesHandler._updateState();\n    _this3.body.emitter.emit('_dataUpdated');\n  });\n\n  // this is called when options of EXISTING nodes or edges have changed.\n  this.body.emitter.on('_dataUpdated', function () {\n    // Order important in following block\n    _this3.clustering._updateState();\n    _this3._updateVisibleIndices();\n\n    _this3._updateValueRange(_this3.body.nodes);\n    _this3._updateValueRange(_this3.body.edges);\n    // start simulation (can be called safely, even if already running)\n    _this3.body.emitter.emit('startSimulation');\n    _this3.body.emitter.emit('_requestRedraw');\n  });\n};\n\n/**\n * Set nodes and edges, and optionally options as well.\n *\n * @param {Object} data              Object containing parameters:\n *                                   {Array | DataSet | DataView} [nodes] Array with nodes\n *                                   {Array | DataSet | DataView} [edges] Array with edges\n *                                   {String} [dot] String containing data in DOT format\n *                                   {String} [gephi] String containing data in gephi JSON format\n *                                   {Options} [options] Object with options\n */\nNetwork.prototype.setData = function (data) {\n  // reset the physics engine.\n  this.body.emitter.emit('resetPhysics');\n  this.body.emitter.emit('_resetData');\n\n  // unselect all to ensure no selections from old data are carried over.\n  this.selectionHandler.unselectAll();\n\n  if (data && data.dot && (data.nodes || data.edges)) {\n    throw new SyntaxError('Data must contain either parameter \"dot\" or ' + ' parameter pair \"nodes\" and \"edges\", but not both.');\n  }\n\n  // set options\n  this.setOptions(data && data.options);\n  // set all data\n  if (data && data.dot) {\n    console.log('The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);');\n    // parse DOT file\n    var dotData = dotparser.DOTToGraph(data.dot);\n    this.setData(dotData);\n    return;\n  } else if (data && data.gephi) {\n    // parse DOT file\n    console.log('The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);');\n    var gephiData = gephiParser.parseGephi(data.gephi);\n    this.setData(gephiData);\n    return;\n  } else {\n    this.nodesHandler.setData(data && data.nodes, true);\n    this.edgesHandler.setData(data && data.edges, true);\n  }\n\n  // emit change in data\n  this.body.emitter.emit('_dataChanged');\n\n  // emit data loaded\n  this.body.emitter.emit('_dataLoaded');\n\n  // find a stable position or start animating to a stable position\n  this.body.emitter.emit('initPhysics');\n};\n\n/**\n * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.\n * var network = new vis.Network(..);\n * network.destroy();\n * network = null;\n */\nNetwork.prototype.destroy = function () {\n  this.body.emitter.emit('destroy');\n  // clear events\n  this.body.emitter.off();\n  this.off();\n\n  // delete modules\n  delete this.groups;\n  delete this.canvas;\n  delete this.selectionHandler;\n  delete this.interactionHandler;\n  delete this.view;\n  delete this.renderer;\n  delete this.physics;\n  delete this.layoutEngine;\n  delete this.clustering;\n  delete this.manipulation;\n  delete this.nodesHandler;\n  delete this.edgesHandler;\n  delete this.configurator;\n  delete this.images;\n\n  for (var nodeId in this.body.nodes) {\n    if (!this.body.nodes.hasOwnProperty(nodeId)) continue;\n    delete this.body.nodes[nodeId];\n  }\n\n  for (var edgeId in this.body.edges) {\n    if (!this.body.edges.hasOwnProperty(edgeId)) continue;\n    delete this.body.edges[edgeId];\n  }\n\n  // remove the container and everything inside it recursively\n  util.recursiveDOMDelete(this.body.container);\n};\n\n/**\n * Update the values of all object in the given array according to the current\n * value range of the objects in the array.\n * @param {Object} obj    An object containing a set of Edges or Nodes\n *                        The objects must have a method getValue() and\n *                        setValueRange(min, max).\n * @private\n */\nNetwork.prototype._updateValueRange = function (obj) {\n  var id;\n\n  // determine the range of the objects\n  var valueMin = undefined;\n  var valueMax = undefined;\n  var valueTotal = 0;\n  for (id in obj) {\n    if (obj.hasOwnProperty(id)) {\n      var value = obj[id].getValue();\n      if (value !== undefined) {\n        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);\n        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);\n        valueTotal += value;\n      }\n    }\n  }\n\n  // adjust the range of all objects\n  if (valueMin !== undefined && valueMax !== undefined) {\n    for (id in obj) {\n      if (obj.hasOwnProperty(id)) {\n        obj[id].setValueRange(valueMin, valueMax, valueTotal);\n      }\n    }\n  }\n};\n\n/**\n * Returns true when the Network is active.\n * @returns {boolean}\n */\nNetwork.prototype.isActive = function () {\n  return !this.activator || this.activator.active;\n};\n\nNetwork.prototype.setSize = function () {\n  return this.canvas.setSize.apply(this.canvas, arguments);\n};\nNetwork.prototype.canvasToDOM = function () {\n  return this.canvas.canvasToDOM.apply(this.canvas, arguments);\n};\nNetwork.prototype.DOMtoCanvas = function () {\n  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);\n};\n\n/**\n * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of\n * nodeIds showing where the node is.\n *\n * If any nodeId in the chain, especially the first passed in as a parameter, is not present in\n * the current nodes list, an empty array is returned.\n *\n * Example:\n * cluster 'A' contains cluster 'B',\n * cluster 'B' contains cluster 'C',\n * cluster 'C' contains node 'fred'.\n * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.\n *\n * @param {string|number} nodeId\n * @returns {Array}\n */\nNetwork.prototype.findNode = function () {\n  return this.clustering.findNode.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.isCluster = function () {\n  return this.clustering.isCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.openCluster = function () {\n  return this.clustering.openCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.cluster = function () {\n  return this.clustering.cluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.getNodesInCluster = function () {\n  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByConnection = function () {\n  return this.clustering.clusterByConnection.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByHubsize = function () {\n  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);\n};\n\n/**\n * This method will cluster all nodes with 1 edge with their respective connected node.\n * The options object is explained in full <a data-scroll=\"\" data-options=\"{ &quot;easing&quot;: &quot;easeInCubic&quot; }\" href=\"#optionsObject\">below</a>.\n *\n * @param {object} [options]\n * @returns {undefined}\n */\nNetwork.prototype.clusterOutliers = function () {\n  return this.clustering.clusterOutliers.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.getSeed = function () {\n  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);\n};\nNetwork.prototype.enableEditMode = function () {\n  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.disableEditMode = function () {\n  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addNodeMode = function () {\n  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNode = function () {\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNodeMode = function () {\n  console.log('Deprecated: Please use editNode instead of editNodeMode.');\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addEdgeMode = function () {\n  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editEdgeMode = function () {\n  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.deleteSelected = function () {\n  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);\n};\nNetwork.prototype.getPositions = function () {\n  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.storePositions = function () {\n  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.moveNode = function () {\n  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getBoundingBox = function () {\n  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getConnectedNodes = function (objectId) {\n  if (this.body.nodes[objectId] !== undefined) {\n    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);\n  } else {\n    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);\n  }\n};\nNetwork.prototype.getConnectedEdges = function () {\n  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.startSimulation = function () {\n  return this.physics.startSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stopSimulation = function () {\n  return this.physics.stopSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stabilize = function () {\n  return this.physics.stabilize.apply(this.physics, arguments);\n};\nNetwork.prototype.getSelection = function () {\n  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.setSelection = function () {\n  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedNodes = function () {\n  return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedEdges = function () {\n  return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getNodeAt = function () {\n  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);\n  if (node !== undefined && node.id !== undefined) {\n    return node.id;\n  }\n  return node;\n};\nNetwork.prototype.getEdgeAt = function () {\n  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);\n  if (edge !== undefined && edge.id !== undefined) {\n    return edge.id;\n  }\n  return edge;\n};\nNetwork.prototype.selectNodes = function () {\n  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.selectEdges = function () {\n  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.unselectAll = function () {\n  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);\n  this.redraw();\n};\nNetwork.prototype.redraw = function () {\n  return this.renderer.redraw.apply(this.renderer, arguments);\n};\nNetwork.prototype.getScale = function () {\n  return this.view.getScale.apply(this.view, arguments);\n};\nNetwork.prototype.getViewPosition = function () {\n  return this.view.getViewPosition.apply(this.view, arguments);\n};\nNetwork.prototype.fit = function () {\n  return this.view.fit.apply(this.view, arguments);\n};\nNetwork.prototype.moveTo = function () {\n  return this.view.moveTo.apply(this.view, arguments);\n};\nNetwork.prototype.focus = function () {\n  return this.view.focus.apply(this.view, arguments);\n};\nNetwork.prototype.releaseNode = function () {\n  return this.view.releaseNode.apply(this.view, arguments);\n};\nNetwork.prototype.getOptionsFromConfigurator = function () {\n  var options = {};\n  if (this.configurator) {\n    options = this.configurator.getOptions.apply(this.configurator);\n  }\n  return options;\n};\n\nmodule.exports = Network;\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Canvas shapes used by Network\n */\nif (typeof CanvasRenderingContext2D !== 'undefined') {\n  /**\n   * Draw a circle shape\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} r\n   */\n  CanvasRenderingContext2D.prototype.circle = function (x, y, r) {\n    this.beginPath();\n    this.arc(x, y, r, 0, 2 * Math.PI, false);\n    this.closePath();\n  };\n\n  /**\n   * Draw a square shape\n   * @param {number} x horizontal center\n   * @param {number} y vertical center\n   * @param {number} r   size, width and height of the square\n   */\n  CanvasRenderingContext2D.prototype.square = function (x, y, r) {\n    this.beginPath();\n    this.rect(x - r, y - r, r * 2, r * 2);\n    this.closePath();\n  };\n\n  /**\n   * Draw a triangle shape\n   * @param {number} x horizontal center\n   * @param {number} y vertical center\n   * @param {number} r   radius, half the length of the sides of the triangle\n   */\n  CanvasRenderingContext2D.prototype.triangle = function (x, y, r) {\n    // http://en.wikipedia.org/wiki/Equilateral_triangle\n    this.beginPath();\n\n    // the change in radius and the offset is here to center the shape\n    r *= 1.15;\n    y += 0.275 * r;\n\n    var s = r * 2;\n    var s2 = s / 2;\n    var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n    var h = Math.sqrt(s * s - s2 * s2); // height\n\n    this.moveTo(x, y - (h - ir));\n    this.lineTo(x + s2, y + ir);\n    this.lineTo(x - s2, y + ir);\n    this.lineTo(x, y - (h - ir));\n    this.closePath();\n  };\n\n  /**\n   * Draw a triangle shape in downward orientation\n   * @param {number} x horizontal center\n   * @param {number} y vertical center\n   * @param {number} r radius\n   */\n  CanvasRenderingContext2D.prototype.triangleDown = function (x, y, r) {\n    // http://en.wikipedia.org/wiki/Equilateral_triangle\n    this.beginPath();\n\n    // the change in radius and the offset is here to center the shape\n    r *= 1.15;\n    y -= 0.275 * r;\n\n    var s = r * 2;\n    var s2 = s / 2;\n    var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n    var h = Math.sqrt(s * s - s2 * s2); // height\n\n    this.moveTo(x, y + (h - ir));\n    this.lineTo(x + s2, y - ir);\n    this.lineTo(x - s2, y - ir);\n    this.lineTo(x, y + (h - ir));\n    this.closePath();\n  };\n\n  /**\n   * Draw a star shape, a star with 5 points\n   * @param {number} x horizontal center\n   * @param {number} y vertical center\n   * @param {number} r   radius, half the length of the sides of the triangle\n   */\n  CanvasRenderingContext2D.prototype.star = function (x, y, r) {\n    // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\n    this.beginPath();\n\n    // the change in radius and the offset is here to center the shape\n    r *= 0.82;\n    y += 0.1 * r;\n\n    for (var n = 0; n < 10; n++) {\n      var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;\n      this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));\n    }\n\n    this.closePath();\n  };\n\n  /**\n   * Draw a Diamond shape\n   * @param {number} x horizontal center\n   * @param {number} y vertical center\n   * @param {number} r   radius, half the length of the sides of the triangle\n   */\n  CanvasRenderingContext2D.prototype.diamond = function (x, y, r) {\n    // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\n    this.beginPath();\n\n    this.lineTo(x, y + r);\n    this.lineTo(x + r, y);\n    this.lineTo(x, y - r);\n    this.lineTo(x - r, y);\n\n    this.closePath();\n  };\n\n  /**\n   * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} w\n   * @param {number} h\n   * @param {number} r\n   */\n  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {\n    var r2d = Math.PI / 180;\n    if (w - 2 * r < 0) {\n      r = w / 2;\n    } //ensure that the radius isn't too large for x\n    if (h - 2 * r < 0) {\n      r = h / 2;\n    } //ensure that the radius isn't too large for y\n    this.beginPath();\n    this.moveTo(x + r, y);\n    this.lineTo(x + w - r, y);\n    this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);\n    this.lineTo(x + w, y + h - r);\n    this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);\n    this.lineTo(x + r, y + h);\n    this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);\n    this.lineTo(x, y + r);\n    this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);\n    this.closePath();\n  };\n\n  /**\n   * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n   *\n   * Postfix '_vis' added to discern it from standard method ellipse().\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} w\n   * @param {number} h\n   */\n  CanvasRenderingContext2D.prototype.ellipse_vis = function (x, y, w, h) {\n    var kappa = 0.5522848,\n        ox = w / 2 * kappa,\n        // control point offset horizontal\n    oy = h / 2 * kappa,\n        // control point offset vertical\n    xe = x + w,\n        // x-end\n    ye = y + h,\n        // y-end\n    xm = x + w / 2,\n        // x-middle\n    ym = y + h / 2; // y-middle\n\n    this.beginPath();\n    this.moveTo(x, ym);\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    this.closePath();\n  };\n\n  /**\n   * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} w\n   * @param {number} h\n   */\n  CanvasRenderingContext2D.prototype.database = function (x, y, w, h) {\n    var f = 1 / 3;\n    var wEllipse = w;\n    var hEllipse = h * f;\n\n    var kappa = 0.5522848,\n        ox = wEllipse / 2 * kappa,\n        // control point offset horizontal\n    oy = hEllipse / 2 * kappa,\n        // control point offset vertical\n    xe = x + wEllipse,\n        // x-end\n    ye = y + hEllipse,\n        // y-end\n    xm = x + wEllipse / 2,\n        // x-middle\n    ym = y + hEllipse / 2,\n        // y-middle\n    ymb = y + (h - hEllipse / 2),\n        // y-midlle, bottom ellipse\n    yeb = y + h; // y-end, bottom ellipse\n\n    this.beginPath();\n    this.moveTo(xe, ym);\n\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n\n    this.lineTo(xe, ymb);\n\n    this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);\n    this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);\n\n    this.lineTo(x, ym);\n  };\n\n  /**\n   * Sets up the dashedLine functionality for drawing\n   * Original code came from http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\n   * @author David Jordan\n   * @date 2012-08-08\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} x2\n   * @param {number} y2\n   * @param {string} pattern\n   */\n  CanvasRenderingContext2D.prototype.dashedLine = function (x, y, x2, y2, pattern) {\n    this.beginPath();\n    this.moveTo(x, y);\n\n    var patternLength = pattern.length;\n    var dx = x2 - x;\n    var dy = y2 - y;\n    var slope = dy / dx;\n    var distRemaining = Math.sqrt(dx * dx + dy * dy);\n    var patternIndex = 0;\n    var draw = true;\n    var xStep = 0;\n    var dashLength = pattern[0];\n\n    while (distRemaining >= 0.1) {\n      dashLength = pattern[patternIndex++ % patternLength];\n      if (dashLength > distRemaining) {\n        dashLength = distRemaining;\n      }\n\n      xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));\n      xStep = dx < 0 ? -xStep : xStep;\n      x += xStep;\n      y += slope * xStep;\n\n      if (draw === true) {\n        this.lineTo(x, y);\n      } else {\n        this.moveTo(x, y);\n      }\n\n      distRemaining -= dashLength;\n      draw = !draw;\n    }\n  };\n\n  /**\n   * Draw a Hexagon shape with 6 sides\n   * @param {Number} x horizontal center\n   * @param {Number} y vertical center\n   * @param {Number} r   radius\n   */\n  CanvasRenderingContext2D.prototype.hexagon = function (x, y, r) {\n    this.beginPath();\n    var sides = 6;\n    var a = Math.PI * 2 / sides;\n    this.moveTo(x + r, y);\n    for (var i = 1; i < sides; i++) {\n      this.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));\n    }\n    this.closePath();\n  };\n}\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __nested_webpack_require_601667__) {\n\n\"use strict\";\n\n\nvar keycharm = __nested_webpack_require_601667__(52);\nvar Emitter = __nested_webpack_require_601667__(73);\nvar Hammer = __nested_webpack_require_601667__(24);\nvar util = __nested_webpack_require_601667__(2);\n\n/**\n * Turn an element into an clickToUse element.\n * When not active, the element has a transparent overlay. When the overlay is\n * clicked, the mode is changed to active.\n * When active, the element is displayed with a blue border around it, and\n * the interactive contents of the element can be used. When clicked outside\n * the element, the elements mode is changed to inactive.\n * @param {Element} container\n * @constructor Activator\n */\nfunction Activator(container) {\n  this.active = false;\n\n  this.dom = {\n    container: container\n  };\n\n  this.dom.overlay = document.createElement('div');\n  this.dom.overlay.className = 'vis-overlay';\n\n  this.dom.container.appendChild(this.dom.overlay);\n\n  this.hammer = Hammer(this.dom.overlay);\n  this.hammer.on('tap', this._onTapOverlay.bind(this));\n\n  // block all touch events (except tap)\n  var me = this;\n  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];\n  events.forEach(function (event) {\n    me.hammer.on(event, function (event) {\n      event.stopPropagation();\n    });\n  });\n\n  // attach a click event to the window, in order to deactivate when clicking outside the timeline\n  if (document && document.body) {\n    this.onClick = function (event) {\n      if (!_hasParent(event.target, container)) {\n        me.deactivate();\n      }\n    };\n    document.body.addEventListener('click', this.onClick);\n  }\n\n  if (this.keycharm !== undefined) {\n    this.keycharm.destroy();\n  }\n  this.keycharm = keycharm();\n\n  // keycharm listener only bounded when active)\n  this.escListener = this.deactivate.bind(this);\n}\n\n// turn into an event emitter\nEmitter(Activator.prototype);\n\n// The currently active activator\nActivator.current = null;\n\n/**\n * Destroy the activator. Cleans up all created DOM and event listeners\n */\nActivator.prototype.destroy = function () {\n  this.deactivate();\n\n  // remove dom\n  this.dom.overlay.parentNode.removeChild(this.dom.overlay);\n\n  // remove global event listener\n  if (this.onClick) {\n    document.body.removeEventListener('click', this.onClick);\n  }\n  // remove keycharm\n  if (this.keycharm !== undefined) {\n    this.keycharm.destroy();\n  }\n  this.keycharm = null;\n  // cleanup hammer instances\n  this.hammer.destroy();\n  this.hammer = null;\n  // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)\n};\n\n/**\n * Activate the element\n * Overlay is hidden, element is decorated with a blue shadow border\n */\nActivator.prototype.activate = function () {\n  // we allow only one active activator at a time\n  if (Activator.current) {\n    Activator.current.deactivate();\n  }\n  Activator.current = this;\n\n  this.active = true;\n  this.dom.overlay.style.display = 'none';\n  util.addClassName(this.dom.container, 'vis-active');\n\n  this.emit('change');\n  this.emit('activate');\n\n  // ugly hack: bind ESC after emitting the events, as the Network rebinds all\n  // keyboard events on a 'change' event\n  this.keycharm.bind('esc', this.escListener);\n};\n\n/**\n * Deactivate the element\n * Overlay is displayed on top of the element\n */\nActivator.prototype.deactivate = function () {\n  this.active = false;\n  this.dom.overlay.style.display = '';\n  util.removeClassName(this.dom.container, 'vis-active');\n  this.keycharm.unbind('esc', this.escListener);\n\n  this.emit('change');\n  this.emit('deactivate');\n};\n\n/**\n * Handle a tap event: activate the container\n * @param {Event}  event   The event\n * @private\n */\nActivator.prototype._onTapOverlay = function (event) {\n  // activate the container\n  this.activate();\n  event.stopPropagation();\n};\n\n/**\n * Test whether the element has the requested parent element somewhere in\n * its chain of parent nodes.\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @returns {boolean} Returns true when the parent is found somewhere in the\n *                    chain of parent nodes.\n * @private\n */\nfunction _hasParent(element, parent) {\n  while (element) {\n    if (element === parent) {\n      return true;\n    }\n    element = element.parentNode;\n  }\n  return false;\n}\n\nmodule.exports = Activator;\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n(function (factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(function () {\n  var _firstTarget = null; // singleton, will contain the target element where the touch event started\n\n  /**\n   * Extend an Hammer.js instance with event propagation.\n   *\n   * Features:\n   * - Events emitted by hammer will propagate in order from child to parent\n   *   elements.\n   * - Events are extended with a function `event.stopPropagation()` to stop\n   *   propagation to parent elements.\n   * - An option `preventDefault` to stop all default browser behavior.\n   *\n   * Usage:\n   *   var hammer = propagatingHammer(new Hammer(element));\n   *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});\n   *\n   * @param {Hammer.Manager} hammer   An hammer instance.\n   * @param {Object} [options]        Available options:\n   *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.\n   *                                    Enforce preventing the default browser behavior.\n   *                                    Cannot be set to `false`.\n   * @return {Hammer.Manager} Returns the same hammer instance with extended\n   *                          functionality\n   */\n  return function propagating(hammer, options) {\n    var _options = options || {\n      preventDefault: false\n    };\n\n    if (hammer.Manager) {\n      // This looks like the Hammer constructor.\n      // Overload the constructors with our own.\n      var Hammer = hammer;\n\n      var PropagatingHammer = function(element, options) {\n        var o = Object.create(_options);\n        if (options) Hammer.assign(o, options);\n        return propagating(new Hammer(element, o), o);\n      };\n      Hammer.assign(PropagatingHammer, Hammer);\n\n      PropagatingHammer.Manager = function (element, options) {\n        var o = Object.create(_options);\n        if (options) Hammer.assign(o, options);\n        return propagating(new Hammer.Manager(element, o), o);\n      };\n\n      return PropagatingHammer;\n    }\n\n    // create a wrapper object which will override the functions\n    // `on`, `off`, `destroy`, and `emit` of the hammer instance\n    var wrapper = Object.create(hammer);\n\n    // attach to DOM element\n    var element = hammer.element;\n\n    if(!element.hammer) element.hammer = [];\n    element.hammer.push(wrapper);\n\n    // register an event to catch the start of a gesture and store the\n    // target in a singleton\n    hammer.on('hammer.input', function (event) {\n      if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {\n        event.preventDefault();\n      }\n      if (event.isFirst) {\n        _firstTarget = event.target;\n      }\n    });\n\n    /** @type {Object.<String, Array.<function>>} */\n    wrapper._handlers = {};\n\n    /**\n     * Register a handler for one or multiple events\n     * @param {String} events    A space separated string with events\n     * @param {function} handler A callback function, called as handler(event)\n     * @returns {Hammer.Manager} Returns the hammer instance\n     */\n    wrapper.on = function (events, handler) {\n      // register the handler\n      split(events).forEach(function (event) {\n        var _handlers = wrapper._handlers[event];\n        if (!_handlers) {\n          wrapper._handlers[event] = _handlers = [];\n\n          // register the static, propagated handler\n          hammer.on(event, propagatedHandler);\n        }\n        _handlers.push(handler);\n      });\n\n      return wrapper;\n    };\n\n    /**\n     * Unregister a handler for one or multiple events\n     * @param {String} events      A space separated string with events\n     * @param {function} [handler] Optional. The registered handler. If not\n     *                             provided, all handlers for given events\n     *                             are removed.\n     * @returns {Hammer.Manager}   Returns the hammer instance\n     */\n    wrapper.off = function (events, handler) {\n      // unregister the handler\n      split(events).forEach(function (event) {\n        var _handlers = wrapper._handlers[event];\n        if (_handlers) {\n          _handlers = handler ? _handlers.filter(function (h) {\n            return h !== handler;\n          }) : [];\n\n          if (_handlers.length > 0) {\n            wrapper._handlers[event] = _handlers;\n          }\n          else {\n            // remove static, propagated handler\n            hammer.off(event, propagatedHandler);\n            delete wrapper._handlers[event];\n          }\n        }\n      });\n\n      return wrapper;\n    };\n\n    /**\n     * Emit to the event listeners\n     * @param {string} eventType\n     * @param {Event} event\n     */\n    wrapper.emit = function(eventType, event) {\n      _firstTarget = event.target;\n      hammer.emit(eventType, event);\n    };\n\n    wrapper.destroy = function () {\n      // Detach from DOM element\n      var hammers = hammer.element.hammer;\n      var idx = hammers.indexOf(wrapper);\n      if(idx !== -1) hammers.splice(idx,1);\n      if(!hammers.length) delete hammer.element.hammer;\n\n      // clear all handlers\n      wrapper._handlers = {};\n\n      // call original hammer destroy\n      hammer.destroy();\n    };\n\n    // split a string with space separated words\n    function split(events) {\n      return events.match(/[^ ]+/g);\n    }\n\n    /**\n     * A static event handler, applying event propagation.\n     * @param {Object} event\n     */\n    function propagatedHandler(event) {\n      // let only a single hammer instance handle this event\n      if (event.type !== 'hammer.input') {\n        // it is possible that the same srcEvent is used with multiple hammer events,\n        // we keep track on which events are handled in an object _handled\n        if (!event.srcEvent._handled) {\n          event.srcEvent._handled = {};\n        }\n\n        if (event.srcEvent._handled[event.type]) {\n          return;\n        }\n        else {\n          event.srcEvent._handled[event.type] = true;\n        }\n      }\n\n      // attach a stopPropagation function to the event\n      var stopped = false;\n      event.stopPropagation = function () {\n        stopped = true;\n      };\n\n      //wrap the srcEvent's stopPropagation to also stop hammer propagation:\n      var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);\n      if(typeof srcStop == \"function\") {\n        event.srcEvent.stopPropagation = function(){\n          srcStop();\n          event.stopPropagation();\n        }\n      }\n\n      // attach firstTarget property to the event\n      event.firstTarget = _firstTarget;\n\n      // propagate over all elements (until stopped)\n      var elem = _firstTarget;\n      while (elem && !stopped) {\n        var elemHammer = elem.hammer;\n        if(elemHammer){\n          var _handlers;\n          for(var k = 0; k < elemHammer.length; k++){\n            _handlers = elemHammer[k]._handlers[event.type];\n            if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {\n              _handlers[i](event);\n            }\n          }\n        }\n        elem = elem.parentNode;\n      }\n    }\n\n    return wrapper;\n  };\n}));\n\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __nested_webpack_require_613978__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return Hammer;\n    }).call(exports, __nested_webpack_require_613978__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n})(window, document, 'Hammer');\n\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// English\nexports['en'] = {\n  edit: 'Edit',\n  del: 'Delete selected',\n  back: 'Back',\n  addNode: 'Add Node',\n  addEdge: 'Add Edge',\n  editNode: 'Edit Node',\n  editEdge: 'Edit Edge',\n  addDescription: 'Click in an empty space to place a new node.',\n  edgeDescription: 'Click on a node and drag the edge to another node to connect them.',\n  editEdgeDescription: 'Click on the control points and drag them to a node to connect to it.',\n  createEdgeError: 'Cannot link edges to a cluster.',\n  deleteClusterError: 'Clusters cannot be deleted.',\n  editClusterError: 'Clusters cannot be edited.'\n};\nexports['en_EN'] = exports['en'];\nexports['en_US'] = exports['en'];\n\n// German\nexports['de'] = {\n  edit: 'Editieren',\n  del: 'L\\xF6sche Auswahl',\n  back: 'Zur\\xFCck',\n  addNode: 'Knoten hinzuf\\xFCgen',\n  addEdge: 'Kante hinzuf\\xFCgen',\n  editNode: 'Knoten editieren',\n  editEdge: 'Kante editieren',\n  addDescription: 'Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.',\n  edgeDescription: 'Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.',\n  editEdgeDescription: 'Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.',\n  createEdgeError: 'Es ist nicht m\\xF6glich, Kanten mit Clustern zu verbinden.',\n  deleteClusterError: 'Cluster k\\xF6nnen nicht gel\\xF6scht werden.',\n  editClusterError: 'Cluster k\\xF6nnen nicht editiert werden.'\n};\nexports['de_DE'] = exports['de'];\n\n// Spanish\nexports['es'] = {\n  edit: 'Editar',\n  del: 'Eliminar selecci\\xF3n',\n  back: '\\xC1tras',\n  addNode: 'A\\xF1adir nodo',\n  addEdge: 'A\\xF1adir arista',\n  editNode: 'Editar nodo',\n  editEdge: 'Editar arista',\n  addDescription: 'Haga clic en un lugar vac\\xEDo para colocar un nuevo nodo.',\n  edgeDescription: 'Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.',\n  editEdgeDescription: 'Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.',\n  createEdgeError: 'No se puede conectar una arista a un grupo.',\n  deleteClusterError: 'No es posible eliminar grupos.',\n  editClusterError: 'No es posible editar grupos.'\n};\nexports['es_ES'] = exports['es'];\n\n//Italiano\nexports['it'] = {\n  edit: 'Modifica',\n  del: 'Cancella la selezione',\n  back: 'Indietro',\n  addNode: 'Aggiungi un nodo',\n  addEdge: 'Aggiungi un vertice',\n  editNode: 'Modifica il nodo',\n  editEdge: 'Modifica il vertice',\n  addDescription: 'Clicca per aggiungere un nuovo nodo',\n  edgeDescription: 'Clicca su un nodo e trascinalo ad un altro nodo per connetterli.',\n  editEdgeDescription: 'Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.',\n  createEdgeError: 'Non si possono collegare vertici ad un cluster',\n  deleteClusterError: 'I cluster non possono essere cancellati',\n  editClusterError: 'I clusters non possono essere modificati.'\n};\nexports['it_IT'] = exports['it'];\n\n// Dutch\nexports['nl'] = {\n  edit: 'Wijzigen',\n  del: 'Selectie verwijderen',\n  back: 'Terug',\n  addNode: 'Node toevoegen',\n  addEdge: 'Link toevoegen',\n  editNode: 'Node wijzigen',\n  editEdge: 'Link wijzigen',\n  addDescription: 'Klik op een leeg gebied om een nieuwe node te maken.',\n  edgeDescription: 'Klik op een node en sleep de link naar een andere node om ze te verbinden.',\n  editEdgeDescription: 'Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.',\n  createEdgeError: 'Kan geen link maken naar een cluster.',\n  deleteClusterError: 'Clusters kunnen niet worden verwijderd.',\n  editClusterError: 'Clusters kunnen niet worden aangepast.'\n};\nexports['nl_NL'] = exports['nl'];\nexports['nl_BE'] = exports['nl'];\n\n// Portuguese Brazil\nexports['pt-br'] = {\n  edit: 'Editar',\n  del: 'Remover selecionado',\n  back: 'Voltar',\n  addNode: 'Adicionar n',\n  addEdge: 'Adicionar aresta',\n  editNode: 'Editar n',\n  editEdge: 'Editar aresta',\n  addDescription: 'Clique em um espao em branco para adicionar um novo n',\n  edgeDescription: 'Clique em um n e arraste a aresta at outro n para conect-los',\n  editEdgeDescription: 'Clique nos pontos de controle e os arraste para um n para conect-los',\n  createEdgeError: 'No foi possvel linkar arestas a um cluster.',\n  deleteClusterError: 'Clusters no puderam ser removidos.',\n  editClusterError: 'Clusters no puderam ser editados.'\n};\nexports['pt-BR'] = exports['pt-br'];\nexports['pt_BR'] = exports['pt-br'];\nexports['pt_br'] = exports['pt-br'];\n\n// Russian\nexports['ru'] = {\n  edit: '',\n  del: ' ',\n  back: '',\n  addNode: ' ',\n  addEdge: ' ',\n  editNode: ' ',\n  editEdge: ' ',\n  addDescription: '   ,    .',\n  edgeDescription: '        ,   .',\n  editEdgeDescription: '        ,    .',\n  createEdgeError: '    .',\n  deleteClusterError: '    ',\n  editClusterError: '   .'\n};\nexports['ru_RU'] = exports['ru'];\n\n// Chinese\nexports['cn'] = {\n  edit: '',\n  del: '',\n  back: '',\n  addNode: '',\n  addEdge: '',\n  editNode: '',\n  editEdge: '',\n  addDescription: '',\n  edgeDescription: '',\n  editEdgeDescription: '',\n  createEdgeError: '',\n  deleteClusterError: '',\n  editClusterError: ''\n};\nexports['zh_CN'] = exports['cn'];\n\n// Ukrainian\nexports['uk'] = {\n  edit: '',\n  del: ' ',\n  back: '',\n  addNode: ' ',\n  addEdge: ' ',\n  editNode: ' ',\n  editEdge: ' ',\n  addDescription: 'K   ,    .',\n  edgeDescription: \"        ,   '.\",\n  editEdgeDescription: '        ,    .',\n  createEdgeError: \"  '   .\",\n  deleteClusterError: '    .',\n  editClusterError: '   .'\n};\nexports['uk_UA'] = exports['uk'];\n\n// French\nexports['fr'] = {\n  edit: 'Editer',\n  del: 'Effacer la selection',\n  back: 'Retour',\n  addNode: 'Ajouter un noeud',\n  addEdge: 'Ajouter un lien',\n  editNode: 'Editer le noeud',\n  editEdge: 'Editer le lien',\n  addDescription: 'Cliquez dans un endroit vide pour placer un noeud.',\n  edgeDescription: 'Cliquez sur un noeud et glissez le lien vers un autre noeud pour les connecter.',\n  editEdgeDescription: 'Cliquez sur les points de contrle et glissez-les pour connecter un noeud.',\n  createEdgeError: 'Impossible de crer un lien vers un cluster.',\n  deleteClusterError: 'Les clusters ne peuvent pas tre ffacs.',\n  editClusterError: 'Les clusters ne peuvent pas tre dites.'\n};\nexports['fr_FR'] = exports['fr'];\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __nested_webpack_require_695069__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_695069__(131), __esModule: true };\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __nested_webpack_require_695223__) {\n\n__nested_webpack_require_695223__(132);\nvar $Object = __nested_webpack_require_695223__(6).Object;\nmodule.exports = function defineProperty(it, key, desc) {\n  return $Object.defineProperty(it, key, desc);\n};\n\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __nested_webpack_require_695482__) {\n\nvar $export = __nested_webpack_require_695482__(11);\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !__nested_webpack_require_695482__(13), 'Object', { defineProperty: __nested_webpack_require_695482__(12).f });\n\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __nested_webpack_require_695779__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_695779__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_695779__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Associates a canvas to a given image, containing a number of renderings\n * of the image at various sizes.\n *\n * This technique is known as 'mipmapping'.\n *\n * NOTE: Images can also be of type 'data:svg+xml`. This code also works\n *       for svg, but the mipmapping may not be necessary.\n *\n * @param {Image} image\n */\nvar CachedImage = function () {\n  /**\n   * @ignore\n   */\n  function CachedImage() {\n    (0, _classCallCheck3['default'])(this, CachedImage);\n\n    // eslint-disable-line no-unused-vars\n    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array\n\n    this.image = new Image();\n    this.canvas = document.createElement('canvas');\n  }\n\n  /**\n   * Called when the image has been successfully loaded.\n   */\n\n\n  (0, _createClass3['default'])(CachedImage, [{\n    key: 'init',\n    value: function init() {\n      if (this.initialized()) return;\n\n      this.src = this.image.src; // For same interface with Image\n      var w = this.image.width;\n      var h = this.image.height;\n\n      // Ease external access\n      this.width = w;\n      this.height = h;\n\n      var h2 = Math.floor(h / 2);\n      var h4 = Math.floor(h / 4);\n      var h8 = Math.floor(h / 8);\n      var h16 = Math.floor(h / 16);\n\n      var w2 = Math.floor(w / 2);\n      var w4 = Math.floor(w / 4);\n      var w8 = Math.floor(w / 8);\n      var w16 = Math.floor(w / 16);\n\n      // Make canvas as small as possible\n      this.canvas.width = 3 * w4;\n      this.canvas.height = h2;\n\n      // Coordinates and sizes of images contained in the canvas\n      // Values per row:  [top x, left y, width, height]\n\n      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];\n\n      this._fillMipMap();\n    }\n\n    /**\n     * @return {Boolean} true if init() has been called, false otherwise.\n     */\n\n  }, {\n    key: 'initialized',\n    value: function initialized() {\n      return this.coordinates !== undefined;\n    }\n\n    /**\n     * Redraw main image in various sizes to the context.\n     *\n     * The rationale behind this is to reduce artefacts due to interpolation\n     * at differing zoom levels.\n     *\n     * Source: http://stackoverflow.com/q/18761404/1223531\n     *\n     * This methods takes the resizing out of the drawing loop, in order to\n     * reduce performance overhead.\n     *\n     * TODO: The code assumes that a 2D context can always be gotten. This is\n     *       not necessarily true! OTOH, if not true then usage of this class\n     *       is senseless.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_fillMipMap',\n    value: function _fillMipMap() {\n      var ctx = this.canvas.getContext('2d');\n\n      // First zoom-level comes from the image\n      var to = this.coordinates[0];\n      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);\n\n      // The rest are copy actions internal to the canvas/context\n      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {\n        var from = this.coordinates[iterations - 1];\n        var _to = this.coordinates[iterations];\n\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);\n      }\n    }\n\n    /**\n     * Draw the image, using the mipmap if necessary.\n     *\n     * MipMap is only used if param factor > 2; otherwise, original bitmap\n     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1\n     *\n     * Credits to 'Alex de Mulder' for original implementation.\n     *\n     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image\n     * @param {Float} factor scale factor at which to draw\n     * @param {number} left\n     * @param {number} top\n     * @param {number} width\n     * @param {number} height\n     */\n\n  }, {\n    key: 'drawImageAtPosition',\n    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {\n      if (!this.initialized()) return; //can't draw image yet not intialized\n\n      if (factor > 2) {\n        // Determine which zoomed image to use\n        factor *= 0.5;\n        var iterations = 0;\n        while (factor > 2 && iterations < this.NUM_ITERATIONS) {\n          factor *= 0.5;\n          iterations += 1;\n        }\n\n        if (iterations >= this.NUM_ITERATIONS) {\n          iterations = this.NUM_ITERATIONS - 1;\n        }\n        //console.log(\"iterations: \" + iterations);\n\n        var from = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);\n      } else {\n        // Draw image directly\n        ctx.drawImage(this.image, left, top, width, height);\n      }\n    }\n  }]);\n  return CachedImage;\n}();\n\nexports['default'] = CachedImage;\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __nested_webpack_require_700931__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_700931__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_700931__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_700931__(2);\n\n/**\n * This class can store groups and options specific for groups.\n */\n\nvar Groups = function () {\n  /**\n   * @ignore\n   */\n  function Groups() {\n    (0, _classCallCheck3['default'])(this, Groups);\n\n    this.clear();\n    this.defaultIndex = 0;\n    this.groupsArray = [];\n    this.groupIndex = 0;\n\n    this.defaultGroups = [{\n      border: '#2B7CE9',\n      background: '#97C2FC',\n      highlight: { border: '#2B7CE9', background: '#D2E5FF' },\n      hover: { border: '#2B7CE9', background: '#D2E5FF' }\n    }, // 0: blue\n    {\n      border: '#FFA500',\n      background: '#FFFF00',\n      highlight: { border: '#FFA500', background: '#FFFFA3' },\n      hover: { border: '#FFA500', background: '#FFFFA3' }\n    }, // 1: yellow\n    {\n      border: '#FA0A10',\n      background: '#FB7E81',\n      highlight: { border: '#FA0A10', background: '#FFAFB1' },\n      hover: { border: '#FA0A10', background: '#FFAFB1' }\n    }, // 2: red\n    {\n      border: '#41A906',\n      background: '#7BE141',\n      highlight: { border: '#41A906', background: '#A1EC76' },\n      hover: { border: '#41A906', background: '#A1EC76' }\n    }, // 3: green\n    {\n      border: '#E129F0',\n      background: '#EB7DF4',\n      highlight: { border: '#E129F0', background: '#F0B3F5' },\n      hover: { border: '#E129F0', background: '#F0B3F5' }\n    }, // 4: magenta\n    {\n      border: '#7C29F0',\n      background: '#AD85E4',\n      highlight: { border: '#7C29F0', background: '#D3BDF0' },\n      hover: { border: '#7C29F0', background: '#D3BDF0' }\n    }, // 5: purple\n    {\n      border: '#C37F00',\n      background: '#FFA807',\n      highlight: { border: '#C37F00', background: '#FFCA66' },\n      hover: { border: '#C37F00', background: '#FFCA66' }\n    }, // 6: orange\n    {\n      border: '#4220FB',\n      background: '#6E6EFD',\n      highlight: { border: '#4220FB', background: '#9B9BFD' },\n      hover: { border: '#4220FB', background: '#9B9BFD' }\n    }, // 7: darkblue\n    {\n      border: '#FD5A77',\n      background: '#FFC0CB',\n      highlight: { border: '#FD5A77', background: '#FFD1D9' },\n      hover: { border: '#FD5A77', background: '#FFD1D9' }\n    }, // 8: pink\n    {\n      border: '#4AD63A',\n      background: '#C2FABC',\n      highlight: { border: '#4AD63A', background: '#E6FFE3' },\n      hover: { border: '#4AD63A', background: '#E6FFE3' }\n    }, // 9: mint\n\n    {\n      border: '#990000',\n      background: '#EE0000',\n      highlight: { border: '#BB0000', background: '#FF3333' },\n      hover: { border: '#BB0000', background: '#FF3333' }\n    }, // 10:bright red\n\n    {\n      border: '#FF6000',\n      background: '#FF6000',\n      highlight: { border: '#FF6000', background: '#FF6000' },\n      hover: { border: '#FF6000', background: '#FF6000' }\n    }, // 12: real orange\n    {\n      border: '#97C2FC',\n      background: '#2B7CE9',\n      highlight: { border: '#D2E5FF', background: '#2B7CE9' },\n      hover: { border: '#D2E5FF', background: '#2B7CE9' }\n    }, // 13: blue\n    {\n      border: '#399605',\n      background: '#255C03',\n      highlight: { border: '#399605', background: '#255C03' },\n      hover: { border: '#399605', background: '#255C03' }\n    }, // 14: green\n    {\n      border: '#B70054',\n      background: '#FF007E',\n      highlight: { border: '#B70054', background: '#FF007E' },\n      hover: { border: '#B70054', background: '#FF007E' }\n    }, // 15: magenta\n    {\n      border: '#AD85E4',\n      background: '#7C29F0',\n      highlight: { border: '#D3BDF0', background: '#7C29F0' },\n      hover: { border: '#D3BDF0', background: '#7C29F0' }\n    }, // 16: purple\n    {\n      border: '#4557FA',\n      background: '#000EA1',\n      highlight: { border: '#6E6EFD', background: '#000EA1' },\n      hover: { border: '#6E6EFD', background: '#000EA1' }\n    }, // 17: darkblue\n    {\n      border: '#FFC0CB',\n      background: '#FD5A77',\n      highlight: { border: '#FFD1D9', background: '#FD5A77' },\n      hover: { border: '#FFD1D9', background: '#FD5A77' }\n    }, // 18: pink\n    {\n      border: '#C2FABC',\n      background: '#74D66A',\n      highlight: { border: '#E6FFE3', background: '#74D66A' },\n      hover: { border: '#E6FFE3', background: '#74D66A' }\n    }, // 19: mint\n\n    {\n      border: '#EE0000',\n      background: '#990000',\n      highlight: { border: '#FF3333', background: '#BB0000' },\n      hover: { border: '#FF3333', background: '#BB0000' } // 20:bright red\n    }];\n\n    this.options = {};\n    this.defaultOptions = {\n      useDefaultGroups: true\n    };\n    util.extend(this.options, this.defaultOptions);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(Groups, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      var optionFields = ['useDefaultGroups'];\n\n      if (options !== undefined) {\n        for (var groupName in options) {\n          if (options.hasOwnProperty(groupName)) {\n            if (optionFields.indexOf(groupName) === -1) {\n              var group = options[groupName];\n              this.add(groupName, group);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Clear all groups\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.groups = {};\n      this.groupsArray = [];\n    }\n\n    /**\n     * Get group options of a groupname.\n     * If groupname is not found, a new group may be created.\n     *\n     * @param {*}       groupname     Can be a number, string, Date, etc.\n     * @param {boolean} [shouldCreate=true] If true, create a new group\n     * @return {Object} The found or created group\n     */\n\n  }, {\n    key: 'get',\n    value: function get(groupname) {\n      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var group = this.groups[groupname];\n\n      if (group === undefined && shouldCreate) {\n        if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {\n          // create new group\n          var index = this.groupIndex % this.groupsArray.length;\n          this.groupIndex++;\n          group = {};\n          group.color = this.groups[this.groupsArray[index]];\n          this.groups[groupname] = group;\n        } else {\n          // create new group\n          var _index = this.defaultIndex % this.defaultGroups.length;\n          this.defaultIndex++;\n          group = {};\n          group.color = this.defaultGroups[_index];\n          this.groups[groupname] = group;\n        }\n      }\n\n      return group;\n    }\n\n    /**\n     * Add a custom group style\n     * @param {string} groupName\n     * @param {Object} style       An object containing borderColor,\n     *                             backgroundColor, etc.\n     * @return {Object} group      The created group object\n     */\n\n  }, {\n    key: 'add',\n    value: function add(groupName, style) {\n      this.groups[groupName] = style;\n      this.groupsArray.push(groupName);\n      return style;\n    }\n  }]);\n  return Groups;\n}();\n\nexports['default'] = Groups;\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __nested_webpack_require_708348__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_708348__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_708348__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_708348__(2);\nvar DataSet = __nested_webpack_require_708348__(33);\nvar DataView = __nested_webpack_require_708348__(51);\nvar Node = __nested_webpack_require_708348__(34)['default'];\n\n/**\n * Handler for Nodes\n */\n\nvar NodesHandler = function () {\n  /**\n   * @param {Object} body\n   * @param {Images} images\n   * @param {Array.<Group>} groups\n   * @param {LayoutEngine} layoutEngine\n   */\n  function NodesHandler(body, images, groups, layoutEngine) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, NodesHandler);\n\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n    this.layoutEngine = layoutEngine;\n\n    // create the node API in the body container\n    this.body.functions.createNode = this.create.bind(this);\n\n    this.nodesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items, params.data, params.oldData);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n\n    this.defaultOptions = {\n      borderWidth: 1,\n      borderWidthSelected: 2,\n      brokenImage: undefined,\n      color: {\n        border: '#2B7CE9',\n        background: '#97C2FC',\n        highlight: {\n          border: '#2B7CE9',\n          background: '#D2E5FF'\n        },\n        hover: {\n          border: '#2B7CE9',\n          background: '#D2E5FF'\n        }\n      },\n      fixed: {\n        x: false,\n        y: false\n      },\n      font: {\n        color: '#343434',\n        size: 14, // px\n        face: 'arial',\n        background: 'none',\n        strokeWidth: 0, // px\n        strokeColor: '#ffffff',\n        align: 'center',\n        vadjust: 0,\n        multi: false,\n        bold: {\n          mod: 'bold'\n        },\n        boldital: {\n          mod: 'bold italic'\n        },\n        ital: {\n          mod: 'italic'\n        },\n        mono: {\n          mod: '',\n          size: 15, // px\n          face: 'monospace',\n          vadjust: 2\n        }\n      },\n      group: undefined,\n      hidden: false,\n      icon: {\n        face: 'FontAwesome', //'FontAwesome',\n        code: undefined, //'\\uf007',\n        size: 50, //50,\n        color: '#2B7CE9' //'#aa00ff'\n      },\n      image: undefined, // --> URL\n      label: undefined,\n      labelHighlightBold: true,\n      level: undefined,\n      margin: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n      },\n      mass: 1,\n      physics: true,\n      scaling: {\n        min: 10,\n        max: 30,\n        label: {\n          enabled: false,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      shadow: {\n        enabled: false,\n        color: 'rgba(0,0,0,0.5)',\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      shape: 'ellipse',\n      shapeProperties: {\n        borderDashes: false, // only for borders\n        borderRadius: 6, // only for box shape\n        interpolation: true, // only for image and circularImage shapes\n        useImageSize: false, // only for image and circularImage shapes\n        useBorderWithImage: false // only for image shape\n      },\n      size: 25,\n      title: undefined,\n      value: undefined,\n      x: undefined,\n      y: undefined\n\n      // Protect from idiocy\n    };if (this.defaultOptions.mass <= 0) {\n      throw 'Internal error: mass in defaultOptions of NodesHandler may not be zero or negative';\n    }\n\n    this.options = util.bridgeObject(this.defaultOptions);\n\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n\n\n  (0, _createClass3['default'])(NodesHandler, [{\n    key: 'bindEventListeners',\n    value: function bindEventListeners() {\n      var _this2 = this;\n\n      // refresh the nodes. Used when reverting from hierarchical layout\n      this.body.emitter.on('refreshNodes', this.refresh.bind(this));\n      this.body.emitter.on('refresh', this.refresh.bind(this));\n      this.body.emitter.on('destroy', function () {\n        util.forEach(_this2.nodesListeners, function (callback, event) {\n          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);\n        });\n        delete _this2.body.functions.createNode;\n        delete _this2.nodesListeners.add;\n        delete _this2.nodesListeners.update;\n        delete _this2.nodesListeners.remove;\n        delete _this2.nodesListeners;\n      });\n    }\n\n    /**\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        Node.parseOptions(this.options, options);\n\n        // update the shape in all nodes\n        if (options.shape !== undefined) {\n          for (var nodeId in this.body.nodes) {\n            if (this.body.nodes.hasOwnProperty(nodeId)) {\n              this.body.nodes[nodeId].updateShape();\n            }\n          }\n        }\n\n        // update the font in all nodes\n        if (options.font !== undefined) {\n          for (var _nodeId in this.body.nodes) {\n            if (this.body.nodes.hasOwnProperty(_nodeId)) {\n              this.body.nodes[_nodeId].updateLabelModule();\n              this.body.nodes[_nodeId].needsRefresh();\n            }\n          }\n        }\n\n        // update the shape size in all nodes\n        if (options.size !== undefined) {\n          for (var _nodeId2 in this.body.nodes) {\n            if (this.body.nodes.hasOwnProperty(_nodeId2)) {\n              this.body.nodes[_nodeId2].needsRefresh();\n            }\n          }\n        }\n\n        // update the state of the variables if needed\n        if (options.hidden !== undefined || options.physics !== undefined) {\n          this.body.emitter.emit('_dataChanged');\n        }\n      }\n    }\n\n    /**\n     * Set a data set with nodes for the network\n     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n\n  }, {\n    key: 'setData',\n    value: function setData(nodes) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var oldNodesData = this.body.data.nodes;\n\n      if (nodes instanceof DataSet || nodes instanceof DataView) {\n        this.body.data.nodes = nodes;\n      } else if (Array.isArray(nodes)) {\n        this.body.data.nodes = new DataSet();\n        this.body.data.nodes.add(nodes);\n      } else if (!nodes) {\n        this.body.data.nodes = new DataSet();\n      } else {\n        throw new TypeError('Array or DataSet expected');\n      }\n\n      if (oldNodesData) {\n        // unsubscribe from old dataset\n        util.forEach(this.nodesListeners, function (callback, event) {\n          oldNodesData.off(event, callback);\n        });\n      }\n\n      // remove drawn nodes\n      this.body.nodes = {};\n\n      if (this.body.data.nodes) {\n        // subscribe to new dataset\n        var me = this;\n        util.forEach(this.nodesListeners, function (callback, event) {\n          me.body.data.nodes.on(event, callback);\n        });\n\n        // draw all new nodes\n        var ids = this.body.data.nodes.getIds();\n        this.add(ids, true);\n      }\n\n      if (doNotEmit === false) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     * Add nodes\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n\n  }, {\n    key: 'add',\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var id = void 0;\n      var newNodes = [];\n      for (var i = 0; i < ids.length; i++) {\n        id = ids[i];\n        var properties = this.body.data.nodes.get(id);\n        var node = this.create(properties);\n        newNodes.push(node);\n        this.body.nodes[id] = node; // note: this may replace an existing node\n      }\n\n      this.layoutEngine.positionInitially(newNodes);\n\n      if (doNotEmit === false) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     * Update existing nodes, or create them when not yet existing\n     * @param {number[] | string[]} ids id's of changed nodes\n     * @param {Array} changedData array with changed data\n     * @param {Array|undefined} oldData optional; array with previous data\n     * @private\n     */\n\n  }, {\n    key: 'update',\n    value: function update(ids, changedData, oldData) {\n      var nodes = this.body.nodes;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var node = nodes[id];\n        var data = changedData[i];\n        if (node !== undefined) {\n          // update node\n          if (node.setOptions(data)) {\n            dataChanged = true;\n          }\n        } else {\n          dataChanged = true;\n          // create node\n          node = this.create(data);\n          nodes[id] = node;\n        }\n      }\n\n      if (!dataChanged && oldData !== undefined) {\n        // Check for any changes which should trigger a layout recalculation\n        // For now, this is just 'level' for hierarchical layout\n        // Assumption: old and new data arranged in same order; at time of writing, this holds.\n        dataChanged = changedData.some(function (newValue, index) {\n          var oldValue = oldData[index];\n          return oldValue && oldValue.level !== newValue.level;\n        });\n      }\n\n      if (dataChanged === true) {\n        this.body.emitter.emit('_dataChanged');\n      } else {\n        this.body.emitter.emit('_dataUpdated');\n      }\n    }\n\n    /**\n     * Remove existing nodes. If nodes do not exist, the method will just ignore it.\n     * @param {number[] | string[]} ids\n     * @private\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(ids) {\n      var nodes = this.body.nodes;\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        delete nodes[id];\n      }\n\n      this.body.emitter.emit('_dataChanged');\n    }\n\n    /**\n     * create a node\n     * @param {Object} properties\n     * @param {class} [constructorClass=Node.default]\n     * @returns {*}\n     */\n\n  }, {\n    key: 'create',\n    value: function create(properties) {\n      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;\n\n      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);\n    }\n\n    /**\n     *\n     * @param {boolean} [clearPositions=false]\n     */\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      var _this3 = this;\n\n      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      util.forEach(this.body.nodes, function (node, nodeId) {\n        var data = _this3.body.data.nodes.get(nodeId);\n        if (data !== undefined) {\n          if (clearPositions === true) {\n            node.setOptions({ x: null, y: null });\n          }\n          node.setOptions({ fixed: false });\n          node.setOptions(data);\n        }\n      });\n    }\n\n    /**\n     * Returns the positions of the nodes.\n     * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string\n     * @returns {{}}\n     */\n\n  }, {\n    key: 'getPositions',\n    value: function getPositions(ids) {\n      var dataArray = {};\n      if (ids !== undefined) {\n        if (Array.isArray(ids) === true) {\n          for (var i = 0; i < ids.length; i++) {\n            if (this.body.nodes[ids[i]] !== undefined) {\n              var node = this.body.nodes[ids[i]];\n              dataArray[ids[i]] = { x: Math.round(node.x), y: Math.round(node.y) };\n            }\n          }\n        } else {\n          if (this.body.nodes[ids] !== undefined) {\n            var _node = this.body.nodes[ids];\n            dataArray[ids] = { x: Math.round(_node.x), y: Math.round(_node.y) };\n          }\n        }\n      } else {\n        for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {\n          var _node2 = this.body.nodes[this.body.nodeIndices[_i]];\n          dataArray[this.body.nodeIndices[_i]] = {\n            x: Math.round(_node2.x),\n            y: Math.round(_node2.y)\n          };\n        }\n      }\n      return dataArray;\n    }\n\n    /**\n     * Load the XY positions of the nodes into the dataset.\n     */\n\n  }, {\n    key: 'storePositions',\n    value: function storePositions() {\n      // todo: add support for clusters and hierarchical.\n      var dataArray = [];\n      var dataset = this.body.data.nodes.getDataSet();\n\n      for (var nodeId in dataset._data) {\n        if (dataset._data.hasOwnProperty(nodeId)) {\n          var node = this.body.nodes[nodeId];\n          if (dataset._data[nodeId].x != Math.round(node.x) || dataset._data[nodeId].y != Math.round(node.y)) {\n            dataArray.push({\n              id: node.id,\n              x: Math.round(node.x),\n              y: Math.round(node.y)\n            });\n          }\n        }\n      }\n      dataset.update(dataArray);\n    }\n\n    /**\n     * get the bounding box of a node.\n     * @param {Node.id} nodeId\n     * @returns {j|*}\n     */\n\n  }, {\n    key: 'getBoundingBox',\n    value: function getBoundingBox(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].shape.boundingBox;\n      }\n    }\n\n    /**\n     * Get the Ids of nodes connected to this node.\n     * @param {Node.id} nodeId\n     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.\n     *                                          Any other value returns both parent and child nodes.\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'getConnectedNodes',\n    value: function getConnectedNodes(nodeId, direction) {\n      var nodeList = [];\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n        var nodeObj = {}; // used to quickly check if node already exists\n        for (var i = 0; i < node.edges.length; i++) {\n          var edge = node.edges[i];\n          if (direction !== 'to' && edge.toId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.fromId] === undefined) {\n              nodeList.push(edge.fromId);\n              nodeObj[edge.fromId] = true;\n            }\n          } else if (direction !== 'from' && edge.fromId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.toId] === undefined) {\n              nodeList.push(edge.toId);\n              nodeObj[edge.toId] = true;\n            }\n          }\n        }\n      }\n      return nodeList;\n    }\n\n    /**\n     * Get the ids of the edges connected to this node.\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n\n  }, {\n    key: 'getConnectedEdges',\n    value: function getConnectedEdges(nodeId) {\n      var edgeList = [];\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n        for (var i = 0; i < node.edges.length; i++) {\n          edgeList.push(node.edges[i].id);\n        }\n      } else {\n        console.log('NodeId provided for getConnectedEdges does not exist. Provided: ', nodeId);\n      }\n      return edgeList;\n    }\n\n    /**\n     * Move a node.\n     *\n     * @param {Node.id} nodeId\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(nodeId, x, y) {\n      var _this4 = this;\n\n      if (this.body.nodes[nodeId] !== undefined) {\n        this.body.nodes[nodeId].x = Number(x);\n        this.body.nodes[nodeId].y = Number(y);\n        setTimeout(function () {\n          _this4.body.emitter.emit('startSimulation');\n        }, 0);\n      } else {\n        console.log('Node id supplied to moveNode does not exist. Provided: ', nodeId);\n      }\n    }\n  }]);\n  return NodesHandler;\n}();\n\nexports['default'] = NodesHandler;\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __nested_webpack_require_724960__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_724960__(137), __esModule: true };\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __nested_webpack_require_725114__) {\n\n__nested_webpack_require_725114__(37);\n__nested_webpack_require_725114__(47);\nmodule.exports = __nested_webpack_require_725114__(138);\n\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __nested_webpack_require_725286__) {\n\nvar classof = __nested_webpack_require_725286__(67);\nvar ITERATOR = __nested_webpack_require_725286__(8)('iterator');\nvar Iterators = __nested_webpack_require_725286__(25);\nmodule.exports = __nested_webpack_require_725286__(6).isIterable = function (it) {\n  var O = Object(it);\n  return O[ITERATOR] !== undefined\n    || '@@iterator' in O\n    // eslint-disable-next-line no-prototype-builtins\n    || Iterators.hasOwnProperty(classof(O));\n};\n\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __nested_webpack_require_725749__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = __nested_webpack_require_725749__(15);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _classCallCheck2 = __nested_webpack_require_725749__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_725749__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar LabelAccumulator = __nested_webpack_require_725749__(140)['default'];\nvar ComponentUtil = __nested_webpack_require_725749__(35)['default'];\n\n// Hash of prepared regexp's for tags\nvar tagPattern = {\n  // HTML\n  '<b>': /<b>/,\n  '<i>': /<i>/,\n  '<code>': /<code>/,\n  '</b>': /<\\/b>/,\n  '</i>': /<\\/i>/,\n  '</code>': /<\\/code>/,\n  // Markdown\n  '*': /\\*/, // bold\n  _: /\\_/, // ital\n  '`': /`/, // mono\n  afterBold: /[^\\*]/,\n  afterItal: /[^_]/,\n  afterMono: /[^`]/\n\n  /**\n   * Internal helper class for parsing the markup tags for HTML and Markdown.\n   *\n   * NOTE: Sequences of tabs and spaces are reduced to single space.\n   *       Scan usage of `this.spacing` within method\n   */\n};\nvar MarkupAccumulator = function () {\n  /**\n   * Create an instance\n   *\n   * @param {string} text  text to parse for markup\n   */\n  function MarkupAccumulator(text) {\n    (0, _classCallCheck3['default'])(this, MarkupAccumulator);\n\n    this.text = text;\n    this.bold = false;\n    this.ital = false;\n    this.mono = false;\n    this.spacing = false;\n    this.position = 0;\n    this.buffer = '';\n    this.modStack = [];\n\n    this.blocks = [];\n  }\n\n  /**\n   * Return the mod label currently on the top of the stack\n   *\n   * @returns {string}  label of topmost mod\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(MarkupAccumulator, [{\n    key: 'mod',\n    value: function mod() {\n      return this.modStack.length === 0 ? 'normal' : this.modStack[0];\n    }\n\n    /**\n     * Return the mod label currently active\n     *\n     * @returns {string}  label of active mod\n     * @private\n     */\n\n  }, {\n    key: 'modName',\n    value: function modName() {\n      if (this.modStack.length === 0) return 'normal';else if (this.modStack[0] === 'mono') return 'mono';else {\n        if (this.bold && this.ital) {\n          return 'boldital';\n        } else if (this.bold) {\n          return 'bold';\n        } else if (this.ital) {\n          return 'ital';\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: 'emitBlock',\n    value: function emitBlock() {\n      if (this.spacing) {\n        this.add(' ');\n        this.spacing = false;\n      }\n      if (this.buffer.length > 0) {\n        this.blocks.push({ text: this.buffer, mod: this.modName() });\n        this.buffer = '';\n      }\n    }\n\n    /**\n     * Output text to buffer\n     *\n     * @param {string} text  text to add\n     * @private\n     */\n\n  }, {\n    key: 'add',\n    value: function add(text) {\n      if (text === ' ') {\n        this.spacing = true;\n      }\n      if (this.spacing) {\n        this.buffer += ' ';\n        this.spacing = false;\n      }\n      if (text != ' ') {\n        this.buffer += text;\n      }\n    }\n\n    /**\n     * Handle parsing of whitespace\n     *\n     * @param {string} ch  the character to check\n     * @returns {boolean} true if the character was processed as whitespace, false otherwise\n     */\n\n  }, {\n    key: 'parseWS',\n    value: function parseWS(ch) {\n      if (/[ \\t]/.test(ch)) {\n        if (!this.mono) {\n          this.spacing = true;\n        } else {\n          this.add(ch);\n        }\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * @param {string} tagName  label for block type to set\n     * @private\n     */\n\n  }, {\n    key: 'setTag',\n    value: function setTag(tagName) {\n      this.emitBlock();\n      this[tagName] = true;\n      this.modStack.unshift(tagName);\n    }\n\n    /**\n     * @param {string} tagName  label for block type to unset\n     * @private\n     */\n\n  }, {\n    key: 'unsetTag',\n    value: function unsetTag(tagName) {\n      this.emitBlock();\n      this[tagName] = false;\n      this.modStack.shift();\n    }\n\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n\n  }, {\n    key: 'parseStartTag',\n    value: function parseStartTag(tagName, tag) {\n      // Note: if 'mono' passed as tagName, there is a double check here. This is OK\n      if (!this.mono && !this[tagName] && this.match(tag)) {\n        this.setTag(tagName);\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * @param {string|RegExp} tag\n     * @param {number} [advance=true] if set, advance current position in text\n     * @returns {boolean} true if match at given position, false otherwise\n     * @private\n     */\n\n  }, {\n    key: 'match',\n    value: function match(tag) {\n      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var _prepareRegExp = this.prepareRegExp(tag),\n          _prepareRegExp2 = (0, _slicedToArray3['default'])(_prepareRegExp, 2),\n          regExp = _prepareRegExp2[0],\n          length = _prepareRegExp2[1];\n\n      var matched = regExp.test(this.text.substr(this.position, length));\n\n      if (matched && advance) {\n        this.position += length - 1;\n      }\n\n      return matched;\n    }\n\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n\n  }, {\n    key: 'parseEndTag',\n    value: function parseEndTag(tagName, tag, nextTag) {\n      var checkTag = this.mod() === tagName;\n      if (tagName === 'mono') {\n        // special handling for 'mono'\n        checkTag = checkTag && this.mono;\n      } else {\n        checkTag = checkTag && !this.mono;\n      }\n\n      if (checkTag && this.match(tag)) {\n        if (nextTag !== undefined) {\n          // Purpose of the following match is to prevent a direct unset/set of a given tag\n          // E.g. '*bold **still bold*' => '*bold still bold*'\n          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {\n            this.unsetTag(tagName);\n          }\n        } else {\n          this.unsetTag(tagName);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * @param {string|RegExp} tag  string to match in text\n     * @param {value} value  string to replace tag with, if found at current position\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(tag, value) {\n      if (this.match(tag)) {\n        this.add(value);\n        this.position += length - 1;\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * Create a regular expression for the tag if it isn't already one.\n     *\n     * The return value is an array `[RegExp, number]`, with exactly two value, where:\n     *  - RegExp is the regular expression to use\n     *  - number is the lenth of the input string to match\n     *\n     * @param {string|RegExp} tag  string to match in text\n     * @returns {Array}  regular expression to use and length of input string to match\n     * @private\n     */\n\n  }, {\n    key: 'prepareRegExp',\n    value: function prepareRegExp(tag) {\n      var length = void 0;\n      var regExp = void 0;\n      if (tag instanceof RegExp) {\n        regExp = tag;\n        length = 1; // ASSUMPTION: regexp only tests one character\n      } else {\n        // use prepared regexp if present\n        var prepared = tagPattern[tag];\n        if (prepared !== undefined) {\n          regExp = prepared;\n        } else {\n          regExp = new RegExp(tag);\n        }\n\n        length = tag.length;\n      }\n\n      return [regExp, length];\n    }\n  }]);\n  return MarkupAccumulator;\n}();\n\n/**\n * Helper class for Label which explodes the label text into lines and blocks within lines\n *\n * @private\n */\n\n\nvar LabelSplitter = function () {\n  /**\n   * @param {CanvasRenderingContext2D} ctx Canvas rendering context\n   * @param {Label} parent reference to the Label instance using current instance\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  function LabelSplitter(ctx, parent, selected, hover) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, LabelSplitter);\n\n    this.ctx = ctx;\n    this.parent = parent;\n\n    /**\n     * Callback to determine text width; passed to LabelAccumulator instance\n     *\n     * @param  {String} text string to determine width of\n     * @param  {String} mod  font type to use for this text\n     * @return {Object} { width, values} width in pixels and font attributes\n     */\n    var textWidth = function textWidth(text, mod) {\n      if (text === undefined) return 0;\n\n      // TODO: This can be done more efficiently with caching\n      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);\n\n      var width = 0;\n      if (text !== '') {\n        // NOTE: The following may actually be *incorrect* for the mod fonts!\n        //       This returns the size with a regular font, bold etc. may\n        //       have different sizes.\n        var measure = _this.ctx.measureText(text);\n        width = measure.width;\n      }\n\n      return { width: width, values: values };\n    };\n\n    this.lines = new LabelAccumulator(textWidth);\n  }\n\n  /**\n   * Split passed text of a label into lines and blocks.\n   *\n   * # NOTE\n   *\n   * The handling of spacing is option dependent:\n   *\n   * - if `font.multi : false`, all spaces are retained\n   * - if `font.multi : true`, every sequence of spaces is compressed to a single space\n   *\n   * This might not be the best way to do it, but this is as it has been working till now.\n   * In order not to break existing functionality, for the time being this behaviour will\n   * be retained in any code changes.\n   *\n   * @param {string} text  text to split\n   * @returns {Array<line>}\n   */\n\n\n  (0, _createClass3['default'])(LabelSplitter, [{\n    key: 'process',\n    value: function process(text) {\n      if (!ComponentUtil.isValidLabel(text)) {\n        return this.lines.finalize();\n      }\n\n      var font = this.parent.fontOptions;\n\n      // Normalize the end-of-line's to a single representation - order important\n      text = text.replace(/\\r\\n/g, '\\n'); // Dos EOL's\n      text = text.replace(/\\r/g, '\\n'); // Mac EOL's\n\n      // Note that at this point, there can be no \\r's in the text.\n      // This is used later on splitStringIntoLines() to split multifont texts.\n\n      var nlLines = String(text).split('\\n');\n      var lineCount = nlLines.length;\n\n      if (font.multi) {\n        // Multi-font case: styling tags active\n        for (var i = 0; i < lineCount; i++) {\n          var blocks = this.splitBlocks(nlLines[i], font.multi);\n          // Post: Sequences of tabs and spaces are reduced to single space\n\n          if (blocks === undefined) continue;\n\n          if (blocks.length === 0) {\n            this.lines.newLine('');\n            continue;\n          }\n\n          if (font.maxWdt > 0) {\n            // widthConstraint.maximum defined\n            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);\n            for (var j = 0; j < blocks.length; j++) {\n              var mod = blocks[j].mod;\n              var _text = blocks[j].text;\n              this.splitStringIntoLines(_text, mod, true);\n            }\n          } else {\n            // widthConstraint.maximum NOT defined\n            for (var _j = 0; _j < blocks.length; _j++) {\n              var _mod = blocks[_j].mod;\n              var _text2 = blocks[_j].text;\n              this.lines.append(_text2, _mod);\n            }\n          }\n\n          this.lines.newLine();\n        }\n      } else {\n        // Single-font case\n        if (font.maxWdt > 0) {\n          // widthConstraint.maximum defined\n          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);\n          for (var _i = 0; _i < lineCount; _i++) {\n            this.splitStringIntoLines(nlLines[_i]);\n          }\n        } else {\n          // widthConstraint.maximum NOT defined\n          for (var _i2 = 0; _i2 < lineCount; _i2++) {\n            this.lines.newLine(nlLines[_i2]);\n          }\n        }\n      }\n\n      return this.lines.finalize();\n    }\n\n    /**\n     * normalize the markup system\n     *\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {string}\n     */\n\n  }, {\n    key: 'decodeMarkupSystem',\n    value: function decodeMarkupSystem(markupSystem) {\n      var system = 'none';\n      if (markupSystem === 'markdown' || markupSystem === 'md') {\n        system = 'markdown';\n      } else if (markupSystem === true || markupSystem === 'html') {\n        system = 'html';\n      }\n      return system;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'splitHtmlBlocks',\n    value: function splitHtmlBlocks(text) {\n      var s = new MarkupAccumulator(text);\n\n      var parseEntities = function parseEntities(ch) {\n        if (/&/.test(ch)) {\n          var parsed = s.replace(s.text, '&lt;', '<') || s.replace(s.text, '&amp;', '&');\n\n          if (!parsed) {\n            s.add('&');\n          }\n\n          return true;\n        }\n\n        return false;\n      };\n\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n\n        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag('bold', '<b>') || s.parseStartTag('ital', '<i>') || s.parseStartTag('mono', '<code>') || s.parseEndTag('bold', '</b>') || s.parseEndTag('ital', '</i>') || s.parseEndTag('mono', '</code>')) || parseEntities(ch);\n\n        if (!parsed) {\n          s.add(ch);\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'splitMarkdownBlocks',\n    value: function splitMarkdownBlocks(text) {\n      var _this2 = this;\n\n      var s = new MarkupAccumulator(text);\n      var beginable = true;\n\n      var parseOverride = function parseOverride(ch) {\n        if (/\\\\/.test(ch)) {\n          if (s.position < _this2.text.length + 1) {\n            s.position++;\n            ch = _this2.text.charAt(s.position);\n            if (/ \\t/.test(ch)) {\n              s.spacing = true;\n            } else {\n              s.add(ch);\n              beginable = false;\n            }\n          }\n\n          return true;\n        }\n\n        return false;\n      };\n\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n\n        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag('bold', '*') || s.parseStartTag('ital', '_') || s.parseStartTag('mono', '`')) || s.parseEndTag('bold', '*', 'afterBold') || s.parseEndTag('ital', '_', 'afterItal') || s.parseEndTag('mono', '`', 'afterMono');\n\n        if (!parsed) {\n          s.add(ch);\n          beginable = false;\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n\n    /**\n     * Explodes a piece of text into single-font blocks using a given markup\n     *\n     * @param {string} text\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {Array.<{text: string, mod: string}>}\n     * @private\n     */\n\n  }, {\n    key: 'splitBlocks',\n    value: function splitBlocks(text, markupSystem) {\n      var system = this.decodeMarkupSystem(markupSystem);\n      if (system === 'none') {\n        return [{\n          text: text,\n          mod: 'normal'\n        }];\n      } else if (system === 'markdown') {\n        return this.splitMarkdownBlocks(text);\n      } else if (system === 'html') {\n        return this.splitHtmlBlocks(text);\n      }\n    }\n\n    /**\n     * @param {string} text\n     * @returns {boolean} true if text length over the current max with\n     * @private\n     */\n\n  }, {\n    key: 'overMaxWidth',\n    value: function overMaxWidth(text) {\n      var width = this.ctx.measureText(text).width;\n      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;\n    }\n\n    /**\n     * Determine the longest part of the sentence which still fits in the\n     * current max width.\n     *\n     * @param {Array} words  Array of strings signifying a text lines\n     * @return {number}      index of first item in string making string go over max\n     * @private\n     */\n\n  }, {\n    key: 'getLongestFit',\n    value: function getLongestFit(words) {\n      var text = '';\n      var w = 0;\n\n      while (w < words.length) {\n        var pre = text === '' ? '' : ' ';\n        var newText = text + pre + words[w];\n\n        if (this.overMaxWidth(newText)) break;\n        text = newText;\n        w++;\n      }\n\n      return w;\n    }\n\n    /**\n     * Determine the longest part of the string which still fits in the\n     * current max width.\n     *\n     * @param {Array} words Array of strings signifying a text lines\n     * @return {number} index of first item in string making string go over max\n     */\n\n  }, {\n    key: 'getLongestFitWord',\n    value: function getLongestFitWord(words) {\n      var w = 0;\n\n      while (w < words.length) {\n        if (this.overMaxWidth(words.slice(0, w))) break;\n        w++;\n      }\n\n      return w;\n    }\n\n    /**\n     * Split the passed text into lines, according to width constraint (if any).\n     *\n     * The method assumes that the input string is a single line, i.e. without lines break.\n     *\n     * This method retains spaces, if still present (case `font.multi: false`).\n     * A space which falls on an internal line break, will be replaced by a newline.\n     * There is no special handling of tabs; these go along with the flow.\n     *\n     * @param {string} str\n     * @param {string} [mod='normal']\n     * @param {boolean} [appendLast=false]\n     * @private\n     */\n\n  }, {\n    key: 'splitStringIntoLines',\n    value: function splitStringIntoLines(str) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';\n      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      // Still-present spaces are relevant, retain them\n      str = str.replace(/^( +)/g, '$1\\r');\n      str = str.replace(/([^\\r][^ ]*)( +)/g, '$1\\r$2\\r');\n      var words = str.split('\\r');\n\n      while (words.length > 0) {\n        var w = this.getLongestFit(words);\n\n        if (w === 0) {\n          // Special case: the first word is already larger than the max width.\n          var word = words[0];\n\n          // Break the word to the largest part that fits the line\n          var x = this.getLongestFitWord(word);\n          this.lines.newLine(word.slice(0, x), mod);\n\n          // Adjust the word, so that the rest will be done next iteration\n          words[0] = word.slice(x);\n        } else {\n          // skip any space that is replaced by a newline\n          var newW = w;\n          if (words[w - 1] === ' ') {\n            w--;\n          } else if (words[newW] === ' ') {\n            newW++;\n          }\n\n          var text = words.slice(0, w).join('');\n\n          if (w == words.length && appendLast) {\n            this.lines.append(text, mod);\n          } else {\n            this.lines.newLine(text, mod);\n          }\n\n          // Adjust the word, so that the rest will be done next iteration\n          words = words.slice(newW);\n        }\n      }\n    }\n  }]);\n  return LabelSplitter;\n}();\n\nexports['default'] = LabelSplitter;\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __nested_webpack_require_745539__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign = __nested_webpack_require_745539__(78);\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = __nested_webpack_require_745539__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_745539__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Callback to determine text dimensions, using the parent label settings.\n * @callback MeasureText\n * @param {text} text\n * @param {text} mod\n * @return {Object} { width, values} width in pixels and font attributes\n */\n\n/**\n * Helper class for Label which collects results of splitting labels into lines and blocks.\n *\n * @private\n */\nvar LabelAccumulator = function () {\n  /**\n   * @param {MeasureText} measureText\n   */\n  function LabelAccumulator(measureText) {\n    (0, _classCallCheck3['default'])(this, LabelAccumulator);\n\n    this.measureText = measureText;\n    this.current = 0;\n    this.width = 0;\n    this.height = 0;\n    this.lines = [];\n  }\n\n  /**\n   * Append given text to the given line.\n   *\n   * @param {number}  l    index of line to add to\n   * @param {string}  text string to append to line\n   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(LabelAccumulator, [{\n    key: '_add',\n    value: function _add(l, text) {\n      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';\n\n      if (this.lines[l] === undefined) {\n        this.lines[l] = {\n          width: 0,\n          height: 0,\n          blocks: []\n        };\n      }\n\n      // We still need to set a block for undefined and empty texts, hence return at this point\n      // This is necessary because we don't know at this point if we're at the\n      // start of an empty line or not.\n      // To compensate, empty blocks are removed in `finalize()`.\n      //\n      // Empty strings should still have a height\n      var tmpText = text;\n      if (text === undefined || text === '') tmpText = ' ';\n\n      // Determine width and get the font properties\n      var result = this.measureText(tmpText, mod);\n      var block = (0, _assign2['default'])({}, result.values);\n      block.text = text;\n      block.width = result.width;\n      block.mod = mod;\n\n      if (text === undefined || text === '') {\n        block.width = 0;\n      }\n\n      this.lines[l].blocks.push(block);\n\n      // Update the line width. We need this for determining if a string goes over max width\n      this.lines[l].width += block.width;\n    }\n\n    /**\n     * Returns the width in pixels of the current line.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'curWidth',\n    value: function curWidth() {\n      var line = this.lines[this.current];\n      if (line === undefined) return 0;\n\n      return line.width;\n    }\n\n    /**\n     * Add text in block to current line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n\n  }, {\n    key: 'append',\n    value: function append(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';\n\n      this._add(this.current, text, mod);\n    }\n\n    /**\n     * Add text in block to current line and start a new line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n\n  }, {\n    key: 'newLine',\n    value: function newLine(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';\n\n      this._add(this.current, text, mod);\n      this.current++;\n    }\n\n    /**\n     * Determine and set the heights of all the lines currently contained in this instance\n     *\n     * Note that width has already been set.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'determineLineHeights',\n    value: function determineLineHeights() {\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        // Looking for max height of blocks in line\n        var height = 0;\n\n        if (line.blocks !== undefined) {\n          // Can happen if text contains e.g. '\\n '\n          for (var l = 0; l < line.blocks.length; l++) {\n            var block = line.blocks[l];\n\n            if (height < block.height) {\n              height = block.height;\n            }\n          }\n        }\n\n        line.height = height;\n      }\n    }\n\n    /**\n     * Determine the full size of the label text, as determined by current lines and blocks\n     *\n     * @private\n     */\n\n  }, {\n    key: 'determineLabelSize',\n    value: function determineLabelSize() {\n      var width = 0;\n      var height = 0;\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        if (line.width > width) {\n          width = line.width;\n        }\n        height += line.height;\n      }\n\n      this.width = width;\n      this.height = height;\n    }\n\n    /**\n     * Remove all empty blocks and empty lines we don't need\n     *\n     * This must be done after the width/height determination,\n     * so that these are set properly for processing here.\n     *\n     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed\n     * @private\n     */\n\n  }, {\n    key: 'removeEmptyBlocks',\n    value: function removeEmptyBlocks() {\n      var tmpLines = [];\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        // Note: an empty line in between text has width zero but is still relevant to layout.\n        // So we can't use width for testing empty line here\n        if (line.blocks.length === 0) continue;\n\n        // Discard final empty line always\n        if (k === this.lines.length - 1) {\n          if (line.width === 0) continue;\n        }\n\n        var tmpLine = {};\n        (0, _assign2['default'])(tmpLine, line);\n        tmpLine.blocks = [];\n\n        var firstEmptyBlock = void 0;\n        var tmpBlocks = [];\n        for (var l = 0; l < line.blocks.length; l++) {\n          var block = line.blocks[l];\n          if (block.width !== 0) {\n            tmpBlocks.push(block);\n          } else {\n            if (firstEmptyBlock === undefined) {\n              firstEmptyBlock = block;\n            }\n          }\n        }\n\n        // Ensure that there is *some* text present\n        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {\n          tmpBlocks.push(firstEmptyBlock);\n        }\n\n        tmpLine.blocks = tmpBlocks;\n\n        tmpLines.push(tmpLine);\n      }\n\n      return tmpLines;\n    }\n\n    /**\n     * Set the sizes for all lines and the whole thing.\n     *\n     * @returns {{width: (number|*), height: (number|*), lines: Array}}\n     */\n\n  }, {\n    key: 'finalize',\n    value: function finalize() {\n      //console.log(JSON.stringify(this.lines, null, 2));\n\n      this.determineLineHeights();\n      this.determineLabelSize();\n      var tmpLines = this.removeEmptyBlocks();\n\n      // Return a simple hash object for further processing.\n      return {\n        width: this.width,\n        height: this.height,\n        lines: tmpLines\n      };\n    }\n  }]);\n  return LabelAccumulator;\n}();\n\nexports['default'] = LabelAccumulator;\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports, __nested_webpack_require_752922__) {\n\n__nested_webpack_require_752922__(142);\nmodule.exports = __nested_webpack_require_752922__(6).Object.assign;\n\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __nested_webpack_require_753082__) {\n\n// 19.1.3.1 Object.assign(target, source)\nvar $export = __nested_webpack_require_753082__(11);\n\n$export($export.S + $export.F, 'Object', { assign: __nested_webpack_require_753082__(143) });\n\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __nested_webpack_require_753323__) {\n\n\"use strict\";\n\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = __nested_webpack_require_753323__(26);\nvar gOPS = __nested_webpack_require_753323__(50);\nvar pIE = __nested_webpack_require_753323__(32);\nvar toObject = __nested_webpack_require_753323__(30);\nvar IObject = __nested_webpack_require_753323__(59);\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __nested_webpack_require_753323__(22)(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __nested_webpack_require_754599__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_754599__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_754599__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_754599__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_754599__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_754599__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _NodeBase2 = __nested_webpack_require_754599__(16);\n\nvar _NodeBase3 = _interopRequireDefault(_NodeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Box Node/Cluster shape.\n *\n * @extends NodeBase\n */\nvar Box = function (_NodeBase) {\n  (0, _inherits3['default'])(Box, _NodeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Box(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Box);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (Box.__proto__ || (0, _getPrototypeOf2['default'])(Box)).call(this, options, body, labelModule));\n\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  (0, _createClass3['default'])(Box, [{\n    key: 'resize',\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n\n        this.width = dimensions.width + this.margin.right + this.margin.left;\n        this.height = dimensions.height + this.margin.top + this.margin.bottom;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      this.initContextForDraw(ctx, values);\n      ctx.roundRect(this.left, this.top, this.width, this.height, values.borderRadius);\n      this.performFill(ctx, values);\n\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n\n      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box\n      this._addBoundingBoxMargin(borderRadius);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      this.resize(ctx);\n      var borderWidth = this.options.borderWidth;\n\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n  }]);\n  return Box;\n}(_NodeBase3['default']);\n\nexports['default'] = Box;\n\n/***/ }),\n/* 145 */\n/***/ (function(module, exports, __nested_webpack_require_758678__) {\n\n__nested_webpack_require_758678__(146);\nmodule.exports = __nested_webpack_require_758678__(6).Object.getPrototypeOf;\n\n\n/***/ }),\n/* 146 */\n/***/ (function(module, exports, __nested_webpack_require_758846__) {\n\n// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = __nested_webpack_require_758846__(30);\nvar $getPrototypeOf = __nested_webpack_require_758846__(66);\n\n__nested_webpack_require_758846__(68)('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n\n\n/***/ }),\n/* 147 */\n/***/ (function(module, exports, __nested_webpack_require_759196__) {\n\nmodule.exports = { \"default\": __nested_webpack_require_759196__(148), __esModule: true };\n\n/***/ }),\n/* 148 */\n/***/ (function(module, exports, __nested_webpack_require_759350__) {\n\n__nested_webpack_require_759350__(149);\nmodule.exports = __nested_webpack_require_759350__(6).Object.setPrototypeOf;\n\n\n/***/ }),\n/* 149 */\n/***/ (function(module, exports, __nested_webpack_require_759518__) {\n\n// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = __nested_webpack_require_759518__(11);\n$export($export.S, 'Object', { setPrototypeOf: __nested_webpack_require_759518__(150).set });\n\n\n/***/ }),\n/* 150 */\n/***/ (function(module, exports, __nested_webpack_require_759761__) {\n\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __nested_webpack_require_759761__(21);\nvar anObject = __nested_webpack_require_759761__(20);\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __nested_webpack_require_759761__(61)(Function.call, __nested_webpack_require_759761__(70).f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n/***/ }),\n/* 151 */\n/***/ (function(module, exports, __nested_webpack_require_760750__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_760750__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_760750__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_760750__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_760750__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_760750__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _CircleImageBase2 = __nested_webpack_require_760750__(53);\n\nvar _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Circle Node/Cluster shape.\n *\n * @extends CircleImageBase\n */\nvar Circle = function (_CircleImageBase) {\n  (0, _inherits3['default'])(Circle, _CircleImageBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Circle(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Circle);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (Circle.__proto__ || (0, _getPrototypeOf2['default'])(Circle)).call(this, options, body, labelModule));\n\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  (0, _createClass3['default'])(Circle, [{\n    key: 'resize',\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n\n        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);\n\n        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      this._drawRawCircle(ctx, x, y, values);\n\n      this.updateBoundingBox(x, y);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);\n    }\n\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n    }\n\n    // prettier-ignore\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle - Unused\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      // eslint-disable-line no-unused-vars\n      this.resize(ctx);\n      return this.width * 0.5;\n    }\n  }]);\n  return Circle;\n}(_CircleImageBase3['default']);\n\nexports['default'] = Circle;\n\n/***/ }),\n/* 152 */\n/***/ (function(module, exports, __nested_webpack_require_764689__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_764689__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_764689__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_764689__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_764689__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_764689__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _CircleImageBase2 = __nested_webpack_require_764689__(53);\n\nvar _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A CircularImage Node/Cluster shape.\n *\n * @extends CircleImageBase\n */\nvar CircularImage = function (_CircleImageBase) {\n  (0, _inherits3['default'])(CircularImage, _CircleImageBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {\n    (0, _classCallCheck3['default'])(this, CircularImage);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (CircularImage.__proto__ || (0, _getPrototypeOf2['default'])(CircularImage)).call(this, options, body, labelModule));\n\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  (0, _createClass3['default'])(CircularImage, [{\n    key: 'resize',\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n\n      if (imageAbsent) {\n        var diameter = this.options.size * 2;\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = 0.5 * this.width;\n        return;\n      }\n\n      // At this point, an image is present, i.e. this.imageObj is valid.\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.switchImages(selected);\n      this.resize();\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.\n      this._drawRawCircle(ctx, x, y, values);\n\n      // now we draw in the circle, we save so we can revert the clip operation after drawing.\n      ctx.save();\n      // clip is used to use the stroke in drawRawCircle as an area that we can draw in.\n      ctx.clip();\n      // draw the image\n      this._drawImageAtPosition(ctx, values);\n      // restore so we can again draw on the full canvas\n      ctx.restore();\n\n      this._drawImageLabel(ctx, x, y, selected, hover);\n\n      this.updateBoundingBox(x, y);\n    }\n\n    // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n\n      // TODO: compare with Image.updateBoundingBox(), consolidate?\n      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n    }\n\n    // prettier-ignore\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle - Unused\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      // eslint-disable-line no-unused-vars\n      this.resize(ctx);\n      return this.width * 0.5;\n    }\n  }]);\n  return CircularImage;\n}(_CircleImageBase3['default']);\n\nexports['default'] = CircularImage;\n\n/***/ }),\n/* 153 */\n/***/ (function(module, exports, __nested_webpack_require_769715__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_769715__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_769715__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_769715__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_769715__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_769715__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _NodeBase2 = __nested_webpack_require_769715__(16);\n\nvar _NodeBase3 = _interopRequireDefault(_NodeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Database Node/Cluster shape.\n *\n * @extends NodeBase\n */\nvar Database = function (_NodeBase) {\n  (0, _inherits3['default'])(Database, _NodeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Database(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Database);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (Database.__proto__ || (0, _getPrototypeOf2['default'])(Database)).call(this, options, body, labelModule));\n\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n\n\n  (0, _createClass3['default'])(Database, [{\n    key: 'resize',\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var size = dimensions.width + this.margin.right + this.margin.left;\n\n        this.width = size;\n        this.height = size;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      this.initContextForDraw(ctx, values);\n      ctx.database(x - this.width / 2, y - this.height / 2, this.width, this.height);\n      this.performFill(ctx, values);\n\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Database;\n}(_NodeBase3['default']);\n\nexports['default'] = Database;\n\n/***/ }),\n/* 154 */\n/***/ (function(module, exports, __nested_webpack_require_772963__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_772963__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_772963__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_772963__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_772963__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_772963__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ShapeBase2 = __nested_webpack_require_772963__(17);\n\nvar _ShapeBase3 = _interopRequireDefault(_ShapeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Diamond Node/Cluster shape.\n *\n * @extends ShapeBase\n */\nvar Diamond = function (_ShapeBase) {\n  (0, _inherits3['default'])(Diamond, _ShapeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Diamond(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Diamond);\n    return (0, _possibleConstructorReturn3['default'])(this, (Diamond.__proto__ || (0, _getPrototypeOf2['default'])(Diamond)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   */\n\n\n  (0, _createClass3['default'])(Diamond, [{\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this._drawShape(ctx, 'diamond', 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Diamond;\n}(_ShapeBase3['default']);\n\nexports['default'] = Diamond;\n\n/***/ }),\n/* 155 */\n/***/ (function(module, exports, __nested_webpack_require_775191__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_775191__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_775191__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_775191__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_775191__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_775191__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ShapeBase2 = __nested_webpack_require_775191__(17);\n\nvar _ShapeBase3 = _interopRequireDefault(_ShapeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Dot Node/Cluster shape.\n *\n * @extends ShapeBase\n */\nvar Dot = function (_ShapeBase) {\n  (0, _inherits3['default'])(Dot, _ShapeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Dot(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Dot);\n    return (0, _possibleConstructorReturn3['default'])(this, (Dot.__proto__ || (0, _getPrototypeOf2['default'])(Dot)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   */\n\n\n  (0, _createClass3['default'])(Dot, [{\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this._drawShape(ctx, 'circle', 2, x, y, selected, hover, values);\n    }\n\n    // prettier-ignore\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      // eslint-disable-line no-unused-vars\n      this.resize(ctx);\n      return this.options.size;\n    }\n  }]);\n  return Dot;\n}(_ShapeBase3['default']);\n\nexports['default'] = Dot;\n\n/***/ }),\n/* 156 */\n/***/ (function(module, exports, __nested_webpack_require_777452__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_777452__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_777452__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_777452__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_777452__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_777452__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _NodeBase2 = __nested_webpack_require_777452__(16);\n\nvar _NodeBase3 = _interopRequireDefault(_NodeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Am Ellipse Node/Cluster shape.\n *\n * @extends NodeBase\n */\nvar Ellipse = function (_NodeBase) {\n  (0, _inherits3['default'])(Ellipse, _NodeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Ellipse(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Ellipse);\n    return (0, _possibleConstructorReturn3['default'])(this, (Ellipse.__proto__ || (0, _getPrototypeOf2['default'])(Ellipse)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  (0, _createClass3['default'])(Ellipse, [{\n    key: 'resize',\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n\n        this.height = dimensions.height * 2;\n        this.width = dimensions.width + dimensions.height;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width * 0.5;\n      this.top = y - this.height * 0.5;\n\n      this.initContextForDraw(ctx, values);\n      ctx.ellipse_vis(this.left, this.top, this.width, this.height);\n      this.performFill(ctx, values);\n\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, x, y, selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      this.resize(ctx);\n      var a = this.width * 0.5;\n      var b = this.height * 0.5;\n      var w = Math.sin(angle) * a;\n      var h = Math.cos(angle) * b;\n      return a * b / Math.sqrt(w * w + h * h);\n    }\n  }]);\n  return Ellipse;\n}(_NodeBase3['default']);\n\nexports['default'] = Ellipse;\n\n/***/ }),\n/* 157 */\n/***/ (function(module, exports, __nested_webpack_require_780835__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_780835__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_780835__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_780835__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_780835__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_780835__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _NodeBase2 = __nested_webpack_require_780835__(16);\n\nvar _NodeBase3 = _interopRequireDefault(_NodeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * An icon replacement for the default Node shape.\n *\n * @extends NodeBase\n */\nvar Icon = function (_NodeBase) {\n  (0, _inherits3['default'])(Icon, _NodeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Icon(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Icon);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (Icon.__proto__ || (0, _getPrototypeOf2['default'])(Icon)).call(this, options, body, labelModule));\n\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  (0, _createClass3['default'])(Icon, [{\n    key: 'resize',\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.iconSize = {\n          width: Number(this.options.icon.size),\n          height: Number(this.options.icon.size)\n        };\n        this.width = this.iconSize.width + this.margin.right + this.margin.left;\n        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.options.icon.size = this.options.icon.size || 50;\n\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this._icon(ctx, x, y, selected, hover, values);\n\n      if (this.options.label !== undefined) {\n        var iconTextSpacing = 5;\n        this.labelModule.draw(ctx, this.left + this.iconSize.width / 2 + this.margin.left, y + this.height / 2 + iconTextSpacing, selected);\n      }\n\n      this.updateBoundingBox(x, y);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.icon.size * 0.5;\n      this.boundingBox.left = x - this.options.icon.size * 0.5;\n      this.boundingBox.right = x + this.options.icon.size * 0.5;\n      this.boundingBox.bottom = y + this.options.icon.size * 0.5;\n\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        var iconTextSpacing = 5;\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover - Unused\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: '_icon',\n    value: function _icon(ctx, x, y, selected, hover, values) {\n      var iconSize = Number(this.options.icon.size);\n\n      if (this.options.icon.code !== undefined) {\n        ctx.font = (selected ? 'bold ' : '') + iconSize + 'px ' + this.options.icon.face;\n\n        // draw icon\n        ctx.fillStyle = this.options.icon.color || 'black';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        ctx.fillText(this.options.icon.code, x, y);\n\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      } else {\n        console.error('When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.');\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Icon;\n}(_NodeBase3['default']);\n\nexports['default'] = Icon;\n\n/***/ }),\n/* 158 */\n/***/ (function(module, exports, __nested_webpack_require_786141__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_786141__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_786141__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_786141__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_786141__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_786141__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _CircleImageBase2 = __nested_webpack_require_786141__(53);\n\nvar _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * An image-based replacement for the default Node shape.\n *\n * @extends CircleImageBase\n */\nvar Image = function (_CircleImageBase) {\n  (0, _inherits3['default'])(Image, _CircleImageBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n  function Image(options, body, labelModule, imageObj, imageObjAlt) {\n    (0, _classCallCheck3['default'])(this, Image);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (Image.__proto__ || (0, _getPrototypeOf2['default'])(Image)).call(this, options, body, labelModule));\n\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  (0, _createClass3['default'])(Image, [{\n    key: 'resize',\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n\n      if (imageAbsent) {\n        var side = this.options.size * 2;\n        this.width = side;\n        this.height = side;\n        return;\n      }\n\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.switchImages(selected);\n      this.resize();\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      if (this.options.shapeProperties.useBorderWithImage === true) {\n        var neutralborderWidth = this.options.borderWidth;\n        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;\n        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;\n        ctx.lineWidth = Math.min(this.width, borderWidth);\n\n        ctx.beginPath();\n\n        // setup the line properties.\n        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;\n\n        // set a fillstyle\n        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;\n\n        // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image\n        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);\n        ctx.fill();\n\n        this.performStroke(ctx, values);\n\n        ctx.closePath();\n      }\n\n      this._drawImageAtPosition(ctx, values);\n\n      this._drawImageLabel(ctx, x, y, selected, hover);\n\n      this.updateBoundingBox(x, y);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: 'updateBoundingBox',\n    value: function updateBoundingBox(x, y) {\n      this.resize();\n      this._updateBoundingBox(x, y);\n\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Image;\n}(_CircleImageBase3['default']);\n\nexports['default'] = Image;\n\n/***/ }),\n/* 159 */\n/***/ (function(module, exports, __nested_webpack_require_791384__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_791384__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_791384__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_791384__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_791384__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_791384__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ShapeBase2 = __nested_webpack_require_791384__(17);\n\nvar _ShapeBase3 = _interopRequireDefault(_ShapeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Square Node/Cluster shape.\n *\n * @extends ShapeBase\n */\nvar Square = function (_ShapeBase) {\n  (0, _inherits3['default'])(Square, _ShapeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Square(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Square);\n    return (0, _possibleConstructorReturn3['default'])(this, (Square.__proto__ || (0, _getPrototypeOf2['default'])(Square)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   */\n\n\n  (0, _createClass3['default'])(Square, [{\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this._drawShape(ctx, 'square', 2, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Square;\n}(_ShapeBase3['default']);\n\nexports['default'] = Square;\n\n/***/ }),\n/* 160 */\n/***/ (function(module, exports, __nested_webpack_require_793601__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_793601__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_793601__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_793601__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_793601__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_793601__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ShapeBase2 = __nested_webpack_require_793601__(17);\n\nvar _ShapeBase3 = _interopRequireDefault(_ShapeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Hexagon Node/Cluster shape.\n *\n * @extends ShapeBase\n */\nvar Hexagon = function (_ShapeBase) {\n  (0, _inherits3['default'])(Hexagon, _ShapeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Hexagon(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Hexagon);\n    return (0, _possibleConstructorReturn3['default'])(this, (Hexagon.__proto__ || (0, _getPrototypeOf2['default'])(Hexagon)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   */\n\n\n  (0, _createClass3['default'])(Hexagon, [{\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this._drawShape(ctx, 'hexagon', 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Hexagon;\n}(_ShapeBase3['default']);\n\nexports['default'] = Hexagon;\n\n/***/ }),\n/* 161 */\n/***/ (function(module, exports, __nested_webpack_require_795829__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_795829__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_795829__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_795829__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_795829__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_795829__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ShapeBase2 = __nested_webpack_require_795829__(17);\n\nvar _ShapeBase3 = _interopRequireDefault(_ShapeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Star Node/Cluster shape.\n *\n * @extends ShapeBase\n */\nvar Star = function (_ShapeBase) {\n  (0, _inherits3['default'])(Star, _ShapeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Star(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Star);\n    return (0, _possibleConstructorReturn3['default'])(this, (Star.__proto__ || (0, _getPrototypeOf2['default'])(Star)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   */\n\n\n  (0, _createClass3['default'])(Star, [{\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this._drawShape(ctx, 'star', 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Star;\n}(_ShapeBase3['default']);\n\nexports['default'] = Star;\n\n/***/ }),\n/* 162 */\n/***/ (function(module, exports, __nested_webpack_require_798024__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_798024__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_798024__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_798024__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_798024__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_798024__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _NodeBase2 = __nested_webpack_require_798024__(16);\n\nvar _NodeBase3 = _interopRequireDefault(_NodeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A text-based replacement for the default Node shape.\n *\n * @extends NodeBase\n */\nvar Text = function (_NodeBase) {\n  (0, _inherits3['default'])(Text, _NodeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Text(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Text);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (Text.__proto__ || (0, _getPrototypeOf2['default'])(Text)).call(this, options, body, labelModule));\n\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n\n\n  (0, _createClass3['default'])(Text, [{\n    key: 'resize',\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n        this.width = this.textSize.width + this.margin.right + this.margin.left;\n        this.height = this.textSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Text;\n}(_NodeBase3['default']);\n\nexports['default'] = Text;\n\n/***/ }),\n/* 163 */\n/***/ (function(module, exports, __nested_webpack_require_801281__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_801281__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_801281__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_801281__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_801281__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_801281__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ShapeBase2 = __nested_webpack_require_801281__(17);\n\nvar _ShapeBase3 = _interopRequireDefault(_ShapeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Triangle Node/Cluster shape.\n *\n * @extends ShapeBase\n */\nvar Triangle = function (_ShapeBase) {\n  (0, _inherits3['default'])(Triangle, _ShapeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function Triangle(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, Triangle);\n    return (0, _possibleConstructorReturn3['default'])(this, (Triangle.__proto__ || (0, _getPrototypeOf2['default'])(Triangle)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   */\n\n\n  (0, _createClass3['default'])(Triangle, [{\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this._drawShape(ctx, 'triangle', 3, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Triangle;\n}(_ShapeBase3['default']);\n\nexports['default'] = Triangle;\n\n/***/ }),\n/* 164 */\n/***/ (function(module, exports, __nested_webpack_require_803507__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_803507__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_803507__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_803507__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_803507__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_803507__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ShapeBase2 = __nested_webpack_require_803507__(17);\n\nvar _ShapeBase3 = _interopRequireDefault(_ShapeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A downward facing Triangle Node/Cluster shape.\n *\n * @extends ShapeBase\n */\nvar TriangleDown = function (_ShapeBase) {\n  (0, _inherits3['default'])(TriangleDown, _ShapeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function TriangleDown(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, TriangleDown);\n    return (0, _possibleConstructorReturn3['default'])(this, (TriangleDown.__proto__ || (0, _getPrototypeOf2['default'])(TriangleDown)).call(this, options, body, labelModule));\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   */\n\n\n  (0, _createClass3['default'])(TriangleDown, [{\n    key: 'draw',\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this._drawShape(ctx, 'triangleDown', 3, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: 'distanceToBorder',\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return TriangleDown;\n}(_ShapeBase3['default']);\n\nexports['default'] = TriangleDown;\n\n/***/ }),\n/* 165 */\n/***/ (function(module, exports, __nested_webpack_require_805789__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_805789__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_805789__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_805789__(2);\nvar DataSet = __nested_webpack_require_805789__(33);\nvar DataView = __nested_webpack_require_805789__(51);\nvar Edge = __nested_webpack_require_805789__(55)['default'];\n\n/**\n * Handler for Edges\n */\n\nvar EdgesHandler = function () {\n  /**\n   * @param {Object} body\n   * @param {Array.<Image>} images\n   * @param {Array.<Group>} groups\n   */\n  function EdgesHandler(body, images, groups) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, EdgesHandler);\n\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n\n    // create the edge API in the body container\n    this.body.functions.createEdge = this.create.bind(this);\n\n    this.edgesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n\n    this.options = {};\n    this.defaultOptions = {\n      arrows: {\n        to: { enabled: false, scaleFactor: 1, type: 'arrow' }, // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}\n        middle: { enabled: false, scaleFactor: 1, type: 'arrow' },\n        from: { enabled: false, scaleFactor: 1, type: 'arrow' }\n      },\n      arrowStrikethrough: true,\n      color: {\n        color: '#848484',\n        highlight: '#848484',\n        hover: '#848484',\n        inherit: 'from',\n        opacity: 1.0\n      },\n      dashes: false,\n      font: {\n        color: '#343434',\n        size: 14, // px\n        face: 'arial',\n        background: 'none',\n        strokeWidth: 2, // px\n        strokeColor: '#ffffff',\n        align: 'horizontal',\n        multi: false,\n        vadjust: 0,\n        bold: {\n          mod: 'bold'\n        },\n        boldital: {\n          mod: 'bold italic'\n        },\n        ital: {\n          mod: 'italic'\n        },\n        mono: {\n          mod: '',\n          size: 15, // px\n          face: 'courier new',\n          vadjust: 2\n        }\n      },\n      hidden: false,\n      hoverWidth: 1.5,\n      label: undefined,\n      labelHighlightBold: true,\n      length: undefined,\n      physics: true,\n      scaling: {\n        min: 1,\n        max: 15,\n        label: {\n          enabled: true,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      selectionWidth: 1.5,\n      selfReferenceSize: 20,\n      shadow: {\n        enabled: false,\n        color: 'rgba(0,0,0,0.5)',\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      background: {\n        enabled: false,\n        color: 'rgba(111,111,111,1)',\n        size: 10,\n        dashes: false\n      },\n      smooth: {\n        enabled: true,\n        type: 'dynamic',\n        forceDirection: 'none',\n        roundness: 0.5\n      },\n      title: undefined,\n      width: 1,\n      value: undefined\n    };\n\n    util.deepExtend(this.options, this.defaultOptions);\n\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n\n\n  (0, _createClass3['default'])(EdgesHandler, [{\n    key: 'bindEventListeners',\n    value: function bindEventListeners() {\n      var _this2 = this;\n\n      // this allows external modules to force all dynamic curves to turn static.\n      this.body.emitter.on('_forceDisableDynamicCurves', function (type) {\n        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (type === 'dynamic') {\n          type = 'continuous';\n        }\n        var dataChanged = false;\n        for (var edgeId in _this2.body.edges) {\n          if (_this2.body.edges.hasOwnProperty(edgeId)) {\n            var edge = _this2.body.edges[edgeId];\n            var edgeData = _this2.body.data.edges._data[edgeId];\n\n            // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.\n            // this is because a change in the global would not affect these curves.\n            if (edgeData !== undefined) {\n              var smoothOptions = edgeData.smooth;\n              if (smoothOptions !== undefined) {\n                if (smoothOptions.enabled === true && smoothOptions.type === 'dynamic') {\n                  if (type === undefined) {\n                    edge.setOptions({ smooth: false });\n                  } else {\n                    edge.setOptions({ smooth: { type: type } });\n                  }\n                  dataChanged = true;\n                }\n              }\n            }\n          }\n        }\n        if (emit === true && dataChanged === true) {\n          _this2.body.emitter.emit('_dataChanged');\n        }\n      });\n\n      // this is called when options of EXISTING nodes or edges have changed.\n      //\n      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.\n      //       See update() for logic.\n      // TODO: Verify and examine the consequences of this. It might still trigger when\n      //       non-option fields have changed, but then reconnecting edges is still useless.\n      //       Alternatively, it might also be called when edges are removed.\n      //\n      this.body.emitter.on('_dataUpdated', function () {\n        _this2.reconnectEdges();\n      });\n\n      // refresh the edges. Used when reverting from hierarchical layout\n      this.body.emitter.on('refreshEdges', this.refresh.bind(this));\n      this.body.emitter.on('refresh', this.refresh.bind(this));\n      this.body.emitter.on('destroy', function () {\n        util.forEach(_this2.edgesListeners, function (callback, event) {\n          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);\n        });\n        delete _this2.body.functions.createEdge;\n        delete _this2.edgesListeners.add;\n        delete _this2.edgesListeners.update;\n        delete _this2.edgesListeners.remove;\n        delete _this2.edgesListeners;\n      });\n    }\n\n    /**\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // use the parser from the Edge class to fill in all shorthand notations\n        Edge.parseOptions(this.options, options, true, this.defaultOptions, true);\n\n        // update smooth settings in all edges\n        var dataChanged = false;\n        if (options.smooth !== undefined) {\n          for (var edgeId in this.body.edges) {\n            if (this.body.edges.hasOwnProperty(edgeId)) {\n              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;\n            }\n          }\n        }\n\n        // update fonts in all edges\n        if (options.font !== undefined) {\n          for (var _edgeId in this.body.edges) {\n            if (this.body.edges.hasOwnProperty(_edgeId)) {\n              this.body.edges[_edgeId].updateLabelModule();\n            }\n          }\n        }\n\n        // update the state of the variables if needed\n        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {\n          this.body.emitter.emit('_dataChanged');\n        }\n      }\n    }\n\n    /**\n     * Load edges by reading the data table\n     * @param {Array | DataSet | DataView} edges    The data containing the edges.\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n\n  }, {\n    key: 'setData',\n    value: function setData(edges) {\n      var _this3 = this;\n\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var oldEdgesData = this.body.data.edges;\n\n      if (edges instanceof DataSet || edges instanceof DataView) {\n        this.body.data.edges = edges;\n      } else if (Array.isArray(edges)) {\n        this.body.data.edges = new DataSet();\n        this.body.data.edges.add(edges);\n      } else if (!edges) {\n        this.body.data.edges = new DataSet();\n      } else {\n        throw new TypeError('Array or DataSet expected');\n      }\n\n      // TODO: is this null or undefined or false?\n      if (oldEdgesData) {\n        // unsubscribe from old dataset\n        util.forEach(this.edgesListeners, function (callback, event) {\n          oldEdgesData.off(event, callback);\n        });\n      }\n\n      // remove drawn edges\n      this.body.edges = {};\n\n      // TODO: is this null or undefined or false?\n      if (this.body.data.edges) {\n        // subscribe to new dataset\n        util.forEach(this.edgesListeners, function (callback, event) {\n          _this3.body.data.edges.on(event, callback);\n        });\n\n        // draw all new nodes\n        var ids = this.body.data.edges.getIds();\n        this.add(ids, true);\n      }\n\n      this.body.emitter.emit('_adjustEdgesForHierarchicalLayout');\n      if (doNotEmit === false) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     * Add edges\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n\n  }, {\n    key: 'add',\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n\n        var oldEdge = edges[id];\n        if (oldEdge) {\n          oldEdge.disconnect();\n        }\n\n        var data = edgesData.get(id, { showInternalIds: true });\n        edges[id] = this.create(data);\n      }\n\n      this.body.emitter.emit('_adjustEdgesForHierarchicalLayout');\n\n      if (doNotEmit === false) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     * Update existing edges, or create them when not yet existing\n     * @param {number[] | string[]} ids\n     * @private\n     */\n\n  }, {\n    key: 'update',\n    value: function update(ids) {\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = edgesData.get(id);\n        var edge = edges[id];\n        if (edge !== undefined) {\n          // update edge\n          edge.disconnect();\n          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.\n          edge.connect();\n        } else {\n          // create edge\n          this.body.edges[id] = this.create(data);\n          dataChanged = true;\n        }\n      }\n\n      if (dataChanged === true) {\n        this.body.emitter.emit('_adjustEdgesForHierarchicalLayout');\n        this.body.emitter.emit('_dataChanged');\n      } else {\n        this.body.emitter.emit('_dataUpdated');\n      }\n    }\n\n    /**\n     * Remove existing edges. Non existing ids will be ignored\n     * @param {number[] | string[]} ids\n     * @param {boolean} [emit=true]\n     * @private\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(ids) {\n      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (ids.length === 0) return; // early out\n\n      var edges = this.body.edges;\n      util.forEach(ids, function (id) {\n        var edge = edges[id];\n        if (edge !== undefined) {\n          edge.remove();\n        }\n      });\n\n      if (emit) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     * Refreshes Edge Handler\n     */\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      var _this4 = this;\n\n      util.forEach(this.body.edges, function (edge, edgeId) {\n        var data = _this4.body.data.edges._data[edgeId];\n        if (data !== undefined) {\n          edge.setOptions(data);\n        }\n      });\n    }\n\n    /**\n     *\n     * @param {Object} properties\n     * @returns {Edge}\n     */\n\n  }, {\n    key: 'create',\n    value: function create(properties) {\n      return new Edge(properties, this.body, this.options, this.defaultOptions);\n    }\n\n    /**\n     * Reconnect all edges\n     * @private\n     */\n\n  }, {\n    key: 'reconnectEdges',\n    value: function reconnectEdges() {\n      var id;\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n\n      for (id in nodes) {\n        if (nodes.hasOwnProperty(id)) {\n          nodes[id].edges = [];\n        }\n      }\n\n      for (id in edges) {\n        if (edges.hasOwnProperty(id)) {\n          var edge = edges[id];\n          edge.from = null;\n          edge.to = null;\n          edge.connect();\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {Edge.id} edgeId\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'getConnectedNodes',\n    value: function getConnectedNodes(edgeId) {\n      var nodeList = [];\n      if (this.body.edges[edgeId] !== undefined) {\n        var edge = this.body.edges[edgeId];\n        if (edge.fromId !== undefined) {\n          nodeList.push(edge.fromId);\n        }\n        if (edge.toId !== undefined) {\n          nodeList.push(edge.toId);\n        }\n      }\n      return nodeList;\n    }\n\n    /**\n     * There is no direct relation between the nodes and the edges DataSet,\n     * so the right place to do call this is in the handler for event `_dataUpdated`.\n     */\n\n  }, {\n    key: '_updateState',\n    value: function _updateState() {\n      this._addMissingEdges();\n      this._removeInvalidEdges();\n    }\n\n    /**\n     * Scan for missing nodes and remove corresponding edges, if any.\n     * @private\n     */\n\n  }, {\n    key: '_removeInvalidEdges',\n    value: function _removeInvalidEdges() {\n      var _this5 = this;\n\n      var edgesToDelete = [];\n\n      util.forEach(this.body.edges, function (edge, id) {\n        var toNode = _this5.body.nodes[edge.toId];\n        var fromNode = _this5.body.nodes[edge.fromId];\n\n        // Skip clustering edges here, let the Clustering module handle those\n        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {\n          return;\n        }\n\n        if (toNode === undefined || fromNode === undefined) {\n          edgesToDelete.push(id);\n        }\n      });\n\n      this.remove(edgesToDelete, false);\n    }\n\n    /**\n     * add all edges from dataset that are not in the cached state\n     * @private\n     */\n\n  }, {\n    key: '_addMissingEdges',\n    value: function _addMissingEdges() {\n      var edgesData = this.body.data.edges;\n      if (edgesData === undefined || edgesData === null) {\n        return; // No edges DataSet yet; can happen on startup\n      }\n\n      var edges = this.body.edges;\n      var addIds = [];\n\n      edgesData.forEach(function (edgeData, edgeId) {\n        var edge = edges[edgeId];\n        if (edge === undefined) {\n          addIds.push(edgeId);\n        }\n      });\n\n      this.add(addIds, true);\n    }\n  }]);\n  return EdgesHandler;\n}();\n\nexports['default'] = EdgesHandler;\n\n/***/ }),\n/* 166 */\n/***/ (function(module, exports, __nested_webpack_require_821252__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = __nested_webpack_require_821252__(15);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _getPrototypeOf = __nested_webpack_require_821252__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_821252__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_821252__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_821252__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_821252__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _CubicBezierEdgeBase2 = __nested_webpack_require_821252__(167);\n\nvar _CubicBezierEdgeBase3 = _interopRequireDefault(_CubicBezierEdgeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual\n * curves in paths between nodes.\n *\n * @extends CubicBezierEdgeBase\n */\nvar CubicBezierEdge = function (_CubicBezierEdgeBase) {\n  (0, _inherits3['default'])(CubicBezierEdge, _CubicBezierEdgeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function CubicBezierEdge(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, CubicBezierEdge);\n    return (0, _possibleConstructorReturn3['default'])(this, (CubicBezierEdge.__proto__ || (0, _getPrototypeOf2['default'])(CubicBezierEdge)).call(this, options, body, labelModule));\n  }\n\n  /**\n   * Draw a line between two nodes\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {ArrowOptions} values\n   * @param {Array.<Node>} viaNodes\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(CubicBezierEdge, [{\n    key: '_line',\n    value: function _line(ctx, values, viaNodes) {\n      // get the coordinates of the support points.\n      var via1 = viaNodes[0];\n      var via2 = viaNodes[1];\n      this._bezierCurve(ctx, values, via1, via2);\n    }\n\n    /**\n     *\n     * @returns {Array.<{x: number, y: number}>}\n     * @private\n     */\n\n  }, {\n    key: '_getViaCoordinates',\n    value: function _getViaCoordinates() {\n      var dx = this.from.x - this.to.x;\n      var dy = this.from.y - this.to.y;\n\n      var x1 = void 0,\n          y1 = void 0,\n          x2 = void 0,\n          y2 = void 0;\n      var roundness = this.options.smooth.roundness;\n\n      // horizontal if x > y or if direction is forced or if direction is horizontal\n      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === 'horizontal') && this.options.smooth.forceDirection !== 'vertical') {\n        y1 = this.from.y;\n        y2 = this.to.y;\n        x1 = this.from.x - roundness * dx;\n        x2 = this.to.x + roundness * dx;\n      } else {\n        y1 = this.from.y - roundness * dy;\n        y2 = this.to.y + roundness * dy;\n        x1 = this.from.x;\n        x2 = this.to.x;\n      }\n\n      return [{ x: x1, y: y1 }, { x: x2, y: y2 }];\n    }\n\n    /**\n     *\n     * @returns {Array.<{x: number, y: number}>}\n     */\n\n  }, {\n    key: 'getViaNode',\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n\n    /**\n     *\n     * @param {Node} nearNode\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {{x: number, y: number, t: number}}\n     * @private\n     */\n\n  }, {\n    key: '_findBorderPosition',\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx);\n    }\n\n    /**\n     *\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Node} via1\n     * @param {Node} via2\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getDistanceToEdge',\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),\n          _ref2 = (0, _slicedToArray3['default'])(_ref, 2),\n          via1 = _ref2[0],\n          via2 = _ref2[1];\n\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2);\n    }\n\n    /**\n     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way\n     * @param {number} percentage\n     * @param {{x: number, y: number}} [via1=this._getViaCoordinates()[0]]\n     * @param {{x: number, y: number}} [via2=this._getViaCoordinates()[1]]\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n\n  }, {\n    key: 'getPoint',\n    value: function getPoint(percentage) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),\n          _ref4 = (0, _slicedToArray3['default'])(_ref3, 2),\n          via1 = _ref4[0],\n          via2 = _ref4[1];\n\n      var t = percentage;\n      var vec = [];\n      vec[0] = Math.pow(1 - t, 3);\n      vec[1] = 3 * t * Math.pow(1 - t, 2);\n      vec[2] = 3 * Math.pow(t, 2) * (1 - t);\n      vec[3] = Math.pow(t, 3);\n      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;\n      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;\n\n      return { x: x, y: y };\n    }\n  }]);\n  return CubicBezierEdge;\n}(_CubicBezierEdgeBase3['default']);\n\nexports['default'] = CubicBezierEdge;\n\n/***/ }),\n/* 167 */\n/***/ (function(module, exports, __nested_webpack_require_826989__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_826989__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_826989__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_826989__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_826989__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_826989__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _BezierEdgeBase2 = __nested_webpack_require_826989__(56);\n\nvar _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model\n * smooth gradual curves in paths between nodes.\n *\n * @extends BezierEdgeBase\n */\nvar CubicBezierEdgeBase = function (_BezierEdgeBase) {\n  (0, _inherits3['default'])(CubicBezierEdgeBase, _BezierEdgeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function CubicBezierEdgeBase(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, CubicBezierEdgeBase);\n    return (0, _possibleConstructorReturn3['default'])(this, (CubicBezierEdgeBase.__proto__ || (0, _getPrototypeOf2['default'])(CubicBezierEdgeBase)).call(this, options, body, labelModule));\n  }\n\n  /**\n   * Calculate the distance between a point (x3,y3) and a line segment from\n   * (x1,y1) to (x2,y2).\n   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\n   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n   * @param {number} x1 from x\n   * @param {number} y1 from y\n   * @param {number} x2 to x\n   * @param {number} y2 to y\n   * @param {number} x3 point to check x\n   * @param {number} y3 point to check y\n   * @param {Node} via1\n   * @param {Node} via2\n   * @returns {number}\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(CubicBezierEdgeBase, [{\n    key: '_getDistanceToBezierEdge',\n    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var distance = void 0;\n      var i = void 0,\n          t = void 0,\n          x = void 0,\n          y = void 0;\n      var lastX = x1;\n      var lastY = y1;\n      var vec = [0, 0, 0, 0];\n      for (i = 1; i < 10; i++) {\n        t = 0.1 * i;\n        vec[0] = Math.pow(1 - t, 3);\n        vec[1] = 3 * t * Math.pow(1 - t, 2);\n        vec[2] = 3 * Math.pow(t, 2) * (1 - t);\n        vec[3] = Math.pow(t, 3);\n        x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;\n        y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;\n        if (i > 0) {\n          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n\n      return minDistance;\n    }\n  }]);\n  return CubicBezierEdgeBase;\n}(_BezierEdgeBase3['default']);\n\nexports['default'] = CubicBezierEdgeBase;\n\n/***/ }),\n/* 168 */\n/***/ (function(module, exports, __nested_webpack_require_830360__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = __nested_webpack_require_830360__(15);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _getPrototypeOf = __nested_webpack_require_830360__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_830360__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_830360__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_830360__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_830360__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _BezierEdgeBase2 = __nested_webpack_require_830360__(56);\n\nvar _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual\n * curves in paths between nodes. The Dynamic piece refers to how the curve\n * reacts to physics changes.\n *\n * @extends BezierEdgeBase\n */\nvar BezierEdgeDynamic = function (_BezierEdgeBase) {\n  (0, _inherits3['default'])(BezierEdgeDynamic, _BezierEdgeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function BezierEdgeDynamic(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, BezierEdgeDynamic);\n\n    // --> this calls the setOptions below\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (BezierEdgeDynamic.__proto__ || (0, _getPrototypeOf2['default'])(BezierEdgeDynamic)).call(this, options, body, labelModule));\n    //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.\n\n\n    _this._boundFunction = function () {\n      _this.positionBezierNode();\n    };\n    _this.body.emitter.on('_repositionBezierNodes', _this._boundFunction);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(BezierEdgeDynamic, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      // check if the physics has changed.\n      var physicsChange = false;\n      if (this.options.physics !== options.physics) {\n        physicsChange = true;\n      }\n\n      // set the options and the to and from nodes\n      this.options = options;\n      this.id = this.options.id;\n      this.from = this.body.nodes[this.options.from];\n      this.to = this.body.nodes[this.options.to];\n\n      // setup the support node and connect\n      this.setupSupportNode();\n      this.connect();\n\n      // when we change the physics state of the edge, we reposition the support node.\n      if (physicsChange === true) {\n        this.via.setOptions({ physics: this.options.physics });\n        this.positionBezierNode();\n      }\n    }\n\n    /**\n     * Connects an edge to node(s)\n     */\n\n  }, {\n    key: 'connect',\n    value: function connect() {\n      this.from = this.body.nodes[this.options.from];\n      this.to = this.body.nodes[this.options.to];\n      if (this.from === undefined || this.to === undefined || this.options.physics === false) {\n        this.via.setOptions({ physics: false });\n      } else {\n        // fix weird behaviour where a self referencing node has physics enabled\n        if (this.from.id === this.to.id) {\n          this.via.setOptions({ physics: false });\n        } else {\n          this.via.setOptions({ physics: true });\n        }\n      }\n    }\n\n    /**\n     * remove the support nodes\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'cleanup',\n    value: function cleanup() {\n      this.body.emitter.off('_repositionBezierNodes', this._boundFunction);\n      if (this.via !== undefined) {\n        delete this.body.nodes[this.via.id];\n        this.via = undefined;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Bezier curves require an anchor point to calculate the smooth flow. These points are nodes. These nodes are invisible but\n     * are used for the force calculation.\n     *\n     * The changed data is not called, if needed, it is returned by the main edge constructor.\n     * @private\n     */\n\n  }, {\n    key: 'setupSupportNode',\n    value: function setupSupportNode() {\n      if (this.via === undefined) {\n        var nodeId = 'edgeId:' + this.id;\n        var node = this.body.functions.createNode({\n          id: nodeId,\n          shape: 'circle',\n          physics: true,\n          hidden: true\n        });\n        this.body.nodes[nodeId] = node;\n        this.via = node;\n        this.via.parentEdgeId = this.id;\n        this.positionBezierNode();\n      }\n    }\n\n    /**\n     * Positions bezier node\n     */\n\n  }, {\n    key: 'positionBezierNode',\n    value: function positionBezierNode() {\n      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {\n        this.via.x = 0.5 * (this.from.x + this.to.x);\n        this.via.y = 0.5 * (this.from.y + this.to.y);\n      } else if (this.via !== undefined) {\n        this.via.x = 0;\n        this.via.y = 0;\n      }\n    }\n\n    /**\n     * Draw a line between two nodes\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     * @param {Node} viaNode\n     * @private\n     */\n\n  }, {\n    key: '_line',\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n\n    /**\n     *\n     * @returns {Node|undefined|*|{index, line, column}}\n     */\n\n  }, {\n    key: 'getViaNode',\n    value: function getViaNode() {\n      return this.via;\n    }\n\n    /**\n     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way\n     *\n     * @param {number} percentage\n     * @param {Node} viaNode\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n\n  }, {\n    key: 'getPoint',\n    value: function getPoint(percentage) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;\n\n      var t = percentage;\n      var x = void 0,\n          y = void 0;\n      if (this.from === this.to) {\n        var _getCircleData = this._getCircleData(this.from),\n            _getCircleData2 = (0, _slicedToArray3['default'])(_getCircleData, 3),\n            cx = _getCircleData2[0],\n            cy = _getCircleData2[1],\n            cr = _getCircleData2[2];\n\n        var a = 2 * Math.PI * (1 - t);\n        x = cx + cr * Math.sin(a);\n        y = cy + cr - cr * (1 - Math.cos(a));\n      } else {\n        x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;\n        y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;\n      }\n\n      return { x: x, y: y };\n    }\n\n    /**\n     *\n     * @param {Node} nearNode\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: '_findBorderPosition',\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx, this.via);\n    }\n\n    /**\n     *\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getDistanceToEdge',\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);\n    }\n  }]);\n  return BezierEdgeDynamic;\n}(_BezierEdgeBase3['default']);\n\nexports['default'] = BezierEdgeDynamic;\n\n/***/ }),\n/* 169 */\n/***/ (function(module, exports, __nested_webpack_require_838185__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_838185__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_838185__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_838185__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_838185__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_838185__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _BezierEdgeBase2 = __nested_webpack_require_838185__(56);\n\nvar _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Static Bezier Edge. Bezier curves are used to model smooth gradual\n * curves in paths between nodes.\n *\n * @extends BezierEdgeBase\n */\nvar BezierEdgeStatic = function (_BezierEdgeBase) {\n  (0, _inherits3['default'])(BezierEdgeStatic, _BezierEdgeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function BezierEdgeStatic(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, BezierEdgeStatic);\n    return (0, _possibleConstructorReturn3['default'])(this, (BezierEdgeStatic.__proto__ || (0, _getPrototypeOf2['default'])(BezierEdgeStatic)).call(this, options, body, labelModule));\n  }\n\n  /**\n   * Draw a line between two nodes\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {ArrowOptions} values\n   * @param {Node} viaNode\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(BezierEdgeStatic, [{\n    key: '_line',\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n\n    /**\n     *\n     * @returns {Array.<{x: number, y: number}>}\n     */\n\n  }, {\n    key: 'getViaNode',\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n\n    /**\n     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.\n     * @returns {{x: undefined, y: undefined}}\n     * @private\n     */\n\n  }, {\n    key: '_getViaCoordinates',\n    value: function _getViaCoordinates() {\n      // Assumption: x/y coordinates in from/to always defined\n      var xVia = undefined;\n      var yVia = undefined;\n      var factor = this.options.smooth.roundness;\n      var type = this.options.smooth.type;\n      var dx = Math.abs(this.from.x - this.to.x);\n      var dy = Math.abs(this.from.y - this.to.y);\n      if (type === 'discrete' || type === 'diagonalCross') {\n        var stepX = void 0;\n        var stepY = void 0;\n\n        if (dx <= dy) {\n          stepX = stepY = factor * dy;\n        } else {\n          stepX = stepY = factor * dx;\n        }\n\n        if (this.from.x > this.to.x) stepX = -stepX;\n        if (this.from.y >= this.to.y) stepY = -stepY;\n\n        xVia = this.from.x + stepX;\n        yVia = this.from.y + stepY;\n\n        if (type === 'discrete') {\n          if (dx <= dy) {\n            xVia = dx < factor * dy ? this.from.x : xVia;\n          } else {\n            yVia = dy < factor * dx ? this.from.y : yVia;\n          }\n        }\n      } else if (type === 'straightCross') {\n        var _stepX = (1 - factor) * dx;\n        var _stepY = (1 - factor) * dy;\n\n        if (dx <= dy) {\n          // up - down\n          _stepX = 0;\n          if (this.from.y < this.to.y) _stepY = -_stepY;\n        } else {\n          // left - right\n          if (this.from.x < this.to.x) _stepX = -_stepX;\n          _stepY = 0;\n        }\n        xVia = this.to.x + _stepX;\n        yVia = this.to.y + _stepY;\n      } else if (type === 'horizontal') {\n        var _stepX2 = (1 - factor) * dx;\n        if (this.from.x < this.to.x) _stepX2 = -_stepX2;\n        xVia = this.to.x + _stepX2;\n        yVia = this.from.y;\n      } else if (type === 'vertical') {\n        var _stepY2 = (1 - factor) * dy;\n        if (this.from.y < this.to.y) _stepY2 = -_stepY2;\n        xVia = this.from.x;\n        yVia = this.to.y + _stepY2;\n      } else if (type === 'curvedCW') {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        var pi = Math.PI;\n\n        var originalAngle = Math.atan2(dy, dx);\n        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);\n\n        xVia = this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle);\n        yVia = this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle);\n      } else if (type === 'curvedCCW') {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var _radius = Math.sqrt(dx * dx + dy * dy);\n        var _pi = Math.PI;\n\n        var _originalAngle = Math.atan2(dy, dx);\n        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);\n\n        xVia = this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle);\n        yVia = this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle);\n      } else {\n        // continuous\n        var _stepX3 = void 0;\n        var _stepY3 = void 0;\n\n        if (dx <= dy) {\n          _stepX3 = _stepY3 = factor * dy;\n        } else {\n          _stepX3 = _stepY3 = factor * dx;\n        }\n\n        if (this.from.x > this.to.x) _stepX3 = -_stepX3;\n        if (this.from.y >= this.to.y) _stepY3 = -_stepY3;\n\n        xVia = this.from.x + _stepX3;\n        yVia = this.from.y + _stepY3;\n\n        if (dx <= dy) {\n          if (this.from.x <= this.to.x) {\n            xVia = this.to.x < xVia ? this.to.x : xVia;\n          } else {\n            xVia = this.to.x > xVia ? this.to.x : xVia;\n          }\n        } else {\n          if (this.from.y >= this.to.y) {\n            yVia = this.to.y > yVia ? this.to.y : yVia;\n          } else {\n            yVia = this.to.y < yVia ? this.to.y : yVia;\n          }\n        }\n      }\n      return { x: xVia, y: yVia };\n    }\n\n    /**\n     *\n     * @param {Node} nearNode\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Object} options\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: '_findBorderPosition',\n    value: function _findBorderPosition(nearNode, ctx) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      return this._findBorderPositionBezier(nearNode, ctx, options.via);\n    }\n\n    /**\n     *\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Node} viaNode\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getDistanceToEdge',\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();\n\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);\n    }\n\n    /**\n     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way\n     * @param {number} percentage\n     * @param {Node} viaNode\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n\n  }, {\n    key: 'getPoint',\n    value: function getPoint(percentage) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();\n\n      var t = percentage;\n      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;\n      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;\n\n      return { x: x, y: y };\n    }\n  }]);\n  return BezierEdgeStatic;\n}(_BezierEdgeBase3['default']);\n\nexports['default'] = BezierEdgeStatic;\n\n/***/ }),\n/* 170 */\n/***/ (function(module, exports, __nested_webpack_require_846176__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_846176__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_846176__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_846176__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_846176__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_846176__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _EdgeBase2 = __nested_webpack_require_846176__(79);\n\nvar _EdgeBase3 = _interopRequireDefault(_EdgeBase2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * A Straight Edge.\n *\n * @extends EdgeBase\n */\nvar StraightEdge = function (_EdgeBase) {\n  (0, _inherits3['default'])(StraightEdge, _EdgeBase);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Label} labelModule\n   */\n  function StraightEdge(options, body, labelModule) {\n    (0, _classCallCheck3['default'])(this, StraightEdge);\n    return (0, _possibleConstructorReturn3['default'])(this, (StraightEdge.__proto__ || (0, _getPrototypeOf2['default'])(StraightEdge)).call(this, options, body, labelModule));\n  }\n\n  /**\n   * Draw a line between two nodes\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {ArrowOptions} values\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(StraightEdge, [{\n    key: '_line',\n    value: function _line(ctx, values) {\n      // draw a straight line\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n\n    /**\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'getViaNode',\n    value: function getViaNode() {\n      return undefined;\n    }\n\n    /**\n     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way\n     *\n     * @param {number} percentage\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n\n  }, {\n    key: 'getPoint',\n    value: function getPoint(percentage) {\n      return {\n        x: (1 - percentage) * this.fromPoint.x + percentage * this.toPoint.x,\n        y: (1 - percentage) * this.fromPoint.y + percentage * this.toPoint.y\n      };\n    }\n\n    /**\n     *\n     * @param {Node} nearNode\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n\n  }, {\n    key: '_findBorderPosition',\n    value: function _findBorderPosition(nearNode, ctx) {\n      var node1 = this.to;\n      var node2 = this.from;\n      if (nearNode.id === this.from.id) {\n        node1 = this.from;\n        node2 = this.to;\n      }\n\n      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);\n      var toBorderDist = nearNode.distanceToBorder(ctx, angle);\n      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;\n\n      var borderPos = {};\n      borderPos.x = (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x;\n      borderPos.y = (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y;\n\n      return borderPos;\n    }\n\n    /**\n     *\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getDistanceToEdge',\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);\n    }\n  }]);\n  return StraightEdge;\n}(_EdgeBase3['default']);\n\nexports['default'] = StraightEdge;\n\n/***/ }),\n/* 171 */\n/***/ (function(module, exports, __nested_webpack_require_850332__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys = __nested_webpack_require_850332__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = __nested_webpack_require_850332__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_850332__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar BarnesHutSolver = __nested_webpack_require_850332__(81)['default'];\nvar Repulsion = __nested_webpack_require_850332__(172)['default'];\nvar HierarchicalRepulsion = __nested_webpack_require_850332__(173)['default'];\nvar SpringSolver = __nested_webpack_require_850332__(174)['default'];\nvar HierarchicalSpringSolver = __nested_webpack_require_850332__(175)['default'];\nvar CentralGravitySolver = __nested_webpack_require_850332__(82)['default'];\nvar ForceAtlas2BasedRepulsionSolver = __nested_webpack_require_850332__(176)['default'];\nvar ForceAtlas2BasedCentralGravitySolver = __nested_webpack_require_850332__(177)['default'];\nvar util = __nested_webpack_require_850332__(2);\nvar EndPoints = __nested_webpack_require_850332__(80)['default']; // for debugging with _drawForces()\n\n/**\n * The physics engine\n */\n\nvar PhysicsEngine = function () {\n  /**\n   * @param {Object} body\n   */\n  function PhysicsEngine(body) {\n    (0, _classCallCheck3['default'])(this, PhysicsEngine);\n\n    this.body = body;\n    this.physicsBody = {\n      physicsNodeIndices: [],\n      physicsEdgeIndices: [],\n      forces: {},\n      velocities: {}\n    };\n\n    this.physicsEnabled = true;\n    this.simulationInterval = 1000 / 60;\n    this.requiresTimeout = true;\n    this.previousStates = {};\n    this.referenceState = {};\n    this.freezeCache = {};\n    this.renderTimer = undefined;\n\n    // parameters for the adaptive timestep\n    this.adaptiveTimestep = false;\n    this.adaptiveTimestepEnabled = false;\n    this.adaptiveCounter = 0;\n    this.adaptiveInterval = 3;\n\n    this.stabilized = false;\n    this.startedStabilization = false;\n    this.stabilizationIterations = 0;\n    this.ready = false; // will be set to true if the stabilize\n\n    // default options\n    this.options = {};\n    this.defaultOptions = {\n      enabled: true,\n      barnesHut: {\n        theta: 0.5,\n        gravitationalConstant: -2000,\n        centralGravity: 0.3,\n        springLength: 95,\n        springConstant: 0.04,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      forceAtlas2Based: {\n        theta: 0.5,\n        gravitationalConstant: -50,\n        centralGravity: 0.01,\n        springConstant: 0.08,\n        springLength: 100,\n        damping: 0.4,\n        avoidOverlap: 0\n      },\n      repulsion: {\n        centralGravity: 0.2,\n        springLength: 200,\n        springConstant: 0.05,\n        nodeDistance: 100,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      hierarchicalRepulsion: {\n        centralGravity: 0.0,\n        springLength: 100,\n        springConstant: 0.01,\n        nodeDistance: 120,\n        damping: 0.09\n      },\n      maxVelocity: 50,\n      minVelocity: 0.75, // px/s\n      solver: 'barnesHut',\n      stabilization: {\n        enabled: true,\n        iterations: 1000, // maximum number of iteration to stabilize\n        updateInterval: 50,\n        onlyDynamicEdges: false,\n        fit: true\n      },\n      timestep: 0.5,\n      adaptiveTimestep: true\n    };\n    util.extend(this.options, this.defaultOptions);\n    this.timestep = 0.5;\n    this.layoutFailed = false;\n\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n\n\n  (0, _createClass3['default'])(PhysicsEngine, [{\n    key: 'bindEventListeners',\n    value: function bindEventListeners() {\n      var _this = this;\n\n      this.body.emitter.on('initPhysics', function () {\n        _this.initPhysics();\n      });\n      this.body.emitter.on('_layoutFailed', function () {\n        _this.layoutFailed = true;\n      });\n      this.body.emitter.on('resetPhysics', function () {\n        _this.stopSimulation();\n        _this.ready = false;\n      });\n      this.body.emitter.on('disablePhysics', function () {\n        _this.physicsEnabled = false;\n        _this.stopSimulation();\n      });\n      this.body.emitter.on('restorePhysics', function () {\n        _this.setOptions(_this.options);\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on('startSimulation', function () {\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on('stopSimulation', function () {\n        _this.stopSimulation();\n      });\n      this.body.emitter.on('destroy', function () {\n        _this.stopSimulation(false);\n        _this.body.emitter.off();\n      });\n      this.body.emitter.on('_dataChanged', function () {\n        // Nodes and/or edges have been added or removed, update shortcut lists.\n        _this.updatePhysicsData();\n      });\n\n      // debug: show forces\n      // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._drawForces(ctx);});\n    }\n\n    /**\n     * set the physics options\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        if (options === false) {\n          this.options.enabled = false;\n          this.physicsEnabled = false;\n          this.stopSimulation();\n        } else if (options === true) {\n          this.options.enabled = true;\n          this.physicsEnabled = true;\n          this.startSimulation();\n        } else {\n          this.physicsEnabled = true;\n          util.selectiveNotDeepExtend(['stabilization'], this.options, options);\n          util.mergeOptions(this.options, options, 'stabilization');\n\n          if (options.enabled === undefined) {\n            this.options.enabled = true;\n          }\n\n          if (this.options.enabled === false) {\n            this.physicsEnabled = false;\n            this.stopSimulation();\n          }\n\n          // set the timestep\n          this.timestep = this.options.timestep;\n        }\n      }\n      this.init();\n    }\n\n    /**\n     * configure the engine.\n     */\n\n  }, {\n    key: 'init',\n    value: function init() {\n      var options;\n      if (this.options.solver === 'forceAtlas2Based') {\n        options = this.options.forceAtlas2Based;\n        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === 'repulsion') {\n        options = this.options.repulsion;\n        this.nodesSolver = new Repulsion(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === 'hierarchicalRepulsion') {\n        options = this.options.hierarchicalRepulsion;\n        this.nodesSolver = new HierarchicalRepulsion(this.body, this.physicsBody, options);\n        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else {\n        // barnesHut\n        options = this.options.barnesHut;\n        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      }\n\n      this.modelOptions = options;\n    }\n\n    /**\n     * initialize the engine\n     */\n\n  }, {\n    key: 'initPhysics',\n    value: function initPhysics() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        if (this.options.stabilization.enabled === true) {\n          this.stabilize();\n        } else {\n          this.stabilized = false;\n          this.ready = true;\n          this.body.emitter.emit('fit', {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom\n          this.startSimulation();\n        }\n      } else {\n        this.ready = true;\n        this.body.emitter.emit('fit');\n      }\n    }\n\n    /**\n     * Start the simulation\n     */\n\n  }, {\n    key: 'startSimulation',\n    value: function startSimulation() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        this.stabilized = false;\n\n        // when visible, adaptivity is disabled.\n        this.adaptiveTimestep = false;\n\n        // this sets the width of all nodes initially which could be required for the avoidOverlap\n        this.body.emitter.emit('_resizeNodes');\n        if (this.viewFunction === undefined) {\n          this.viewFunction = this.simulationStep.bind(this);\n          this.body.emitter.on('initRedraw', this.viewFunction);\n          this.body.emitter.emit('_startRendering');\n        }\n      } else {\n        this.body.emitter.emit('_redraw');\n      }\n    }\n\n    /**\n     * Stop the simulation, force stabilization.\n     * @param {boolean} [emit=true]\n     */\n\n  }, {\n    key: 'stopSimulation',\n    value: function stopSimulation() {\n      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this.stabilized = true;\n      if (emit === true) {\n        this._emitStabilized();\n      }\n      if (this.viewFunction !== undefined) {\n        this.body.emitter.off('initRedraw', this.viewFunction);\n        this.viewFunction = undefined;\n        if (emit === true) {\n          this.body.emitter.emit('_stopRendering');\n        }\n      }\n    }\n\n    /**\n     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.\n     *\n     */\n\n  }, {\n    key: 'simulationStep',\n    value: function simulationStep() {\n      // check if the physics have settled\n      var startTime = Date.now();\n      this.physicsTick();\n      var physicsTime = Date.now() - startTime;\n\n      // run double speed if it is a little graph\n      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {\n        this.physicsTick();\n\n        // this makes sure there is no jitter. The decision is taken once to run it at double speed.\n        this.runDoubleSpeed = true;\n      }\n\n      if (this.stabilized === true) {\n        this.stopSimulation();\n      }\n    }\n\n    /**\n     * trigger the stabilized event.\n     *\n     * @param {number} [amountOfIterations=this.stabilizationIterations]\n     * @private\n     */\n\n  }, {\n    key: '_emitStabilized',\n    value: function _emitStabilized() {\n      var _this2 = this;\n\n      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;\n\n      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {\n        setTimeout(function () {\n          _this2.body.emitter.emit('stabilized', { iterations: amountOfIterations });\n          _this2.startedStabilization = false;\n          _this2.stabilizationIterations = 0;\n        }, 0);\n      }\n    }\n\n    /**\n     * Calculate the forces for one physics iteration and move the nodes.\n     * @private\n     */\n\n  }, {\n    key: 'physicsStep',\n    value: function physicsStep() {\n      this.gravitySolver.solve();\n      this.nodesSolver.solve();\n      this.edgesSolver.solve();\n      this.moveNodes();\n    }\n\n    /**\n     * Make dynamic adjustments to the timestep, based on current state.\n     *\n     * Helper function for physicsTick().\n     * @private\n     */\n\n  }, {\n    key: 'adjustTimeStep',\n    value: function adjustTimeStep() {\n      var factor = 1.2; // Factor for increasing the timestep on success.\n\n      // we compare the two steps. if it is acceptable we double the step.\n      if (this._evaluateStepQuality() === true) {\n        this.timestep = factor * this.timestep;\n      } else {\n        // if not, we decrease the step to a minimum of the options timestep.\n        // if the decreased timestep is smaller than the options step, we do not reset the counter\n        // we assume that the options timestep is stable enough.\n        if (this.timestep / factor < this.options.timestep) {\n          this.timestep = this.options.timestep;\n        } else {\n          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure\n          // that large instabilities do not form.\n          this.adaptiveCounter = -1; // check again next iteration\n          this.timestep = Math.max(this.options.timestep, this.timestep / factor);\n        }\n      }\n    }\n\n    /**\n     * A single simulation step (or 'tick') in the physics simulation\n     *\n     * @private\n     */\n\n  }, {\n    key: 'physicsTick',\n    value: function physicsTick() {\n      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.\n      if (this.stabilized === true) return;\n\n      // adaptivity means the timestep adapts to the situation, only applicable for stabilization\n      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {\n        // timestep remains stable for \"interval\" iterations.\n        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;\n\n        if (doAdaptive) {\n          // first the big step and revert.\n          this.timestep = 2 * this.timestep;\n          this.physicsStep();\n          this.revert(); // saves the reference state\n\n          // now the normal step. Since this is the last step, it is the more stable one and we will take this.\n          this.timestep = 0.5 * this.timestep;\n\n          // since it's half the step, we do it twice.\n          this.physicsStep();\n          this.physicsStep();\n\n          this.adjustTimeStep();\n        } else {\n          this.physicsStep(); // normal step, keeping timestep constant\n        }\n\n        this.adaptiveCounter += 1;\n      } else {\n        // case for the static timestep, we reset it to the one in options and take a normal step.\n        this.timestep = this.options.timestep;\n        this.physicsStep();\n      }\n\n      if (this.stabilized === true) this.revert();\n      this.stabilizationIterations++;\n    }\n\n    /**\n     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'updatePhysicsData',\n    value: function updatePhysicsData() {\n      this.physicsBody.forces = {};\n      this.physicsBody.physicsNodeIndices = [];\n      this.physicsBody.physicsEdgeIndices = [];\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n\n      // get node indices for physics\n      for (var nodeId in nodes) {\n        if (nodes.hasOwnProperty(nodeId)) {\n          if (nodes[nodeId].options.physics === true) {\n            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);\n          }\n        }\n      }\n\n      // get edge indices for physics\n      for (var edgeId in edges) {\n        if (edges.hasOwnProperty(edgeId)) {\n          if (edges[edgeId].options.physics === true) {\n            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);\n          }\n        }\n      }\n\n      // get the velocity and the forces vector\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var _nodeId = this.physicsBody.physicsNodeIndices[i];\n        this.physicsBody.forces[_nodeId] = { x: 0, y: 0\n\n          // forces can be reset because they are recalculated. Velocities have to persist.\n        };if (this.physicsBody.velocities[_nodeId] === undefined) {\n          this.physicsBody.velocities[_nodeId] = { x: 0, y: 0 };\n        }\n      }\n\n      // clean deleted nodes from the velocity vector\n      for (var _nodeId2 in this.physicsBody.velocities) {\n        if (nodes[_nodeId2] === undefined) {\n          delete this.physicsBody.velocities[_nodeId2];\n        }\n      }\n    }\n\n    /**\n     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.\n     */\n\n  }, {\n    key: 'revert',\n    value: function revert() {\n      var nodeIds = (0, _keys2['default'])(this.previousStates);\n      var nodes = this.body.nodes;\n      var velocities = this.physicsBody.velocities;\n      this.referenceState = {};\n\n      for (var i = 0; i < nodeIds.length; i++) {\n        var nodeId = nodeIds[i];\n        if (nodes[nodeId] !== undefined) {\n          if (nodes[nodeId].options.physics === true) {\n            this.referenceState[nodeId] = {\n              positions: { x: nodes[nodeId].x, y: nodes[nodeId].y }\n            };\n            velocities[nodeId].x = this.previousStates[nodeId].vx;\n            velocities[nodeId].y = this.previousStates[nodeId].vy;\n            nodes[nodeId].x = this.previousStates[nodeId].x;\n            nodes[nodeId].y = this.previousStates[nodeId].y;\n          }\n        } else {\n          delete this.previousStates[nodeId];\n        }\n      }\n    }\n\n    /**\n     * This compares the reference state to the current state\n     *\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_evaluateStepQuality',\n    value: function _evaluateStepQuality() {\n      var dx = void 0,\n          dy = void 0,\n          dpos = void 0;\n      var nodes = this.body.nodes;\n      var reference = this.referenceState;\n      var posThreshold = 0.3;\n\n      for (var nodeId in this.referenceState) {\n        if (this.referenceState.hasOwnProperty(nodeId) && nodes[nodeId] !== undefined) {\n          dx = nodes[nodeId].x - reference[nodeId].positions.x;\n          dy = nodes[nodeId].y - reference[nodeId].positions.y;\n\n          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n\n          if (dpos > posThreshold) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * move the nodes one timestep and check if they are stabilized\n     */\n\n  }, {\n    key: 'moveNodes',\n    value: function moveNodes() {\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var maxNodeVelocity = 0;\n      var averageNodeVelocity = 0;\n\n      // the velocity threshold (energy in the system) for the adaptivity toggle\n      var velocityAdaptiveThreshold = 5;\n\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        var nodeVelocity = this._performStep(nodeId);\n        // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized\n        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);\n        averageNodeVelocity += nodeVelocity;\n      }\n\n      // evaluating the stabilized and adaptiveTimestepEnabled conditions\n      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;\n      this.stabilized = maxNodeVelocity < this.options.minVelocity;\n    }\n\n    /**\n     * Calculate new velocity for a coordinate direction\n     *\n     * @param {number} v  velocity for current coordinate\n     * @param {number} f  regular force for current coordinate\n     * @param {number} m  mass of current node\n     * @returns {number} new velocity for current coordinate\n     * @private\n     */\n\n  }, {\n    key: 'calculateComponentVelocity',\n    value: function calculateComponentVelocity(v, f, m) {\n      var df = this.modelOptions.damping * v; // damping force\n      var a = (f - df) / m; // acceleration\n\n      v += a * this.timestep;\n\n      // Put a limit on the velocities if it is really high\n      var maxV = this.options.maxVelocity || 1e9;\n      if (Math.abs(v) > maxV) {\n        v = v > 0 ? maxV : -maxV;\n      }\n\n      return v;\n    }\n\n    /**\n     * Perform the actual step\n     *\n     * @param {Node.id} nodeId\n     * @returns {number} the new velocity of given node\n     * @private\n     */\n\n  }, {\n    key: '_performStep',\n    value: function _performStep(nodeId) {\n      var node = this.body.nodes[nodeId];\n      var force = this.physicsBody.forces[nodeId];\n      var velocity = this.physicsBody.velocities[nodeId];\n\n      // store the state so we can revert\n      this.previousStates[nodeId] = {\n        x: node.x,\n        y: node.y,\n        vx: velocity.x,\n        vy: velocity.y\n      };\n\n      if (node.options.fixed.x === false) {\n        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);\n        node.x += velocity.x * this.timestep;\n      } else {\n        force.x = 0;\n        velocity.x = 0;\n      }\n\n      if (node.options.fixed.y === false) {\n        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);\n        node.y += velocity.y * this.timestep;\n      } else {\n        force.y = 0;\n        velocity.y = 0;\n      }\n\n      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));\n      return totalVelocity;\n    }\n\n    /**\n     * When initializing and stabilizing, we can freeze nodes with a predefined position.\n     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_freezeNodes',\n    value: function _freezeNodes() {\n      var nodes = this.body.nodes;\n      for (var id in nodes) {\n        if (nodes.hasOwnProperty(id)) {\n          if (nodes[id].x && nodes[id].y) {\n            var fixed = nodes[id].options.fixed;\n            this.freezeCache[id] = { x: fixed.x, y: fixed.y };\n            fixed.x = true;\n            fixed.y = true;\n          }\n        }\n      }\n    }\n\n    /**\n     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_restoreFrozenNodes',\n    value: function _restoreFrozenNodes() {\n      var nodes = this.body.nodes;\n      for (var id in nodes) {\n        if (nodes.hasOwnProperty(id)) {\n          if (this.freezeCache[id] !== undefined) {\n            nodes[id].options.fixed.x = this.freezeCache[id].x;\n            nodes[id].options.fixed.y = this.freezeCache[id].y;\n          }\n        }\n      }\n      this.freezeCache = {};\n    }\n\n    /**\n     * Find a stable position for all nodes\n     *\n     * @param {number} [iterations=this.options.stabilization.iterations]\n     */\n\n  }, {\n    key: 'stabilize',\n    value: function stabilize() {\n      var _this3 = this;\n\n      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;\n\n      if (typeof iterations !== 'number') {\n        iterations = this.options.stabilization.iterations;\n        console.log('The stabilize method needs a numeric amount of iterations. Switching to default: ', iterations);\n      }\n\n      if (this.physicsBody.physicsNodeIndices.length === 0) {\n        this.ready = true;\n        return;\n      }\n\n      // enable adaptive timesteps\n      this.adaptiveTimestep =  true && this.options.adaptiveTimestep;\n\n      // this sets the width of all nodes initially which could be required for the avoidOverlap\n      this.body.emitter.emit('_resizeNodes');\n\n      this.stopSimulation(); // stop the render loop\n      this.stabilized = false;\n\n      // block redraw requests\n      this.body.emitter.emit('_blockRedraw');\n      this.targetIterations = iterations;\n\n      // start the stabilization\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._freezeNodes();\n      }\n      this.stabilizationIterations = 0;\n\n      setTimeout(function () {\n        return _this3._stabilizationBatch();\n      }, 0);\n    }\n\n    /**\n     * If not already stabilizing, start it and emit a start event.\n     *\n     * @returns {boolean} true if stabilization started with this call\n     * @private\n     */\n\n  }, {\n    key: '_startStabilizing',\n    value: function _startStabilizing() {\n      if (this.startedStabilization === true) return false;\n\n      this.body.emitter.emit('startStabilizing');\n      this.startedStabilization = true;\n      return true;\n    }\n\n    /**\n     * One batch of stabilization\n     * @private\n     */\n\n  }, {\n    key: '_stabilizationBatch',\n    value: function _stabilizationBatch() {\n      var _this4 = this;\n\n      var running = function running() {\n        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;\n      };\n\n      var sendProgress = function sendProgress() {\n        _this4.body.emitter.emit('stabilizationProgress', {\n          iterations: _this4.stabilizationIterations,\n          total: _this4.targetIterations\n        });\n      };\n\n      if (this._startStabilizing()) {\n        sendProgress(); // Ensure that there is at least one start event.\n      }\n\n      var count = 0;\n      while (running() && count < this.options.stabilization.updateInterval) {\n        this.physicsTick();\n        count++;\n      }\n\n      sendProgress();\n\n      if (running()) {\n        setTimeout(this._stabilizationBatch.bind(this), 0);\n      } else {\n        this._finalizeStabilization();\n      }\n    }\n\n    /**\n     * Wrap up the stabilization, fit and emit the events.\n     * @private\n     */\n\n  }, {\n    key: '_finalizeStabilization',\n    value: function _finalizeStabilization() {\n      this.body.emitter.emit('_allowRedraw');\n      if (this.options.stabilization.fit === true) {\n        this.body.emitter.emit('fit');\n      }\n\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._restoreFrozenNodes();\n      }\n\n      this.body.emitter.emit('stabilizationIterationsDone');\n      this.body.emitter.emit('_requestRedraw');\n\n      if (this.stabilized === true) {\n        this._emitStabilized();\n      } else {\n        this.startSimulation();\n      }\n\n      this.ready = true;\n    }\n\n    //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * Debug function that display arrows for the forces currently active in the network.\n     *\n     * Use this when debugging only.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n\n  }, {\n    key: '_drawForces',\n    value: function _drawForces(ctx) {\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var index = this.physicsBody.physicsNodeIndices[i];\n        var node = this.body.nodes[index];\n        var force = this.physicsBody.forces[index];\n        var factor = 20;\n        var colorFactor = 0.03;\n        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));\n\n        var size = Math.min(Math.max(5, forceSize), 15);\n        var arrowSize = 3 * size;\n\n        var color = util.HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);\n\n        var point = {\n          x: node.x + factor * force.x,\n          y: node.y + factor * force.y\n        };\n\n        ctx.lineWidth = size;\n        ctx.strokeStyle = color;\n        ctx.beginPath();\n        ctx.moveTo(node.x, node.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.stroke();\n\n        var angle = Math.atan2(force.y, force.x);\n        ctx.fillStyle = color;\n        EndPoints.draw(ctx, {\n          type: 'arrow',\n          point: point,\n          angle: angle,\n          length: arrowSize\n        });\n        ctx.fill();\n      }\n    }\n  }]);\n  return PhysicsEngine;\n}();\n\nexports['default'] = PhysicsEngine;\n\n/***/ }),\n/* 172 */\n/***/ (function(module, exports, __nested_webpack_require_877742__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_877742__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_877742__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Repulsion Solver\n */\nvar RepulsionSolver = function () {\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function RepulsionSolver(body, physicsBody, options) {\n    (0, _classCallCheck3[\"default\"])(this, RepulsionSolver);\n\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3[\"default\"])(RepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;\n\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // repulsing forces between nodes\n      var nodeDistance = this.options.nodeDistance;\n\n      // approximation constants\n      var a = -2 / 3 / nodeDistance;\n      var b = 4 / 3;\n\n      // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        node1 = nodes[nodeIndices[i]];\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          node2 = nodes[nodeIndices[j]];\n\n          dx = node2.x - node1.x;\n          dy = node2.y - node1.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n\n          // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.\n          if (distance === 0) {\n            distance = 0.1 * Math.random();\n            dx = distance;\n          }\n\n          if (distance < 2 * nodeDistance) {\n            if (distance < 0.5 * nodeDistance) {\n              repulsingForce = 1.0;\n            } else {\n              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))\n            }\n            repulsingForce = repulsingForce / distance;\n\n            fx = dx * repulsingForce;\n            fy = dy * repulsingForce;\n\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return RepulsionSolver;\n}();\n\nexports[\"default\"] = RepulsionSolver;\n\n/***/ }),\n/* 173 */\n/***/ (function(module, exports, __nested_webpack_require_880884__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_880884__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_880884__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Hierarchical Repulsion Solver\n */\nvar HierarchicalRepulsionSolver = function () {\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function HierarchicalRepulsionSolver(body, physicsBody, options) {\n    (0, _classCallCheck3[\"default\"])(this, HierarchicalRepulsionSolver);\n\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3[\"default\"])(HierarchicalRepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;\n\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // repulsing forces between nodes\n      var nodeDistance = this.options.nodeDistance;\n\n      // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n      for (i = 0; i < nodeIndices.length - 1; i++) {\n        node1 = nodes[nodeIndices[i]];\n        for (j = i + 1; j < nodeIndices.length; j++) {\n          node2 = nodes[nodeIndices[j]];\n\n          // nodes only affect nodes on their level\n          if (node1.level === node2.level) {\n            dx = node2.x - node1.x;\n            dy = node2.y - node1.y;\n            distance = Math.sqrt(dx * dx + dy * dy);\n\n            var steepness = 0.05;\n            if (distance < nodeDistance) {\n              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * nodeDistance, 2);\n            } else {\n              repulsingForce = 0;\n            }\n            // normalize force with\n            if (distance === 0) {\n              distance = 0.01;\n            } else {\n              repulsingForce = repulsingForce / distance;\n            }\n            fx = dx * repulsingForce;\n            fy = dy * repulsingForce;\n\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return HierarchicalRepulsionSolver;\n}();\n\nexports[\"default\"] = HierarchicalRepulsionSolver;\n\n/***/ }),\n/* 174 */\n/***/ (function(module, exports, __nested_webpack_require_884003__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_884003__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_884003__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Spring Solver\n */\nvar SpringSolver = function () {\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function SpringSolver(body, physicsBody, options) {\n    (0, _classCallCheck3[\"default\"])(this, SpringSolver);\n\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3[\"default\"])(SpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength = void 0,\n          edge = void 0;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var edges = this.body.edges;\n      var node1 = void 0,\n          node2 = void 0,\n          node3 = void 0;\n\n      // forces caused by the edges, modelled as springs\n      for (var i = 0; i < edgeIndices.length; i++) {\n        edge = edges[edgeIndices[i]];\n        if (edge.connected === true && edge.toId !== edge.fromId) {\n          // only calculate forces if nodes are in the same sector\n          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {\n            if (edge.edgeType.via !== undefined) {\n              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n              node1 = edge.to;\n              node2 = edge.edgeType.via;\n              node3 = edge.from;\n\n              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);\n              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);\n            } else {\n              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use\n              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.\n              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;\n              this._calculateSpringForce(edge.from, edge.to, edgeLength);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This is the code actually performing the calculation for the function above.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @param {number} edgeLength\n     * @private\n     */\n\n  }, {\n    key: \"_calculateSpringForce\",\n    value: function _calculateSpringForce(node1, node2, edgeLength) {\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);\n\n      // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n      var springForce = this.options.springConstant * (edgeLength - distance) / distance;\n\n      var fx = dx * springForce;\n      var fy = dy * springForce;\n\n      // handle the case where one node is not part of the physcis\n      if (this.physicsBody.forces[node1.id] !== undefined) {\n        this.physicsBody.forces[node1.id].x += fx;\n        this.physicsBody.forces[node1.id].y += fy;\n      }\n\n      if (this.physicsBody.forces[node2.id] !== undefined) {\n        this.physicsBody.forces[node2.id].x -= fx;\n        this.physicsBody.forces[node2.id].y -= fy;\n      }\n    }\n  }]);\n  return SpringSolver;\n}();\n\nexports[\"default\"] = SpringSolver;\n\n/***/ }),\n/* 175 */\n/***/ (function(module, exports, __nested_webpack_require_888054__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_888054__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_888054__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Hierarchical Spring Solver\n */\nvar HierarchicalSpringSolver = function () {\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function HierarchicalSpringSolver(body, physicsBody, options) {\n    (0, _classCallCheck3[\"default\"])(this, HierarchicalSpringSolver);\n\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3[\"default\"])(HierarchicalSpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var dx, dy, fx, fy, springForce, distance;\n      var edges = this.body.edges;\n      var factor = 0.5;\n\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // initialize the spring force counters\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        forces[nodeId].springFx = 0;\n        forces[nodeId].springFy = 0;\n      }\n\n      // forces caused by the edges, modelled as springs\n      for (var _i = 0; _i < edgeIndices.length; _i++) {\n        edge = edges[edgeIndices[_i]];\n        if (edge.connected === true) {\n          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n\n          dx = edge.from.x - edge.to.x;\n          dy = edge.from.y - edge.to.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n          distance = distance === 0 ? 0.01 : distance;\n\n          // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n          springForce = this.options.springConstant * (edgeLength - distance) / distance;\n\n          fx = dx * springForce;\n          fy = dy * springForce;\n\n          if (edge.to.level != edge.from.level) {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].springFx -= fx;\n              forces[edge.toId].springFy -= fy;\n            }\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].springFx += fx;\n              forces[edge.fromId].springFy += fy;\n            }\n          } else {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].x -= factor * fx;\n              forces[edge.toId].y -= factor * fy;\n            }\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].x += factor * fx;\n              forces[edge.fromId].y += factor * fy;\n            }\n          }\n        }\n      }\n\n      // normalize spring forces\n      springForce = 1;\n      var springFx, springFy;\n      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {\n        var _nodeId = nodeIndices[_i2];\n        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));\n        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));\n\n        forces[_nodeId].x += springFx;\n        forces[_nodeId].y += springFy;\n      }\n\n      // retain energy balance\n      var totalFx = 0;\n      var totalFy = 0;\n      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {\n        var _nodeId2 = nodeIndices[_i3];\n        totalFx += forces[_nodeId2].x;\n        totalFy += forces[_nodeId2].y;\n      }\n      var correctionFx = totalFx / nodeIndices.length;\n      var correctionFy = totalFy / nodeIndices.length;\n\n      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {\n        var _nodeId3 = nodeIndices[_i4];\n        forces[_nodeId3].x -= correctionFx;\n        forces[_nodeId3].y -= correctionFy;\n      }\n    }\n  }]);\n  return HierarchicalSpringSolver;\n}();\n\nexports[\"default\"] = HierarchicalSpringSolver;\n\n/***/ }),\n/* 176 */\n/***/ (function(module, exports, __nested_webpack_require_892574__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_892574__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_892574__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_892574__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_892574__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_892574__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _BarnesHutSolver2 = __nested_webpack_require_892574__(81);\n\nvar _BarnesHutSolver3 = _interopRequireDefault(_BarnesHutSolver2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * @extends BarnesHutSolver\n */\nvar ForceAtlas2BasedRepulsionSolver = function (_BarnesHutSolver) {\n  (0, _inherits3['default'])(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);\n\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {\n    (0, _classCallCheck3['default'])(this, ForceAtlas2BasedRepulsionSolver);\n    return (0, _possibleConstructorReturn3['default'])(this, (ForceAtlas2BasedRepulsionSolver.__proto__ || (0, _getPrototypeOf2['default'])(ForceAtlas2BasedRepulsionSolver)).call(this, body, physicsBody, options));\n  }\n\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Node} node\n   * @param {Object} parentBranch\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(ForceAtlas2BasedRepulsionSolver, [{\n    key: '_calculateForces',\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1 * Math.random();\n        dx = distance;\n      }\n\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n\n      var degree = node.edges.length + 1;\n      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n  }]);\n  return ForceAtlas2BasedRepulsionSolver;\n}(_BarnesHutSolver3['default']);\n\nexports['default'] = ForceAtlas2BasedRepulsionSolver;\n\n/***/ }),\n/* 177 */\n/***/ (function(module, exports, __nested_webpack_require_895653__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_895653__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_895653__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_895653__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_895653__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_895653__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _CentralGravitySolver2 = __nested_webpack_require_895653__(82);\n\nvar _CentralGravitySolver3 = _interopRequireDefault(_CentralGravitySolver2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * @extends CentralGravitySolver\n */\nvar ForceAtlas2BasedCentralGravitySolver = function (_CentralGravitySolver) {\n  (0, _inherits3['default'])(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);\n\n  /**\n   * @param {Object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {Object} options\n   */\n  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {\n    (0, _classCallCheck3['default'])(this, ForceAtlas2BasedCentralGravitySolver);\n    return (0, _possibleConstructorReturn3['default'])(this, (ForceAtlas2BasedCentralGravitySolver.__proto__ || (0, _getPrototypeOf2['default'])(ForceAtlas2BasedCentralGravitySolver)).call(this, body, physicsBody, options));\n  }\n\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Object<Node.id, Node>} forces\n   * @param {Node} node\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(ForceAtlas2BasedCentralGravitySolver, [{\n    key: '_calculateForces',\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      if (distance > 0) {\n        var degree = node.edges.length + 1;\n        var gravityForce = this.options.centralGravity * degree * node.options.mass;\n        forces[node.id].x = dx * gravityForce;\n        forces[node.id].y = dy * gravityForce;\n      }\n    }\n  }]);\n  return ForceAtlas2BasedCentralGravitySolver;\n}(_CentralGravitySolver3['default']);\n\nexports['default'] = ForceAtlas2BasedCentralGravitySolver;\n\n/***/ }),\n/* 178 */\n/***/ (function(module, exports, __nested_webpack_require_898211__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys = __nested_webpack_require_898211__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _typeof2 = __nested_webpack_require_898211__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _classCallCheck2 = __nested_webpack_require_898211__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_898211__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/* ===========================================================================\n\n# TODO\n\n- `edgeReplacedById` not cleaned up yet on cluster edge removal\n- allowSingleNodeCluster could be a global option as well; currently needs to always\n  be passed to clustering methods\n\n----------------------------------------------\n\n# State Model for Clustering\n\nThe total state for clustering is non-trivial. It is useful to have a model\navailable as to how it works. The following documents the relevant state items.\n\n\n## Network State\n\nThe following `network`-members are relevant to clustering:\n\n- `body.nodes`       - all nodes actively participating in the network\n- `body.edges`       - same for edges\n- `body.nodeIndices` - id's of nodes that are visible at a given moment\n- `body.edgeIndices` - same for edges\n\nThis includes:\n\n- helper nodes for dragging in `manipulation`\n- helper nodes for edge type `dynamic`\n- cluster nodes and edges\n- there may be more than this.\n\nA node/edge may be missing in the `Indices` member if:\n\n- it is a helper node\n- the node or edge state has option `hidden` set\n- It is not visible due to clustering\n\n\n## Clustering State\n\nFor the hashes, the id's of the nodes/edges are used as key.\n\nMember `network.clustering` contains the following items:\n\n- `clusteredNodes` - hash with values: { clusterId: <id of cluster>, node: <node instance>}\n- `clusteredEdges` - hash with values: restore information for given edge\n\n\nDue to nesting of clusters, these members can contain cluster nodes and edges as well.\n\nThe important thing to note here, is that the clustered nodes and edges also\nappear in the members of the cluster nodes. For data update, it is therefore \nimportant to scan these lists as well as the cluster nodes.\n\n\n### Cluster Node\n\nA cluster node has the following extra fields:\n\n- `isCluster : true` - indication that this is a cluster node\n- `containedNodes`   - hash of nodes contained in this cluster\n- `containedEdges`   - same for edges\n- `edges`            - array of cluster edges for this node \n\n\n**NOTE:**\n\n- `containedEdges` can also contain edges which are not clustered; e.g. an edge\n   connecting two nodes in the same cluster.\n\n\n### Cluster Edge\n\nThese are the items in the `edges` member of a clustered node. They have the\nfollowing relevant members:\n\n- 'clusteringEdgeReplacingIds` - array of id's of edges replaced by this edge\n\nNote that it's possible to nest clusters, so that `clusteringEdgeReplacingIds`\ncan contain edge id's of other clusters.\n\n\n### Clustered Edge\n\nThis is any edge contained by a cluster edge. It gets the following additional\nmember:\n\n- `edgeReplacedById` - id of the cluster edge in which current edge is clustered\n\n\n   =========================================================================== */\nvar util = __nested_webpack_require_898211__(2);\nvar NetworkUtil = __nested_webpack_require_898211__(57)['default'];\nvar Cluster = __nested_webpack_require_898211__(179)['default'];\nvar Edge = __nested_webpack_require_898211__(55)['default']; // Only needed for check on type!\nvar Node = __nested_webpack_require_898211__(34)['default']; // Only needed for check on type!\n\n/**\n * The clustering engine\n */\n\nvar ClusterEngine = function () {\n  /**\n   * @param {Object} body\n   */\n  function ClusterEngine(body) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, ClusterEngine);\n\n    this.body = body;\n    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}\n    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge\n\n    this.options = {};\n    this.defaultOptions = {};\n    util.extend(this.options, this.defaultOptions);\n\n    this.body.emitter.on('_resetData', function () {\n      _this.clusteredNodes = {};\n      _this.clusteredEdges = {};\n    });\n  }\n\n  /**\n   *\n   * @param {number} hubsize\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(ClusterEngine, [{\n    key: 'clusterByHubsize',\n    value: function clusterByHubsize(hubsize, options) {\n      if (hubsize === undefined) {\n        hubsize = this._getHubSize();\n      } else if ((typeof hubsize === 'undefined' ? 'undefined' : (0, _typeof3['default'])(hubsize)) === 'object') {\n        options = this._checkOptions(hubsize);\n        hubsize = this._getHubSize();\n      }\n\n      var nodesToCluster = [];\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        if (node.edges.length >= hubsize) {\n          nodesToCluster.push(node.id);\n        }\n      }\n\n      for (var _i = 0; _i < nodesToCluster.length; _i++) {\n        this.clusterByConnection(nodesToCluster[_i], options, true);\n      }\n\n      this.body.emitter.emit('_dataChanged');\n    }\n\n    /**\n     * loop over all nodes, check if they adhere to the condition and cluster if needed.\n     * @param {Object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: 'cluster',\n    value: function cluster() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (options.joinCondition === undefined) {\n        throw new Error('Cannot call clusterByNodeData without a joinCondition function in the options.');\n      }\n\n      // check if the options object is fine, append if needed\n      options = this._checkOptions(options);\n\n      var childNodesObj = {};\n      var childEdgesObj = {};\n\n      // collect the nodes that will be in the cluster\n      util.forEach(this.body.nodes, function (node, nodeId) {\n        if (node.options && options.joinCondition(node.options) === true) {\n          childNodesObj[nodeId] = node;\n\n          // collect the edges that will be in the cluster\n          util.forEach(node.edges, function (edge) {\n            if (_this2.clusteredEdges[edge.id] === undefined) {\n              childEdgesObj[edge.id] = edge;\n            }\n          });\n        }\n      });\n\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n\n    /**\n     * Cluster all nodes in the network that have only X edges\n     * @param {number} edgeCount\n     * @param {Object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: 'clusterByEdgeCount',\n    value: function clusterByEdgeCount(edgeCount, options) {\n      var _this3 = this;\n\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      options = this._checkOptions(options);\n      var clusters = [];\n      var usedNodes = {};\n      var edge = void 0,\n          edges = void 0,\n          relevantEdgeCount = void 0;\n      // collect the nodes that will be in the cluster\n\n      var _loop = function _loop(i) {\n        var childNodesObj = {};\n        var childEdgesObj = {};\n        var nodeId = _this3.body.nodeIndices[i];\n        var node = _this3.body.nodes[nodeId];\n\n        // if this node is already used in another cluster this session, we do not have to re-evaluate it.\n        if (usedNodes[nodeId] === undefined) {\n          relevantEdgeCount = 0;\n          edges = [];\n          for (var j = 0; j < node.edges.length; j++) {\n            edge = node.edges[j];\n            if (_this3.clusteredEdges[edge.id] === undefined) {\n              if (edge.toId !== edge.fromId) {\n                relevantEdgeCount++;\n              }\n              edges.push(edge);\n            }\n          }\n\n          // this node qualifies, we collect its neighbours to start the clustering process.\n          if (relevantEdgeCount === edgeCount) {\n            checkJoinCondition = function checkJoinCondition(node) {\n              if (options.joinCondition === undefined || options.joinCondition === null) {\n                return true;\n              }\n\n              var clonedOptions = NetworkUtil.cloneOptions(node);\n              return options.joinCondition(clonedOptions);\n            };\n\n            var gatheringSuccessful = true;\n            for (var _j = 0; _j < edges.length; _j++) {\n              edge = edges[_j];\n              var childNodeId = _this3._getConnectedId(edge, nodeId);\n              // add the nodes to the list by the join condition.\n              if (checkJoinCondition(node)) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[nodeId] = node;\n                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];\n                usedNodes[nodeId] = true;\n              } else {\n                // this node does not qualify after all.\n                gatheringSuccessful = false;\n                break;\n              }\n            }\n\n            // add to the cluster queue\n            if ((0, _keys2['default'])(childNodesObj).length > 0 && (0, _keys2['default'])(childEdgesObj).length > 0 && gatheringSuccessful === true) {\n              /**\n               * Search for cluster data that contains any of the node id's\n               * @returns {Boolean} true if no joinCondition, otherwise return value of joinCondition\n               */\n              findClusterData = function findClusterData() {\n                for (var n = 0; n < clusters.length; ++n) {\n                  // Search for a cluster containing any of the node id's\n                  for (var m in childNodesObj) {\n                    if (clusters[n].nodes[m] !== undefined) {\n                      return clusters[n];\n                    }\n                  }\n                }\n\n                return undefined;\n              };\n\n              // If any of the found nodes is part of a cluster found in this method,\n              // add the current values to that cluster\n\n\n              foundCluster = findClusterData();\n\n              if (foundCluster !== undefined) {\n                // Add nodes to found cluster if not present\n                for (var m in childNodesObj) {\n                  if (foundCluster.nodes[m] === undefined) {\n                    foundCluster.nodes[m] = childNodesObj[m];\n                  }\n                }\n\n                // Add edges to found cluster, if not present\n                for (var _m in childEdgesObj) {\n                  if (foundCluster.edges[_m] === undefined) {\n                    foundCluster.edges[_m] = childEdgesObj[_m];\n                  }\n                }\n              } else {\n                // Create a new cluster group\n                clusters.push({ nodes: childNodesObj, edges: childEdgesObj });\n              }\n            }\n          }\n        }\n      };\n\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var checkJoinCondition;\n        var findClusterData;\n        var foundCluster;\n\n        _loop(i);\n      }\n\n      for (var i = 0; i < clusters.length; i++) {\n        this._cluster(clusters[i].nodes, clusters[i].edges, options, false);\n      }\n\n      if (refreshData === true) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     * Cluster all nodes in the network that have only 1 edge\n     * @param {Object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: 'clusterOutliers',\n    value: function clusterOutliers(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      this.clusterByEdgeCount(1, options, refreshData);\n    }\n\n    /**\n     * Cluster all nodes in the network that have only 2 edge\n     * @param {Object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: 'clusterBridges',\n    value: function clusterBridges(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      this.clusterByEdgeCount(2, options, refreshData);\n    }\n\n    /**\n     * suck all connected nodes of a node into the node.\n     * @param {Node.id} nodeId\n     * @param {Object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: 'clusterByConnection',\n    value: function clusterByConnection(nodeId, options) {\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      // kill conditions\n      if (nodeId === undefined) {\n        throw new Error('No nodeId supplied to clusterByConnection!');\n      }\n      if (this.body.nodes[nodeId] === undefined) {\n        throw new Error('The nodeId given to clusterByConnection does not exist!');\n      }\n\n      var node = this.body.nodes[nodeId];\n      options = this._checkOptions(options, node);\n      if (options.clusterNodeProperties.x === undefined) {\n        options.clusterNodeProperties.x = node.x;\n      }\n      if (options.clusterNodeProperties.y === undefined) {\n        options.clusterNodeProperties.y = node.y;\n      }\n      if (options.clusterNodeProperties.fixed === undefined) {\n        options.clusterNodeProperties.fixed = {};\n        options.clusterNodeProperties.fixed.x = node.options.fixed.x;\n        options.clusterNodeProperties.fixed.y = node.options.fixed.y;\n      }\n\n      var childNodesObj = {};\n      var childEdgesObj = {};\n      var parentNodeId = node.id;\n      var parentClonedOptions = NetworkUtil.cloneOptions(node);\n      childNodesObj[parentNodeId] = node;\n\n      // collect the nodes that will be in the cluster\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        if (this.clusteredEdges[edge.id] === undefined) {\n          var childNodeId = this._getConnectedId(edge, parentNodeId);\n\n          // if the child node is not in a cluster\n          if (this.clusteredNodes[childNodeId] === undefined) {\n            if (childNodeId !== parentNodeId) {\n              if (options.joinCondition === undefined) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n              } else {\n                // clone the options and insert some additional parameters that could be interesting.\n                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);\n                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {\n                  childEdgesObj[edge.id] = edge;\n                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n                }\n              }\n            } else {\n              // swallow the edge if it is self-referencing.\n              childEdgesObj[edge.id] = edge;\n            }\n          }\n        }\n      }\n      var childNodeIDs = (0, _keys2['default'])(childNodesObj).map(function (childNode) {\n        return childNodesObj[childNode].id;\n      });\n\n      for (childNode in childNodesObj) {\n        if (!childNodesObj.hasOwnProperty(childNode)) continue;\n\n        var childNode = childNodesObj[childNode];\n        for (var y = 0; y < childNode.edges.length; y++) {\n          var childEdge = childNode.edges[y];\n          if (childNodeIDs.indexOf(this._getConnectedId(childEdge, childNode.id)) > -1) {\n            childEdgesObj[childEdge.id] = childEdge;\n          }\n        }\n      }\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n\n    /**\n     * This function creates the edges that will be attached to the cluster\n     * It looks for edges that are connected to the nodes from the \"outside' of the cluster.\n     *\n     * @param {{Node.id: vis.Node}} childNodesObj\n     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj\n     * @param {Object} clusterNodeProperties\n     * @param {Object} clusterEdgeProperties\n     * @private\n     */\n\n  }, {\n    key: '_createClusterEdges',\n    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {\n      var edge = void 0,\n          childNodeId = void 0,\n          childNode = void 0,\n          toId = void 0,\n          fromId = void 0,\n          otherNodeId = void 0;\n\n      // loop over all child nodes and their edges to find edges going out of the cluster\n      // these edges will be replaced by clusterEdges.\n      var childKeys = (0, _keys2['default'])(childNodesObj);\n      var createEdges = [];\n      for (var i = 0; i < childKeys.length; i++) {\n        childNodeId = childKeys[i];\n        childNode = childNodesObj[childNodeId];\n\n        // construct new edges from the cluster to others\n        for (var j = 0; j < childNode.edges.length; j++) {\n          edge = childNode.edges[j];\n          // we only handle edges that are visible to the system, not the disabled ones from the clustering process.\n          if (this.clusteredEdges[edge.id] === undefined) {\n            // self-referencing edges will be added to the \"hidden\" list\n            if (edge.toId == edge.fromId) {\n              childEdgesObj[edge.id] = edge;\n            } else {\n              // set up the from and to.\n              if (edge.toId == childNodeId) {\n                // this is a double equals because ints and strings can be interchanged here.\n                toId = clusterNodeProperties.id;\n                fromId = edge.fromId;\n                otherNodeId = fromId;\n              } else {\n                toId = edge.toId;\n                fromId = clusterNodeProperties.id;\n                otherNodeId = toId;\n              }\n            }\n\n            // Only edges from the cluster outwards are being replaced.\n            if (childNodesObj[otherNodeId] === undefined) {\n              createEdges.push({ edge: edge, fromId: fromId, toId: toId });\n            }\n          }\n        }\n      }\n\n      //\n      // Here we actually create the replacement edges.\n      //\n      // We could not do this in the loop above as the creation process\n      // would add an edge to the edges array we are iterating over.\n      //\n      // NOTE: a clustered edge can have multiple base edges!\n      //\n      var newEdges = [];\n\n      /**\n       * Find a cluster edge which matches the given created edge.\n       * @param {vis.Edge} createdEdge\n       * @returns {vis.Edge}\n       */\n      var getNewEdge = function getNewEdge(createdEdge) {\n        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {\n          var newEdge = newEdges[_j2];\n\n          // We replace both to and from edges with a single cluster edge\n          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;\n          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;\n\n          if (matchToDirection || matchFromDirection) {\n            return newEdge;\n          }\n        }\n\n        return null;\n      };\n\n      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {\n        var createdEdge = createEdges[_j3];\n        var _edge = createdEdge.edge;\n        var newEdge = getNewEdge(createdEdge);\n\n        if (newEdge === null) {\n          // Create a clustered edge for this connection\n          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);\n\n          newEdges.push(newEdge);\n        } else {\n          newEdge.clusteringEdgeReplacingIds.push(_edge.id);\n        }\n\n        // also reference the new edge in the old edge\n        this.body.edges[_edge.id].edgeReplacedById = newEdge.id;\n\n        // hide the replaced edge\n        this._backupEdgeOptions(_edge);\n        _edge.setOptions({ physics: false });\n      }\n    }\n\n    /**\n     * This function checks the options that can be supplied to the different cluster functions\n     * for certain fields and inserts defaults if needed\n     * @param {Object} options\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: '_checkOptions',\n    value: function _checkOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.clusterEdgeProperties === undefined) {\n        options.clusterEdgeProperties = {};\n      }\n      if (options.clusterNodeProperties === undefined) {\n        options.clusterNodeProperties = {};\n      }\n\n      return options;\n    }\n\n    /**\n     *\n     * @param {Object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node\n     * @param {Object}    childEdgesObj         | object with edge objects, id as keys\n     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}\n     * @param {boolean}   refreshData | when true, do not wrap up\n     * @private\n     */\n\n  }, {\n    key: '_cluster',\n    value: function _cluster(childNodesObj, childEdgesObj, options) {\n      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      // Remove nodes which are already clustered\n      var tmpNodesToRemove = [];\n      for (var _nodeId in childNodesObj) {\n        if (childNodesObj.hasOwnProperty(_nodeId)) {\n          if (this.clusteredNodes[_nodeId] !== undefined) {\n            tmpNodesToRemove.push(_nodeId);\n          }\n        }\n      }\n\n      for (var n = 0; n < tmpNodesToRemove.length; ++n) {\n        delete childNodesObj[tmpNodesToRemove[n]];\n      }\n\n      // kill condition: no nodes don't bother\n      if ((0, _keys2['default'])(childNodesObj).length == 0) {\n        return;\n      }\n\n      // allow clusters of 1 if options allow\n      if ((0, _keys2['default'])(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {\n        return;\n      }\n\n      var clusterNodeProperties = util.deepExtend({}, options.clusterNodeProperties);\n\n      // construct the clusterNodeProperties\n      if (options.processProperties !== undefined) {\n        // get the childNode options\n        var childNodesOptions = [];\n        for (var _nodeId2 in childNodesObj) {\n          if (childNodesObj.hasOwnProperty(_nodeId2)) {\n            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId2]);\n            childNodesOptions.push(clonedOptions);\n          }\n        }\n\n        // get cluster properties based on childNodes\n        var childEdgesOptions = [];\n        for (var edgeId in childEdgesObj) {\n          if (childEdgesObj.hasOwnProperty(edgeId)) {\n            // these cluster edges will be removed on creation of the cluster.\n            if (edgeId.substr(0, 12) !== 'clusterEdge:') {\n              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], 'edge');\n              childEdgesOptions.push(_clonedOptions);\n            }\n          }\n        }\n\n        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);\n        if (!clusterNodeProperties) {\n          throw new Error('The processProperties function does not return properties!');\n        }\n      }\n\n      // check if we have an unique id;\n      if (clusterNodeProperties.id === undefined) {\n        clusterNodeProperties.id = 'cluster:' + util.randomUUID();\n      }\n      var clusterId = clusterNodeProperties.id;\n\n      if (clusterNodeProperties.label === undefined) {\n        clusterNodeProperties.label = 'cluster';\n      }\n\n      // give the clusterNode a position if it does not have one.\n      var pos = undefined;\n      if (clusterNodeProperties.x === undefined) {\n        pos = this._getClusterPosition(childNodesObj);\n        clusterNodeProperties.x = pos.x;\n      }\n      if (clusterNodeProperties.y === undefined) {\n        if (pos === undefined) {\n          pos = this._getClusterPosition(childNodesObj);\n        }\n        clusterNodeProperties.y = pos.y;\n      }\n\n      // force the ID to remain the same\n      clusterNodeProperties.id = clusterId;\n\n      // create the cluster Node\n      // Note that allowSingleNodeCluster, if present, is stored in the options as well\n      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);\n      clusterNode.containedNodes = childNodesObj;\n      clusterNode.containedEdges = childEdgesObj;\n      // cache a copy from the cluster edge properties if we have to reconnect others later on\n      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;\n\n      // finally put the cluster node into global\n      this.body.nodes[clusterNodeProperties.id] = clusterNode;\n\n      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);\n\n      // set ID to undefined so no duplicates arise\n      clusterNodeProperties.id = undefined;\n\n      // wrap up\n      if (refreshData === true) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n\n  }, {\n    key: '_backupEdgeOptions',\n    value: function _backupEdgeOptions(edge) {\n      if (this.clusteredEdges[edge.id] === undefined) {\n        this.clusteredEdges[edge.id] = { physics: edge.options.physics };\n      }\n    }\n\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n\n  }, {\n    key: '_restoreEdge',\n    value: function _restoreEdge(edge) {\n      var originalOptions = this.clusteredEdges[edge.id];\n      if (originalOptions !== undefined) {\n        edge.setOptions({ physics: originalOptions.physics });\n        delete this.clusteredEdges[edge.id];\n      }\n    }\n\n    /**\n     * Check if a node is a cluster.\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n\n  }, {\n    key: 'isCluster',\n    value: function isCluster(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].isCluster === true;\n      } else {\n        console.log('Node does not exist.');\n        return false;\n      }\n    }\n\n    /**\n     * get the position of the cluster node based on what's inside\n     * @param {object} childNodesObj    | object with node objects, id as keys\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n\n  }, {\n    key: '_getClusterPosition',\n    value: function _getClusterPosition(childNodesObj) {\n      var childKeys = (0, _keys2['default'])(childNodesObj);\n      var minX = childNodesObj[childKeys[0]].x;\n      var maxX = childNodesObj[childKeys[0]].x;\n      var minY = childNodesObj[childKeys[0]].y;\n      var maxY = childNodesObj[childKeys[0]].y;\n      var node = void 0;\n      for (var i = 1; i < childKeys.length; i++) {\n        node = childNodesObj[childKeys[i]];\n        minX = node.x < minX ? node.x : minX;\n        maxX = node.x > maxX ? node.x : maxX;\n        minY = node.y < minY ? node.y : minY;\n        maxY = node.y > maxY ? node.y : maxY;\n      }\n\n      return { x: 0.5 * (minX + maxX), y: 0.5 * (minY + maxY) };\n    }\n\n    /**\n     * Open a cluster by calling this function.\n     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node\n     * @param {Object} options\n     * @param {boolean} refreshData | wrap up afterwards if not true\n     */\n\n  }, {\n    key: 'openCluster',\n    value: function openCluster(clusterNodeId, options) {\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      // kill conditions\n      if (clusterNodeId === undefined) {\n        throw new Error('No clusterNodeId supplied to openCluster.');\n      }\n\n      var clusterNode = this.body.nodes[clusterNodeId];\n\n      if (clusterNode === undefined) {\n        throw new Error('The clusterNodeId supplied to openCluster does not exist.');\n      }\n      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {\n        throw new Error('The node:' + clusterNodeId + ' is not a valid cluster.');\n      }\n\n      // Check if current cluster is clustered itself\n      var stack = this.findNode(clusterNodeId);\n      var parentIndex = stack.indexOf(clusterNodeId) - 1;\n      if (parentIndex >= 0) {\n        // Current cluster is clustered; transfer contained nodes and edges to parent\n        var parentClusterNodeId = stack[parentIndex];\n        var parentClusterNode = this.body.nodes[parentClusterNodeId];\n\n        // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged\n        parentClusterNode._openChildCluster(clusterNodeId);\n\n        // All components of child cluster node have been transferred. It can die now.\n        delete this.body.nodes[clusterNodeId];\n        if (refreshData === true) {\n          this.body.emitter.emit('_dataChanged');\n        }\n\n        return;\n      }\n\n      // main body\n      var containedNodes = clusterNode.containedNodes;\n      var containedEdges = clusterNode.containedEdges;\n\n      // allow the user to position the nodes after release.\n      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === 'function') {\n        var positions = {};\n        var clusterPosition = { x: clusterNode.x, y: clusterNode.y };\n        for (var _nodeId3 in containedNodes) {\n          if (containedNodes.hasOwnProperty(_nodeId3)) {\n            var containedNode = this.body.nodes[_nodeId3];\n            positions[_nodeId3] = { x: containedNode.x, y: containedNode.y };\n          }\n        }\n        var newPositions = options.releaseFunction(clusterPosition, positions);\n\n        for (var _nodeId4 in containedNodes) {\n          if (containedNodes.hasOwnProperty(_nodeId4)) {\n            var _containedNode = this.body.nodes[_nodeId4];\n            if (newPositions[_nodeId4] !== undefined) {\n              _containedNode.x = newPositions[_nodeId4].x === undefined ? clusterNode.x : newPositions[_nodeId4].x;\n              _containedNode.y = newPositions[_nodeId4].y === undefined ? clusterNode.y : newPositions[_nodeId4].y;\n            }\n          }\n        }\n      } else {\n        // copy the position from the cluster\n        util.forEach(containedNodes, function (containedNode) {\n          // inherit position\n          if (containedNode.options.fixed.x === false) {\n            containedNode.x = clusterNode.x;\n          }\n          if (containedNode.options.fixed.y === false) {\n            containedNode.y = clusterNode.y;\n          }\n        });\n      }\n\n      // release nodes\n      for (var _nodeId5 in containedNodes) {\n        if (containedNodes.hasOwnProperty(_nodeId5)) {\n          var _containedNode2 = this.body.nodes[_nodeId5];\n\n          // inherit speed\n          _containedNode2.vx = clusterNode.vx;\n          _containedNode2.vy = clusterNode.vy;\n\n          _containedNode2.setOptions({ physics: true });\n\n          delete this.clusteredNodes[_nodeId5];\n        }\n      }\n\n      // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.\n      var edgesToBeDeleted = [];\n      for (var i = 0; i < clusterNode.edges.length; i++) {\n        edgesToBeDeleted.push(clusterNode.edges[i]);\n      }\n\n      // actually handling the deleting.\n      for (var _i2 = 0; _i2 < edgesToBeDeleted.length; _i2++) {\n        var edge = edgesToBeDeleted[_i2];\n        var otherNodeId = this._getConnectedId(edge, clusterNodeId);\n        var otherNode = this.clusteredNodes[otherNodeId];\n\n        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {\n          var transferId = edge.clusteringEdgeReplacingIds[j];\n          var transferEdge = this.body.edges[transferId];\n          if (transferEdge === undefined) continue;\n\n          // if the other node is in another cluster, we transfer ownership of this edge to the other cluster\n          if (otherNode !== undefined) {\n            // transfer ownership:\n            var otherCluster = this.body.nodes[otherNode.clusterId];\n            otherCluster.containedEdges[transferEdge.id] = transferEdge;\n\n            // delete local reference\n            delete containedEdges[transferEdge.id];\n\n            // get to and from\n            var fromId = transferEdge.fromId;\n            var toId = transferEdge.toId;\n            if (transferEdge.toId == otherNodeId) {\n              toId = otherNode.clusterId;\n            } else {\n              fromId = otherNode.clusterId;\n            }\n\n            // create new cluster edge from the otherCluster\n            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, { hidden: false, physics: true });\n          } else {\n            this._restoreEdge(transferEdge);\n          }\n        }\n\n        edge.remove();\n      }\n\n      // handle the releasing of the edges\n      for (var edgeId in containedEdges) {\n        if (containedEdges.hasOwnProperty(edgeId)) {\n          this._restoreEdge(containedEdges[edgeId]);\n        }\n      }\n\n      // remove clusterNode\n      delete this.body.nodes[clusterNodeId];\n\n      if (refreshData === true) {\n        this.body.emitter.emit('_dataChanged');\n      }\n    }\n\n    /**\n     *\n     * @param {Cluster.id} clusterId\n     * @returns {Array.<Node.id>}\n     */\n\n  }, {\n    key: 'getNodesInCluster',\n    value: function getNodesInCluster(clusterId) {\n      var nodesArray = [];\n      if (this.isCluster(clusterId) === true) {\n        var containedNodes = this.body.nodes[clusterId].containedNodes;\n        for (var _nodeId6 in containedNodes) {\n          if (containedNodes.hasOwnProperty(_nodeId6)) {\n            nodesArray.push(this.body.nodes[_nodeId6].id);\n          }\n        }\n      }\n\n      return nodesArray;\n    }\n\n    /**\n     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node\n     *\n     * If a node can't be found in the chain, return an empty array.\n     *\n     * @param {string|number} nodeId\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'findNode',\n    value: function findNode(nodeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n      var node = void 0;\n\n      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {\n        node = this.body.nodes[nodeId];\n        if (node === undefined) return [];\n        stack.push(node.id);\n\n        nodeId = this.clusteredNodes[nodeId].clusterId;\n        counter++;\n      }\n\n      node = this.body.nodes[nodeId];\n      if (node === undefined) return [];\n      stack.push(node.id);\n\n      stack.reverse();\n      return stack;\n    }\n\n    /**\n     * Using a clustered nodeId, update with the new options\n     * @param {vis.Edge.id} clusteredNodeId\n     * @param {object} newOptions\n     */\n\n  }, {\n    key: 'updateClusteredNode',\n    value: function updateClusteredNode(clusteredNodeId, newOptions) {\n      if (clusteredNodeId === undefined) {\n        throw new Error('No clusteredNodeId supplied to updateClusteredNode.');\n      }\n      if (newOptions === undefined) {\n        throw new Error('No newOptions supplied to updateClusteredNode.');\n      }\n      if (this.body.nodes[clusteredNodeId] === undefined) {\n        throw new Error('The clusteredNodeId supplied to updateClusteredNode does not exist.');\n      }\n\n      this.body.nodes[clusteredNodeId].setOptions(newOptions);\n      this.body.emitter.emit('_dataChanged');\n    }\n\n    /**\n     * Using a base edgeId, update all related clustered edges with the new options\n     * @param {vis.Edge.id} startEdgeId\n     * @param {object} newOptions\n     */\n\n  }, {\n    key: 'updateEdge',\n    value: function updateEdge(startEdgeId, newOptions) {\n      if (startEdgeId === undefined) {\n        throw new Error('No startEdgeId supplied to updateEdge.');\n      }\n      if (newOptions === undefined) {\n        throw new Error('No newOptions supplied to updateEdge.');\n      }\n      if (this.body.edges[startEdgeId] === undefined) {\n        throw new Error('The startEdgeId supplied to updateEdge does not exist.');\n      }\n\n      var allEdgeIds = this.getClusteredEdges(startEdgeId);\n      for (var i = 0; i < allEdgeIds.length; i++) {\n        var edge = this.body.edges[allEdgeIds[i]];\n        edge.setOptions(newOptions);\n      }\n      this.body.emitter.emit('_dataChanged');\n    }\n\n    /**\n     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)\n     * @param {vis.Edge.id} edgeId\n     * @returns {Array.<vis.Edge.id>}\n     */\n\n  }, {\n    key: 'getClusteredEdges',\n    value: function getClusteredEdges(edgeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n\n      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {\n        stack.push(this.body.edges[edgeId].id);\n        edgeId = this.body.edges[edgeId].edgeReplacedById;\n        counter++;\n      }\n      stack.reverse();\n      return stack;\n    }\n\n    /**\n     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {vis.Edge.id} baseEdgeId\n     *\n     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.\n     */\n\n  }, {\n    key: 'getBaseEdge',\n    value: function getBaseEdge(clusteredEdgeId) {\n      // Just kludge this by returning the first base edge id found\n      return this.getBaseEdges(clusteredEdgeId)[0];\n    }\n\n    /**\n     * Get all regular edges for this clustered edge id.\n     *\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge\n     */\n\n  }, {\n    key: 'getBaseEdges',\n    value: function getBaseEdges(clusteredEdgeId) {\n      var IdsToHandle = [clusteredEdgeId];\n      var doneIds = [];\n      var foundIds = [];\n      var max = 100;\n      var counter = 0;\n\n      while (IdsToHandle.length > 0 && counter < max) {\n        var nextId = IdsToHandle.pop();\n        if (nextId === undefined) continue; // Paranoia here and onwards\n        var nextEdge = this.body.edges[nextId];\n        if (nextEdge === undefined) continue;\n        counter++;\n\n        var replacingIds = nextEdge.clusteringEdgeReplacingIds;\n        if (replacingIds === undefined) {\n          // nextId is a base id\n          foundIds.push(nextId);\n        } else {\n          // Another cluster edge, unravel this one as well\n          for (var i = 0; i < replacingIds.length; ++i) {\n            var replacingId = replacingIds[i];\n\n            // Don't add if already handled\n            // TODO: never triggers; find a test-case which does\n            if (IdsToHandle.indexOf(replacingIds) !== -1 || doneIds.indexOf(replacingIds) !== -1) {\n              continue;\n            }\n\n            IdsToHandle.push(replacingId);\n          }\n        }\n\n        doneIds.push(nextId);\n      }\n\n      return foundIds;\n    }\n\n    /**\n     * Get the Id the node is connected to\n     * @param {vis.Edge} edge\n     * @param {Node.id} nodeId\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: '_getConnectedId',\n    value: function _getConnectedId(edge, nodeId) {\n      if (edge.toId != nodeId) {\n        return edge.toId;\n      } else if (edge.fromId != nodeId) {\n        return edge.fromId;\n      } else {\n        return edge.fromId;\n      }\n    }\n\n    /**\n     * We determine how many connections denote an important hub.\n     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getHubSize',\n    value: function _getHubSize() {\n      var average = 0;\n      var averageSquared = 0;\n      var hubCounter = 0;\n      var largestHub = 0;\n\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var _node = this.body.nodes[this.body.nodeIndices[i]];\n        if (_node.edges.length > largestHub) {\n          largestHub = _node.edges.length;\n        }\n        average += _node.edges.length;\n        averageSquared += Math.pow(_node.edges.length, 2);\n        hubCounter += 1;\n      }\n      average = average / hubCounter;\n      averageSquared = averageSquared / hubCounter;\n\n      var variance = averageSquared - Math.pow(average, 2);\n      var standardDeviation = Math.sqrt(variance);\n\n      var hubThreshold = Math.floor(average + 2 * standardDeviation);\n\n      // always have at least one to cluster\n      if (hubThreshold > largestHub) {\n        hubThreshold = largestHub;\n      }\n\n      return hubThreshold;\n    }\n\n    /**\n     * Create an edge for the cluster representation.\n     *\n     * @param {Node.id} fromId\n     * @param {Node.id} toId\n     * @param {vis.Edge} baseEdge\n     * @param {Object} clusterEdgeProperties\n     * @param {Object} extraOptions\n     * @returns {Edge} newly created clustered edge\n     * @private\n     */\n\n  }, {\n    key: '_createClusteredEdge',\n    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {\n      // copy the options of the edge we will replace\n      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, 'edge');\n      // make sure the properties of clusterEdges are superimposed on it\n      util.deepExtend(clonedOptions, clusterEdgeProperties);\n\n      // set up the edge\n      clonedOptions.from = fromId;\n      clonedOptions.to = toId;\n      clonedOptions.id = 'clusterEdge:' + util.randomUUID();\n\n      // apply the edge specific options to it if specified\n      if (extraOptions !== undefined) {\n        util.deepExtend(clonedOptions, extraOptions);\n      }\n\n      var newEdge = this.body.functions.createEdge(clonedOptions);\n      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];\n      newEdge.connect();\n\n      // Register the new edge\n      this.body.edges[newEdge.id] = newEdge;\n\n      return newEdge;\n    }\n\n    /**\n     * Add the passed child nodes and edges to the given cluster node.\n     *\n     * @param {Object|Node} childNodes  hash of nodes or single node to add in cluster\n     * @param {Object|Edge} childEdges  hash of edges or single edge to take into account when clustering\n     * @param {Node} clusterNode  cluster node to add nodes and edges to\n     * @param {Object} [clusterEdgeProperties]\n     * @private\n     */\n\n  }, {\n    key: '_clusterEdges',\n    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {\n      if (childEdges instanceof Edge) {\n        var edge = childEdges;\n        var obj = {};\n        obj[edge.id] = edge;\n        childEdges = obj;\n      }\n\n      if (childNodes instanceof Node) {\n        var _node2 = childNodes;\n        var _obj = {};\n        _obj[_node2.id] = _node2;\n        childNodes = _obj;\n      }\n\n      if (clusterNode === undefined || clusterNode === null) {\n        throw new Error('_clusterEdges: parameter clusterNode required');\n      }\n\n      if (clusterEdgeProperties === undefined) {\n        // Take the required properties from the cluster node\n        clusterEdgeProperties = clusterNode.clusterEdgeProperties;\n      }\n\n      // create the new edges that will connect to the cluster.\n      // All self-referencing edges will be added to childEdges here.\n      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);\n\n      // disable the childEdges\n      for (var edgeId in childEdges) {\n        if (childEdges.hasOwnProperty(edgeId)) {\n          if (this.body.edges[edgeId] !== undefined) {\n            var _edge2 = this.body.edges[edgeId];\n            // cache the options before changing\n            this._backupEdgeOptions(_edge2);\n            // disable physics and hide the edge\n            _edge2.setOptions({ physics: false });\n          }\n        }\n      }\n\n      // disable the childNodes\n      for (var _nodeId7 in childNodes) {\n        if (childNodes.hasOwnProperty(_nodeId7)) {\n          this.clusteredNodes[_nodeId7] = {\n            clusterId: clusterNode.id,\n            node: this.body.nodes[_nodeId7]\n          };\n          this.body.nodes[_nodeId7].setOptions({ physics: false });\n        }\n      }\n    }\n\n    /**\n     * Determine in which cluster given nodeId resides.\n     *\n     * If not in cluster, return undefined.\n     *\n     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).\n     *\n     * @param {Node.id} nodeId\n     * @returns {Node|undefined} Node instance for cluster, if present\n     * @private\n     */\n\n  }, {\n    key: '_getClusterNodeForNode',\n    value: function _getClusterNodeForNode(nodeId) {\n      if (nodeId === undefined) return undefined;\n      var clusteredNode = this.clusteredNodes[nodeId];\n\n      // NOTE: If no cluster info found, it should actually be an error\n      if (clusteredNode === undefined) return undefined;\n      var clusterId = clusteredNode.clusterId;\n      if (clusterId === undefined) return undefined;\n\n      return this.body.nodes[clusterId];\n    }\n\n    /**\n     * Internal helper function for conditionally removing items in array\n     *\n     * Done like this because Array.filter() is not fully supported by all IE's.\n     *\n     * @param {Array} arr\n     * @param {function} callback\n     * @returns {Array}\n     * @private\n     */\n\n  }, {\n    key: '_filter',\n    value: function _filter(arr, callback) {\n      var ret = [];\n\n      util.forEach(arr, function (item) {\n        if (callback(item)) {\n          ret.push(item);\n        }\n      });\n\n      return ret;\n    }\n\n    /**\n     * Scan all edges for changes in clustering and adjust this if necessary.\n     *\n     * Call this (internally) after there has been a change in node or edge data.\n     *\n     * Pre: States of this.body.nodes and this.body.edges consistent\n     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges\n     *      of cluster nodes.\n     */\n\n  }, {\n    key: '_updateState',\n    value: function _updateState() {\n      var _this4 = this;\n\n      var nodeId = void 0;\n      var deletedNodeIds = [];\n      var deletedEdgeIds = {};\n\n      /**\n       * Utility function to iterate over clustering nodes only\n       *\n       * @param {Function} callback  function to call for each cluster node\n       */\n      var eachClusterNode = function eachClusterNode(callback) {\n        util.forEach(_this4.body.nodes, function (node) {\n          if (node.isCluster === true) {\n            callback(node);\n          }\n        });\n      };\n\n      //\n      // Remove deleted regular nodes from clustering\n      //\n\n      // Determine the deleted nodes\n      for (nodeId in this.clusteredNodes) {\n        if (!this.clusteredNodes.hasOwnProperty(nodeId)) continue;\n        var _node3 = this.body.nodes[nodeId];\n\n        if (_node3 === undefined) {\n          deletedNodeIds.push(nodeId);\n        }\n      }\n\n      // Remove nodes from cluster nodes\n      eachClusterNode(function (clusterNode) {\n        for (var n = 0; n < deletedNodeIds.length; n++) {\n          delete clusterNode.containedNodes[deletedNodeIds[n]];\n        }\n      });\n\n      // Remove nodes from cluster list\n      for (var n = 0; n < deletedNodeIds.length; n++) {\n        delete this.clusteredNodes[deletedNodeIds[n]];\n      }\n\n      //\n      // Remove deleted edges from clustering\n      //\n\n      // Add the deleted clustered edges to the list\n      util.forEach(this.clusteredEdges, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n        if (edge === undefined || !edge.endPointsValid()) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n\n      // Cluster nodes can also contain edges which are not clustered,\n      // i.e. nodes 1-2 within cluster with an edge in between.\n      // So the cluster nodes also need to be scanned for invalid edges\n      eachClusterNode(function (clusterNode) {\n        util.forEach(clusterNode.containedEdges, function (edge, edgeId) {\n          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {\n            deletedEdgeIds[edgeId] = edgeId;\n          }\n        });\n      });\n\n      // Also scan for cluster edges which need to be removed in the active list.\n      // Regular edges have been removed beforehand, so this only picks up the cluster edges.\n      util.forEach(this.body.edges, function (edge, edgeId) {\n        // Explicitly scan the contained edges for validity\n        var isValid = true;\n        var replacedIds = edge.clusteringEdgeReplacingIds;\n        if (replacedIds !== undefined) {\n          var numValid = 0;\n\n          util.forEach(replacedIds, function (containedEdgeId) {\n            var containedEdge = _this4.body.edges[containedEdgeId];\n\n            if (containedEdge !== undefined && containedEdge.endPointsValid()) {\n              numValid += 1;\n            }\n          });\n\n          isValid = numValid > 0;\n        }\n\n        if (!edge.endPointsValid() || !isValid) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n\n      // Remove edges from cluster nodes\n      eachClusterNode(function (clusterNode) {\n        util.forEach(deletedEdgeIds, function (deletedEdgeId) {\n          delete clusterNode.containedEdges[deletedEdgeId];\n\n          util.forEach(clusterNode.edges, function (edge, m) {\n            if (edge.id === deletedEdgeId) {\n              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop\n              return;\n            }\n\n            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {\n              return !deletedEdgeIds[id];\n            });\n          });\n\n          // Clean up the nulls\n          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {\n            return item !== null;\n          });\n        });\n      });\n\n      // Remove from cluster list\n      util.forEach(deletedEdgeIds, function (edgeId) {\n        delete _this4.clusteredEdges[edgeId];\n      });\n\n      // Remove cluster edges from active list (this.body.edges).\n      // deletedEdgeIds still contains id of regular edges, but these should all\n      // be gone when you reach here.\n      util.forEach(deletedEdgeIds, function (edgeId) {\n        delete _this4.body.edges[edgeId];\n      });\n\n      //\n      // Check changed cluster state of edges\n      //\n\n      // Iterating over keys here, because edges may be removed in the loop\n      var ids = (0, _keys2['default'])(this.body.edges);\n      util.forEach(ids, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n\n        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);\n        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {\n          return; // all is well\n        }\n\n        if (shouldBeClustered) {\n          // add edge to clustering\n          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);\n          if (clusterFrom !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);\n          }\n\n          var clusterTo = _this4._getClusterNodeForNode(edge.toId);\n          if (clusterTo !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);\n          }\n\n          // TODO: check that it works for both edges clustered\n          //       (This might be paranoia)\n        } else {\n          // This should not be happening, the state should\n          // be properly updated at this point.\n          //\n          // If it *is* reached during normal operation, then we have to implement\n          // undo clustering for this edge here.\n          throw new Error('remove edge from clustering not implemented!');\n        }\n      });\n\n      // Clusters may be nested to any level. Keep on opening until nothing to open\n      var changed = false;\n      var continueLoop = true;\n\n      var _loop2 = function _loop2() {\n        var clustersToOpen = [];\n\n        // Determine the id's of clusters that need opening\n        eachClusterNode(function (clusterNode) {\n          var numNodes = (0, _keys2['default'])(clusterNode.containedNodes).length;\n          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;\n          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {\n            clustersToOpen.push(clusterNode.id);\n          }\n        });\n\n        // Open them\n        for (var _n = 0; _n < clustersToOpen.length; ++_n) {\n          _this4.openCluster(clustersToOpen[_n], {}, false /* Don't refresh, we're in an refresh/update already */\n          );\n        }\n\n        continueLoop = clustersToOpen.length > 0;\n        changed = changed || continueLoop;\n      };\n\n      while (continueLoop) {\n        _loop2();\n      }\n\n      if (changed) {\n        this._updateState(); // Redo this method (recursion possible! should be safe)\n      }\n    }\n\n    /**\n     * Determine if node with given id is part of a cluster.\n     *\n     * @param {Node.id} nodeId\n     * @return {boolean} true if part of a cluster.\n     */\n\n  }, {\n    key: '_isClusteredNode',\n    value: function _isClusteredNode(nodeId) {\n      return this.clusteredNodes[nodeId] !== undefined;\n    }\n\n    /**\n     * Determine if edge with given id is not visible due to clustering.\n     *\n     * An edge is considered clustered if:\n     * - it is directly replaced by a clustering edge\n     * - any of its connecting nodes is in a cluster\n     *\n     * @param {vis.Edge.id} edgeId\n     * @return {boolean} true if part of a cluster.\n     */\n\n  }, {\n    key: '_isClusteredEdge',\n    value: function _isClusteredEdge(edgeId) {\n      return this.clusteredEdges[edgeId] !== undefined;\n    }\n  }]);\n  return ClusterEngine;\n}();\n\nexports['default'] = ClusterEngine;\n\n/***/ }),\n/* 179 */\n/***/ (function(module, exports, __nested_webpack_require_951802__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = __nested_webpack_require_951802__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __nested_webpack_require_951802__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_951802__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_951802__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_951802__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_951802__(2);\nvar Node = __nested_webpack_require_951802__(34)['default'];\n\n/**\n * A Cluster is a special Node that allows a group of Nodes positioned closely together\n * to be represented by a single Cluster Node.\n *\n * @extends Node\n */\n\nvar Cluster = function (_Node) {\n  (0, _inherits3['default'])(Cluster, _Node);\n\n  /**\n   * @param {Object} options\n   * @param {Object} body\n   * @param {Array.<HTMLImageElement>}imagelist\n   * @param {Array} grouplist\n   * @param {Object} globalOptions\n   * @param {Object} defaultOptions     Global default options for nodes\n   */\n  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    (0, _classCallCheck3['default'])(this, Cluster);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (Cluster.__proto__ || (0, _getPrototypeOf2['default'])(Cluster)).call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions));\n\n    _this.isCluster = true;\n    _this.containedNodes = {};\n    _this.containedEdges = {};\n    return _this;\n  }\n\n  /**\n   * Transfer child cluster data to current and disconnect the child cluster.\n   *\n   * Please consult the header comment in 'Clustering.js' for the fields set here.\n   *\n   * @param {string|number} childClusterId  id of child cluster to open\n   */\n\n\n  (0, _createClass3['default'])(Cluster, [{\n    key: '_openChildCluster',\n    value: function _openChildCluster(childClusterId) {\n      var _this2 = this;\n\n      var childCluster = this.body.nodes[childClusterId];\n      if (this.containedNodes[childClusterId] === undefined) {\n        throw new Error('node with id: ' + childClusterId + ' not in current cluster');\n      }\n      if (!childCluster.isCluster) {\n        throw new Error('node with id: ' + childClusterId + ' is not a cluster');\n      }\n\n      // Disconnect child cluster from current cluster\n      delete this.containedNodes[childClusterId];\n      util.forEach(childCluster.edges, function (edge) {\n        delete _this2.containedEdges[edge.id];\n      });\n\n      // Transfer nodes and edges\n      util.forEach(childCluster.containedNodes, function (node, nodeId) {\n        _this2.containedNodes[nodeId] = node;\n      });\n      childCluster.containedNodes = {};\n\n      util.forEach(childCluster.containedEdges, function (edge, edgeId) {\n        _this2.containedEdges[edgeId] = edge;\n      });\n      childCluster.containedEdges = {};\n\n      // Transfer edges within cluster edges which are clustered\n      util.forEach(childCluster.edges, function (clusterEdge) {\n        util.forEach(_this2.edges, function (parentClusterEdge) {\n          // Assumption: a clustered edge can only be present in a single clustering edge\n          // Not tested here\n          var index = parentClusterEdge.clusteringEdgeReplacingIds.indexOf(clusterEdge.id);\n          if (index === -1) return;\n\n          util.forEach(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {\n            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);\n\n            // Maintain correct bookkeeping for transferred edge\n            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;\n          });\n\n          // Remove cluster edge from parent cluster edge\n          parentClusterEdge.clusteringEdgeReplacingIds.splice(index, 1);\n        });\n      });\n      childCluster.edges = [];\n    }\n  }]);\n  return Cluster;\n}(Node);\n\nexports['default'] = Cluster;\n\n/***/ }),\n/* 180 */\n/***/ (function(module, exports, __nested_webpack_require_956047__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_956047__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_956047__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Initializes window.requestAnimationFrame() to a usable form.\n *\n * Specifically, set up this method for the case of running on node.js with jsdom enabled.\n *\n * NOTES:\n *\n * * On node.js, when calling this directly outside of this class, `window` is not defined.\n *   This happens even if jsdom is used.\n * * For node.js + jsdom, `window` is available at the moment the constructor is called.\n *   For this reason, the called is placed within the constructor.\n * * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.\n * * During unit testing, it happens that the window object is reset during execution, causing\n *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,\n *   see `_requestNextFrame()`.\n * * Since this is a global object, it may affect other modules besides `Network`. With normal\n *   usage, this does not cause any problems. During unit testing, errors may occur. These have\n *   been compensated for, see comment block in _requestNextFrame().\n *\n * @private\n */\nfunction _initRequestAnimationFrame() {\n  var func;\n\n  if (window !== undefined) {\n    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n  }\n\n  if (func === undefined) {\n    // window or method not present, setting mock requestAnimationFrame\n    window.requestAnimationFrame = function (callback) {\n      //console.log(\"Called mock requestAnimationFrame\");\n      callback();\n    };\n  } else {\n    window.requestAnimationFrame = func;\n  }\n}\n\nvar util = __nested_webpack_require_956047__(2);\n\n/**\n * The canvas renderer\n */\n\nvar CanvasRenderer = function () {\n  /**\n   * @param {Object} body\n   * @param {Canvas} canvas\n   */\n  function CanvasRenderer(body, canvas) {\n    (0, _classCallCheck3['default'])(this, CanvasRenderer);\n\n    _initRequestAnimationFrame();\n    this.body = body;\n    this.canvas = canvas;\n\n    this.redrawRequested = false;\n    this.renderTimer = undefined;\n    this.requiresTimeout = true;\n    this.renderingActive = false;\n    this.renderRequests = 0;\n    this.allowRedraw = true;\n\n    this.dragging = false;\n    this.zooming = false;\n    this.options = {};\n    this.defaultOptions = {\n      hideEdgesOnDrag: false,\n      hideEdgesOnZoom: false,\n      hideNodesOnDrag: false\n    };\n    util.extend(this.options, this.defaultOptions);\n\n    this._determineBrowserMethod();\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n\n\n  (0, _createClass3['default'])(CanvasRenderer, [{\n    key: 'bindEventListeners',\n    value: function bindEventListeners() {\n      var _this = this;\n\n      this.body.emitter.on('dragStart', function () {\n        _this.dragging = true;\n      });\n      this.body.emitter.on('dragEnd', function () {\n        _this.dragging = false;\n      });\n      this.body.emitter.on('zoom', function () {\n        _this.zooming = true;\n        window.clearTimeout(_this.zoomTimeoutId);\n        _this.zoomTimeoutId = window.setTimeout(function () {\n          _this.zooming = false;\n          _this._requestRedraw.bind(_this)();\n        }, 250);\n      });\n      this.body.emitter.on('_resizeNodes', function () {\n        _this._resizeNodes();\n      });\n      this.body.emitter.on('_redraw', function () {\n        if (_this.renderingActive === false) {\n          _this._redraw();\n        }\n      });\n      this.body.emitter.on('_blockRedraw', function () {\n        _this.allowRedraw = false;\n      });\n      this.body.emitter.on('_allowRedraw', function () {\n        _this.allowRedraw = true;\n        _this.redrawRequested = false;\n      });\n      this.body.emitter.on('_requestRedraw', this._requestRedraw.bind(this));\n      this.body.emitter.on('_startRendering', function () {\n        _this.renderRequests += 1;\n        _this.renderingActive = true;\n        _this._startRendering();\n      });\n      this.body.emitter.on('_stopRendering', function () {\n        _this.renderRequests -= 1;\n        _this.renderingActive = _this.renderRequests > 0;\n        _this.renderTimer = undefined;\n      });\n      this.body.emitter.on('destroy', function () {\n        _this.renderRequests = 0;\n        _this.allowRedraw = false;\n        _this.renderingActive = false;\n        if (_this.requiresTimeout === true) {\n          clearTimeout(_this.renderTimer);\n        } else {\n          window.cancelAnimationFrame(_this.renderTimer);\n        }\n        _this.body.emitter.off();\n      });\n    }\n\n    /**\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = ['hideEdgesOnDrag', 'hideEdgesOnZoom', 'hideNodesOnDrag'];\n        util.selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n\n    /**\n     * Prepare the drawing of the next frame.\n     *\n     * Calls the callback when the next frame can or will be drawn.\n     *\n     * @param {function} callback\n     * @param {number} delay - timeout case only, wait this number of milliseconds\n     * @returns {function|undefined}\n     * @private\n     */\n\n  }, {\n    key: '_requestNextFrame',\n    value: function _requestNextFrame(callback, delay) {\n      // During unit testing, it happens that the mock window object is reset while\n      // the next frame is still pending. Then, either 'window' is not present, or\n      // 'requestAnimationFrame()' is not present because it is not defined on the\n      // mock window object.\n      //\n      // As a consequence, unrelated unit tests may appear to fail, even if the problem\n      // described happens in the current unit test.\n      //\n      // This is not something that will happen in normal operation, but we still need\n      // to take it into account.\n      //\n      if (typeof window === 'undefined') return; // Doing `if (window === undefined)` does not work here!\n\n      var timer = void 0;\n\n      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset\n      // while running this method.\n\n      if (this.requiresTimeout === true) {\n        // wait given number of milliseconds and perform the animation step function\n        timer = myWindow.setTimeout(callback, delay);\n      } else {\n        if (myWindow.requestAnimationFrame) {\n          timer = myWindow.requestAnimationFrame(callback);\n        }\n      }\n\n      return timer;\n    }\n\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_startRendering',\n    value: function _startRendering() {\n      if (this.renderingActive === true) {\n        if (this.renderTimer === undefined) {\n          this.renderTimer = this._requestNextFrame(this._renderStep.bind(this), this.simulationInterval);\n        }\n      }\n    }\n\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_renderStep',\n    value: function _renderStep() {\n      if (this.renderingActive === true) {\n        // reset the renderTimer so a new scheduled animation step can be set\n        this.renderTimer = undefined;\n\n        if (this.requiresTimeout === true) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n\n        this._redraw();\n\n        if (this.requiresTimeout === false) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n      }\n    }\n\n    /**\n     * Redraw the network with the current data\n     * chart will be resized too.\n     */\n\n  }, {\n    key: 'redraw',\n    value: function redraw() {\n      this.body.emitter.emit('setSize');\n      this._redraw();\n    }\n\n    /**\n     * Redraw the network with the current data\n     * @private\n     */\n\n  }, {\n    key: '_requestRedraw',\n    value: function _requestRedraw() {\n      var _this2 = this;\n\n      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {\n        this.redrawRequested = true;\n        this._requestNextFrame(function () {\n          _this2._redraw(false);\n        }, 0);\n      }\n    }\n\n    /**\n     * Redraw the network with the current data\n     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.\n     *                                   Only the nodes are drawn after which they are quickly drawn over.\n     * @private\n     */\n\n  }, {\n    key: '_redraw',\n    value: function _redraw() {\n      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.allowRedraw === true) {\n        this.body.emitter.emit('initRedraw');\n\n        this.redrawRequested = false;\n\n        // when the container div was hidden, this fixes it back up!\n        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {\n          this.canvas.setSize();\n        }\n\n        this.canvas.setTransform();\n\n        var ctx = this.canvas.getContext();\n\n        // clear the canvas\n        var w = this.canvas.frame.canvas.clientWidth;\n        var h = this.canvas.frame.canvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n\n        // if the div is hidden, we stop the redraw here for performance.\n        if (this.canvas.frame.clientWidth === 0) {\n          return;\n        }\n\n        // set scaling and translation\n        ctx.save();\n        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n        ctx.scale(this.body.view.scale, this.body.view.scale);\n\n        ctx.beginPath();\n        this.body.emitter.emit('beforeDrawing', ctx);\n        ctx.closePath();\n\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawEdges(ctx);\n          }\n        }\n\n        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {\n          this._drawNodes(ctx, hidden);\n        }\n\n        ctx.beginPath();\n        this.body.emitter.emit('afterDrawing', ctx);\n        ctx.closePath();\n\n        // restore original scaling and translation\n        ctx.restore();\n        if (hidden === true) {\n          ctx.clearRect(0, 0, w, h);\n        }\n      }\n    }\n\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {boolean} [alwaysShow]\n     * @private\n     */\n\n  }, {\n    key: '_resizeNodes',\n    value: function _resizeNodes() {\n      this.canvas.setTransform();\n      var ctx = this.canvas.getContext();\n      ctx.save();\n      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n      ctx.scale(this.body.view.scale, this.body.view.scale);\n\n      var nodes = this.body.nodes;\n      var node = void 0;\n\n      // resize all nodes\n      for (var nodeId in nodes) {\n        if (nodes.hasOwnProperty(nodeId)) {\n          node = nodes[nodeId];\n          node.resize(ctx);\n          node.updateBoundingBox(ctx, node.selected);\n        }\n      }\n\n      // restore original scaling and translation\n      ctx.restore();\n    }\n\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @param {boolean} [alwaysShow]\n     * @private\n     */\n\n  }, {\n    key: '_drawNodes',\n    value: function _drawNodes(ctx) {\n      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var nodes = this.body.nodes;\n      var nodeIndices = this.body.nodeIndices;\n      var node = void 0;\n      var selected = [];\n      var margin = 20;\n      var topLeft = this.canvas.DOMtoCanvas({ x: -margin, y: -margin });\n      var bottomRight = this.canvas.DOMtoCanvas({\n        x: this.canvas.frame.canvas.clientWidth + margin,\n        y: this.canvas.frame.canvas.clientHeight + margin\n      });\n      var viewableArea = {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n\n        // draw unselected nodes;\n      };for (var i = 0; i < nodeIndices.length; i++) {\n        node = nodes[nodeIndices[i]];\n        // set selected nodes aside\n        if (node.isSelected()) {\n          selected.push(nodeIndices[i]);\n        } else {\n          if (alwaysShow === true) {\n            node.draw(ctx);\n          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {\n            node.draw(ctx);\n          } else {\n            node.updateBoundingBox(ctx, node.selected);\n          }\n        }\n      }\n\n      // draw the selected nodes on top\n      for (var _i = 0; _i < selected.length; _i++) {\n        node = nodes[selected[_i]];\n        node.draw(ctx);\n      }\n    }\n\n    /**\n     * Redraw all edges\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n\n  }, {\n    key: '_drawEdges',\n    value: function _drawEdges(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n      var edge = void 0;\n\n      for (var i = 0; i < edgeIndices.length; i++) {\n        edge = edges[edgeIndices[i]];\n        if (edge.connected === true) {\n          edge.draw(ctx);\n        }\n      }\n    }\n\n    /**\n     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because\n     * some implementations (safari and IE9) did not support requestAnimationFrame\n     * @private\n     */\n\n  }, {\n    key: '_determineBrowserMethod',\n    value: function _determineBrowserMethod() {\n      if (typeof window !== 'undefined') {\n        var browserType = navigator.userAgent.toLowerCase();\n        this.requiresTimeout = false;\n        if (browserType.indexOf('msie 9.0') != -1) {\n          // IE 9\n          this.requiresTimeout = true;\n        } else if (browserType.indexOf('safari') != -1) {\n          // safari\n          if (browserType.indexOf('chrome') <= -1) {\n            this.requiresTimeout = true;\n          }\n        }\n      } else {\n        this.requiresTimeout = true;\n      }\n    }\n  }]);\n  return CanvasRenderer;\n}();\n\nexports['default'] = CanvasRenderer;\n\n/***/ }),\n/* 181 */\n/***/ (function(module, exports, __nested_webpack_require_970513__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_970513__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_970513__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar Hammer = __nested_webpack_require_970513__(24);\nvar hammerUtil = __nested_webpack_require_970513__(36);\n\nvar util = __nested_webpack_require_970513__(2);\n\n/**\n * Create the main frame for the Network.\n * This function is executed once when a Network object is created. The frame\n * contains a canvas, and this canvas contains all objects like the axis and\n * nodes.\n */\n\nvar Canvas = function () {\n  /**\n   * @param {Object} body\n   */\n  function Canvas(body) {\n    (0, _classCallCheck3['default'])(this, Canvas);\n\n    this.body = body;\n    this.pixelRatio = 1;\n    this.resizeTimer = undefined;\n    this.resizeFunction = this._onResize.bind(this);\n    this.cameraState = {};\n    this.initialized = false;\n    this.canvasViewCenter = {};\n\n    this.options = {};\n    this.defaultOptions = {\n      autoResize: true,\n      height: '100%',\n      width: '100%'\n    };\n    util.extend(this.options, this.defaultOptions);\n\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n\n\n  (0, _createClass3['default'])(Canvas, [{\n    key: 'bindEventListeners',\n    value: function bindEventListeners() {\n      var _this = this;\n\n      // bind the events\n      this.body.emitter.once('resize', function (obj) {\n        if (obj.width !== 0) {\n          _this.body.view.translation.x = obj.width * 0.5;\n        }\n        if (obj.height !== 0) {\n          _this.body.view.translation.y = obj.height * 0.5;\n        }\n      });\n      this.body.emitter.on('setSize', this.setSize.bind(this));\n      this.body.emitter.on('destroy', function () {\n        _this.hammerFrame.destroy();\n        _this.hammer.destroy();\n        _this._cleanUp();\n      });\n    }\n\n    /**\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      var _this2 = this;\n\n      if (options !== undefined) {\n        var fields = ['width', 'height', 'autoResize'];\n        util.selectiveDeepExtend(fields, this.options, options);\n      }\n\n      if (this.options.autoResize === true) {\n        // automatically adapt to a changing size of the browser.\n        this._cleanUp();\n        this.resizeTimer = setInterval(function () {\n          var changed = _this2.setSize();\n          if (changed === true) {\n            _this2.body.emitter.emit('_requestRedraw');\n          }\n        }, 1000);\n        this.resizeFunction = this._onResize.bind(this);\n        util.addEventListener(window, 'resize', this.resizeFunction);\n      }\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_cleanUp',\n    value: function _cleanUp() {\n      // automatically adapt to a changing size of the browser.\n      if (this.resizeTimer !== undefined) {\n        clearInterval(this.resizeTimer);\n      }\n      util.removeEventListener(window, 'resize', this.resizeFunction);\n      this.resizeFunction = undefined;\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_onResize',\n    value: function _onResize() {\n      this.setSize();\n      this.body.emitter.emit('_redraw');\n    }\n\n    /**\n     * Get and store the cameraState\n     *\n     * @param {number} [pixelRatio=this.pixelRatio]\n     * @private\n     */\n\n  }, {\n    key: '_getCameraState',\n    value: function _getCameraState() {\n      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;\n\n      if (this.initialized === true) {\n        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;\n        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;\n        this.cameraState.scale = this.body.view.scale;\n        this.cameraState.position = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.width / pixelRatio,\n          y: 0.5 * this.frame.canvas.height / pixelRatio\n        });\n      }\n    }\n\n    /**\n     * Set the cameraState\n     * @private\n     */\n\n  }, {\n    key: '_setCameraState',\n    value: function _setCameraState() {\n      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) {\n        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;\n        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;\n        var newScale = this.cameraState.scale;\n\n        if (widthRatio != 1 && heightRatio != 1) {\n          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);\n        } else if (widthRatio != 1) {\n          newScale = this.cameraState.scale * widthRatio;\n        } else if (heightRatio != 1) {\n          newScale = this.cameraState.scale * heightRatio;\n        }\n\n        this.body.view.scale = newScale;\n        // this comes from the view module.\n        var currentViewCenter = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.clientWidth,\n          y: 0.5 * this.frame.canvas.clientHeight\n        });\n\n        var distanceFromCenter = {\n          // offset from view, distance view has to change by these x and y to center the node\n          x: currentViewCenter.x - this.cameraState.position.x,\n          y: currentViewCenter.y - this.cameraState.position.y\n        };\n        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;\n        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;\n      }\n    }\n\n    /**\n     *\n     * @param {number|string} value\n     * @returns {string}\n     * @private\n     */\n\n  }, {\n    key: '_prepareValue',\n    value: function _prepareValue(value) {\n      if (typeof value === 'number') {\n        return value + 'px';\n      } else if (typeof value === 'string') {\n        if (value.indexOf('%') !== -1 || value.indexOf('px') !== -1) {\n          return value;\n        } else if (value.indexOf('%') === -1) {\n          return value + 'px';\n        }\n      }\n      throw new Error('Could not use the value supplied for width or height:' + value);\n    }\n\n    /**\n     * Create the HTML\n     */\n\n  }, {\n    key: '_create',\n    value: function _create() {\n      // remove all elements from the container element.\n      while (this.body.container.hasChildNodes()) {\n        this.body.container.removeChild(this.body.container.firstChild);\n      }\n\n      this.frame = document.createElement('div');\n      this.frame.className = 'vis-network';\n      this.frame.style.position = 'relative';\n      this.frame.style.overflow = 'hidden';\n      this.frame.tabIndex = 900; // tab index is required for keycharm to bind keystrokes to the div instead of the window\n\n      //////////////////////////////////////////////////////////////////\n\n      this.frame.canvas = document.createElement('canvas');\n      this.frame.canvas.style.position = 'relative';\n      this.frame.appendChild(this.frame.canvas);\n\n      if (!this.frame.canvas.getContext) {\n        var noCanvas = document.createElement('DIV');\n        noCanvas.style.color = 'red';\n        noCanvas.style.fontWeight = 'bold';\n        noCanvas.style.padding = '10px';\n        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';\n        this.frame.canvas.appendChild(noCanvas);\n      } else {\n        this._setPixelRatio();\n        this.setTransform();\n      }\n\n      // add the frame to the container element\n      this.body.container.appendChild(this.frame);\n\n      this.body.view.scale = 1;\n      this.body.view.translation = {\n        x: 0.5 * this.frame.canvas.clientWidth,\n        y: 0.5 * this.frame.canvas.clientHeight\n      };\n\n      this._bindHammer();\n    }\n\n    /**\n     * This function binds hammer, it can be repeated over and over due to the uniqueness check.\n     * @private\n     */\n\n  }, {\n    key: '_bindHammer',\n    value: function _bindHammer() {\n      var _this3 = this;\n\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n      }\n      this.drag = {};\n      this.pinch = {};\n\n      // init hammer\n      this.hammer = new Hammer(this.frame.canvas);\n      this.hammer.get('pinch').set({ enable: true });\n      // enable to get better response, todo: test on mobile.\n      this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_ALL });\n\n      hammerUtil.onTouch(this.hammer, function (event) {\n        _this3.body.eventListeners.onTouch(event);\n      });\n      this.hammer.on('tap', function (event) {\n        _this3.body.eventListeners.onTap(event);\n      });\n      this.hammer.on('doubletap', function (event) {\n        _this3.body.eventListeners.onDoubleTap(event);\n      });\n      this.hammer.on('press', function (event) {\n        _this3.body.eventListeners.onHold(event);\n      });\n      this.hammer.on('panstart', function (event) {\n        _this3.body.eventListeners.onDragStart(event);\n      });\n      this.hammer.on('panmove', function (event) {\n        _this3.body.eventListeners.onDrag(event);\n      });\n      this.hammer.on('panend', function (event) {\n        _this3.body.eventListeners.onDragEnd(event);\n      });\n      this.hammer.on('pinch', function (event) {\n        _this3.body.eventListeners.onPinch(event);\n      });\n\n      // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?\n      this.frame.canvas.addEventListener('mousewheel', function (event) {\n        _this3.body.eventListeners.onMouseWheel(event);\n      });\n      this.frame.canvas.addEventListener('DOMMouseScroll', function (event) {\n        _this3.body.eventListeners.onMouseWheel(event);\n      });\n\n      this.frame.canvas.addEventListener('mousemove', function (event) {\n        _this3.body.eventListeners.onMouseMove(event);\n      });\n      this.frame.canvas.addEventListener('contextmenu', function (event) {\n        _this3.body.eventListeners.onContext(event);\n      });\n\n      this.hammerFrame = new Hammer(this.frame);\n      hammerUtil.onRelease(this.hammerFrame, function (event) {\n        _this3.body.eventListeners.onRelease(event);\n      });\n    }\n\n    /**\n     * Set a new size for the network\n     * @param {string} width   Width in pixels or percentage (for example '800px'\n     *                         or '50%')\n     * @param {string} height  Height in pixels or percentage  (for example '400px'\n     *                         or '30%')\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'setSize',\n    value: function setSize() {\n      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;\n      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;\n\n      width = this._prepareValue(width);\n      height = this._prepareValue(height);\n\n      var emitEvent = false;\n      var oldWidth = this.frame.canvas.width;\n      var oldHeight = this.frame.canvas.height;\n\n      // update the pixel ratio\n      //\n      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code\n      //       where it is assumed that the pixel ratio could change at runtime.\n      //       The only way I can think of this happening is a rotating screen or tablet; but then\n      //       there should be a mechanism for reloading the data (TODO: check if this is present).\n      //\n      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage\n      //       of pixel ratio must be overhauled for this.\n      //\n      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is\n      //       constant.\n      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value\n      this._setPixelRatio();\n\n      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {\n        this._getCameraState(previousRatio);\n\n        this.frame.style.width = width;\n        this.frame.style.height = height;\n\n        this.frame.canvas.style.width = '100%';\n        this.frame.canvas.style.height = '100%';\n\n        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n\n        this.options.width = width;\n        this.options.height = height;\n\n        this.canvasViewCenter = {\n          x: 0.5 * this.frame.clientWidth,\n          y: 0.5 * this.frame.clientHeight\n        };\n\n        emitEvent = true;\n      } else {\n        // this would adapt the width of the canvas to the width from 100% if and only if\n        // there is a change.\n\n        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n\n        // store the camera if there is a change in size.\n        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {\n          this._getCameraState(previousRatio);\n        }\n\n        if (this.frame.canvas.width !== newWidth) {\n          this.frame.canvas.width = newWidth;\n          emitEvent = true;\n        }\n        if (this.frame.canvas.height !== newHeight) {\n          this.frame.canvas.height = newHeight;\n          emitEvent = true;\n        }\n      }\n\n      if (emitEvent === true) {\n        this.body.emitter.emit('resize', {\n          width: Math.round(this.frame.canvas.width / this.pixelRatio),\n          height: Math.round(this.frame.canvas.height / this.pixelRatio),\n          oldWidth: Math.round(oldWidth / this.pixelRatio),\n          oldHeight: Math.round(oldHeight / this.pixelRatio)\n        });\n\n        // restore the camera on change.\n        this._setCameraState();\n      }\n\n      // set initialized so the get and set camera will work from now on.\n      this.initialized = true;\n      return emitEvent;\n    }\n\n    /**\n     *\n     * @returns {CanvasRenderingContext2D}\n     */\n\n  }, {\n    key: 'getContext',\n    value: function getContext() {\n      return this.frame.canvas.getContext('2d');\n    }\n\n    /**\n     * Determine the pixel ratio for various browsers.\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_determinePixelRatio',\n    value: function _determinePixelRatio() {\n      var ctx = this.getContext();\n      if (ctx === undefined) {\n        throw new Error('Could not get canvax context');\n      }\n\n      var numerator = 1;\n      if (typeof window !== 'undefined') {\n        // (window !== undefined) doesn't work here!\n        // Protection during unit tests, where 'window' can be missing\n        numerator = window.devicePixelRatio || 1;\n      }\n\n      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n\n      return numerator / denominator;\n    }\n\n    /**\n     * Lazy determination of pixel ratio.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_setPixelRatio',\n    value: function _setPixelRatio() {\n      this.pixelRatio = this._determinePixelRatio();\n    }\n\n    /**\n     * Set the transform in the contained context, based on its pixelRatio\n     */\n\n  }, {\n    key: 'setTransform',\n    value: function setTransform() {\n      var ctx = this.getContext();\n      if (ctx === undefined) {\n        throw new Error('Could not get canvax context');\n      }\n\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    }\n\n    /**\n     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_XconvertDOMtoCanvas',\n    value: function _XconvertDOMtoCanvas(x) {\n      return (x - this.body.view.translation.x) / this.body.view.scale;\n    }\n\n    /**\n     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_XconvertCanvasToDOM',\n    value: function _XconvertCanvasToDOM(x) {\n      return x * this.body.view.scale + this.body.view.translation.x;\n    }\n\n    /**\n     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_YconvertDOMtoCanvas',\n    value: function _YconvertDOMtoCanvas(y) {\n      return (y - this.body.view.translation.y) / this.body.view.scale;\n    }\n\n    /**\n     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_YconvertCanvasToDOM',\n    value: function _YconvertCanvasToDOM(y) {\n      return y * this.body.view.scale + this.body.view.translation.y;\n    }\n\n    /**\n     * @param {point} pos\n     * @returns {point}\n     */\n\n  }, {\n    key: 'canvasToDOM',\n    value: function canvasToDOM(pos) {\n      return {\n        x: this._XconvertCanvasToDOM(pos.x),\n        y: this._YconvertCanvasToDOM(pos.y)\n      };\n    }\n\n    /**\n     *\n     * @param {point} pos\n     * @returns {point}\n     */\n\n  }, {\n    key: 'DOMtoCanvas',\n    value: function DOMtoCanvas(pos) {\n      return {\n        x: this._XconvertDOMtoCanvas(pos.x),\n        y: this._YconvertDOMtoCanvas(pos.y)\n      };\n    }\n  }]);\n  return Canvas;\n}();\n\nexports['default'] = Canvas;\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports, __nested_webpack_require_988723__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign = __nested_webpack_require_988723__(78);\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = __nested_webpack_require_988723__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_988723__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_988723__(2);\n\nvar NetworkUtil = __nested_webpack_require_988723__(57)['default'];\n\n/**\n * The view\n */\n\nvar View = function () {\n  /**\n   * @param {Object} body\n   * @param {Canvas} canvas\n   */\n  function View(body, canvas) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, View);\n\n    this.body = body;\n    this.canvas = canvas;\n\n    this.animationSpeed = 1 / this.renderRefreshRate;\n    this.animationEasingFunction = 'easeInOutQuint';\n    this.easingTime = 0;\n    this.sourceScale = 0;\n    this.targetScale = 0;\n    this.sourceTranslation = 0;\n    this.targetTranslation = 0;\n    this.lockedOnNodeId = undefined;\n    this.lockedOnNodeOffset = undefined;\n    this.touchTime = 0;\n\n    this.viewFunction = undefined;\n\n    this.body.emitter.on('fit', this.fit.bind(this));\n    this.body.emitter.on('animationFinished', function () {\n      _this.body.emitter.emit('_stopRendering');\n    });\n    this.body.emitter.on('unlockNode', this.releaseNode.bind(this));\n  }\n\n  /**\n   *\n   * @param {Object} [options={}]\n   */\n\n\n  (0, _createClass3['default'])(View, [{\n    key: 'setOptions',\n    value: function setOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.options = options;\n    }\n\n    /**\n     * This function zooms out to fit all data on screen based on amount of nodes\n     * @param {Object} [options={{nodes=Array}}]\n     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;\n     */\n\n  }, {\n    key: 'fit',\n    value: function fit() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { nodes: [] };\n      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var range = void 0;\n      var zoomLevel = void 0;\n      options = (0, _assign2['default'])({}, options);\n      if (options.nodes === undefined || options.nodes.length === 0) {\n        options.nodes = this.body.nodeIndices;\n      }\n\n      if (initialZoom === true) {\n        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.\n        var positionDefined = 0;\n        for (var nodeId in this.body.nodes) {\n          if (this.body.nodes.hasOwnProperty(nodeId)) {\n            var node = this.body.nodes[nodeId];\n            if (node.predefinedPosition === true) {\n              positionDefined += 1;\n            }\n          }\n        }\n        if (positionDefined > 0.5 * this.body.nodeIndices.length) {\n          this.fit(options, false);\n          return;\n        }\n\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n\n        var numberOfNodes = this.body.nodeIndices.length;\n        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.\n\n        // correct for larger canvasses.\n        var factor = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);\n        zoomLevel *= factor;\n      } else {\n        this.body.emitter.emit('_resizeNodes');\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n\n        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;\n        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;\n\n        var xZoomLevel = this.canvas.frame.canvas.clientWidth / xDistance;\n        var yZoomLevel = this.canvas.frame.canvas.clientHeight / yDistance;\n\n        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;\n      }\n\n      if (zoomLevel > 1.0) {\n        zoomLevel = 1.0;\n      } else if (zoomLevel === 0) {\n        zoomLevel = 1.0;\n      }\n\n      var center = NetworkUtil.findCenter(range);\n      var animationOptions = {\n        position: center,\n        scale: zoomLevel,\n        animation: options.animation\n      };\n      this.moveTo(animationOptions);\n    }\n\n    // animation\n\n    /**\n     * Center a node in view.\n     *\n     * @param {number} nodeId\n     * @param {number} [options]\n     */\n\n  }, {\n    key: 'focus',\n    value: function focus(nodeId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.body.nodes[nodeId] !== undefined) {\n        var nodePosition = {\n          x: this.body.nodes[nodeId].x,\n          y: this.body.nodes[nodeId].y\n        };\n        options.position = nodePosition;\n        options.lockedOnNode = nodeId;\n\n        this.moveTo(options);\n      } else {\n        console.log('Node: ' + nodeId + ' cannot be found.');\n      }\n    }\n\n    /**\n     *\n     * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.scale    = number                 // scale to move to\n     *                          |  options.position = {x:number, y:number}   // position to move to\n     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to\n     */\n\n  }, {\n    key: 'moveTo',\n    value: function moveTo(options) {\n      if (options === undefined) {\n        options = {};\n        return;\n      }\n      if (options.offset === undefined) {\n        options.offset = { x: 0, y: 0 };\n      }\n      if (options.offset.x === undefined) {\n        options.offset.x = 0;\n      }\n      if (options.offset.y === undefined) {\n        options.offset.y = 0;\n      }\n      if (options.scale === undefined) {\n        options.scale = this.body.view.scale;\n      }\n      if (options.position === undefined) {\n        options.position = this.getViewPosition();\n      }\n      if (options.animation === undefined) {\n        options.animation = { duration: 0 };\n      }\n      if (options.animation === false) {\n        options.animation = { duration: 0 };\n      }\n      if (options.animation === true) {\n        options.animation = {};\n      }\n      if (options.animation.duration === undefined) {\n        options.animation.duration = 1000;\n      } // default duration\n      if (options.animation.easingFunction === undefined) {\n        options.animation.easingFunction = 'easeInOutQuad';\n      } // default easing function\n\n      this.animateView(options);\n    }\n\n    /**\n     *\n     * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.time     = number                 // animation time in milliseconds\n     *                          |  options.scale    = number                 // scale to animate to\n     *                          |  options.position = {x:number, y:number}   // position to animate to\n     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,\n     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,\n     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,\n     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint\n     */\n\n  }, {\n    key: 'animateView',\n    value: function animateView(options) {\n      if (options === undefined) {\n        return;\n      }\n      this.animationEasingFunction = options.animation.easingFunction;\n      // release if something focussed on the node\n      this.releaseNode();\n      if (options.locked === true) {\n        this.lockedOnNodeId = options.lockedOnNode;\n        this.lockedOnNodeOffset = options.offset;\n      }\n\n      // forcefully complete the old animation if it was still running\n      if (this.easingTime != 0) {\n        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.\n      }\n\n      this.sourceScale = this.body.view.scale;\n      this.sourceTranslation = this.body.view.translation;\n      this.targetScale = options.scale;\n\n      // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw\n      // but at least then we'll have the target transition\n      this.body.view.scale = this.targetScale;\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - options.position.x,\n        y: viewCenter.y - options.position.y\n      };\n      this.targetTranslation = {\n        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,\n        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y\n\n        // if the time is set to 0, don't do an animation\n      };if (options.animation.duration === 0) {\n        if (this.lockedOnNodeId != undefined) {\n          this.viewFunction = this._lockedRedraw.bind(this);\n          this.body.emitter.on('initRedraw', this.viewFunction);\n        } else {\n          this.body.view.scale = this.targetScale;\n          this.body.view.translation = this.targetTranslation;\n          this.body.emitter.emit('_requestRedraw');\n        }\n      } else {\n        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's\n        this.animationEasingFunction = options.animation.easingFunction;\n\n        this.viewFunction = this._transitionRedraw.bind(this);\n        this.body.emitter.on('initRedraw', this.viewFunction);\n        this.body.emitter.emit('_startRendering');\n      }\n    }\n\n    /**\n     * used to animate smoothly by hijacking the redraw function.\n     * @private\n     */\n\n  }, {\n    key: '_lockedRedraw',\n    value: function _lockedRedraw() {\n      var nodePosition = {\n        x: this.body.nodes[this.lockedOnNodeId].x,\n        y: this.body.nodes[this.lockedOnNodeId].y\n      };\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - nodePosition.x,\n        y: viewCenter.y - nodePosition.y\n      };\n      var sourceTranslation = this.body.view.translation;\n      var targetTranslation = {\n        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,\n        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y\n      };\n\n      this.body.view.translation = targetTranslation;\n    }\n\n    /**\n     * Resets state of a locked on Node\n     */\n\n  }, {\n    key: 'releaseNode',\n    value: function releaseNode() {\n      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {\n        this.body.emitter.off('initRedraw', this.viewFunction);\n        this.lockedOnNodeId = undefined;\n        this.lockedOnNodeOffset = undefined;\n      }\n    }\n\n    /**\n     * @param {boolean} [finished=false]\n     * @private\n     */\n\n  }, {\n    key: '_transitionRedraw',\n    value: function _transitionRedraw() {\n      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      this.easingTime += this.animationSpeed;\n      this.easingTime = finished === true ? 1.0 : this.easingTime;\n\n      var progress = util.easingFunctions[this.animationEasingFunction](this.easingTime);\n\n      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;\n      this.body.view.translation = {\n        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,\n        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress\n\n        // cleanup\n      };if (this.easingTime >= 1.0) {\n        this.body.emitter.off('initRedraw', this.viewFunction);\n        this.easingTime = 0;\n        if (this.lockedOnNodeId != undefined) {\n          this.viewFunction = this._lockedRedraw.bind(this);\n          this.body.emitter.on('initRedraw', this.viewFunction);\n        }\n        this.body.emitter.emit('animationFinished');\n      }\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'getScale',\n    value: function getScale() {\n      return this.body.view.scale;\n    }\n\n    /**\n     *\n     * @returns {{x: number, y: number}}\n     */\n\n  }, {\n    key: 'getViewPosition',\n    value: function getViewPosition() {\n      return this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n    }\n  }]);\n  return View;\n}();\n\nexports['default'] = View;\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports, __nested_webpack_require_1002183__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_1002183__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1002183__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_1002183__(2);\nvar NavigationHandler = __nested_webpack_require_1002183__(184)['default'];\nvar Popup = __nested_webpack_require_1002183__(185)['default'];\n\n/**\n * Handler for interactions\n */\n\nvar InteractionHandler = function () {\n  /**\n   * @param {Object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   */\n  function InteractionHandler(body, canvas, selectionHandler) {\n    (0, _classCallCheck3['default'])(this, InteractionHandler);\n\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.navigationHandler = new NavigationHandler(body, canvas);\n\n    // bind the events from hammer to functions in this object\n    this.body.eventListeners.onTap = this.onTap.bind(this);\n    this.body.eventListeners.onTouch = this.onTouch.bind(this);\n    this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this);\n    this.body.eventListeners.onHold = this.onHold.bind(this);\n    this.body.eventListeners.onDragStart = this.onDragStart.bind(this);\n    this.body.eventListeners.onDrag = this.onDrag.bind(this);\n    this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this);\n    this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this);\n    this.body.eventListeners.onPinch = this.onPinch.bind(this);\n    this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this);\n    this.body.eventListeners.onRelease = this.onRelease.bind(this);\n    this.body.eventListeners.onContext = this.onContext.bind(this);\n\n    this.touchTime = 0;\n    this.drag = {};\n    this.pinch = {};\n    this.popup = undefined;\n    this.popupObj = undefined;\n    this.popupTimer = undefined;\n\n    this.body.functions.getPointer = this.getPointer.bind(this);\n\n    this.options = {};\n    this.defaultOptions = {\n      dragNodes: true,\n      dragView: true,\n      hover: false,\n      keyboard: {\n        enabled: false,\n        speed: { x: 10, y: 10, zoom: 0.02 },\n        bindToWindow: true\n      },\n      navigationButtons: false,\n      tooltipDelay: 300,\n      zoomView: true,\n      zoomSpeed: 1\n    };\n    util.extend(this.options, this.defaultOptions);\n\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n\n\n  (0, _createClass3['default'])(InteractionHandler, [{\n    key: 'bindEventListeners',\n    value: function bindEventListeners() {\n      var _this = this;\n\n      this.body.emitter.on('destroy', function () {\n        clearTimeout(_this.popupTimer);\n        delete _this.body.functions.getPointer;\n      });\n    }\n\n    /**\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // extend all but the values in fields\n        var fields = ['hideEdgesOnDrag', 'hideEdgesOnZoom', 'hideNodesOnDrag', 'keyboard', 'multiselect', 'selectable', 'selectConnectedEdges'];\n        util.selectiveNotDeepExtend(fields, this.options, options);\n\n        // merge the keyboard options in.\n        util.mergeOptions(this.options, options, 'keyboard');\n\n        if (options.tooltip) {\n          util.extend(this.options.tooltip, options.tooltip);\n          if (options.tooltip.color) {\n            this.options.tooltip.color = util.parseColor(options.tooltip.color);\n          }\n        }\n      }\n\n      this.navigationHandler.setOptions(this.options);\n    }\n\n    /**\n     * Get the pointer location from a touch location\n     * @param {{x: number, y: number}} touch\n     * @return {{x: number, y: number}} pointer\n     * @private\n     */\n\n  }, {\n    key: 'getPointer',\n    value: function getPointer(touch) {\n      return {\n        x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),\n        y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)\n      };\n    }\n\n    /**\n     * On start of a touch gesture, store the pointer\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: 'onTouch',\n    value: function onTouch(event) {\n      if (new Date().valueOf() - this.touchTime > 50) {\n        this.drag.pointer = this.getPointer(event.center);\n        this.drag.pinched = false;\n        this.pinch.scale = this.body.view.scale;\n        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     * handle tap/click event: select/unselect a node\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onTap',\n    value: function onTap(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);\n\n      this.checkSelectionChanges(pointer, event, multiselect);\n      this.selectionHandler._generateClickEvent('click', event, pointer);\n    }\n\n    /**\n     * handle doubletap event\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onDoubleTap',\n    value: function onDoubleTap(event) {\n      var pointer = this.getPointer(event.center);\n      this.selectionHandler._generateClickEvent('doubleClick', event, pointer);\n    }\n\n    /**\n     * handle long tap event: multi select nodes\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onHold',\n    value: function onHold(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect;\n\n      this.checkSelectionChanges(pointer, event, multiselect);\n\n      this.selectionHandler._generateClickEvent('click', event, pointer);\n      this.selectionHandler._generateClickEvent('hold', event, pointer);\n    }\n\n    /**\n     * handle the release of the screen\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onRelease',\n    value: function onRelease(event) {\n      if (new Date().valueOf() - this.touchTime > 10) {\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler._generateClickEvent('release', event, pointer);\n        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     *\n     * @param {Event} event\n     */\n\n  }, {\n    key: 'onContext',\n    value: function onContext(event) {\n      var pointer = this.getPointer({ x: event.clientX, y: event.clientY });\n      this.selectionHandler._generateClickEvent('oncontext', event, pointer);\n    }\n\n    /**\n     * Select and deselect nodes depending current selection change.\n     *\n     * For changing nodes, select/deselect events are fired.\n     *\n     * NOTE: For a given edge, if one connecting node is deselected and with the same\n     *       click the other node is selected, no events for the edge will fire.\n     *       It was selected and it will remain selected.\n     *\n     * TODO: This is all SelectionHandler calls; the method should be moved to there.\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {Event} event\n     * @param {boolean} [add=false]\n     */\n\n  }, {\n    key: 'checkSelectionChanges',\n    value: function checkSelectionChanges(pointer, event) {\n      var add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var previousSelection = this.selectionHandler.getSelection();\n      var selected = false;\n      if (add === true) {\n        selected = this.selectionHandler.selectAdditionalOnPoint(pointer);\n      } else {\n        selected = this.selectionHandler.selectOnPoint(pointer);\n      }\n      var currentSelection = this.selectionHandler.getSelection();\n\n      // See NOTE in method comment for the reason to do it like this\n      var deselectedItems = this._determineDifference(previousSelection, currentSelection);\n      var selectedItems = this._determineDifference(currentSelection, previousSelection);\n\n      if (deselectedItems.edges.length > 0) {\n        this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);\n        selected = true;\n      }\n\n      if (deselectedItems.nodes.length > 0) {\n        this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);\n        selected = true;\n      }\n\n      if (selectedItems.nodes.length > 0) {\n        this.selectionHandler._generateClickEvent('selectNode', event, pointer);\n        selected = true;\n      }\n\n      if (selectedItems.edges.length > 0) {\n        this.selectionHandler._generateClickEvent('selectEdge', event, pointer);\n        selected = true;\n      }\n\n      // fire the select event if anything has been selected or deselected\n      if (selected === true) {\n        // select or unselect\n        this.selectionHandler._generateClickEvent('select', event, pointer);\n      }\n    }\n\n    /**\n     * Remove all node and edge id's from the first set that are present in the second one.\n     *\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet\n     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}\n     * @private\n     */\n\n  }, {\n    key: '_determineDifference',\n    value: function _determineDifference(firstSet, secondSet) {\n      var arrayDiff = function arrayDiff(firstArr, secondArr) {\n        var result = [];\n\n        for (var i = 0; i < firstArr.length; i++) {\n          var value = firstArr[i];\n          if (secondArr.indexOf(value) === -1) {\n            result.push(value);\n          }\n        }\n\n        return result;\n      };\n\n      return {\n        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),\n        edges: arrayDiff(firstSet.edges, secondSet.edges)\n      };\n    }\n\n    /**\n     * This function is called by onDragStart.\n     * It is separated out because we can then overload it for the datamanipulation system.\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onDragStart',\n    value: function onDragStart(event) {\n      //in case the touch event was triggered on an external div, do the initial touch now.\n      if (this.drag.pointer === undefined) {\n        this.onTouch(event);\n      }\n\n      // note: drag.pointer is set in onTouch to get the initial touch location\n      var node = this.selectionHandler.getNodeAt(this.drag.pointer);\n\n      this.drag.dragging = true;\n      this.drag.selection = [];\n      this.drag.translation = util.extend({}, this.body.view.translation); // copy the object\n      this.drag.nodeId = undefined;\n\n      if (node !== undefined && this.options.dragNodes === true) {\n        this.drag.nodeId = node.id;\n        // select the clicked node if not yet selected\n        if (node.isSelected() === false) {\n          this.selectionHandler.unselectAll();\n          this.selectionHandler.selectObject(node);\n        }\n\n        // after select to contain the node\n        this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer);\n\n        var selection = this.selectionHandler.selectionObj.nodes;\n        // create an array with the selected nodes and their original location and status\n        for (var nodeId in selection) {\n          if (selection.hasOwnProperty(nodeId)) {\n            var object = selection[nodeId];\n            var s = {\n              id: object.id,\n              node: object,\n\n              // store original x, y, xFixed and yFixed, make the node temporarily Fixed\n              x: object.x,\n              y: object.y,\n              xFixed: object.options.fixed.x,\n              yFixed: object.options.fixed.y\n            };\n\n            object.options.fixed.x = true;\n            object.options.fixed.y = true;\n\n            this.drag.selection.push(s);\n          }\n        }\n      } else {\n        // fallback if no node is selected and thus the view is dragged.\n        this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer, undefined, true);\n      }\n    }\n\n    /**\n     * handle drag event\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onDrag',\n    value: function onDrag(event) {\n      var _this2 = this;\n\n      if (this.drag.pinched === true) {\n        return;\n      }\n\n      // remove the focus on node if it is focussed on by the focusOnNode\n      this.body.emitter.emit('unlockNode');\n\n      var pointer = this.getPointer(event.center);\n\n      var selection = this.drag.selection;\n      if (selection && selection.length && this.options.dragNodes === true) {\n        this.selectionHandler._generateClickEvent('dragging', event, pointer);\n\n        // calculate delta's and new location\n        var deltaX = pointer.x - this.drag.pointer.x;\n        var deltaY = pointer.y - this.drag.pointer.y;\n\n        // update position of all selected nodes\n        selection.forEach(function (selection) {\n          var node = selection.node;\n          // only move the node if it was not fixed initially\n          if (selection.xFixed === false) {\n            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);\n          }\n          // only move the node if it was not fixed initially\n          if (selection.yFixed === false) {\n            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);\n          }\n        });\n\n        // start the simulation of the physics\n        this.body.emitter.emit('startSimulation');\n      } else {\n        // move the network\n        if (this.options.dragView === true) {\n          this.selectionHandler._generateClickEvent('dragging', event, pointer, undefined, true);\n\n          // if the drag was not started properly because the click started outside the network div, start it now.\n          if (this.drag.pointer === undefined) {\n            this.onDragStart(event);\n            return;\n          }\n          var diffX = pointer.x - this.drag.pointer.x;\n          var diffY = pointer.y - this.drag.pointer.y;\n\n          this.body.view.translation = {\n            x: this.drag.translation.x + diffX,\n            y: this.drag.translation.y + diffY\n          };\n          this.body.emitter.emit('_requestRedraw');\n        }\n      }\n    }\n\n    /**\n     * handle drag start event\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onDragEnd',\n    value: function onDragEnd(event) {\n      this.drag.dragging = false;\n      var selection = this.drag.selection;\n      if (selection && selection.length) {\n        selection.forEach(function (s) {\n          // restore original xFixed and yFixed\n          s.node.options.fixed.x = s.xFixed;\n          s.node.options.fixed.y = s.yFixed;\n        });\n        this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center));\n        this.body.emitter.emit('startSimulation');\n      } else {\n        this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center), undefined, true);\n        this.body.emitter.emit('_requestRedraw');\n      }\n    }\n\n    /**\n     * Handle pinch event\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: 'onPinch',\n    value: function onPinch(event) {\n      var pointer = this.getPointer(event.center);\n\n      this.drag.pinched = true;\n      if (this.pinch['scale'] === undefined) {\n        this.pinch.scale = 1;\n      }\n\n      // TODO: enabled moving while pinching?\n      var scale = this.pinch.scale * event.scale;\n      this.zoom(scale, pointer);\n    }\n\n    /**\n     * Zoom the network in or out\n     * @param {number} scale a number around 1, and between 0.01 and 10\n     * @param {{x: number, y: number}} pointer    Position on screen\n     * @private\n     */\n\n  }, {\n    key: 'zoom',\n    value: function zoom(scale, pointer) {\n      if (this.options.zoomView === true) {\n        var scaleOld = this.body.view.scale;\n        if (scale < 0.00001) {\n          scale = 0.00001;\n        }\n        if (scale > 10) {\n          scale = 10;\n        }\n\n        var preScaleDragPointer = undefined;\n        if (this.drag !== undefined) {\n          if (this.drag.dragging === true) {\n            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);\n          }\n        }\n        // + this.canvas.frame.canvas.clientHeight / 2\n        var translation = this.body.view.translation;\n\n        var scaleFrac = scale / scaleOld;\n        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;\n        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;\n\n        this.body.view.scale = scale;\n        this.body.view.translation = { x: tx, y: ty };\n\n        if (preScaleDragPointer != undefined) {\n          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);\n          this.drag.pointer.x = postScaleDragPointer.x;\n          this.drag.pointer.y = postScaleDragPointer.y;\n        }\n\n        this.body.emitter.emit('_requestRedraw');\n\n        if (scaleOld < scale) {\n          this.body.emitter.emit('zoom', {\n            direction: '+',\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        } else {\n          this.body.emitter.emit('zoom', {\n            direction: '-',\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        }\n      }\n    }\n\n    /**\n     * Event handler for mouse wheel event, used to zoom the timeline\n     * See http://adomas.org/javascript-mouse-wheel/\n     *     https://github.com/EightMedia/hammer.js/issues/256\n     * @param {MouseEvent}  event\n     * @private\n     */\n\n  }, {\n    key: 'onMouseWheel',\n    value: function onMouseWheel(event) {\n      if (this.options.zoomView === true) {\n        // retrieve delta\n        var delta = 0;\n        if (event.wheelDelta) {\n          /* IE/Opera. */\n          delta = event.wheelDelta / 120;\n        } else if (event.detail) {\n          /* Mozilla case. */\n          // In Mozilla, sign of delta is different than in IE.\n          // Also, delta is multiple of 3.\n          delta = -event.detail / 3;\n        }\n\n        // If delta is nonzero, handle it.\n        // Basically, delta is now positive if wheel was scrolled up,\n        // and negative, if wheel was scrolled down.\n        if (delta !== 0) {\n          // calculate the new scale\n          var scale = this.body.view.scale;\n          var zoom = delta * (this.options.zoomSpeed / 10);\n          if (delta < 0) {\n            zoom = zoom / (1 - zoom);\n          }\n          scale *= 1 + zoom;\n\n          // calculate the pointer location\n          var pointer = this.getPointer({ x: event.clientX, y: event.clientY });\n\n          // apply the new scale\n          this.zoom(scale, pointer);\n        }\n\n        // Prevent default actions caused by mouse wheel.\n        event.preventDefault();\n      }\n    }\n\n    /**\n     * Mouse move handler for checking whether the title moves over a node with a title.\n     * @param  {Event} event\n     * @private\n     */\n\n  }, {\n    key: 'onMouseMove',\n    value: function onMouseMove(event) {\n      var _this3 = this;\n\n      var pointer = this.getPointer({ x: event.clientX, y: event.clientY });\n      var popupVisible = false;\n\n      // check if the previously selected node is still selected\n      if (this.popup !== undefined) {\n        if (this.popup.hidden === false) {\n          this._checkHidePopup(pointer);\n        }\n\n        // if the popup was not hidden above\n        if (this.popup.hidden === false) {\n          popupVisible = true;\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.show();\n        }\n      }\n\n      // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.\n      if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {\n        this.canvas.frame.focus();\n      }\n\n      // start a timeout that will check if the mouse is positioned above an element\n      if (popupVisible === false) {\n        if (this.popupTimer !== undefined) {\n          clearInterval(this.popupTimer); // stop any running calculationTimer\n          this.popupTimer = undefined;\n        }\n        if (!this.drag.dragging) {\n          this.popupTimer = setTimeout(function () {\n            return _this3._checkShowPopup(pointer);\n          }, this.options.tooltipDelay);\n        }\n      }\n\n      // adding hover highlights\n      if (this.options.hover === true) {\n        this.selectionHandler.hoverObject(event, pointer);\n      }\n    }\n\n    /**\n     * Check if there is an element on the given position in the network\n     * (a node or edge). If so, and if this element has a title,\n     * show a popup window with its title.\n     *\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n\n  }, {\n    key: '_checkShowPopup',\n    value: function _checkShowPopup(pointer) {\n      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n      var pointerObj = {\n        left: x,\n        top: y,\n        right: x,\n        bottom: y\n      };\n\n      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;\n      var nodeUnderCursor = false;\n      var popupType = 'node';\n\n      // check if a node is under the cursor.\n      if (this.popupObj === undefined) {\n        // search the nodes for overlap, select the top one in case of multiple nodes\n        var nodeIndices = this.body.nodeIndices;\n        var nodes = this.body.nodes;\n        var node = void 0;\n        var overlappingNodes = [];\n        for (var i = 0; i < nodeIndices.length; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.isOverlappingWith(pointerObj) === true) {\n            nodeUnderCursor = true;\n            if (node.getTitle() !== undefined) {\n              overlappingNodes.push(nodeIndices[i]);\n            }\n          }\n        }\n\n        if (overlappingNodes.length > 0) {\n          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others\n          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];\n          // if you hover over a node, the title of the edge is not supposed to be shown.\n          nodeUnderCursor = true;\n        }\n      }\n\n      if (this.popupObj === undefined && nodeUnderCursor === false) {\n        // search the edges for overlap\n        var edgeIndices = this.body.edgeIndices;\n        var edges = this.body.edges;\n        var edge = void 0;\n        var overlappingEdges = [];\n        for (var _i = 0; _i < edgeIndices.length; _i++) {\n          edge = edges[edgeIndices[_i]];\n          if (edge.isOverlappingWith(pointerObj) === true) {\n            if (edge.connected === true && edge.getTitle() !== undefined) {\n              overlappingEdges.push(edgeIndices[_i]);\n            }\n          }\n        }\n\n        if (overlappingEdges.length > 0) {\n          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];\n          popupType = 'edge';\n        }\n      }\n\n      if (this.popupObj !== undefined) {\n        // show popup message window\n        if (this.popupObj.id !== previousPopupObjId) {\n          if (this.popup === undefined) {\n            this.popup = new Popup(this.canvas.frame);\n          }\n\n          this.popup.popupTargetType = popupType;\n          this.popup.popupTargetId = this.popupObj.id;\n\n          // adjust a small offset such that the mouse cursor is located in the\n          // bottom left location of the popup, and you can easily move over the\n          // popup area\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.setText(this.popupObj.getTitle());\n          this.popup.show();\n          this.body.emitter.emit('showPopup', this.popupObj.id);\n        }\n      } else {\n        if (this.popup !== undefined) {\n          this.popup.hide();\n          this.body.emitter.emit('hidePopup');\n        }\n      }\n    }\n\n    /**\n     * Check if the popup must be hidden, which is the case when the mouse is no\n     * longer hovering on the object\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n\n  }, {\n    key: '_checkHidePopup',\n    value: function _checkHidePopup(pointer) {\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n\n      var stillOnObj = false;\n      if (this.popup.popupTargetType === 'node') {\n        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {\n          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n\n          // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.\n          // we initially only check stillOnObj because this is much faster.\n          if (stillOnObj === true) {\n            var overNode = this.selectionHandler.getNodeAt(pointer);\n            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;\n          }\n        }\n      } else {\n        if (this.selectionHandler.getNodeAt(pointer) === undefined) {\n          if (this.body.edges[this.popup.popupTargetId] !== undefined) {\n            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n          }\n        }\n      }\n\n      if (stillOnObj === false) {\n        this.popupObj = undefined;\n        this.popup.hide();\n        this.body.emitter.emit('hidePopup');\n      }\n    }\n  }]);\n  return InteractionHandler;\n}();\n\nexports['default'] = InteractionHandler;\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __nested_webpack_require_1028063__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_1028063__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1028063__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar Hammer = __nested_webpack_require_1028063__(24);\nvar hammerUtil = __nested_webpack_require_1028063__(36);\nvar keycharm = __nested_webpack_require_1028063__(52);\n\n/**\n * Navigation Handler\n */\n\nvar NavigationHandler = function () {\n  /**\n   * @param {Object} body\n   * @param {Canvas} canvas\n   */\n  function NavigationHandler(body, canvas) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, NavigationHandler);\n\n    this.body = body;\n    this.canvas = canvas;\n\n    this.iconsCreated = false;\n    this.navigationHammers = [];\n    this.boundFunctions = {};\n    this.touchTime = 0;\n    this.activated = false;\n\n    this.body.emitter.on('activate', function () {\n      _this.activated = true;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on('deactivate', function () {\n      _this.activated = false;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on('destroy', function () {\n      if (_this.keycharm !== undefined) {\n        _this.keycharm.destroy();\n      }\n    });\n\n    this.options = {};\n  }\n\n  /**\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(NavigationHandler, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        this.options = options;\n        this.create();\n      }\n    }\n\n    /**\n     * Creates or refreshes navigation and sets key bindings\n     */\n\n  }, {\n    key: 'create',\n    value: function create() {\n      if (this.options.navigationButtons === true) {\n        if (this.iconsCreated === false) {\n          this.loadNavigationElements();\n        }\n      } else if (this.iconsCreated === true) {\n        this.cleanNavigation();\n      }\n\n      this.configureKeyboardBindings();\n    }\n\n    /**\n     * Cleans up previous navigation items\n     */\n\n  }, {\n    key: 'cleanNavigation',\n    value: function cleanNavigation() {\n      // clean hammer bindings\n      if (this.navigationHammers.length != 0) {\n        for (var i = 0; i < this.navigationHammers.length; i++) {\n          this.navigationHammers[i].destroy();\n        }\n        this.navigationHammers = [];\n      }\n\n      // clean up previous navigation items\n      if (this.navigationDOM && this.navigationDOM['wrapper'] && this.navigationDOM['wrapper'].parentNode) {\n        this.navigationDOM['wrapper'].parentNode.removeChild(this.navigationDOM['wrapper']);\n      }\n\n      this.iconsCreated = false;\n    }\n\n    /**\n     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation\n     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent\n     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.\n     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'loadNavigationElements',\n    value: function loadNavigationElements() {\n      var _this2 = this;\n\n      this.cleanNavigation();\n\n      this.navigationDOM = {};\n      var navigationDivs = ['up', 'down', 'left', 'right', 'zoomIn', 'zoomOut', 'zoomExtends'];\n      var navigationDivActions = ['_moveUp', '_moveDown', '_moveLeft', '_moveRight', '_zoomIn', '_zoomOut', '_fit'];\n\n      this.navigationDOM['wrapper'] = document.createElement('div');\n      this.navigationDOM['wrapper'].className = 'vis-navigation';\n      this.canvas.frame.appendChild(this.navigationDOM['wrapper']);\n\n      for (var i = 0; i < navigationDivs.length; i++) {\n        this.navigationDOM[navigationDivs[i]] = document.createElement('div');\n        this.navigationDOM[navigationDivs[i]].className = 'vis-button vis-' + navigationDivs[i];\n        this.navigationDOM['wrapper'].appendChild(this.navigationDOM[navigationDivs[i]]);\n\n        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);\n        if (navigationDivActions[i] === '_fit') {\n          hammerUtil.onTouch(hammer, this._fit.bind(this));\n        } else {\n          hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, navigationDivActions[i]));\n        }\n\n        this.navigationHammers.push(hammer);\n      }\n\n      // use a hammer for the release so we do not require the one used in the rest of the network\n      // the one the rest uses can be overloaded by the manipulation system.\n      var hammerFrame = new Hammer(this.canvas.frame);\n      hammerUtil.onRelease(hammerFrame, function () {\n        _this2._stopMovement();\n      });\n      this.navigationHammers.push(hammerFrame);\n\n      this.iconsCreated = true;\n    }\n\n    /**\n     *\n     * @param {string} action\n     */\n\n  }, {\n    key: 'bindToRedraw',\n    value: function bindToRedraw(action) {\n      if (this.boundFunctions[action] === undefined) {\n        this.boundFunctions[action] = this[action].bind(this);\n        this.body.emitter.on('initRedraw', this.boundFunctions[action]);\n        this.body.emitter.emit('_startRendering');\n      }\n    }\n\n    /**\n     *\n     * @param {string} action\n     */\n\n  }, {\n    key: 'unbindFromRedraw',\n    value: function unbindFromRedraw(action) {\n      if (this.boundFunctions[action] !== undefined) {\n        this.body.emitter.off('initRedraw', this.boundFunctions[action]);\n        this.body.emitter.emit('_stopRendering');\n        delete this.boundFunctions[action];\n      }\n    }\n\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n\n  }, {\n    key: '_fit',\n    value: function _fit() {\n      if (new Date().valueOf() - this.touchTime > 700) {\n        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)\n        this.body.emitter.emit('fit', { duration: 700 });\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n\n  }, {\n    key: '_stopMovement',\n    value: function _stopMovement() {\n      for (var boundAction in this.boundFunctions) {\n        if (this.boundFunctions.hasOwnProperty(boundAction)) {\n          this.body.emitter.off('initRedraw', this.boundFunctions[boundAction]);\n          this.body.emitter.emit('_stopRendering');\n        }\n      }\n      this.boundFunctions = {};\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_moveUp',\n    value: function _moveUp() {\n      this.body.view.translation.y += this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_moveDown',\n    value: function _moveDown() {\n      this.body.view.translation.y -= this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_moveLeft',\n    value: function _moveLeft() {\n      this.body.view.translation.x += this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_moveRight',\n    value: function _moveRight() {\n      this.body.view.translation.x -= this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_zoomIn',\n    value: function _zoomIn() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n\n      this.body.view.scale = scale;\n      this.body.view.translation = { x: tx, y: ty };\n      this.body.emitter.emit('zoom', {\n        direction: '+',\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: '_zoomOut',\n    value: function _zoomOut() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n\n      this.body.view.scale = scale;\n      this.body.view.translation = { x: tx, y: ty };\n      this.body.emitter.emit('zoom', {\n        direction: '-',\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n\n    /**\n     * bind all keys using keycharm.\n     */\n\n  }, {\n    key: 'configureKeyboardBindings',\n    value: function configureKeyboardBindings() {\n      var _this3 = this;\n\n      if (this.keycharm !== undefined) {\n        this.keycharm.destroy();\n      }\n\n      if (this.options.keyboard.enabled === true) {\n        if (this.options.keyboard.bindToWindow === true) {\n          this.keycharm = keycharm({ container: window, preventDefault: true });\n        } else {\n          this.keycharm = keycharm({\n            container: this.canvas.frame,\n            preventDefault: true\n          });\n        }\n\n        this.keycharm.reset();\n\n        if (this.activated === true) {\n          this.keycharm.bind('up', function () {\n            _this3.bindToRedraw('_moveUp');\n          }, 'keydown');\n          this.keycharm.bind('down', function () {\n            _this3.bindToRedraw('_moveDown');\n          }, 'keydown');\n          this.keycharm.bind('left', function () {\n            _this3.bindToRedraw('_moveLeft');\n          }, 'keydown');\n          this.keycharm.bind('right', function () {\n            _this3.bindToRedraw('_moveRight');\n          }, 'keydown');\n          this.keycharm.bind('=', function () {\n            _this3.bindToRedraw('_zoomIn');\n          }, 'keydown');\n          this.keycharm.bind('num+', function () {\n            _this3.bindToRedraw('_zoomIn');\n          }, 'keydown');\n          this.keycharm.bind('num-', function () {\n            _this3.bindToRedraw('_zoomOut');\n          }, 'keydown');\n          this.keycharm.bind('-', function () {\n            _this3.bindToRedraw('_zoomOut');\n          }, 'keydown');\n          this.keycharm.bind('[', function () {\n            _this3.bindToRedraw('_zoomOut');\n          }, 'keydown');\n          this.keycharm.bind(']', function () {\n            _this3.bindToRedraw('_zoomIn');\n          }, 'keydown');\n          this.keycharm.bind('pageup', function () {\n            _this3.bindToRedraw('_zoomIn');\n          }, 'keydown');\n          this.keycharm.bind('pagedown', function () {\n            _this3.bindToRedraw('_zoomOut');\n          }, 'keydown');\n\n          this.keycharm.bind('up', function () {\n            _this3.unbindFromRedraw('_moveUp');\n          }, 'keyup');\n          this.keycharm.bind('down', function () {\n            _this3.unbindFromRedraw('_moveDown');\n          }, 'keyup');\n          this.keycharm.bind('left', function () {\n            _this3.unbindFromRedraw('_moveLeft');\n          }, 'keyup');\n          this.keycharm.bind('right', function () {\n            _this3.unbindFromRedraw('_moveRight');\n          }, 'keyup');\n          this.keycharm.bind('=', function () {\n            _this3.unbindFromRedraw('_zoomIn');\n          }, 'keyup');\n          this.keycharm.bind('num+', function () {\n            _this3.unbindFromRedraw('_zoomIn');\n          }, 'keyup');\n          this.keycharm.bind('num-', function () {\n            _this3.unbindFromRedraw('_zoomOut');\n          }, 'keyup');\n          this.keycharm.bind('-', function () {\n            _this3.unbindFromRedraw('_zoomOut');\n          }, 'keyup');\n          this.keycharm.bind('[', function () {\n            _this3.unbindFromRedraw('_zoomOut');\n          }, 'keyup');\n          this.keycharm.bind(']', function () {\n            _this3.unbindFromRedraw('_zoomIn');\n          }, 'keyup');\n          this.keycharm.bind('pageup', function () {\n            _this3.unbindFromRedraw('_zoomIn');\n          }, 'keyup');\n          this.keycharm.bind('pagedown', function () {\n            _this3.unbindFromRedraw('_zoomOut');\n          }, 'keyup');\n        }\n      }\n    }\n  }]);\n  return NavigationHandler;\n}();\n\nexports['default'] = NavigationHandler;\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports, __nested_webpack_require_1040705__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_1040705__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1040705__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Popup is a class to create a popup window with some text\n */\nvar Popup = function () {\n  /**\n   * @param {Element} container       The container object.\n   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')\n   */\n  function Popup(container, overflowMethod) {\n    (0, _classCallCheck3['default'])(this, Popup);\n\n    this.container = container;\n    this.overflowMethod = overflowMethod || 'cap';\n\n    this.x = 0;\n    this.y = 0;\n    this.padding = 5;\n    this.hidden = false;\n\n    // create the frame\n    this.frame = document.createElement('div');\n    this.frame.className = 'vis-tooltip';\n    this.container.appendChild(this.frame);\n  }\n\n  /**\n   * @param {number} x   Horizontal position of the popup window\n   * @param {number} y   Vertical position of the popup window\n   */\n\n\n  (0, _createClass3['default'])(Popup, [{\n    key: 'setPosition',\n    value: function setPosition(x, y) {\n      this.x = parseInt(x);\n      this.y = parseInt(y);\n    }\n\n    /**\n     * Set the content for the popup window. This can be HTML code or text.\n     * @param {string | Element} content\n     */\n\n  }, {\n    key: 'setText',\n    value: function setText(content) {\n      if (content instanceof Element) {\n        this.frame.innerHTML = '';\n        this.frame.appendChild(content);\n      } else {\n        this.frame.innerHTML = content; // string containing text or HTML\n      }\n    }\n\n    /**\n     * Show the popup window\n     * @param {boolean} [doShow]    Show or hide the window\n     */\n\n  }, {\n    key: 'show',\n    value: function show(doShow) {\n      if (doShow === undefined) {\n        doShow = true;\n      }\n\n      if (doShow === true) {\n        var height = this.frame.clientHeight;\n        var width = this.frame.clientWidth;\n        var maxHeight = this.frame.parentNode.clientHeight;\n        var maxWidth = this.frame.parentNode.clientWidth;\n\n        var left = 0,\n            top = 0;\n\n        if (this.overflowMethod == 'flip') {\n          var isLeft = false,\n              isTop = true; // Where around the position it's located\n\n          if (this.y - height < this.padding) {\n            isTop = false;\n          }\n\n          if (this.x + width > maxWidth - this.padding) {\n            isLeft = true;\n          }\n\n          if (isLeft) {\n            left = this.x - width;\n          } else {\n            left = this.x;\n          }\n\n          if (isTop) {\n            top = this.y - height;\n          } else {\n            top = this.y;\n          }\n        } else {\n          top = this.y - height;\n          if (top + height + this.padding > maxHeight) {\n            top = maxHeight - height - this.padding;\n          }\n          if (top < this.padding) {\n            top = this.padding;\n          }\n\n          left = this.x;\n          if (left + width + this.padding > maxWidth) {\n            left = maxWidth - width - this.padding;\n          }\n          if (left < this.padding) {\n            left = this.padding;\n          }\n        }\n\n        this.frame.style.left = left + 'px';\n        this.frame.style.top = top + 'px';\n        this.frame.style.visibility = 'visible';\n        this.hidden = false;\n      } else {\n        this.hide();\n      }\n    }\n\n    /**\n     * Hide the popup window\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.hidden = true;\n      this.frame.style.left = '0';\n      this.frame.style.top = '0';\n      this.frame.style.visibility = 'hidden';\n    }\n\n    /**\n     * Remove the popup window\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM\n    }\n  }]);\n  return Popup;\n}();\n\nexports['default'] = Popup;\n\n/***/ }),\n/* 186 */\n/***/ (function(module, exports, __nested_webpack_require_1044884__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys = __nested_webpack_require_1044884__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = __nested_webpack_require_1044884__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1044884__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar Node = __nested_webpack_require_1044884__(34)['default'];\nvar Edge = __nested_webpack_require_1044884__(55)['default'];\n\nvar util = __nested_webpack_require_1044884__(2);\n\n/**\n * The handler for selections\n */\n\nvar SelectionHandler = function () {\n  /**\n   * @param {Object} body\n   * @param {Canvas} canvas\n   */\n  function SelectionHandler(body, canvas) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, SelectionHandler);\n\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionObj = { nodes: [], edges: [] };\n    this.hoverObj = { nodes: {}, edges: {} };\n\n    this.options = {};\n    this.defaultOptions = {\n      multiselect: false,\n      selectable: true,\n      selectConnectedEdges: true,\n      hoverConnectedEdges: true\n    };\n    util.extend(this.options, this.defaultOptions);\n\n    this.body.emitter.on('_dataChanged', function () {\n      _this.updateSelection();\n    });\n  }\n\n  /**\n   *\n   * @param {Object} [options]\n   */\n\n\n  (0, _createClass3['default'])(SelectionHandler, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = ['multiselect', 'hoverConnectedEdges', 'selectable', 'selectConnectedEdges'];\n        util.selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n\n    /**\n     * handles the selection part of the tap;\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'selectOnPoint',\n    value: function selectOnPoint(pointer) {\n      var selected = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n\n        // unselect after getting the objects in order to restore width and height.\n        this.unselectAll();\n\n        if (obj !== undefined) {\n          selected = this.selectObject(obj);\n        }\n        this.body.emitter.emit('_requestRedraw');\n      }\n      return selected;\n    }\n\n    /**\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'selectAdditionalOnPoint',\n    value: function selectAdditionalOnPoint(pointer) {\n      var selectionChanged = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n\n        if (obj !== undefined) {\n          selectionChanged = true;\n          if (obj.isSelected() === true) {\n            this.deselectObject(obj);\n          } else {\n            this.selectObject(obj);\n          }\n\n          this.body.emitter.emit('_requestRedraw');\n        }\n      }\n      return selectionChanged;\n    }\n\n    /**\n     * Create an object containing the standard fields for an event.\n     *\n     * @param {Event} event\n     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse\n     * @returns {{}}\n     * @private\n     */\n\n  }, {\n    key: '_initBaseEvent',\n    value: function _initBaseEvent(event, pointer) {\n      var properties = {};\n\n      properties['pointer'] = {\n        DOM: { x: pointer.x, y: pointer.y },\n        canvas: this.canvas.DOMtoCanvas(pointer)\n      };\n      properties['event'] = event;\n\n      return properties;\n    }\n\n    /**\n     * Generate an event which the user can catch.\n     *\n     * This adds some extra data to the event with respect to cursor position and\n     * selected nodes and edges.\n     *\n     * @param {string} eventType                          Name of event to send\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse\n     * @param {Object|undefined} oldSelection             If present, selection state before event occured\n     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed\n     */\n\n  }, {\n    key: '_generateClickEvent',\n    value: function _generateClickEvent(eventType, event, pointer, oldSelection) {\n      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      var properties = this._initBaseEvent(event, pointer);\n\n      if (emptySelection === true) {\n        properties.nodes = [];\n        properties.edges = [];\n      } else {\n        var tmp = this.getSelection();\n        properties.nodes = tmp.nodes;\n        properties.edges = tmp.edges;\n      }\n\n      if (oldSelection !== undefined) {\n        properties['previousSelection'] = oldSelection;\n      }\n\n      if (eventType == 'click') {\n        // For the time being, restrict this functionality to\n        // just the click event.\n        properties.items = this.getClickedItems(pointer);\n      }\n\n      if (event.controlEdge !== undefined) {\n        properties.controlEdge = event.controlEdge;\n      }\n\n      this.body.emitter.emit(eventType, properties);\n    }\n\n    /**\n     *\n     * @param {Object} obj\n     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'selectObject',\n    value: function selectObject(obj) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;\n\n      if (obj !== undefined) {\n        if (obj instanceof Node) {\n          if (highlightEdges === true) {\n            this._selectConnectedEdges(obj);\n          }\n        }\n        obj.select();\n        this._addToSelection(obj);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     *\n     * @param {Object} obj\n     */\n\n  }, {\n    key: 'deselectObject',\n    value: function deselectObject(obj) {\n      if (obj.isSelected() === true) {\n        obj.selected = false;\n        this._removeFromSelection(obj);\n      }\n    }\n\n    /**\n     * retrieve all nodes overlapping with given object\n     * @param {Object} object  An object with parameters left, top, right, bottom\n     * @return {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n\n  }, {\n    key: '_getAllNodesOverlappingWith',\n    value: function _getAllNodesOverlappingWith(object) {\n      var overlappingNodes = [];\n      var nodes = this.body.nodes;\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var nodeId = this.body.nodeIndices[i];\n        if (nodes[nodeId].isOverlappingWith(object)) {\n          overlappingNodes.push(nodeId);\n        }\n      }\n      return overlappingNodes;\n    }\n\n    /**\n     * Return a position object in canvasspace from a single point in screenspace\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {{left: number, top: number, right: number, bottom: number}}\n     * @private\n     */\n\n  }, {\n    key: '_pointerToPositionObject',\n    value: function _pointerToPositionObject(pointer) {\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      return {\n        left: canvasPos.x - 1,\n        top: canvasPos.y + 1,\n        right: canvasPos.x + 1,\n        bottom: canvasPos.y - 1\n      };\n    }\n\n    /**\n     * Get the top node at the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnNode=true]\n     * @return {Node | undefined} node\n     */\n\n  }, {\n    key: 'getNodeAt',\n    value: function getNodeAt(pointer) {\n      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // we first check if this is an navigation controls element\n      var positionObject = this._pointerToPositionObject(pointer);\n      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);\n      // if there are overlapping nodes, select the last one, this is the\n      // one which is drawn on top of the others\n      if (overlappingNodes.length > 0) {\n        if (returnNode === true) {\n          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];\n        } else {\n          return overlappingNodes[overlappingNodes.length - 1];\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    /**\n     * retrieve all edges overlapping with given object, selector is around center\n     * @param {Object} object  An object with parameters left, top, right, bottom\n     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes\n     * @private\n     */\n\n  }, {\n    key: '_getEdgesOverlappingWith',\n    value: function _getEdgesOverlappingWith(object, overlappingEdges) {\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        if (edges[edgeId].isOverlappingWith(object)) {\n          overlappingEdges.push(edgeId);\n        }\n      }\n    }\n\n    /**\n     * retrieve all nodes overlapping with given object\n     * @param {Object} object  An object with parameters left, top, right, bottom\n     * @return {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n\n  }, {\n    key: '_getAllEdgesOverlappingWith',\n    value: function _getAllEdgesOverlappingWith(object) {\n      var overlappingEdges = [];\n      this._getEdgesOverlappingWith(object, overlappingEdges);\n      return overlappingEdges;\n    }\n\n    /**\n     * Get the edges nearest to the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnEdge=true]\n     * @return {Edge | undefined} node\n     */\n\n  }, {\n    key: 'getEdgeAt',\n    value: function getEdgeAt(pointer) {\n      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Iterate over edges, pick closest within 10\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      var mindist = 10;\n      var overlappingEdge = null;\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        var edge = edges[edgeId];\n        if (edge.connected) {\n          var xFrom = edge.from.x;\n          var yFrom = edge.from.y;\n          var xTo = edge.to.x;\n          var yTo = edge.to.y;\n          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);\n          if (dist < mindist) {\n            overlappingEdge = edgeId;\n            mindist = dist;\n          }\n        }\n      }\n      if (overlappingEdge !== null) {\n        if (returnEdge === true) {\n          return this.body.edges[overlappingEdge];\n        } else {\n          return overlappingEdge;\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    /**\n     * Add object to the selection array.\n     *\n     * @param {Object} obj\n     * @private\n     */\n\n  }, {\n    key: '_addToSelection',\n    value: function _addToSelection(obj) {\n      if (obj instanceof Node) {\n        this.selectionObj.nodes[obj.id] = obj;\n      } else {\n        this.selectionObj.edges[obj.id] = obj;\n      }\n    }\n\n    /**\n     * Add object to the selection array.\n     *\n     * @param {Object} obj\n     * @private\n     */\n\n  }, {\n    key: '_addToHover',\n    value: function _addToHover(obj) {\n      if (obj instanceof Node) {\n        this.hoverObj.nodes[obj.id] = obj;\n      } else {\n        this.hoverObj.edges[obj.id] = obj;\n      }\n    }\n\n    /**\n     * Remove a single option from selection.\n     *\n     * @param {Object} obj\n     * @private\n     */\n\n  }, {\n    key: '_removeFromSelection',\n    value: function _removeFromSelection(obj) {\n      if (obj instanceof Node) {\n        delete this.selectionObj.nodes[obj.id];\n        this._unselectConnectedEdges(obj);\n      } else {\n        delete this.selectionObj.edges[obj.id];\n      }\n    }\n\n    /**\n     * Unselect all. The selectionObj is useful for this.\n     */\n\n  }, {\n    key: 'unselectAll',\n    value: function unselectAll() {\n      for (var nodeId in this.selectionObj.nodes) {\n        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n          this.selectionObj.nodes[nodeId].unselect();\n        }\n      }\n      for (var edgeId in this.selectionObj.edges) {\n        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {\n          this.selectionObj.edges[edgeId].unselect();\n        }\n      }\n\n      this.selectionObj = { nodes: {}, edges: {} };\n    }\n\n    /**\n     * return the number of selected nodes\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getSelectedNodeCount',\n    value: function _getSelectedNodeCount() {\n      var count = 0;\n      for (var nodeId in this.selectionObj.nodes) {\n        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n          count += 1;\n        }\n      }\n      return count;\n    }\n\n    /**\n     * return the selected node\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getSelectedNode',\n    value: function _getSelectedNode() {\n      for (var nodeId in this.selectionObj.nodes) {\n        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n          return this.selectionObj.nodes[nodeId];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * return the selected edge\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getSelectedEdge',\n    value: function _getSelectedEdge() {\n      for (var edgeId in this.selectionObj.edges) {\n        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {\n          return this.selectionObj.edges[edgeId];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * return the number of selected edges\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getSelectedEdgeCount',\n    value: function _getSelectedEdgeCount() {\n      var count = 0;\n      for (var edgeId in this.selectionObj.edges) {\n        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {\n          count += 1;\n        }\n      }\n      return count;\n    }\n\n    /**\n     * return the number of selected objects.\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getSelectedObjectCount',\n    value: function _getSelectedObjectCount() {\n      var count = 0;\n      for (var nodeId in this.selectionObj.nodes) {\n        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n          count += 1;\n        }\n      }\n      for (var edgeId in this.selectionObj.edges) {\n        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {\n          count += 1;\n        }\n      }\n      return count;\n    }\n\n    /**\n     * Check if anything is selected\n     *\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_selectionIsEmpty',\n    value: function _selectionIsEmpty() {\n      for (var nodeId in this.selectionObj.nodes) {\n        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n          return false;\n        }\n      }\n      for (var edgeId in this.selectionObj.edges) {\n        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * check if one of the selected nodes is a cluster.\n     *\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_clusterInSelection',\n    value: function _clusterInSelection() {\n      for (var nodeId in this.selectionObj.nodes) {\n        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n          if (this.selectionObj.nodes[nodeId].clusterSize > 1) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * select the edges connected to the node that is being selected\n     *\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: '_selectConnectedEdges',\n    value: function _selectConnectedEdges(node) {\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        edge.select();\n        this._addToSelection(edge);\n      }\n    }\n\n    /**\n     * select the edges connected to the node that is being selected\n     *\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: '_hoverConnectedEdges',\n    value: function _hoverConnectedEdges(node) {\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        edge.hover = true;\n        this._addToHover(edge);\n      }\n    }\n\n    /**\n     * unselect the edges connected to the node that is being selected\n     *\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: '_unselectConnectedEdges',\n    value: function _unselectConnectedEdges(node) {\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        edge.unselect();\n        this._removeFromSelection(edge);\n      }\n    }\n\n    /**\n     * Remove the highlight from a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @private\n     */\n\n  }, {\n    key: 'emitBlurEvent',\n    value: function emitBlurEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n\n      if (object.hover === true) {\n        object.hover = false;\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit('blurNode', properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit('blurEdge', properties);\n        }\n      }\n    }\n\n    /**\n     * Create the highlight for a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @returns {boolean} hoverChanged\n     * @private\n     */\n\n  }, {\n    key: 'emitHoverEvent',\n    value: function emitHoverEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n      var hoverChanged = false;\n\n      if (object.hover === false) {\n        object.hover = true;\n        this._addToHover(object);\n        hoverChanged = true;\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit('hoverNode', properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit('hoverEdge', properties);\n        }\n      }\n\n      return hoverChanged;\n    }\n\n    /**\n     * Perform actions in response to a mouse movement.\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse\n     */\n\n  }, {\n    key: 'hoverObject',\n    value: function hoverObject(event, pointer) {\n      var object = this.getNodeAt(pointer);\n      if (object === undefined) {\n        object = this.getEdgeAt(pointer);\n      }\n\n      var hoverChanged = false;\n      // remove all node hover highlights\n      for (var nodeId in this.hoverObj.nodes) {\n        if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {\n          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);\n            delete this.hoverObj.nodes[nodeId];\n            hoverChanged = true;\n          }\n        }\n      }\n\n      // removing all edge hover highlights\n      for (var edgeId in this.hoverObj.edges) {\n        if (this.hoverObj.edges.hasOwnProperty(edgeId)) {\n          // if the hover has been changed here it means that the node has been hovered over or off\n          // we then do not use the emitBlurEvent method here.\n          if (hoverChanged === true) {\n            this.hoverObj.edges[edgeId].hover = false;\n            delete this.hoverObj.edges[edgeId];\n          }\n          // if the blur remains the same and the object is undefined (mouse off) or another\n          // edge has been hovered, or another node has been hovered we blur the edge.\n          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {\n              this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);\n              delete this.hoverObj.edges[edgeId];\n              hoverChanged = true;\n            }\n        }\n      }\n\n      if (object !== undefined) {\n        var hoveredEdgesCount = (0, _keys2['default'])(this.hoverObj.edges).length;\n        var hoveredNodesCount = (0, _keys2['default'])(this.hoverObj.nodes).length;\n        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n\n        if (hoverChanged || newOnlyHoveredEdge) {\n          hoverChanged = this.emitHoverEvent(event, pointer, object);\n        }\n\n        if (object instanceof Node && this.options.hoverConnectedEdges === true) {\n          this._hoverConnectedEdges(object);\n        }\n      }\n\n      if (hoverChanged === true) {\n        this.body.emitter.emit('_requestRedraw');\n      }\n    }\n\n    /**\n     *\n     * retrieve the currently selected objects\n     * @return {{nodes: Array.<string>, edges: Array.<string>}} selection\n     */\n\n  }, {\n    key: 'getSelection',\n    value: function getSelection() {\n      var nodeIds = this.getSelectedNodes();\n      var edgeIds = this.getSelectedEdges();\n      return { nodes: nodeIds, edges: edgeIds };\n    }\n\n    /**\n     *\n     * retrieve the currently selected nodes\n     * @return {string[]} selection    An array with the ids of the\n     *                                            selected nodes.\n     */\n\n  }, {\n    key: 'getSelectedNodes',\n    value: function getSelectedNodes() {\n      var idArray = [];\n      if (this.options.selectable === true) {\n        for (var nodeId in this.selectionObj.nodes) {\n          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n            idArray.push(this.selectionObj.nodes[nodeId].id);\n          }\n        }\n      }\n      return idArray;\n    }\n\n    /**\n     *\n     * retrieve the currently selected edges\n     * @return {Array} selection    An array with the ids of the\n     *                                            selected nodes.\n     */\n\n  }, {\n    key: 'getSelectedEdges',\n    value: function getSelectedEdges() {\n      var idArray = [];\n      if (this.options.selectable === true) {\n        for (var edgeId in this.selectionObj.edges) {\n          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {\n            idArray.push(this.selectionObj.edges[edgeId].id);\n          }\n        }\n      }\n      return idArray;\n    }\n\n    /**\n     * Updates the current selection\n     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection\n     * @param {Object} options                                 Options\n     */\n\n  }, {\n    key: 'setSelection',\n    value: function setSelection(selection) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var i = void 0,\n          id = void 0;\n\n      if (!selection || !selection.nodes && !selection.edges) throw 'Selection must be an object with nodes and/or edges properties';\n      // first unselect any selected node, if option is true or undefined\n      if (options.unselectAll || options.unselectAll === undefined) {\n        this.unselectAll();\n      }\n      if (selection.nodes) {\n        for (i = 0; i < selection.nodes.length; i++) {\n          id = selection.nodes[i];\n\n          var node = this.body.nodes[id];\n          if (!node) {\n            throw new RangeError('Node with id \"' + id + '\" not found');\n          }\n          // don't select edges with it\n          this.selectObject(node, options.highlightEdges);\n        }\n      }\n\n      if (selection.edges) {\n        for (i = 0; i < selection.edges.length; i++) {\n          id = selection.edges[i];\n\n          var edge = this.body.edges[id];\n          if (!edge) {\n            throw new RangeError('Edge with id \"' + id + '\" not found');\n          }\n          this.selectObject(edge);\n        }\n      }\n      this.body.emitter.emit('_requestRedraw');\n    }\n\n    /**\n     * select zero or more nodes with the option to highlight edges\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     * @param {boolean} [highlightEdges]\n     */\n\n  }, {\n    key: 'selectNodes',\n    value: function selectNodes(selection) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';\n\n      this.setSelection({ nodes: selection }, { highlightEdges: highlightEdges });\n    }\n\n    /**\n     * select zero or more edges\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     */\n\n  }, {\n    key: 'selectEdges',\n    value: function selectEdges(selection) {\n      if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';\n\n      this.setSelection({ edges: selection });\n    }\n\n    /**\n     * Validate the selection: remove ids of nodes which no longer exist\n     * @private\n     */\n\n  }, {\n    key: 'updateSelection',\n    value: function updateSelection() {\n      for (var nodeId in this.selectionObj.nodes) {\n        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {\n          if (!this.body.nodes.hasOwnProperty(nodeId)) {\n            delete this.selectionObj.nodes[nodeId];\n          }\n        }\n      }\n      for (var edgeId in this.selectionObj.edges) {\n        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {\n          if (!this.body.edges.hasOwnProperty(edgeId)) {\n            delete this.selectionObj.edges[edgeId];\n          }\n        }\n      }\n    }\n\n    /**\n     * Determine all the visual elements clicked which are on the given point.\n     *\n     * All elements are returned; this includes nodes, edges and their labels.\n     * The order returned is from highest to lowest, i.e. element 0 of the return\n     * value is the topmost item clicked on.\n     *\n     * The return value consists of an array of the following possible elements:\n     *\n     * - `{nodeId:number}`             - node with given id clicked on\n     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on\n     * - `{edgeId:number}`             - edge with given id clicked on\n     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on\n     *\n     * ## NOTES\n     *\n     * - Currently, there is only one label associated with a node or an edge,\n     *   but this is expected to change somewhere in the future.\n     * - Since there is no z-indexing yet, it is not really possible to set the nodes and\n     *   edges in the correct order. For the time being, nodes come first.\n     *\n     * @param {point} pointer  mouse position in screen coordinates\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}\n     * @private\n     */\n\n  }, {\n    key: 'getClickedItems',\n    value: function getClickedItems(pointer) {\n      var point = this.canvas.DOMtoCanvas(pointer);\n      var items = [];\n\n      // Note reverse order; we want the topmost clicked items to be first in the array\n      // Also note that selected nodes are disregarded here; these normally display on top\n      var nodeIndices = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      for (var i = nodeIndices.length - 1; i >= 0; i--) {\n        var node = nodes[nodeIndices[i]];\n        var ret = node.getItemsOnPoint(point);\n        items.push.apply(items, ret); // Append the return value to the running list.\n      }\n\n      var edgeIndices = this.body.edgeIndices;\n      var edges = this.body.edges;\n      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {\n        var edge = edges[edgeIndices[_i]];\n        var _ret = edge.getItemsOnPoint(point);\n        items.push.apply(items, _ret); // Append the return value to the running list.\n      }\n\n      return items;\n    }\n  }]);\n  return SelectionHandler;\n}();\n\nexports['default'] = SelectionHandler;\n\n/***/ }),\n/* 187 */\n/***/ (function(module, exports, __nested_webpack_require_1073236__) {\n\n\"use strict\";\n/**\n * There's a mix-up with terms in the code. Following are the formal definitions:\n *\n *   tree   - a strict hierarchical network, i.e. every node has at most one parent\n *   forest - a collection of trees. These distinct trees are thus not connected.\n *\n * So:\n * - in a network that is not a tree, there exist nodes with multiple parents.\n * - a network consisting of unconnected sub-networks, of which at least one\n *   is not a tree, is not a forest.\n *\n * In the code, the definitions are:\n *\n *   tree   - any disconnected sub-network, strict hierarchical or not.\n *   forest - a bunch of these sub-networks\n *\n * The difference between tree and not-tree is important in the code, notably within\n * to the block-shifting algorithm. The algorithm assumes formal trees and fails\n * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).\n *\n * In order to distinguish the definitions in the following code, the adjective 'formal' is\n * used. If 'formal' is absent, you must assume the non-formal definition.\n *\n * ----------------------------------------------------------------------------------\n * NOTES\n * =====\n *\n * A hierarchical layout is a different thing from a hierarchical network.\n * The layout is a way to arrange the nodes in the view; this can be done\n * on non-hierarchical networks as well. The converse is also possible.\n */\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = __nested_webpack_require_1073236__(15);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _typeof2 = __nested_webpack_require_1073236__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _keys = __nested_webpack_require_1073236__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = __nested_webpack_require_1073236__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1073236__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar TimSort = __nested_webpack_require_1073236__(83);\nvar util = __nested_webpack_require_1073236__(2);\nvar NetworkUtil = __nested_webpack_require_1073236__(57)['default'];\n\nvar _require = __nested_webpack_require_1073236__(189),\n    HorizontalStrategy = _require.HorizontalStrategy,\n    VerticalStrategy = _require.VerticalStrategy;\n\n/**\n * Container for derived data on current network, relating to hierarchy.\n *\n * @private\n */\n\n\nvar HierarchicalStatus = function () {\n  /**\n   * @ignore\n   */\n  function HierarchicalStatus() {\n    (0, _classCallCheck3['default'])(this, HierarchicalStatus);\n\n    this.childrenReference = {}; // child id's per node id\n    this.parentReference = {}; // parent id's per node id\n    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong\n\n    this.distributionOrdering = {}; // The nodes per level, in the display order\n    this.levels = {}; // hierarchy level per node id\n    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.\n\n    this.isTree = false; // True if current network is a formal tree\n    this.treeIndex = -1; // Highest tree id in current network.\n  }\n\n  /**\n   * Add the relation between given nodes to the current state.\n   *\n   * @param {Node.id} parentNodeId\n   * @param {Node.id} childNodeId\n   */\n\n\n  (0, _createClass3['default'])(HierarchicalStatus, [{\n    key: 'addRelation',\n    value: function addRelation(parentNodeId, childNodeId) {\n      if (this.childrenReference[parentNodeId] === undefined) {\n        this.childrenReference[parentNodeId] = [];\n      }\n      this.childrenReference[parentNodeId].push(childNodeId);\n\n      if (this.parentReference[childNodeId] === undefined) {\n        this.parentReference[childNodeId] = [];\n      }\n      this.parentReference[childNodeId].push(parentNodeId);\n    }\n\n    /**\n     * Check if the current state is for a formal tree or formal forest.\n     *\n     * This is the case if every node has at most one parent.\n     *\n     * Pre: parentReference init'ed properly for current network\n     */\n\n  }, {\n    key: 'checkIfTree',\n    value: function checkIfTree() {\n      for (var i in this.parentReference) {\n        if (this.parentReference[i].length > 1) {\n          this.isTree = false;\n          return;\n        }\n      }\n\n      this.isTree = true;\n    }\n\n    /**\n     * Return the number of separate trees in the current network.\n     * @returns {number}\n     */\n\n  }, {\n    key: 'numTrees',\n    value: function numTrees() {\n      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively\n    }\n\n    /**\n     * Assign a tree id to a node\n     * @param {Node} node\n     * @param {string|number} treeId\n     */\n\n  }, {\n    key: 'setTreeIndex',\n    value: function setTreeIndex(node, treeId) {\n      if (treeId === undefined) return; // Don't bother\n\n      if (this.trees[node.id] === undefined) {\n        this.trees[node.id] = treeId;\n        this.treeIndex = Math.max(treeId, this.treeIndex);\n      }\n    }\n\n    /**\n     * Ensure level for given id is defined.\n     *\n     * Sets level to zero for given node id if not already present\n     *\n     * @param {Node.id} nodeId\n     */\n\n  }, {\n    key: 'ensureLevel',\n    value: function ensureLevel(nodeId) {\n      if (this.levels[nodeId] === undefined) {\n        this.levels[nodeId] = 0;\n      }\n    }\n\n    /**\n     * get the maximum level of a branch.\n     *\n     * TODO: Never entered; find a test case to test this!\n     * @param {Node.id} nodeId\n     * @returns {number}\n     */\n\n  }, {\n    key: 'getMaxLevel',\n    value: function getMaxLevel(nodeId) {\n      var _this = this;\n\n      var accumulator = {};\n\n      var _getMaxLevel = function _getMaxLevel(nodeId) {\n        if (accumulator[nodeId] !== undefined) {\n          return accumulator[nodeId];\n        }\n        var level = _this.levels[nodeId];\n        if (_this.childrenReference[nodeId]) {\n          var children = _this.childrenReference[nodeId];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              level = Math.max(level, _getMaxLevel(children[i]));\n            }\n          }\n        }\n        accumulator[nodeId] = level;\n        return level;\n      };\n\n      return _getMaxLevel(nodeId);\n    }\n\n    /**\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n\n  }, {\n    key: 'levelDownstream',\n    value: function levelDownstream(nodeA, nodeB) {\n      if (this.levels[nodeB.id] === undefined) {\n        // set initial level\n        if (this.levels[nodeA.id] === undefined) {\n          this.levels[nodeA.id] = 0;\n        }\n        // set level\n        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;\n      }\n    }\n\n    /**\n     * Small util method to set the minimum levels of the nodes to zero.\n     *\n     * @param {Array.<Node>} nodes\n     */\n\n  }, {\n    key: 'setMinLevelToZero',\n    value: function setMinLevelToZero(nodes) {\n      var minLevel = 1e9;\n      // get the minimum level\n      for (var nodeId in nodes) {\n        if (nodes.hasOwnProperty(nodeId)) {\n          if (this.levels[nodeId] !== undefined) {\n            minLevel = Math.min(this.levels[nodeId], minLevel);\n          }\n        }\n      }\n\n      // subtract the minimum from the set so we have a range starting from 0\n      for (var _nodeId in nodes) {\n        if (nodes.hasOwnProperty(_nodeId)) {\n          if (this.levels[_nodeId] !== undefined) {\n            this.levels[_nodeId] -= minLevel;\n          }\n        }\n      }\n    }\n\n    /**\n     * Get the min and max xy-coordinates of a given tree\n     *\n     * @param {Array.<Node>} nodes\n     * @param {number} index\n     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}\n     */\n\n  }, {\n    key: 'getTreeSize',\n    value: function getTreeSize(nodes, index) {\n      var min_x = 1e9;\n      var max_x = -1e9;\n      var min_y = 1e9;\n      var max_y = -1e9;\n\n      for (var nodeId in this.trees) {\n        if (this.trees.hasOwnProperty(nodeId)) {\n          if (this.trees[nodeId] === index) {\n            var node = nodes[nodeId];\n            min_x = Math.min(node.x, min_x);\n            max_x = Math.max(node.x, max_x);\n            min_y = Math.min(node.y, min_y);\n            max_y = Math.max(node.y, max_y);\n          }\n        }\n      }\n\n      return {\n        min_x: min_x,\n        max_x: max_x,\n        min_y: min_y,\n        max_y: max_y\n      };\n    }\n\n    /**\n     * Check if two nodes have the same parent(s)\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @return {boolean} true if the two nodes have a same ancestor node, false otherwise\n     */\n\n  }, {\n    key: 'hasSameParent',\n    value: function hasSameParent(node1, node2) {\n      var parents1 = this.parentReference[node1.id];\n      var parents2 = this.parentReference[node2.id];\n      if (parents1 === undefined || parents2 === undefined) {\n        return false;\n      }\n\n      for (var i = 0; i < parents1.length; i++) {\n        for (var j = 0; j < parents2.length; j++) {\n          if (parents1[i] == parents2[j]) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Check if two nodes are in the same tree.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @return {Boolean} true if this is so, false otherwise\n     */\n\n  }, {\n    key: 'inSameSubNetwork',\n    value: function inSameSubNetwork(node1, node2) {\n      return this.trees[node1.id] === this.trees[node2.id];\n    }\n\n    /**\n     * Get a list of the distinct levels in the current network\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'getLevels',\n    value: function getLevels() {\n      return (0, _keys2['default'])(this.distributionOrdering);\n    }\n\n    /**\n     * Add a node to the ordering per level\n     *\n     * @param {Node} node\n     * @param {number} level\n     */\n\n  }, {\n    key: 'addToOrdering',\n    value: function addToOrdering(node, level) {\n      if (this.distributionOrdering[level] === undefined) {\n        this.distributionOrdering[level] = [];\n      }\n\n      var isPresent = false;\n      var curLevel = this.distributionOrdering[level];\n      for (var n in curLevel) {\n        //if (curLevel[n].id === node.id) {\n        if (curLevel[n] === node) {\n          isPresent = true;\n          break;\n        }\n      }\n\n      if (!isPresent) {\n        this.distributionOrdering[level].push(node);\n        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;\n      }\n    }\n  }]);\n  return HierarchicalStatus;\n}();\n\n/**\n * The Layout Engine\n */\n\n\nvar LayoutEngine = function () {\n  /**\n   * @param {Object} body\n   */\n  function LayoutEngine(body) {\n    (0, _classCallCheck3['default'])(this, LayoutEngine);\n\n    this.body = body;\n\n    this.initialRandomSeed = Math.round(Math.random() * 1000000);\n    this.randomSeed = this.initialRandomSeed;\n    this.setPhysics = false;\n    this.options = {};\n    this.optionsBackup = { physics: {} };\n\n    this.defaultOptions = {\n      randomSeed: undefined,\n      improvedLayout: true,\n      hierarchical: {\n        enabled: false,\n        levelSeparation: 150,\n        nodeSpacing: 100,\n        treeSpacing: 200,\n        blockShifting: true,\n        edgeMinimization: true,\n        parentCentralization: true,\n        direction: 'UD', // UD, DU, LR, RL\n        sortMethod: 'hubsize' // hubsize, directed\n      }\n    };\n    util.extend(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n\n\n  (0, _createClass3['default'])(LayoutEngine, [{\n    key: 'bindEventListeners',\n    value: function bindEventListeners() {\n      var _this2 = this;\n\n      this.body.emitter.on('_dataChanged', function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on('_dataLoaded', function () {\n        _this2.layoutNetwork();\n      });\n      this.body.emitter.on('_resetHierarchicalLayout', function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on('_adjustEdgesForHierarchicalLayout', function () {\n        if (_this2.options.hierarchical.enabled !== true) {\n          return;\n        }\n        // get the type of static smooth curve in case it is required\n        var type = _this2.direction.curveType();\n\n        // force all edges into static smooth curves.\n        _this2.body.emitter.emit('_forceDisableDynamicCurves', type, false);\n      });\n    }\n\n    /**\n     *\n     * @param {Object} options\n     * @param {Object} allOptions\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options, allOptions) {\n      if (options !== undefined) {\n        var hierarchical = this.options.hierarchical;\n        var prevHierarchicalState = hierarchical.enabled;\n        util.selectiveDeepExtend(['randomSeed', 'improvedLayout'], this.options, options);\n        util.mergeOptions(this.options, options, 'hierarchical');\n        if (options.randomSeed !== undefined) {\n          this.initialRandomSeed = options.randomSeed;\n        }\n\n        if (hierarchical.enabled === true) {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit('refresh', true);\n          }\n\n          // make sure the level separation is the right way up\n          if (hierarchical.direction === 'RL' || hierarchical.direction === 'DU') {\n            if (hierarchical.levelSeparation > 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          } else {\n            if (hierarchical.levelSeparation < 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          }\n\n          this.setDirectionStrategy();\n\n          this.body.emitter.emit('_resetHierarchicalLayout');\n          // because the hierarchical system needs it's own physics and smooth curve settings,\n          // we adapt the other options if needed.\n          return this.adaptAllOptionsForHierarchicalLayout(allOptions);\n        } else {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit('refresh');\n            return util.deepExtend(allOptions, this.optionsBackup);\n          }\n        }\n      }\n      return allOptions;\n    }\n\n    /**\n     *\n     * @param {Object} allOptions\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'adaptAllOptionsForHierarchicalLayout',\n    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {\n      if (this.options.hierarchical.enabled === true) {\n        var backupPhysics = this.optionsBackup.physics;\n\n        // set the physics\n        if (allOptions.physics === undefined || allOptions.physics === true) {\n          allOptions.physics = {\n            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,\n            solver: 'hierarchicalRepulsion'\n          };\n          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;\n          backupPhysics.solver = backupPhysics.solver || 'barnesHut';\n        } else if ((0, _typeof3['default'])(allOptions.physics) === 'object') {\n          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;\n          backupPhysics.solver = allOptions.physics.solver || 'barnesHut';\n          allOptions.physics.solver = 'hierarchicalRepulsion';\n        } else if (allOptions.physics !== false) {\n          backupPhysics.solver = 'barnesHut';\n          allOptions.physics = { solver: 'hierarchicalRepulsion' };\n        }\n\n        // get the type of static smooth curve in case it is required\n        var type = this.direction.curveType();\n\n        // disable smooth curves if nothing is defined. If smooth curves have been turned on,\n        // turn them into static smooth curves.\n        if (allOptions.edges === undefined) {\n          this.optionsBackup.edges = {\n            smooth: { enabled: true, type: 'dynamic' }\n          };\n          allOptions.edges = { smooth: false };\n        } else if (allOptions.edges.smooth === undefined) {\n          this.optionsBackup.edges = {\n            smooth: { enabled: true, type: 'dynamic' }\n          };\n          allOptions.edges.smooth = false;\n        } else {\n          if (typeof allOptions.edges.smooth === 'boolean') {\n            this.optionsBackup.edges = { smooth: allOptions.edges.smooth };\n            allOptions.edges.smooth = {\n              enabled: allOptions.edges.smooth,\n              type: type\n            };\n          } else {\n            var smooth = allOptions.edges.smooth;\n\n            // allow custom types except for dynamic\n            if (smooth.type !== undefined && smooth.type !== 'dynamic') {\n              type = smooth.type;\n            }\n\n            // TODO: this is options merging; see if the standard routines can be used here.\n            this.optionsBackup.edges = {\n              smooth: smooth.enabled === undefined ? true : smooth.enabled,\n              type: smooth.type === undefined ? 'dynamic' : smooth.type,\n              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n\n              // NOTE: Copying an object to self; this is basically setting defaults for undefined variables\n            };allOptions.edges.smooth = {\n              enabled: smooth.enabled === undefined ? true : smooth.enabled,\n              type: type,\n              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n            };\n          }\n        }\n\n        // Force all edges into static smooth curves.\n        // Only applies to edges that do not use the global options for smooth.\n        this.body.emitter.emit('_forceDisableDynamicCurves', type);\n      }\n\n      return allOptions;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'seededRandom',\n    value: function seededRandom() {\n      var x = Math.sin(this.randomSeed++) * 10000;\n      return x - Math.floor(x);\n    }\n\n    /**\n     *\n     * @param {Array.<Node>} nodesArray\n     */\n\n  }, {\n    key: 'positionInitially',\n    value: function positionInitially(nodesArray) {\n      if (this.options.hierarchical.enabled !== true) {\n        this.randomSeed = this.initialRandomSeed;\n        var radius = nodesArray.length + 50;\n        for (var i = 0; i < nodesArray.length; i++) {\n          var node = nodesArray[i];\n          var angle = 2 * Math.PI * this.seededRandom();\n          if (node.x === undefined) {\n            node.x = radius * Math.cos(angle);\n          }\n          if (node.y === undefined) {\n            node.y = radius * Math.sin(angle);\n          }\n        }\n      }\n    }\n\n    /**\n     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we\n     * cluster them first to reduce the amount.\n     */\n\n  }, {\n    key: 'layoutNetwork',\n    value: function layoutNetwork() {\n      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {\n        var indices = this.body.nodeIndices;\n\n        // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible\n        // nodes have predefined positions we use this.\n        var positionDefined = 0;\n        for (var i = 0; i < indices.length; i++) {\n          var node = this.body.nodes[indices[i]];\n          if (node.predefinedPosition === true) {\n            positionDefined += 1;\n          }\n        }\n\n        // if less than half of the nodes have a predefined position we continue\n        if (positionDefined < 0.5 * indices.length) {\n          var MAX_LEVELS = 10;\n          var level = 0;\n          var clusterThreshold = 150; // TODO add this to options\n\n          //\n          // Define the options for the hidden cluster nodes\n          // These options don't propagate outside the clustering phase.\n          //\n          // Some options are explicitly disabled, because they may be set in group or default node options.\n          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.\n          //\n          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden\n          // cluster nodes, leading to an exception on creation.\n          //\n          // All settings here are performance related, except when noted otherwise.\n          //\n          var clusterOptions = {\n            clusterNodeProperties: {\n              shape: 'ellipse', // Bugfix: avoid type 'image', no images supplied\n              label: '', // avoid label handling\n              group: '', // avoid group handling\n              font: { multi: false // avoid font propagation\n              } },\n            clusterEdgeProperties: {\n              label: '', // avoid label handling\n              font: { multi: false }, // avoid font propagation\n              smooth: {\n                enabled: false // avoid drawing penalty for complex edges\n              }\n            }\n\n            // if there are a lot of nodes, we cluster before we run the algorithm.\n            // NOTE: this part fails to find clusters for large scale-free networks, which should\n            //       be easily clusterable.\n            // TODO: examine why this is so\n          };if (indices.length > clusterThreshold) {\n            var startLength = indices.length;\n            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {\n              //console.time(\"clustering\")\n              level += 1;\n              var before = indices.length;\n              // if there are many nodes we do a hubsize cluster\n              if (level % 3 === 0) {\n                this.body.modules.clustering.clusterBridges(clusterOptions);\n              } else {\n                this.body.modules.clustering.clusterOutliers(clusterOptions);\n              }\n              var after = indices.length;\n              if (before == after && level % 3 !== 0) {\n                this._declusterAll();\n                this.body.emitter.emit('_layoutFailed');\n                console.info('This network could not be positioned by this version of the improved layout algorithm.' + ' Please disable improvedLayout for better performance.');\n                return;\n              }\n              //console.timeEnd(\"clustering\")\n              //console.log(before,level,after);\n            }\n            // increase the size of the edges\n            this.body.modules.kamadaKawai.setOptions({\n              springLength: Math.max(150, 2 * startLength)\n            });\n          }\n          if (level > MAX_LEVELS) {\n            console.info(\"The clustering didn't succeed within the amount of interations allowed,\" + ' progressing with partial result.');\n          }\n\n          // position the system for these nodes and edges\n          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);\n\n          // shift to center point\n          this._shiftToCenter();\n\n          // perturb the nodes a little bit to force the physics to kick in\n          var offset = 70;\n          for (var _i = 0; _i < indices.length; _i++) {\n            // Only perturb the nodes that aren't fixed\n            var _node = this.body.nodes[indices[_i]];\n            if (_node.predefinedPosition === false) {\n              _node.x += (0.5 - this.seededRandom()) * offset;\n              _node.y += (0.5 - this.seededRandom()) * offset;\n            }\n          }\n\n          // uncluster all clusters\n          this._declusterAll();\n\n          // reposition all bezier nodes.\n          this.body.emitter.emit('_repositionBezierNodes');\n        }\n      }\n    }\n\n    /**\n     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view\n     * @private\n     */\n\n  }, {\n    key: '_shiftToCenter',\n    value: function _shiftToCenter() {\n      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);\n      var center = NetworkUtil.findCenter(range);\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        node.x -= center.x;\n        node.y -= center.y;\n      }\n    }\n\n    /**\n     * Expands all clusters\n     * @private\n     */\n\n  }, {\n    key: '_declusterAll',\n    value: function _declusterAll() {\n      var clustersPresent = true;\n      while (clustersPresent === true) {\n        clustersPresent = false;\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {\n            clustersPresent = true;\n            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);\n          }\n        }\n        if (clustersPresent === true) {\n          this.body.emitter.emit('_dataChanged');\n        }\n      }\n    }\n\n    /**\n     *\n     * @returns {number|*}\n     */\n\n  }, {\n    key: 'getSeed',\n    value: function getSeed() {\n      return this.initialRandomSeed;\n    }\n\n    /**\n     * This is the main function to layout the nodes in a hierarchical way.\n     * It checks if the node details are supplied correctly\n     *\n     * @private\n     */\n\n  }, {\n    key: 'setupHierarchicalLayout',\n    value: function setupHierarchicalLayout() {\n      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {\n        // get the size of the largest hubs and check if the user has defined a level for a node.\n        var node = void 0,\n            nodeId = void 0;\n        var definedLevel = false;\n        var undefinedLevel = false;\n        this.lastNodeOnLevel = {};\n        this.hierarchical = new HierarchicalStatus();\n\n        for (nodeId in this.body.nodes) {\n          if (this.body.nodes.hasOwnProperty(nodeId)) {\n            node = this.body.nodes[nodeId];\n            if (node.options.level !== undefined) {\n              definedLevel = true;\n              this.hierarchical.levels[nodeId] = node.options.level;\n            } else {\n              undefinedLevel = true;\n            }\n          }\n        }\n\n        // if the user defined some levels but not all, alert and run without hierarchical layout\n        if (undefinedLevel === true && definedLevel === true) {\n          throw new Error('To use the hierarchical layout, nodes require either no predefined levels' + ' or levels have to be defined for all nodes.');\n        } else {\n          // define levels if undefined by the users. Based on hubsize.\n          if (undefinedLevel === true) {\n            var sortMethod = this.options.hierarchical.sortMethod;\n            if (sortMethod === 'hubsize') {\n              this._determineLevelsByHubsize();\n            } else if (sortMethod === 'directed') {\n              this._determineLevelsDirected();\n            } else if (sortMethod === 'custom') {\n              this._determineLevelsCustomCallback();\n            }\n          }\n\n          // fallback for cases where there are nodes but no edges\n          for (var _nodeId2 in this.body.nodes) {\n            if (this.body.nodes.hasOwnProperty(_nodeId2)) {\n              this.hierarchical.ensureLevel(_nodeId2);\n            }\n          }\n          // check the distribution of the nodes per level.\n          var distribution = this._getDistribution();\n\n          // get the parent children relations.\n          this._generateMap();\n\n          // place the nodes on the canvas.\n          this._placeNodesByHierarchy(distribution);\n\n          // condense the whitespace.\n          this._condenseHierarchy();\n\n          // shift to center so gravity does not have to do much\n          this._shiftToCenter();\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_condenseHierarchy',\n    value: function _condenseHierarchy() {\n      var _this3 = this;\n\n      // Global var in this scope to define when the movement has stopped.\n      var stillShifting = false;\n      var branches = {};\n      // first we have some methods to help shifting trees around.\n      // the main method to shift the trees\n      var shiftTrees = function shiftTrees() {\n        var treeSizes = getTreeSizes();\n        var shiftBy = 0;\n        for (var i = 0; i < treeSizes.length - 1; i++) {\n          var diff = treeSizes[i].max - treeSizes[i + 1].min;\n          shiftBy += diff + _this3.options.hierarchical.treeSpacing;\n          shiftTree(i + 1, shiftBy);\n        }\n      };\n\n      // shift a single tree by an offset\n      var shiftTree = function shiftTree(index, offset) {\n        var trees = _this3.hierarchical.trees;\n\n        for (var nodeId in trees) {\n          if (trees.hasOwnProperty(nodeId)) {\n            if (trees[nodeId] === index) {\n              _this3.direction.shift(nodeId, offset);\n            }\n          }\n        }\n      };\n\n      // get the width of all trees\n      var getTreeSizes = function getTreeSizes() {\n        var treeWidths = [];\n        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {\n          treeWidths.push(_this3.direction.getTreeSize(i));\n        }\n        return treeWidths;\n      };\n\n      // get a map of all nodes in this branch\n      var getBranchNodes = function getBranchNodes(source, map) {\n        if (map[source.id]) {\n          return;\n        }\n        map[source.id] = true;\n        if (_this3.hierarchical.childrenReference[source.id]) {\n          var children = _this3.hierarchical.childrenReference[source.id];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              getBranchNodes(_this3.body.nodes[children[i]], map);\n            }\n          }\n        }\n      };\n\n      // get a min max width as well as the maximum movement space it has on either sides\n      // we use min max terminology because width and height can interchange depending on the direction of the layout\n      var getBranchBoundary = function getBranchBoundary(branchMap) {\n        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;\n\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        var min = 1e9;\n        var max = -1e9;\n        for (var branchNode in branchMap) {\n          if (branchMap.hasOwnProperty(branchNode)) {\n            var node = _this3.body.nodes[branchNode];\n            var level = _this3.hierarchical.levels[node.id];\n            var position = _this3.direction.getPosition(node);\n\n            // get the space around the node.\n\n            var _getSpaceAroundNode2 = _this3._getSpaceAroundNode(node, branchMap),\n                _getSpaceAroundNode3 = (0, _slicedToArray3['default'])(_getSpaceAroundNode2, 2),\n                minSpaceNode = _getSpaceAroundNode3[0],\n                maxSpaceNode = _getSpaceAroundNode3[1];\n\n            minSpace = Math.min(minSpaceNode, minSpace);\n            maxSpace = Math.min(maxSpaceNode, maxSpace);\n\n            // the width is only relevant for the levels two nodes have in common. This is why we filter on this.\n            if (level <= maxLevel) {\n              min = Math.min(position, min);\n              max = Math.max(position, max);\n            }\n          }\n        }\n\n        return [min, max, minSpace, maxSpace];\n      };\n\n      // check what the maximum level is these nodes have in common.\n      var getCollisionLevel = function getCollisionLevel(node1, node2) {\n        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);\n        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);\n        return Math.min(maxLevel1, maxLevel2);\n      };\n\n      /**\n       * Condense elements. These can be nodes or branches depending on the callback.\n       *\n       * @param {function} callback\n       * @param {Array.<number>} levels\n       * @param {*} centerParents\n       */\n      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {\n        var hier = _this3.hierarchical;\n\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = hier.distributionOrdering[level];\n          if (levelNodes.length > 1) {\n            for (var j = 0; j < levelNodes.length - 1; j++) {\n              var node1 = levelNodes[j];\n              var node2 = levelNodes[j + 1];\n\n              // NOTE: logic maintained as it was; if nodes have same ancestor,\n              //       then of course they are in the same sub-network.\n              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {\n                callback(node1, node2, centerParents);\n              }\n            }\n          }\n        }\n      };\n\n      // callback for shifting branches\n      var branchShiftCallback = function branchShiftCallback(node1, node2) {\n        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        //window.CALLBACKS.push(() => {\n        var pos1 = _this3.direction.getPosition(node1);\n        var pos2 = _this3.direction.getPosition(node2);\n        var diffAbs = Math.abs(pos2 - pos1);\n        var nodeSpacing = _this3.options.hierarchical.nodeSpacing;\n        //console.log(\"NOW CHECKING:\", node1.id, node2.id, diffAbs);\n        if (diffAbs > nodeSpacing) {\n          var branchNodes1 = {};\n          var branchNodes2 = {};\n\n          getBranchNodes(node1, branchNodes1);\n          getBranchNodes(node2, branchNodes2);\n\n          // check the largest distance between the branches\n          var maxLevel = getCollisionLevel(node1, node2);\n          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);\n          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);\n          var max1 = branchNodeBoundary1[1];\n          var min2 = branchNodeBoundary2[0];\n          var minSpace2 = branchNodeBoundary2[2];\n\n          //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,\n          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);\n          var diffBranch = Math.abs(max1 - min2);\n          if (diffBranch > nodeSpacing) {\n            var offset = max1 - min2 + nodeSpacing;\n            if (offset < -minSpace2 + nodeSpacing) {\n              offset = -minSpace2 + nodeSpacing;\n              //console.log(\"RESETTING OFFSET\", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);\n            }\n            if (offset < 0) {\n              //console.log(\"SHIFTING\", node2.id, offset);\n              _this3._shiftBlock(node2.id, offset);\n              stillShifting = true;\n\n              if (centerParent === true) _this3._centerParent(node2);\n            }\n          }\n        }\n        //this.body.emitter.emit(\"_redraw\");})\n      };\n\n      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {\n        //window.CALLBACKS.push(() => {\n        //  console.log(\"ts\",node.id);\n        var nodeId = node.id;\n        var allEdges = node.edges;\n        var nodeLevel = _this3.hierarchical.levels[node.id];\n\n        // gather constants\n        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;\n        var referenceNodes = {};\n        var aboveEdges = [];\n        for (var i = 0; i < allEdges.length; i++) {\n          var edge = allEdges[i];\n          if (edge.toId != edge.fromId) {\n            var otherNode = edge.toId == nodeId ? edge.from : edge.to;\n            referenceNodes[allEdges[i].id] = otherNode;\n            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {\n              aboveEdges.push(edge);\n            }\n          }\n        }\n\n        // differentiated sum of lengths based on only moving one node over one axis\n        var getFx = function getFx(point, edges) {\n          var sum = 0;\n          for (var _i2 = 0; _i2 < edges.length; _i2++) {\n            if (referenceNodes[edges[_i2].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;\n              sum += a / Math.sqrt(a * a + C2);\n            }\n          }\n          return sum;\n        };\n\n        // doubly differentiated sum of lengths based on only moving one node over one axis\n        var getDFx = function getDFx(point, edges) {\n          var sum = 0;\n          for (var _i3 = 0; _i3 < edges.length; _i3++) {\n            if (referenceNodes[edges[_i3].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;\n              sum -= C2 * Math.pow(a * a + C2, -1.5);\n            }\n          }\n          return sum;\n        };\n\n        var getGuess = function getGuess(iterations, edges) {\n          var guess = _this3.direction.getPosition(node);\n          // Newton's method for optimization\n          var guessMap = {};\n          for (var _i4 = 0; _i4 < iterations; _i4++) {\n            var fx = getFx(guess, edges);\n            var dfx = getDFx(guess, edges);\n\n            // we limit the movement to avoid instability.\n            var limit = 40;\n            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));\n            guess = guess - ratio;\n            // reduce duplicates\n            if (guessMap[guess] !== undefined) {\n              break;\n            }\n            guessMap[guess] = _i4;\n          }\n          return guess;\n        };\n\n        var moveBranch = function moveBranch(guess) {\n          // position node if there is space\n          var nodePosition = _this3.direction.getPosition(node);\n\n          // check movable area of the branch\n          if (branches[node.id] === undefined) {\n            var branchNodes = {};\n            getBranchNodes(node, branchNodes);\n            branches[node.id] = branchNodes;\n          }\n          var branchBoundary = getBranchBoundary(branches[node.id]);\n          var minSpaceBranch = branchBoundary[2];\n          var maxSpaceBranch = branchBoundary[3];\n\n          var diff = guess - nodePosition;\n\n          // check if we are allowed to move the node:\n          var branchOffset = 0;\n          if (diff > 0) {\n            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          } else if (diff < 0) {\n            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          }\n\n          if (branchOffset != 0) {\n            //console.log(\"moving branch:\",branchOffset, maxSpaceBranch, minSpaceBranch)\n            _this3._shiftBlock(node.id, branchOffset);\n            //this.body.emitter.emit(\"_redraw\");\n            stillShifting = true;\n          }\n        };\n\n        var moveNode = function moveNode(guess) {\n          var nodePosition = _this3.direction.getPosition(node);\n\n          // position node if there is space\n\n          var _getSpaceAroundNode4 = _this3._getSpaceAroundNode(node),\n              _getSpaceAroundNode5 = (0, _slicedToArray3['default'])(_getSpaceAroundNode4, 2),\n              minSpace = _getSpaceAroundNode5[0],\n              maxSpace = _getSpaceAroundNode5[1];\n\n          var diff = guess - nodePosition;\n          // check if we are allowed to move the node:\n          var newPosition = nodePosition;\n          if (diff > 0) {\n            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          } else if (diff < 0) {\n            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          }\n\n          if (newPosition !== nodePosition) {\n            //console.log(\"moving Node:\",diff, minSpace, maxSpace);\n            _this3.direction.setPosition(node, newPosition);\n            //this.body.emitter.emit(\"_redraw\");\n            stillShifting = true;\n          }\n        };\n\n        var guess = getGuess(iterations, aboveEdges);\n        moveBranch(guess);\n        guess = getGuess(iterations, allEdges);\n        moveNode(guess);\n        //})\n      };\n\n      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = levels.reverse();\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          for (var j = 0; j < levels.length; j++) {\n            var level = levels[j];\n            var levelNodes = _this3.hierarchical.distributionOrdering[level];\n            for (var k = 0; k < levelNodes.length; k++) {\n              minimizeEdgeLength(1000, levelNodes[k]);\n            }\n          }\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED minimizeEdgeLengthBottomUp IN \" + i);\n            break;\n          }\n        }\n      };\n\n      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = levels.reverse();\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          shiftElementsCloser(branchShiftCallback, levels, true);\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED shiftBranchesCloserBottomUp IN \" + (i+1));\n            break;\n          }\n        }\n      };\n\n      // center all parents\n      var centerAllParents = function centerAllParents() {\n        for (var nodeId in _this3.body.nodes) {\n          if (_this3.body.nodes.hasOwnProperty(nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);\n        }\n      };\n\n      // center all parents\n      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {\n        var levels = _this3.hierarchical.getLevels();\n        levels = levels.reverse();\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = _this3.hierarchical.distributionOrdering[level];\n          for (var j = 0; j < levelNodes.length; j++) {\n            _this3._centerParent(levelNodes[j]);\n          }\n        }\n      };\n\n      // the actual work is done here.\n      if (this.options.hierarchical.blockShifting === true) {\n        shiftBranchesCloserBottomUp(5);\n        centerAllParents();\n      }\n\n      // minimize edge length\n      if (this.options.hierarchical.edgeMinimization === true) {\n        minimizeEdgeLengthBottomUp(20);\n      }\n\n      if (this.options.hierarchical.parentCentralization === true) {\n        centerAllParentsBottomUp();\n      }\n\n      shiftTrees();\n    }\n\n    /**\n     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.\n     * This is used to only get the distances to nodes outside of a branch.\n     * @param {Node} node\n     * @param {{Node.id: vis.Node}} map\n     * @returns {number[]}\n     * @private\n     */\n\n  }, {\n    key: '_getSpaceAroundNode',\n    value: function _getSpaceAroundNode(node, map) {\n      var useMap = true;\n      if (map === undefined) {\n        useMap = false;\n      }\n      var level = this.hierarchical.levels[node.id];\n      if (level !== undefined) {\n        var index = this.hierarchical.distributionIndex[node.id];\n        var position = this.direction.getPosition(node);\n        var ordering = this.hierarchical.distributionOrdering[level];\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        if (index !== 0) {\n          var prevNode = ordering[index - 1];\n          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {\n            var prevPos = this.direction.getPosition(prevNode);\n            minSpace = position - prevPos;\n          }\n        }\n\n        if (index != ordering.length - 1) {\n          var nextNode = ordering[index + 1];\n          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {\n            var nextPos = this.direction.getPosition(nextNode);\n            maxSpace = Math.min(maxSpace, nextPos - position);\n          }\n        }\n\n        return [minSpace, maxSpace];\n      } else {\n        return [0, 0];\n      }\n    }\n\n    /**\n     * We use this method to center a parent node and check if it does not cross other nodes when it does.\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: '_centerParent',\n    value: function _centerParent(node) {\n      if (this.hierarchical.parentReference[node.id]) {\n        var parents = this.hierarchical.parentReference[node.id];\n        for (var i = 0; i < parents.length; i++) {\n          var parentId = parents[i];\n          var parentNode = this.body.nodes[parentId];\n          var children = this.hierarchical.childrenReference[parentId];\n\n          if (children !== undefined) {\n            // get the range of the children\n            var newPosition = this._getCenterPosition(children);\n\n            var position = this.direction.getPosition(parentNode);\n\n            var _getSpaceAroundNode6 = this._getSpaceAroundNode(parentNode),\n                _getSpaceAroundNode7 = (0, _slicedToArray3['default'])(_getSpaceAroundNode6, 2),\n                minSpace = _getSpaceAroundNode7[0],\n                maxSpace = _getSpaceAroundNode7[1];\n\n            var diff = position - newPosition;\n            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {\n              this.direction.setPosition(parentNode, newPosition);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This function places the nodes on the canvas based on the hierarchial distribution.\n     *\n     * @param {Object} distribution | obtained by the function this._getDistribution()\n     * @private\n     */\n\n  }, {\n    key: '_placeNodesByHierarchy',\n    value: function _placeNodesByHierarchy(distribution) {\n      this.positionedNodes = {};\n      // start placing all the level 0 nodes first. Then recursively position their branches.\n      for (var level in distribution) {\n        if (distribution.hasOwnProperty(level)) {\n          // sort nodes in level by position:\n          var nodeArray = (0, _keys2['default'])(distribution[level]);\n          nodeArray = this._indexArrayToNodes(nodeArray);\n          this.direction.sort(nodeArray);\n          var handledNodeCount = 0;\n\n          for (var i = 0; i < nodeArray.length; i++) {\n            var node = nodeArray[i];\n            if (this.positionedNodes[node.id] === undefined) {\n              var spacing = this.options.hierarchical.nodeSpacing;\n              var pos = spacing * handledNodeCount;\n              // We get the X or Y values we need and store them in pos and previousPos.\n              // The get and set make sure we get X or Y\n              if (handledNodeCount > 0) {\n                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;\n              }\n              this.direction.setPosition(node, pos, level);\n              this._validatePositionAndContinue(node, level, pos);\n\n              handledNodeCount++;\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes\n     * on a X position that ensures there will be no overlap.\n     *\n     * @param {Node.id} parentId\n     * @param {number} parentLevel\n     * @private\n     */\n\n  }, {\n    key: '_placeBranchNodes',\n    value: function _placeBranchNodes(parentId, parentLevel) {\n      var childRef = this.hierarchical.childrenReference[parentId];\n\n      // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.\n      if (childRef === undefined) {\n        return;\n      }\n\n      // get a list of childNodes\n      var childNodes = [];\n      for (var i = 0; i < childRef.length; i++) {\n        childNodes.push(this.body.nodes[childRef[i]]);\n      }\n\n      // use the positions to order the nodes.\n      this.direction.sort(childNodes);\n\n      // position the childNodes\n      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {\n        var childNode = childNodes[_i5];\n        var childNodeLevel = this.hierarchical.levels[childNode.id];\n        // check if the child node is below the parent node and if it has already been positioned.\n        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {\n          // get the amount of space required for this node. If parent the width is based on the amount of children.\n          var spacing = this.options.hierarchical.nodeSpacing;\n          var pos = void 0;\n\n          // we get the X or Y values we need and store them in pos and previousPos.\n          // The get and set make sure we get X or Y\n          if (_i5 === 0) {\n            pos = this.direction.getPosition(this.body.nodes[parentId]);\n          } else {\n            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;\n          }\n          this.direction.setPosition(childNode, pos, childNodeLevel);\n          this._validatePositionAndContinue(childNode, childNodeLevel, pos);\n        } else {\n          return;\n        }\n      }\n\n      // center the parent nodes.\n      var center = this._getCenterPosition(childNodes);\n      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);\n    }\n\n    /**\n     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.\n     * Finally it will call _placeBranchNodes to place the branch nodes.\n     * @param {Node} node\n     * @param {number} level\n     * @param {number} pos\n     * @private\n     */\n\n  }, {\n    key: '_validatePositionAndContinue',\n    value: function _validatePositionAndContinue(node, level, pos) {\n      // This method only works for formal trees and formal forests\n      // Early exit if this is not the case\n      if (!this.hierarchical.isTree) return;\n\n      // if overlap has been detected, we shift the branch\n      if (this.lastNodeOnLevel[level] !== undefined) {\n        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);\n        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {\n          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;\n          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);\n          this._shiftBlock(sharedParent.withChild, diff);\n        }\n      }\n\n      this.lastNodeOnLevel[level] = node.id; // store change in position.\n      this.positionedNodes[node.id] = true;\n      this._placeBranchNodes(node.id, level);\n    }\n\n    /**\n     * Receives an array with node indices and returns an array with the actual node references.\n     * Used for sorting based on node properties.\n     * @param {Array.<Node.id>} idArray\n     * @returns {Array.<Node>}\n     */\n\n  }, {\n    key: '_indexArrayToNodes',\n    value: function _indexArrayToNodes(idArray) {\n      var array = [];\n      for (var i = 0; i < idArray.length; i++) {\n        array.push(this.body.nodes[idArray[i]]);\n      }\n      return array;\n    }\n\n    /**\n     * This function get the distribution of levels based on hubsize\n     *\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: '_getDistribution',\n    value: function _getDistribution() {\n      var distribution = {};\n      var nodeId = void 0,\n          node = void 0;\n\n      // we fix Y because the hierarchy is vertical,\n      // we fix X so we do not give a node an x position for a second time.\n      // the fix of X is removed after the x value has been set.\n      for (nodeId in this.body.nodes) {\n        if (this.body.nodes.hasOwnProperty(nodeId)) {\n          node = this.body.nodes[nodeId];\n          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];\n          this.direction.fix(node, level);\n          if (distribution[level] === undefined) {\n            distribution[level] = {};\n          }\n          distribution[level][nodeId] = node;\n        }\n      }\n      return distribution;\n    }\n\n    /**\n     * Return the active (i.e. visible) edges for this node\n     *\n     * @param {Node} node\n     * @returns {Array.<vis.Edge>} Array of edge instances\n     * @private\n     */\n\n  }, {\n    key: '_getActiveEdges',\n    value: function _getActiveEdges(node) {\n      var _this4 = this;\n\n      var result = [];\n\n      util.forEach(node.edges, function (edge) {\n        if (_this4.body.edgeIndices.indexOf(edge.id) !== -1) {\n          result.push(edge);\n        }\n      });\n\n      return result;\n    }\n\n    /**\n     * Get the hubsizes for all active nodes.\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_getHubSizes',\n    value: function _getHubSizes() {\n      var _this5 = this;\n\n      var hubSizes = {};\n      var nodeIds = this.body.nodeIndices;\n\n      util.forEach(nodeIds, function (nodeId) {\n        var node = _this5.body.nodes[nodeId];\n        var hubSize = _this5._getActiveEdges(node).length;\n        hubSizes[hubSize] = true;\n      });\n\n      // Make an array of the size sorted descending\n      var result = [];\n      util.forEach(hubSizes, function (size) {\n        result.push(Number(size));\n      });\n\n      TimSort.sort(result, function (a, b) {\n        return b - a;\n      });\n\n      return result;\n    }\n\n    /**\n     * this function allocates nodes in levels based on the recursive branching from the largest hubs.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_determineLevelsByHubsize',\n    value: function _determineLevelsByHubsize() {\n      var _this6 = this;\n\n      var levelDownstream = function levelDownstream(nodeA, nodeB) {\n        _this6.hierarchical.levelDownstream(nodeA, nodeB);\n      };\n\n      var hubSizes = this._getHubSizes();\n\n      var _loop = function _loop(i) {\n        var hubSize = hubSizes[i];\n        if (hubSize === 0) return 'break';\n\n        util.forEach(_this6.body.nodeIndices, function (nodeId) {\n          var node = _this6.body.nodes[nodeId];\n\n          if (hubSize === _this6._getActiveEdges(node).length) {\n            _this6._crawlNetwork(levelDownstream, nodeId);\n          }\n        });\n      };\n\n      for (var i = 0; i < hubSizes.length; ++i) {\n        var _ret = _loop(i);\n\n        if (_ret === 'break') break;\n      }\n    }\n\n    /**\n     * TODO: release feature\n     * TODO: Determine if this feature is needed at all\n     *\n     * @private\n     */\n\n  }, {\n    key: '_determineLevelsCustomCallback',\n    value: function _determineLevelsCustomCallback() {\n      var _this7 = this;\n\n      var minLevel = 100000;\n\n      // TODO: this should come from options.\n      // eslint-disable-next-line no-unused-vars\n      var customCallback = function customCallback(nodeA, nodeB, edge) {};\n\n      // TODO: perhaps move to HierarchicalStatus.\n      //       But I currently don't see the point, this method is not used.\n      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {\n        var levelA = _this7.hierarchical.levels[nodeA.id];\n        // set initial level\n        if (levelA === undefined) {\n          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;\n        }\n\n        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, 'node'), NetworkUtil.cloneOptions(nodeB, 'node'), NetworkUtil.cloneOptions(edge, 'edge'));\n\n        _this7.hierarchical.levels[nodeB.id] = levelA + diff;\n      };\n\n      this._crawlNetwork(levelByDirection);\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n\n    /**\n     * Allocate nodes in levels based on the direction of the edges.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_determineLevelsDirected',\n    value: function _determineLevelsDirected() {\n      var _this8 = this;\n\n      var minLevel = 10000;\n\n      /**\n       * Check if there is an edge going the opposite direction for given edge\n       *\n       * @param {Edge} edge  edge to check\n       * @returns {boolean} true if there's another edge going into the opposite direction\n       */\n      var isBidirectional = function isBidirectional(edge) {\n        util.forEach(_this8.body.edges, function (otherEdge) {\n          if (otherEdge.toId === edge.fromId && otherEdge.fromId === edge.toId) {\n            return true;\n          }\n        });\n\n        return false;\n      };\n\n      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {\n        var levelA = _this8.hierarchical.levels[nodeA.id];\n        var levelB = _this8.hierarchical.levels[nodeB.id];\n\n        if (isBidirectional(edge) && levelA !== undefined && levelB !== undefined) {\n          // Don't redo the level determination if already done in this case.\n          return;\n        }\n\n        // set initial level\n        if (levelA === undefined) {\n          levelA = _this8.hierarchical.levels[nodeA.id] = minLevel;\n        }\n        if (edge.toId == nodeB.id) {\n          _this8.hierarchical.levels[nodeB.id] = levelA + 1;\n        } else {\n          _this8.hierarchical.levels[nodeB.id] = levelA - 1;\n        }\n      };\n\n      this._crawlNetwork(levelByDirection);\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n\n    /**\n     * Update the bookkeeping of parent and child.\n     * @private\n     */\n\n  }, {\n    key: '_generateMap',\n    value: function _generateMap() {\n      var _this9 = this;\n\n      var fillInRelations = function fillInRelations(parentNode, childNode) {\n        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {\n          _this9.hierarchical.addRelation(parentNode.id, childNode.id);\n        }\n      };\n\n      this._crawlNetwork(fillInRelations);\n      this.hierarchical.checkIfTree();\n    }\n\n    /**\n     * Crawl over the entire network and use a callback on each node couple that is connected to each other.\n     * @param {function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.\n     * @param {Node.id} startingNodeId\n     * @private\n     */\n\n  }, {\n    key: '_crawlNetwork',\n    value: function _crawlNetwork() {\n      var _this10 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      var startingNodeId = arguments[1];\n\n      var progress = {};\n\n      var crawler = function crawler(node, tree) {\n        if (progress[node.id] === undefined) {\n          _this10.hierarchical.setTreeIndex(node, tree);\n\n          progress[node.id] = true;\n          var childNode = void 0;\n          var edges = _this10._getActiveEdges(node);\n          for (var i = 0; i < edges.length; i++) {\n            var edge = edges[i];\n            if (edge.connected === true) {\n              if (edge.toId == node.id) {\n                // Not '===' because id's can be string and numeric\n                childNode = edge.from;\n              } else {\n                childNode = edge.to;\n              }\n\n              if (node.id != childNode.id) {\n                // Not '!==' because id's can be string and numeric\n                callback(node, childNode, edge);\n                crawler(childNode, tree);\n              }\n            }\n          }\n        }\n      };\n\n      if (startingNodeId === undefined) {\n        // Crawl over all nodes\n        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree\n\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          var nodeId = this.body.nodeIndices[i];\n\n          if (progress[nodeId] === undefined) {\n            var node = this.body.nodes[nodeId];\n            crawler(node, treeIndex);\n            treeIndex += 1;\n          }\n        }\n      } else {\n        // Crawl from the given starting node\n        var _node2 = this.body.nodes[startingNodeId];\n        if (_node2 === undefined) {\n          console.error('Node not found:', startingNodeId);\n          return;\n        }\n        crawler(_node2);\n      }\n    }\n\n    /**\n     * Shift a branch a certain distance\n     * @param {Node.id} parentId\n     * @param {number} diff\n     * @private\n     */\n\n  }, {\n    key: '_shiftBlock',\n    value: function _shiftBlock(parentId, diff) {\n      var _this11 = this;\n\n      var progress = {};\n      var shifter = function shifter(parentId) {\n        if (progress[parentId]) {\n          return;\n        }\n        progress[parentId] = true;\n        _this11.direction.shift(parentId, diff);\n\n        var childRef = _this11.hierarchical.childrenReference[parentId];\n        if (childRef !== undefined) {\n          for (var i = 0; i < childRef.length; i++) {\n            shifter(childRef[i]);\n          }\n        }\n      };\n      shifter(parentId);\n    }\n\n    /**\n     * Find a common parent between branches.\n     * @param {Node.id} childA\n     * @param {Node.id} childB\n     * @returns {{foundParent, withChild}}\n     * @private\n     */\n\n  }, {\n    key: '_findCommonParent',\n    value: function _findCommonParent(childA, childB) {\n      var _this12 = this;\n\n      var parents = {};\n      var iterateParents = function iterateParents(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n            parents[parent] = true;\n            iterateParents(parents, parent);\n          }\n        }\n      };\n      var findParent = function findParent(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n            if (parents[parent] !== undefined) {\n              return { foundParent: parent, withChild: child };\n            }\n            var branch = findParent(parents, parent);\n            if (branch.foundParent !== null) {\n              return branch;\n            }\n          }\n        }\n        return { foundParent: null, withChild: child };\n      };\n\n      iterateParents(parents, childA);\n      return findParent(parents, childB);\n    }\n\n    /**\n     * Set the strategy pattern for handling the coordinates given the current direction.\n     *\n     * The individual instances contain all the operations and data specific to a layout direction.\n     *\n     * @param {Node} node\n     * @param {{x: number, y: number}} position\n     * @param {number} level\n     * @param {boolean} [doNotUpdate=false]\n     * @private\n     */\n\n  }, {\n    key: 'setDirectionStrategy',\n    value: function setDirectionStrategy() {\n      var isVertical = this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU';\n\n      if (isVertical) {\n        this.direction = new VerticalStrategy(this);\n      } else {\n        this.direction = new HorizontalStrategy(this);\n      }\n    }\n\n    /**\n     * Determine the center position of a branch from the passed list of child nodes\n     *\n     * This takes into account the positions of all the child nodes.\n     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's\n     * @return {number}\n     * @private\n     */\n\n  }, {\n    key: '_getCenterPosition',\n    value: function _getCenterPosition(childNodes) {\n      var minPos = 1e9;\n      var maxPos = -1e9;\n\n      for (var i = 0; i < childNodes.length; i++) {\n        var childNode = void 0;\n        if (childNodes[i].id !== undefined) {\n          childNode = childNodes[i];\n        } else {\n          var childNodeId = childNodes[i];\n          childNode = this.body.nodes[childNodeId];\n        }\n\n        var position = this.direction.getPosition(childNode);\n        minPos = Math.min(minPos, position);\n        maxPos = Math.max(maxPos, position);\n      }\n\n      return 0.5 * (minPos + maxPos);\n    }\n  }]);\n  return LayoutEngine;\n}();\n\nexports['default'] = LayoutEngine;\n\n/***/ }),\n/* 188 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/****\n * The MIT License\n *\n * Copyright (c) 2015 Marco Ziccardi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n ****/\n(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (exports) {\n  'use strict';\n\n  exports.__esModule = true;\n  exports.sort = sort;\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  var DEFAULT_MIN_MERGE = 32;\n\n  var DEFAULT_MIN_GALLOPING = 7;\n\n  var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n  var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];\n\n  function log10(x) {\n    if (x < 1e5) {\n      if (x < 1e2) {\n        return x < 1e1 ? 0 : 1;\n      }\n\n      if (x < 1e4) {\n        return x < 1e3 ? 2 : 3;\n      }\n\n      return 4;\n    }\n\n    if (x < 1e7) {\n      return x < 1e6 ? 5 : 6;\n    }\n\n    if (x < 1e9) {\n      return x < 1e8 ? 7 : 8;\n    }\n\n    return 9;\n  }\n\n  function alphabeticalCompare(a, b) {\n    if (a === b) {\n      return 0;\n    }\n\n    if (~ ~a === a && ~ ~b === b) {\n      if (a === 0 || b === 0) {\n        return a < b ? -1 : 1;\n      }\n\n      if (a < 0 || b < 0) {\n        if (b >= 0) {\n          return -1;\n        }\n\n        if (a >= 0) {\n          return 1;\n        }\n\n        a = -a;\n        b = -b;\n      }\n\n      var al = log10(a);\n      var bl = log10(b);\n\n      var t = 0;\n\n      if (al < bl) {\n        a *= POWERS_OF_TEN[bl - al - 1];\n        b /= 10;\n        t = -1;\n      } else if (al > bl) {\n        b *= POWERS_OF_TEN[al - bl - 1];\n        a /= 10;\n        t = 1;\n      }\n\n      if (a === b) {\n        return t;\n      }\n\n      return a < b ? -1 : 1;\n    }\n\n    var aStr = String(a);\n    var bStr = String(b);\n\n    if (aStr === bStr) {\n      return 0;\n    }\n\n    return aStr < bStr ? -1 : 1;\n  }\n\n  function minRunLength(n) {\n    var r = 0;\n\n    while (n >= DEFAULT_MIN_MERGE) {\n      r |= n & 1;\n      n >>= 1;\n    }\n\n    return n + r;\n  }\n\n  function makeAscendingRun(array, lo, hi, compare) {\n    var runHi = lo + 1;\n\n    if (runHi === hi) {\n      return 1;\n    }\n\n    if (compare(array[runHi++], array[lo]) < 0) {\n      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n        runHi++;\n      }\n\n      reverseRun(array, lo, runHi);\n    } else {\n      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n        runHi++;\n      }\n    }\n\n    return runHi - lo;\n  }\n\n  function reverseRun(array, lo, hi) {\n    hi--;\n\n    while (lo < hi) {\n      var t = array[lo];\n      array[lo++] = array[hi];\n      array[hi--] = t;\n    }\n  }\n\n  function binaryInsertionSort(array, lo, hi, start, compare) {\n    if (start === lo) {\n      start++;\n    }\n\n    for (; start < hi; start++) {\n      var pivot = array[start];\n\n      var left = lo;\n      var right = start;\n\n      while (left < right) {\n        var mid = left + right >>> 1;\n\n        if (compare(pivot, array[mid]) < 0) {\n          right = mid;\n        } else {\n          left = mid + 1;\n        }\n      }\n\n      var n = start - left;\n\n      switch (n) {\n        case 3:\n          array[left + 3] = array[left + 2];\n\n        case 2:\n          array[left + 2] = array[left + 1];\n\n        case 1:\n          array[left + 1] = array[left];\n          break;\n        default:\n          while (n > 0) {\n            array[left + n] = array[left + n - 1];\n            n--;\n          }\n      }\n\n      array[left] = pivot;\n    }\n  }\n\n  function gallopLeft(value, array, start, length, hint, compare) {\n    var lastOffset = 0;\n    var maxOffset = 0;\n    var offset = 1;\n\n    if (compare(value, array[start + hint]) > 0) {\n      maxOffset = length - hint;\n\n      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n        lastOffset = offset;\n        offset = (offset << 1) + 1;\n\n        if (offset <= 0) {\n          offset = maxOffset;\n        }\n      }\n\n      if (offset > maxOffset) {\n        offset = maxOffset;\n      }\n\n      lastOffset += hint;\n      offset += hint;\n    } else {\n      maxOffset = hint + 1;\n      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n        lastOffset = offset;\n        offset = (offset << 1) + 1;\n\n        if (offset <= 0) {\n          offset = maxOffset;\n        }\n      }\n      if (offset > maxOffset) {\n        offset = maxOffset;\n      }\n\n      var tmp = lastOffset;\n      lastOffset = hint - offset;\n      offset = hint - tmp;\n    }\n\n    lastOffset++;\n    while (lastOffset < offset) {\n      var m = lastOffset + (offset - lastOffset >>> 1);\n\n      if (compare(value, array[start + m]) > 0) {\n        lastOffset = m + 1;\n      } else {\n        offset = m;\n      }\n    }\n    return offset;\n  }\n\n  function gallopRight(value, array, start, length, hint, compare) {\n    var lastOffset = 0;\n    var maxOffset = 0;\n    var offset = 1;\n\n    if (compare(value, array[start + hint]) < 0) {\n      maxOffset = hint + 1;\n\n      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n        lastOffset = offset;\n        offset = (offset << 1) + 1;\n\n        if (offset <= 0) {\n          offset = maxOffset;\n        }\n      }\n\n      if (offset > maxOffset) {\n        offset = maxOffset;\n      }\n\n      var tmp = lastOffset;\n      lastOffset = hint - offset;\n      offset = hint - tmp;\n    } else {\n      maxOffset = length - hint;\n\n      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n        lastOffset = offset;\n        offset = (offset << 1) + 1;\n\n        if (offset <= 0) {\n          offset = maxOffset;\n        }\n      }\n\n      if (offset > maxOffset) {\n        offset = maxOffset;\n      }\n\n      lastOffset += hint;\n      offset += hint;\n    }\n\n    lastOffset++;\n\n    while (lastOffset < offset) {\n      var m = lastOffset + (offset - lastOffset >>> 1);\n\n      if (compare(value, array[start + m]) < 0) {\n        offset = m;\n      } else {\n        lastOffset = m + 1;\n      }\n    }\n\n    return offset;\n  }\n\n  var TimSort = (function () {\n    function TimSort(array, compare) {\n      _classCallCheck(this, TimSort);\n\n      this.array = null;\n      this.compare = null;\n      this.minGallop = DEFAULT_MIN_GALLOPING;\n      this.length = 0;\n      this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n      this.stackLength = 0;\n      this.runStart = null;\n      this.runLength = null;\n      this.stackSize = 0;\n\n      this.array = array;\n      this.compare = compare;\n\n      this.length = array.length;\n\n      if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n        this.tmpStorageLength = this.length >>> 1;\n      }\n\n      this.tmp = new Array(this.tmpStorageLength);\n\n      this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;\n\n      this.runStart = new Array(this.stackLength);\n      this.runLength = new Array(this.stackLength);\n    }\n\n    TimSort.prototype.pushRun = function pushRun(runStart, runLength) {\n      this.runStart[this.stackSize] = runStart;\n      this.runLength[this.stackSize] = runLength;\n      this.stackSize += 1;\n    };\n\n    TimSort.prototype.mergeRuns = function mergeRuns() {\n      while (this.stackSize > 1) {\n        var n = this.stackSize - 2;\n\n        if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {\n\n          if (this.runLength[n - 1] < this.runLength[n + 1]) {\n            n--;\n          }\n        } else if (this.runLength[n] > this.runLength[n + 1]) {\n          break;\n        }\n        this.mergeAt(n);\n      }\n    };\n\n    TimSort.prototype.forceMergeRuns = function forceMergeRuns() {\n      while (this.stackSize > 1) {\n        var n = this.stackSize - 2;\n\n        if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\n          n--;\n        }\n\n        this.mergeAt(n);\n      }\n    };\n\n    TimSort.prototype.mergeAt = function mergeAt(i) {\n      var compare = this.compare;\n      var array = this.array;\n\n      var start1 = this.runStart[i];\n      var length1 = this.runLength[i];\n      var start2 = this.runStart[i + 1];\n      var length2 = this.runLength[i + 1];\n\n      this.runLength[i] = length1 + length2;\n\n      if (i === this.stackSize - 3) {\n        this.runStart[i + 1] = this.runStart[i + 2];\n        this.runLength[i + 1] = this.runLength[i + 2];\n      }\n\n      this.stackSize--;\n\n      var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n      start1 += k;\n      length1 -= k;\n\n      if (length1 === 0) {\n        return;\n      }\n\n      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n      if (length2 === 0) {\n        return;\n      }\n\n      if (length1 <= length2) {\n        this.mergeLow(start1, length1, start2, length2);\n      } else {\n        this.mergeHigh(start1, length1, start2, length2);\n      }\n    };\n\n    TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {\n\n      var compare = this.compare;\n      var array = this.array;\n      var tmp = this.tmp;\n      var i = 0;\n\n      for (i = 0; i < length1; i++) {\n        tmp[i] = array[start1 + i];\n      }\n\n      var cursor1 = 0;\n      var cursor2 = start2;\n      var dest = start1;\n\n      array[dest++] = array[cursor2++];\n\n      if (--length2 === 0) {\n        for (i = 0; i < length1; i++) {\n          array[dest + i] = tmp[cursor1 + i];\n        }\n        return;\n      }\n\n      if (length1 === 1) {\n        for (i = 0; i < length2; i++) {\n          array[dest + i] = array[cursor2 + i];\n        }\n        array[dest + length2] = tmp[cursor1];\n        return;\n      }\n\n      var minGallop = this.minGallop;\n\n      while (true) {\n        var count1 = 0;\n        var count2 = 0;\n        var exit = false;\n\n        do {\n          if (compare(array[cursor2], tmp[cursor1]) < 0) {\n            array[dest++] = array[cursor2++];\n            count2++;\n            count1 = 0;\n\n            if (--length2 === 0) {\n              exit = true;\n              break;\n            }\n          } else {\n            array[dest++] = tmp[cursor1++];\n            count1++;\n            count2 = 0;\n            if (--length1 === 1) {\n              exit = true;\n              break;\n            }\n          }\n        } while ((count1 | count2) < minGallop);\n\n        if (exit) {\n          break;\n        }\n\n        do {\n          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n          if (count1 !== 0) {\n            for (i = 0; i < count1; i++) {\n              array[dest + i] = tmp[cursor1 + i];\n            }\n\n            dest += count1;\n            cursor1 += count1;\n            length1 -= count1;\n            if (length1 <= 1) {\n              exit = true;\n              break;\n            }\n          }\n\n          array[dest++] = array[cursor2++];\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n\n          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n          if (count2 !== 0) {\n            for (i = 0; i < count2; i++) {\n              array[dest + i] = array[cursor2 + i];\n            }\n\n            dest += count2;\n            cursor2 += count2;\n            length2 -= count2;\n\n            if (length2 === 0) {\n              exit = true;\n              break;\n            }\n          }\n          array[dest++] = tmp[cursor1++];\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n\n          minGallop--;\n        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n        if (exit) {\n          break;\n        }\n\n        if (minGallop < 0) {\n          minGallop = 0;\n        }\n\n        minGallop += 2;\n      }\n\n      this.minGallop = minGallop;\n\n      if (minGallop < 1) {\n        this.minGallop = 1;\n      }\n\n      if (length1 === 1) {\n        for (i = 0; i < length2; i++) {\n          array[dest + i] = array[cursor2 + i];\n        }\n        array[dest + length2] = tmp[cursor1];\n      } else if (length1 === 0) {\n        throw new Error('mergeLow preconditions were not respected');\n      } else {\n        for (i = 0; i < length1; i++) {\n          array[dest + i] = tmp[cursor1 + i];\n        }\n      }\n    };\n\n    TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {\n      var compare = this.compare;\n      var array = this.array;\n      var tmp = this.tmp;\n      var i = 0;\n\n      for (i = 0; i < length2; i++) {\n        tmp[i] = array[start2 + i];\n      }\n\n      var cursor1 = start1 + length1 - 1;\n      var cursor2 = length2 - 1;\n      var dest = start2 + length2 - 1;\n      var customCursor = 0;\n      var customDest = 0;\n\n      array[dest--] = array[cursor1--];\n\n      if (--length1 === 0) {\n        customCursor = dest - (length2 - 1);\n\n        for (i = 0; i < length2; i++) {\n          array[customCursor + i] = tmp[i];\n        }\n\n        return;\n      }\n\n      if (length2 === 1) {\n        dest -= length1;\n        cursor1 -= length1;\n        customDest = dest + 1;\n        customCursor = cursor1 + 1;\n\n        for (i = length1 - 1; i >= 0; i--) {\n          array[customDest + i] = array[customCursor + i];\n        }\n\n        array[dest] = tmp[cursor2];\n        return;\n      }\n\n      var minGallop = this.minGallop;\n\n      while (true) {\n        var count1 = 0;\n        var count2 = 0;\n        var exit = false;\n\n        do {\n          if (compare(tmp[cursor2], array[cursor1]) < 0) {\n            array[dest--] = array[cursor1--];\n            count1++;\n            count2 = 0;\n            if (--length1 === 0) {\n              exit = true;\n              break;\n            }\n          } else {\n            array[dest--] = tmp[cursor2--];\n            count2++;\n            count1 = 0;\n            if (--length2 === 1) {\n              exit = true;\n              break;\n            }\n          }\n        } while ((count1 | count2) < minGallop);\n\n        if (exit) {\n          break;\n        }\n\n        do {\n          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n          if (count1 !== 0) {\n            dest -= count1;\n            cursor1 -= count1;\n            length1 -= count1;\n            customDest = dest + 1;\n            customCursor = cursor1 + 1;\n\n            for (i = count1 - 1; i >= 0; i--) {\n              array[customDest + i] = array[customCursor + i];\n            }\n\n            if (length1 === 0) {\n              exit = true;\n              break;\n            }\n          }\n\n          array[dest--] = tmp[cursor2--];\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n\n          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n          if (count2 !== 0) {\n            dest -= count2;\n            cursor2 -= count2;\n            length2 -= count2;\n            customDest = dest + 1;\n            customCursor = cursor2 + 1;\n\n            for (i = 0; i < count2; i++) {\n              array[customDest + i] = tmp[customCursor + i];\n            }\n\n            if (length2 <= 1) {\n              exit = true;\n              break;\n            }\n          }\n\n          array[dest--] = array[cursor1--];\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n\n          minGallop--;\n        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n        if (exit) {\n          break;\n        }\n\n        if (minGallop < 0) {\n          minGallop = 0;\n        }\n\n        minGallop += 2;\n      }\n\n      this.minGallop = minGallop;\n\n      if (minGallop < 1) {\n        this.minGallop = 1;\n      }\n\n      if (length2 === 1) {\n        dest -= length1;\n        cursor1 -= length1;\n        customDest = dest + 1;\n        customCursor = cursor1 + 1;\n\n        for (i = length1 - 1; i >= 0; i--) {\n          array[customDest + i] = array[customCursor + i];\n        }\n\n        array[dest] = tmp[cursor2];\n      } else if (length2 === 0) {\n        throw new Error('mergeHigh preconditions were not respected');\n      } else {\n        customCursor = dest - (length2 - 1);\n        for (i = 0; i < length2; i++) {\n          array[customCursor + i] = tmp[i];\n        }\n      }\n    };\n\n    return TimSort;\n  })();\n\n  function sort(array, compare, lo, hi) {\n    if (!Array.isArray(array)) {\n      throw new TypeError('Can only sort arrays');\n    }\n\n    if (!compare) {\n      compare = alphabeticalCompare;\n    } else if (typeof compare !== 'function') {\n      hi = lo;\n      lo = compare;\n      compare = alphabeticalCompare;\n    }\n\n    if (!lo) {\n      lo = 0;\n    }\n    if (!hi) {\n      hi = array.length;\n    }\n\n    var remaining = hi - lo;\n\n    if (remaining < 2) {\n      return;\n    }\n\n    var runLength = 0;\n\n    if (remaining < DEFAULT_MIN_MERGE) {\n      runLength = makeAscendingRun(array, lo, hi, compare);\n      binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n      return;\n    }\n\n    var ts = new TimSort(array, compare);\n\n    var minRun = minRunLength(remaining);\n\n    do {\n      runLength = makeAscendingRun(array, lo, hi, compare);\n      if (runLength < minRun) {\n        var force = remaining;\n        if (force > minRun) {\n          force = minRun;\n        }\n\n        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n        runLength = force;\n      }\n\n      ts.pushRun(lo, runLength);\n      ts.mergeRuns();\n\n      remaining -= runLength;\n      lo += runLength;\n    } while (remaining !== 0);\n\n    ts.forceMergeRuns();\n  }\n});\n\n\n/***/ }),\n/* 189 */\n/***/ (function(module, exports, __nested_webpack_require_1156316__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VerticalStrategy = exports.HorizontalStrategy = undefined;\n\nvar _getPrototypeOf = __nested_webpack_require_1156316__(3);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _possibleConstructorReturn2 = __nested_webpack_require_1156316__(4);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __nested_webpack_require_1156316__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classCallCheck2 = __nested_webpack_require_1156316__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1156316__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Helper classes for LayoutEngine.\n *\n * Strategy pattern for usage of direction methods for hierarchical layouts.\n */\nvar TimSort = __nested_webpack_require_1156316__(83);\n\n/**\n * Interface definition for direction strategy classes.\n *\n * This class describes the interface for the Strategy\n * pattern classes used to differentiate horizontal and vertical\n * direction of hierarchical results.\n *\n * For a given direction, one coordinate will be 'fixed', meaning that it is\n * determined by level.\n * The other coordinate is 'unfixed', meaning that the nodes on a given level\n * can still move along that coordinate. So:\n *\n * - `vertical` layout: `x` unfixed, `y` fixed per level\n * - `horizontal` layout: `x` fixed per level, `y` unfixed\n *\n * The local methods are stubs and should be regarded as abstract.\n * Derived classes **must** implement all the methods themselves.\n *\n * @private\n */\n\nvar DirectionInterface = function () {\n  function DirectionInterface() {\n    (0, _classCallCheck3['default'])(this, DirectionInterface);\n  }\n\n  (0, _createClass3['default'])(DirectionInterface, [{\n    key: 'abstract',\n\n    /** @ignore **/\n    value: function abstract() {\n      throw new Error(\"Can't instantiate abstract class!\");\n    }\n\n    /**\n     * This is a dummy call which is used to suppress the jsdoc errors of type:\n     *\n     *   \"'param' is assigned a value but never used\"\n     *\n     * @ignore\n     **/\n\n  }, {\n    key: 'fake_use',\n    value: function fake_use() {}\n    // Do nothing special\n\n\n    /**\n     * Type to use to translate dynamic curves to, in the case of hierarchical layout.\n     * Dynamic curves do not work for these.\n     *\n     * The value should be perpendicular to the actual direction of the layout.\n     *\n     * @return {string} Direction, either 'vertical' or 'horizontal'\n     */\n\n  }, {\n    key: 'curveType',\n    value: function curveType() {\n      return this.abstract();\n    }\n\n    /**\n     * Return the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to read\n     * @return {number} Value of the unfixed coordinate\n     */\n\n  }, {\n    key: 'getPosition',\n    value: function getPosition(node) {\n      this.fake_use(node);\n      return this.abstract();\n    }\n\n    /**\n     * Set the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} position\n     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to\n     */\n\n  }, {\n    key: 'setPosition',\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      this.fake_use(node, position, level);\n      this.abstract();\n    }\n\n    /**\n     * Get the width of a tree.\n     *\n     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,\n     * only among themselves. In essence, it is a sub-network.\n     *\n     * @param {number} index The index number of a tree\n     * @return {number} the width of a tree in the view coordinates\n     */\n\n  }, {\n    key: 'getTreeSize',\n    value: function getTreeSize(index) {\n      this.fake_use(index);\n      return this.abstract();\n    }\n\n    /**\n     * Sort array of nodes on the unfixed coordinates.\n     *\n     * **Note:** chrome has non-stable sorting implementation, which\n     * has a tendency to change the order of the array items,\n     * even if the custom sort function returns 0.\n     *\n     * For this reason, an external sort implementation is used,\n     * which has the added benefit of being faster than the standard\n     * platforms implementation. This has been verified on `node.js`,\n     * `firefox` and `chrome` (all linux).\n     *\n     * @param {Array.<Node>} nodeArray array of nodes to sort\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort(nodeArray) {\n      this.fake_use(nodeArray);\n      this.abstract();\n    }\n\n    /**\n     * Assign the fixed coordinate of the node to the given level\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} level The level to fix to\n     */\n\n  }, {\n    key: 'fix',\n    value: function fix(node, level) {\n      this.fake_use(node, level);\n      this.abstract();\n    }\n\n    /**\n     * Add an offset to the unfixed coordinate of the given node.\n     *\n     * @param {NodeId} nodeId Id of the node to adjust\n     * @param {number} diff Offset to add to the unfixed coordinate\n     */\n\n  }, {\n    key: 'shift',\n    value: function shift(nodeId, diff) {\n      this.fake_use(nodeId, diff);\n      this.abstract();\n    }\n  }]);\n  return DirectionInterface;\n}();\n\n/**\n * Vertical Strategy\n *\n * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.\n *\n * @extends DirectionInterface\n * @private\n */\n\n\nvar VerticalStrategy = function (_DirectionInterface) {\n  (0, _inherits3['default'])(VerticalStrategy, _DirectionInterface);\n\n  /**\n   * Constructor\n   *\n   * @param {Object} layout reference to the parent LayoutEngine instance.\n   */\n  function VerticalStrategy(layout) {\n    (0, _classCallCheck3['default'])(this, VerticalStrategy);\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, (VerticalStrategy.__proto__ || (0, _getPrototypeOf2['default'])(VerticalStrategy)).call(this));\n\n    _this.layout = layout;\n    return _this;\n  }\n\n  /** @inheritdoc */\n\n\n  (0, _createClass3['default'])(VerticalStrategy, [{\n    key: 'curveType',\n    value: function curveType() {\n      return 'horizontal';\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'getPosition',\n    value: function getPosition(node) {\n      return node.x;\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'setPosition',\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.x = position;\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'getTreeSize',\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return { min: res.min_x, max: res.max_x };\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'sort',\n    value: function sort(nodeArray) {\n      TimSort.sort(nodeArray, function (a, b) {\n        return a.x - b.x;\n      });\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'fix',\n    value: function fix(node, level) {\n      node.y = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.y = true;\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'shift',\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].x += diff;\n    }\n  }]);\n  return VerticalStrategy;\n}(DirectionInterface);\n\n/**\n * Horizontal Strategy\n *\n * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.\n *\n * @extends DirectionInterface\n * @private\n */\n\n\nvar HorizontalStrategy = function (_DirectionInterface2) {\n  (0, _inherits3['default'])(HorizontalStrategy, _DirectionInterface2);\n\n  /**\n   * Constructor\n   *\n   * @param {Object} layout reference to the parent LayoutEngine instance.\n   */\n  function HorizontalStrategy(layout) {\n    (0, _classCallCheck3['default'])(this, HorizontalStrategy);\n\n    var _this2 = (0, _possibleConstructorReturn3['default'])(this, (HorizontalStrategy.__proto__ || (0, _getPrototypeOf2['default'])(HorizontalStrategy)).call(this));\n\n    _this2.layout = layout;\n    return _this2;\n  }\n\n  /** @inheritdoc */\n\n\n  (0, _createClass3['default'])(HorizontalStrategy, [{\n    key: 'curveType',\n    value: function curveType() {\n      return 'vertical';\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'getPosition',\n    value: function getPosition(node) {\n      return node.y;\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'setPosition',\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.y = position;\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'getTreeSize',\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return { min: res.min_y, max: res.max_y };\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'sort',\n    value: function sort(nodeArray) {\n      TimSort.sort(nodeArray, function (a, b) {\n        return a.y - b.y;\n      });\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'fix',\n    value: function fix(node, level) {\n      node.x = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.x = true;\n    }\n\n    /** @inheritdoc */\n\n  }, {\n    key: 'shift',\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].y += diff;\n    }\n  }]);\n  return HorizontalStrategy;\n}(DirectionInterface);\n\nexports.HorizontalStrategy = HorizontalStrategy;\nexports.VerticalStrategy = VerticalStrategy;\n\n/***/ }),\n/* 190 */\n/***/ (function(module, exports, __nested_webpack_require_1166276__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys = __nested_webpack_require_1166276__(9);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _stringify = __nested_webpack_require_1166276__(23);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _typeof2 = __nested_webpack_require_1166276__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _classCallCheck2 = __nested_webpack_require_1166276__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1166276__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_1166276__(2);\nvar Hammer = __nested_webpack_require_1166276__(24);\nvar hammerUtil = __nested_webpack_require_1166276__(36);\n\n/**\n * Clears the toolbar div element of children\n *\n * @private\n */\n\nvar ManipulationSystem = function () {\n  /**\n   * @param {Object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   */\n  function ManipulationSystem(body, canvas, selectionHandler) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, ManipulationSystem);\n\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n\n    this.editMode = false;\n    this.manipulationDiv = undefined;\n    this.editModeDiv = undefined;\n    this.closeDiv = undefined;\n\n    this.manipulationHammers = [];\n    this.temporaryUIFunctions = {};\n    this.temporaryEventFunctions = [];\n\n    this.touchTime = 0;\n    this.temporaryIds = { nodes: [], edges: [] };\n    this.guiEnabled = false;\n    this.inMode = false;\n    this.selectedControlNode = undefined;\n\n    this.options = {};\n    this.defaultOptions = {\n      enabled: false,\n      initiallyActive: false,\n      addNode: true,\n      addEdge: true,\n      editNode: undefined,\n      editEdge: true,\n      deleteNode: true,\n      deleteEdge: true,\n      controlNodeStyle: {\n        shape: 'dot',\n        size: 6,\n        color: {\n          background: '#ff0000',\n          border: '#3c3c3c',\n          highlight: { background: '#07f968', border: '#3c3c3c' }\n        },\n        borderWidth: 2,\n        borderWidthSelected: 2\n      }\n    };\n    util.extend(this.options, this.defaultOptions);\n\n    this.body.emitter.on('destroy', function () {\n      _this._clean();\n    });\n    this.body.emitter.on('_dataChanged', this._restore.bind(this));\n    this.body.emitter.on('_resetData', this._restore.bind(this));\n  }\n\n  /**\n   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.\n   * @private\n   */\n\n\n  (0, _createClass3['default'])(ManipulationSystem, [{\n    key: '_restore',\n    value: function _restore() {\n      if (this.inMode !== false) {\n        if (this.options.initiallyActive === true) {\n          this.enableEditMode();\n        } else {\n          this.disableEditMode();\n        }\n      }\n    }\n\n    /**\n     * Set the Options\n     *\n     * @param {Object} options\n     * @param {Object} allOptions\n     * @param {Object} globalOptions\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options, allOptions, globalOptions) {\n      if (allOptions !== undefined) {\n        if (allOptions.locale !== undefined) {\n          this.options.locale = allOptions.locale;\n        } else {\n          this.options.locale = globalOptions.locale;\n        }\n        if (allOptions.locales !== undefined) {\n          this.options.locales = allOptions.locales;\n        } else {\n          this.options.locales = globalOptions.locales;\n        }\n      }\n\n      if (options !== undefined) {\n        if (typeof options === 'boolean') {\n          this.options.enabled = options;\n        } else {\n          this.options.enabled = true;\n          util.deepExtend(this.options, options);\n        }\n        if (this.options.initiallyActive === true) {\n          this.editMode = true;\n        }\n        this._setup();\n      }\n    }\n\n    /**\n     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'toggleEditMode',\n    value: function toggleEditMode() {\n      if (this.editMode === true) {\n        this.disableEditMode();\n      } else {\n        this.enableEditMode();\n      }\n    }\n\n    /**\n     * Enables Edit Mode\n     */\n\n  }, {\n    key: 'enableEditMode',\n    value: function enableEditMode() {\n      this.editMode = true;\n\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = 'block';\n        this.closeDiv.style.display = 'block';\n        this.editModeDiv.style.display = 'none';\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * Disables Edit Mode\n     */\n\n  }, {\n    key: 'disableEditMode',\n    value: function disableEditMode() {\n      this.editMode = false;\n\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = 'none';\n        this.closeDiv.style.display = 'none';\n        this.editModeDiv.style.display = 'block';\n        this._createEditButton();\n      }\n    }\n\n    /**\n     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'showManipulatorToolbar',\n    value: function showManipulatorToolbar() {\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n\n      // reset global variables\n      this.manipulationDOM = {};\n\n      // if the gui is enabled, draw all elements.\n      if (this.guiEnabled === true) {\n        // a _restore will hide these menus\n        this.editMode = true;\n        this.manipulationDiv.style.display = 'block';\n        this.closeDiv.style.display = 'block';\n\n        var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();\n        var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();\n        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;\n        var locale = this.options.locales[this.options.locale];\n        var needSeperator = false;\n\n        if (this.options.addNode !== false) {\n          this._createAddNodeButton(locale);\n          needSeperator = true;\n        }\n        if (this.options.addEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(1);\n          } else {\n            needSeperator = true;\n          }\n          this._createAddEdgeButton(locale);\n        }\n\n        if (selectedNodeCount === 1 && typeof this.options.editNode === 'function') {\n          if (needSeperator === true) {\n            this._createSeperator(2);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditNodeButton(locale);\n        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(3);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditEdgeButton(locale);\n        }\n\n        // remove buttons\n        if (selectedTotalCount !== 0) {\n          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          }\n        }\n\n        // bind the close button\n        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));\n\n        // refresh this bar based on what has been selected\n        this._temporaryBindEvent('select', this.showManipulatorToolbar.bind(this));\n      }\n\n      // redraw to show any possible changes\n      this.body.emitter.emit('_redraw');\n    }\n\n    /**\n     * Create the toolbar for adding Nodes\n     */\n\n  }, {\n    key: 'addNodeMode',\n    value: function addNodeMode() {\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n\n      this.inMode = 'addNode';\n      if (this.guiEnabled === true) {\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale['addDescription'] || this.options.locales['en']['addDescription']);\n\n        // bind the close button\n        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));\n      }\n\n      this._temporaryBindEvent('click', this._performAddNode.bind(this));\n    }\n\n    /**\n     * call the bound function to handle the editing of the node. The node has to be selected.\n     */\n\n  }, {\n    key: 'editNode',\n    value: function editNode() {\n      var _this2 = this;\n\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      var node = this.selectionHandler._getSelectedNode();\n      if (node !== undefined) {\n        this.inMode = 'editNode';\n        if (typeof this.options.editNode === 'function') {\n          if (node.isCluster !== true) {\n            var data = util.deepExtend({}, node.options, false);\n            data.x = node.x;\n            data.y = node.y;\n\n            if (this.options.editNode.length === 2) {\n              this.options.editNode(data, function (finalizedData) {\n                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === 'editNode') {\n                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n                  _this2.body.data.nodes.getDataSet().update(finalizedData);\n                }\n                _this2.showManipulatorToolbar();\n              });\n            } else {\n              throw new Error('The function for edit does not support two arguments (data, callback)');\n            }\n          } else {\n            alert(this.options.locales[this.options.locale]['editClusterError'] || this.options.locales['en']['editClusterError']);\n          }\n        } else {\n          throw new Error('No function has been configured to handle the editing of nodes.');\n        }\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * create the toolbar to connect nodes\n     */\n\n  }, {\n    key: 'addEdgeMode',\n    value: function addEdgeMode() {\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n\n      this.inMode = 'addEdge';\n      if (this.guiEnabled === true) {\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale['edgeDescription'] || this.options.locales['en']['edgeDescription']);\n\n        // bind the close button\n        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));\n      }\n\n      // temporarily overload functions\n      this._temporaryBindUI('onTouch', this._handleConnect.bind(this));\n      this._temporaryBindUI('onDragEnd', this._finishConnect.bind(this));\n      this._temporaryBindUI('onDrag', this._dragControlNode.bind(this));\n      this._temporaryBindUI('onRelease', this._finishConnect.bind(this));\n      this._temporaryBindUI('onDragStart', this._dragStartEdge.bind(this));\n      this._temporaryBindUI('onHold', function () {});\n    }\n\n    /**\n     * create the toolbar to edit edges\n     */\n\n  }, {\n    key: 'editEdgeMode',\n    value: function editEdgeMode() {\n      // when using the gui, enable edit mode if it wasn't already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n\n      this.inMode = 'editEdge';\n      if ((0, _typeof3['default'])(this.options.editEdge) === 'object' && typeof this.options.editEdge.editWithoutDrag === 'function') {\n        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];\n        if (this.edgeBeingEditedId !== undefined) {\n          var edge = this.body.edges[this.edgeBeingEditedId];\n          this._performEditEdge(edge.from, edge.to);\n          return;\n        }\n      }\n      if (this.guiEnabled === true) {\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale['editEdgeDescription'] || this.options.locales['en']['editEdgeDescription']);\n\n        // bind the close button\n        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));\n      }\n\n      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];\n      if (this.edgeBeingEditedId !== undefined) {\n        var _edge = this.body.edges[this.edgeBeingEditedId];\n\n        // create control nodes\n        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);\n        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);\n\n        this.temporaryIds.nodes.push(controlNodeFrom.id);\n        this.temporaryIds.nodes.push(controlNodeTo.id);\n\n        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;\n        this.body.nodeIndices.push(controlNodeFrom.id);\n        this.body.nodes[controlNodeTo.id] = controlNodeTo;\n        this.body.nodeIndices.push(controlNodeTo.id);\n\n        // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI\n        this._temporaryBindUI('onTouch', this._controlNodeTouch.bind(this)); // used to get the position\n        this._temporaryBindUI('onTap', function () {}); // disabled\n        this._temporaryBindUI('onHold', function () {}); // disabled\n        this._temporaryBindUI('onDragStart', this._controlNodeDragStart.bind(this)); // used to select control node\n        this._temporaryBindUI('onDrag', this._controlNodeDrag.bind(this)); // used to drag control node\n        this._temporaryBindUI('onDragEnd', this._controlNodeDragEnd.bind(this)); // used to connect or revert control nodes\n        this._temporaryBindUI('onMouseMove', function () {}); // disabled\n\n        // create function to position control nodes correctly on movement\n        // automatically cleaned up because we use the temporary bind\n        this._temporaryBindEvent('beforeDrawing', function (ctx) {\n          var positions = _edge.edgeType.findBorderPositions(ctx);\n          if (controlNodeFrom.selected === false) {\n            controlNodeFrom.x = positions.from.x;\n            controlNodeFrom.y = positions.from.y;\n          }\n          if (controlNodeTo.selected === false) {\n            controlNodeTo.x = positions.to.x;\n            controlNodeTo.y = positions.to.y;\n          }\n        });\n\n        this.body.emitter.emit('_redraw');\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * delete everything in the selection\n     */\n\n  }, {\n    key: 'deleteSelected',\n    value: function deleteSelected() {\n      var _this3 = this;\n\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n\n      this.inMode = 'delete';\n      var selectedNodes = this.selectionHandler.getSelectedNodes();\n      var selectedEdges = this.selectionHandler.getSelectedEdges();\n      var deleteFunction = undefined;\n      if (selectedNodes.length > 0) {\n        for (var i = 0; i < selectedNodes.length; i++) {\n          if (this.body.nodes[selectedNodes[i]].isCluster === true) {\n            alert(this.options.locales[this.options.locale]['deleteClusterError'] || this.options.locales['en']['deleteClusterError']);\n            return;\n          }\n        }\n\n        if (typeof this.options.deleteNode === 'function') {\n          deleteFunction = this.options.deleteNode;\n        }\n      } else if (selectedEdges.length > 0) {\n        if (typeof this.options.deleteEdge === 'function') {\n          deleteFunction = this.options.deleteEdge;\n        }\n      }\n\n      if (typeof deleteFunction === 'function') {\n        var data = { nodes: selectedNodes, edges: selectedEdges };\n        if (deleteFunction.length === 2) {\n          deleteFunction(data, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === 'delete') {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);\n              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);\n              _this3.body.emitter.emit('startSimulation');\n              _this3.showManipulatorToolbar();\n            } else {\n              _this3.body.emitter.emit('startSimulation');\n              _this3.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error('The function for delete does not support two arguments (data, callback)');\n        }\n      } else {\n        this.body.data.edges.getDataSet().remove(selectedEdges);\n        this.body.data.nodes.getDataSet().remove(selectedNodes);\n        this.body.emitter.emit('startSimulation');\n        this.showManipulatorToolbar();\n      }\n    }\n\n    //********************************************** PRIVATE ***************************************//\n\n    /**\n     * draw or remove the DOM\n     * @private\n     */\n\n  }, {\n    key: '_setup',\n    value: function _setup() {\n      if (this.options.enabled === true) {\n        // Enable the GUI\n        this.guiEnabled = true;\n\n        this._createWrappers();\n        if (this.editMode === false) {\n          this._createEditButton();\n        } else {\n          this.showManipulatorToolbar();\n        }\n      } else {\n        this._removeManipulationDOM();\n\n        // disable the gui\n        this.guiEnabled = false;\n      }\n    }\n\n    /**\n     * create the div overlays that contain the DOM\n     * @private\n     */\n\n  }, {\n    key: '_createWrappers',\n    value: function _createWrappers() {\n      // load the manipulator HTML elements. All styling done in css.\n      if (this.manipulationDiv === undefined) {\n        this.manipulationDiv = document.createElement('div');\n        this.manipulationDiv.className = 'vis-manipulation';\n        if (this.editMode === true) {\n          this.manipulationDiv.style.display = 'block';\n        } else {\n          this.manipulationDiv.style.display = 'none';\n        }\n        this.canvas.frame.appendChild(this.manipulationDiv);\n      }\n\n      // container for the edit button.\n      if (this.editModeDiv === undefined) {\n        this.editModeDiv = document.createElement('div');\n        this.editModeDiv.className = 'vis-edit-mode';\n        if (this.editMode === true) {\n          this.editModeDiv.style.display = 'none';\n        } else {\n          this.editModeDiv.style.display = 'block';\n        }\n        this.canvas.frame.appendChild(this.editModeDiv);\n      }\n\n      // container for the close div button\n      if (this.closeDiv === undefined) {\n        this.closeDiv = document.createElement('div');\n        this.closeDiv.className = 'vis-close';\n        this.closeDiv.style.display = this.manipulationDiv.style.display;\n        this.canvas.frame.appendChild(this.closeDiv);\n      }\n    }\n\n    /**\n     * generate a new target node. Used for creating new edges and editing edges\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {Node}\n     * @private\n     */\n\n  }, {\n    key: '_getNewTargetNode',\n    value: function _getNewTargetNode(x, y) {\n      var controlNodeStyle = util.deepExtend({}, this.options.controlNodeStyle);\n\n      controlNodeStyle.id = 'targetNode' + util.randomUUID();\n      controlNodeStyle.hidden = false;\n      controlNodeStyle.physics = false;\n      controlNodeStyle.x = x;\n      controlNodeStyle.y = y;\n\n      // we have to define the bounding box in order for the nodes to be drawn immediately\n      var node = this.body.functions.createNode(controlNodeStyle);\n      node.shape.boundingBox = { left: x, right: x, top: y, bottom: y };\n\n      return node;\n    }\n\n    /**\n     * Create the edit button\n     */\n\n  }, {\n    key: '_createEditButton',\n    value: function _createEditButton() {\n      // restore everything to it's original state (if applicable)\n      this._clean();\n\n      // reset the manipulationDOM\n      this.manipulationDOM = {};\n\n      // empty the editModeDiv\n      util.recursiveDOMDelete(this.editModeDiv);\n\n      // create the contents for the editMode button\n      var locale = this.options.locales[this.options.locale];\n      var button = this._createButton('editMode', 'vis-button vis-edit vis-edit-mode', locale['edit'] || this.options.locales['en']['edit']);\n      this.editModeDiv.appendChild(button);\n\n      // bind a hammer listener to the button, calling the function toggleEditMode.\n      this._bindHammerToDiv(button, this.toggleEditMode.bind(this));\n    }\n\n    /**\n     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.\n     * @private\n     */\n\n  }, {\n    key: '_clean',\n    value: function _clean() {\n      // not in mode\n      this.inMode = false;\n\n      // _clean the divs\n      if (this.guiEnabled === true) {\n        util.recursiveDOMDelete(this.editModeDiv);\n        util.recursiveDOMDelete(this.manipulationDiv);\n\n        // removes all the bindings and overloads\n        this._cleanManipulatorHammers();\n      }\n\n      // remove temporary nodes and edges\n      this._cleanupTemporaryNodesAndEdges();\n\n      // restore overloaded UI functions\n      this._unbindTemporaryUIs();\n\n      // remove the temporaryEventFunctions\n      this._unbindTemporaryEvents();\n\n      // restore the physics if required\n      this.body.emitter.emit('restorePhysics');\n    }\n\n    /**\n     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.\n     * @private\n     */\n\n  }, {\n    key: '_cleanManipulatorHammers',\n    value: function _cleanManipulatorHammers() {\n      // _clean hammer bindings\n      if (this.manipulationHammers.length != 0) {\n        for (var i = 0; i < this.manipulationHammers.length; i++) {\n          this.manipulationHammers[i].destroy();\n        }\n        this.manipulationHammers = [];\n      }\n    }\n\n    /**\n     * Remove all DOM elements created by this module.\n     * @private\n     */\n\n  }, {\n    key: '_removeManipulationDOM',\n    value: function _removeManipulationDOM() {\n      // removes all the bindings and overloads\n      this._clean();\n\n      // empty the manipulation divs\n      util.recursiveDOMDelete(this.manipulationDiv);\n      util.recursiveDOMDelete(this.editModeDiv);\n      util.recursiveDOMDelete(this.closeDiv);\n\n      // remove the manipulation divs\n      if (this.manipulationDiv) {\n        this.canvas.frame.removeChild(this.manipulationDiv);\n      }\n      if (this.editModeDiv) {\n        this.canvas.frame.removeChild(this.editModeDiv);\n      }\n      if (this.closeDiv) {\n        this.canvas.frame.removeChild(this.closeDiv);\n      }\n\n      // set the references to undefined\n      this.manipulationDiv = undefined;\n      this.editModeDiv = undefined;\n      this.closeDiv = undefined;\n    }\n\n    /**\n     * create a seperator line. the index is to differentiate in the manipulation dom\n     * @param {number} [index=1]\n     * @private\n     */\n\n  }, {\n    key: '_createSeperator',\n    value: function _createSeperator() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      this.manipulationDOM['seperatorLineDiv' + index] = document.createElement('div');\n      this.manipulationDOM['seperatorLineDiv' + index].className = 'vis-separator-line';\n      this.manipulationDiv.appendChild(this.manipulationDOM['seperatorLineDiv' + index]);\n    }\n\n    // ----------------------    DOM functions for buttons    --------------------------//\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: '_createAddNodeButton',\n    value: function _createAddNodeButton(locale) {\n      var button = this._createButton('addNode', 'vis-button vis-add', locale['addNode'] || this.options.locales['en']['addNode']);\n      this.manipulationDiv.appendChild(button);\n      this._bindHammerToDiv(button, this.addNodeMode.bind(this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: '_createAddEdgeButton',\n    value: function _createAddEdgeButton(locale) {\n      var button = this._createButton('addEdge', 'vis-button vis-connect', locale['addEdge'] || this.options.locales['en']['addEdge']);\n      this.manipulationDiv.appendChild(button);\n      this._bindHammerToDiv(button, this.addEdgeMode.bind(this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: '_createEditNodeButton',\n    value: function _createEditNodeButton(locale) {\n      var button = this._createButton('editNode', 'vis-button vis-edit', locale['editNode'] || this.options.locales['en']['editNode']);\n      this.manipulationDiv.appendChild(button);\n      this._bindHammerToDiv(button, this.editNode.bind(this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: '_createEditEdgeButton',\n    value: function _createEditEdgeButton(locale) {\n      var button = this._createButton('editEdge', 'vis-button vis-edit', locale['editEdge'] || this.options.locales['en']['editEdge']);\n      this.manipulationDiv.appendChild(button);\n      this._bindHammerToDiv(button, this.editEdgeMode.bind(this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: '_createDeleteButton',\n    value: function _createDeleteButton(locale) {\n      var deleteBtnClass;\n      if (this.options.rtl) {\n        deleteBtnClass = 'vis-button vis-delete-rtl';\n      } else {\n        deleteBtnClass = 'vis-button vis-delete';\n      }\n      var button = this._createButton('delete', deleteBtnClass, locale['del'] || this.options.locales['en']['del']);\n      this.manipulationDiv.appendChild(button);\n      this._bindHammerToDiv(button, this.deleteSelected.bind(this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: '_createBackButton',\n    value: function _createBackButton(locale) {\n      var button = this._createButton('back', 'vis-button vis-back', locale['back'] || this.options.locales['en']['back']);\n      this.manipulationDiv.appendChild(button);\n      this._bindHammerToDiv(button, this.showManipulatorToolbar.bind(this));\n    }\n\n    /**\n     *\n     * @param {number|string} id\n     * @param {string} className\n     * @param {label} label\n     * @param {string} labelClassName\n     * @returns {HTMLElement}\n     * @private\n     */\n\n  }, {\n    key: '_createButton',\n    value: function _createButton(id, className, label) {\n      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vis-label';\n\n      this.manipulationDOM[id + 'Div'] = document.createElement('div');\n      this.manipulationDOM[id + 'Div'].className = className;\n      this.manipulationDOM[id + 'Label'] = document.createElement('div');\n      this.manipulationDOM[id + 'Label'].className = labelClassName;\n      this.manipulationDOM[id + 'Label'].innerHTML = label;\n      this.manipulationDOM[id + 'Div'].appendChild(this.manipulationDOM[id + 'Label']);\n      return this.manipulationDOM[id + 'Div'];\n    }\n\n    /**\n     *\n     * @param {Label} label\n     * @private\n     */\n\n  }, {\n    key: '_createDescription',\n    value: function _createDescription(label) {\n      this.manipulationDiv.appendChild(this._createButton('description', 'vis-button vis-none', label));\n    }\n\n    // -------------------------- End of DOM functions for buttons ------------------------------//\n\n    /**\n     * this binds an event until cleanup by the clean functions.\n     * @param {Event}  event   The event\n     * @param {function} newFunction\n     * @private\n     */\n\n  }, {\n    key: '_temporaryBindEvent',\n    value: function _temporaryBindEvent(event, newFunction) {\n      this.temporaryEventFunctions.push({\n        event: event,\n        boundFunction: newFunction\n      });\n      this.body.emitter.on(event, newFunction);\n    }\n\n    /**\n     * this overrides an UI function until cleanup by the clean function\n     * @param {string} UIfunctionName\n     * @param {function} newFunction\n     * @private\n     */\n\n  }, {\n    key: '_temporaryBindUI',\n    value: function _temporaryBindUI(UIfunctionName, newFunction) {\n      if (this.body.eventListeners[UIfunctionName] !== undefined) {\n        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];\n        this.body.eventListeners[UIfunctionName] = newFunction;\n      } else {\n        throw new Error('This UI function does not exist. Typo? You tried: ' + UIfunctionName + ' possible are: ' + (0, _stringify2['default'])((0, _keys2['default'])(this.body.eventListeners)));\n      }\n    }\n\n    /**\n     * Restore the overridden UI functions to their original state.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_unbindTemporaryUIs',\n    value: function _unbindTemporaryUIs() {\n      for (var functionName in this.temporaryUIFunctions) {\n        if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {\n          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];\n          delete this.temporaryUIFunctions[functionName];\n        }\n      }\n      this.temporaryUIFunctions = {};\n    }\n\n    /**\n     * Unbind the events created by _temporaryBindEvent\n     * @private\n     */\n\n  }, {\n    key: '_unbindTemporaryEvents',\n    value: function _unbindTemporaryEvents() {\n      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {\n        var eventName = this.temporaryEventFunctions[i].event;\n        var boundFunction = this.temporaryEventFunctions[i].boundFunction;\n        this.body.emitter.off(eventName, boundFunction);\n      }\n      this.temporaryEventFunctions = [];\n    }\n\n    /**\n     * Bind an hammer instance to a DOM element.\n     *\n     * @param {Element} domElement\n     * @param {function} boundFunction\n     */\n\n  }, {\n    key: '_bindHammerToDiv',\n    value: function _bindHammerToDiv(domElement, boundFunction) {\n      var hammer = new Hammer(domElement, {});\n      hammerUtil.onTouch(hammer, boundFunction);\n      this.manipulationHammers.push(hammer);\n    }\n\n    /**\n     * Neatly clean up temporary edges and nodes\n     * @private\n     */\n\n  }, {\n    key: '_cleanupTemporaryNodesAndEdges',\n    value: function _cleanupTemporaryNodesAndEdges() {\n      // _clean temporary edges\n      for (var i = 0; i < this.temporaryIds.edges.length; i++) {\n        this.body.edges[this.temporaryIds.edges[i]].disconnect();\n        delete this.body.edges[this.temporaryIds.edges[i]];\n        var indexTempEdge = this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);\n        if (indexTempEdge !== -1) {\n          this.body.edgeIndices.splice(indexTempEdge, 1);\n        }\n      }\n\n      // _clean temporary nodes\n      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {\n        delete this.body.nodes[this.temporaryIds.nodes[_i]];\n        var indexTempNode = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[_i]);\n        if (indexTempNode !== -1) {\n          this.body.nodeIndices.splice(indexTempNode, 1);\n        }\n      }\n\n      this.temporaryIds = { nodes: [], edges: [] };\n    }\n\n    // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//\n\n    /**\n     * the touch is used to get the position of the initial click\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: '_controlNodeTouch',\n    value: function _controlNodeTouch(event) {\n      this.selectionHandler.unselectAll();\n      this.lastTouch = this.body.functions.getPointer(event.center);\n      this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object\n    }\n\n    /**\n     * the drag start is used to mark one of the control nodes as selected.\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: '_controlNodeDragStart',\n    value: function _controlNodeDragStart() /* event */{\n      // eslint-disable-line no-unused-vars\n      var pointer = this.lastTouch;\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var from = this.body.nodes[this.temporaryIds.nodes[0]];\n      var to = this.body.nodes[this.temporaryIds.nodes[1]];\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      this.selectedControlNode = undefined;\n\n      var fromSelect = from.isOverlappingWith(pointerObj);\n      var toSelect = to.isOverlappingWith(pointerObj);\n\n      if (fromSelect === true) {\n        this.selectedControlNode = from;\n        edge.edgeType.from = from;\n      } else if (toSelect === true) {\n        this.selectedControlNode = to;\n        edge.edgeType.to = to;\n      }\n\n      // we use the selection to find the node that is being dragged. We explicitly select it here.\n      if (this.selectedControlNode !== undefined) {\n        this.selectionHandler.selectObject(this.selectedControlNode);\n      }\n\n      this.body.emitter.emit('_redraw');\n    }\n\n    /**\n     * dragging the control nodes or the canvas\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: '_controlNodeDrag',\n    value: function _controlNodeDrag(event) {\n      this.body.emitter.emit('disablePhysics');\n      var pointer = this.body.functions.getPointer(event.center);\n      var pos = this.canvas.DOMtoCanvas(pointer);\n      if (this.selectedControlNode !== undefined) {\n        this.selectedControlNode.x = pos.x;\n        this.selectedControlNode.y = pos.y;\n      } else {\n        // if the drag was not started properly because the click started outside the network div, start it now.\n        var diffX = pointer.x - this.lastTouch.x;\n        var diffY = pointer.y - this.lastTouch.y;\n        this.body.view.translation = {\n          x: this.lastTouch.translation.x + diffX,\n          y: this.lastTouch.translation.y + diffY\n        };\n      }\n      this.body.emitter.emit('_redraw');\n    }\n\n    /**\n     * connecting or restoring the control nodes.\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: '_controlNodeDragEnd',\n    value: function _controlNodeDragEnd(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      // if the node that was dragged is not a control node, return\n      if (this.selectedControlNode === undefined) {\n        return;\n      }\n\n      // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.\n      this.selectionHandler.unselectAll();\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      // perform the connection\n      if (node !== undefined && this.selectedControlNode !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);\n        } else {\n          var from = this.body.nodes[this.temporaryIds.nodes[0]];\n          if (this.selectedControlNode.id === from.id) {\n            this._performEditEdge(node.id, edge.to.id);\n          } else {\n            this._performEditEdge(edge.from.id, node.id);\n          }\n        }\n      } else {\n        edge.updateEdgeType();\n        this.body.emitter.emit('restorePhysics');\n      }\n\n      this.body.emitter.emit('_redraw');\n    }\n\n    // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//\n\n    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//\n    /**\n     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description\n     * to walk the user through the process.\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: '_handleConnect',\n    value: function _handleConnect(event) {\n      // check to avoid double fireing of this function.\n      if (new Date().valueOf() - this.touchTime > 100) {\n        this.lastTouch = this.body.functions.getPointer(event.center);\n        this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object\n\n        var pointer = this.lastTouch;\n        var node = this.selectionHandler.getNodeAt(pointer);\n\n        if (node !== undefined) {\n          if (node.isCluster === true) {\n            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);\n          } else {\n            // create a node the temporary line can look at\n            var targetNode = this._getNewTargetNode(node.x, node.y);\n            this.body.nodes[targetNode.id] = targetNode;\n            this.body.nodeIndices.push(targetNode.id);\n\n            // create a temporary edge\n            var connectionEdge = this.body.functions.createEdge({\n              id: 'connectionEdge' + util.randomUUID(),\n              from: node.id,\n              to: targetNode.id,\n              physics: false,\n              smooth: {\n                enabled: true,\n                type: 'continuous',\n                roundness: 0.5\n              }\n            });\n            this.body.edges[connectionEdge.id] = connectionEdge;\n            this.body.edgeIndices.push(connectionEdge.id);\n\n            this.temporaryIds.nodes.push(targetNode.id);\n            this.temporaryIds.edges.push(connectionEdge.id);\n          }\n        }\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: '_dragControlNode',\n    value: function _dragControlNode(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      // remember the edge id\n      var connectFromId = undefined;\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n      // get the overlapping node but NOT the temporary node;\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        // if the node id is NOT a temporary node, accept the node.\n        if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n\n      event.controlEdge = { from: connectFromId, to: node ? node.id : undefined };\n      this.selectionHandler._generateClickEvent('controlNodeDragging', event, pointer);\n\n      if (this.temporaryIds.nodes[0] !== undefined) {\n        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.\n        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n        this.body.emitter.emit('_redraw');\n      } else {\n        var diffX = pointer.x - this.lastTouch.x;\n        var diffY = pointer.y - this.lastTouch.y;\n        this.body.view.translation = {\n          x: this.lastTouch.translation.x + diffX,\n          y: this.lastTouch.translation.y + diffY\n        };\n      }\n    }\n\n    /**\n     * Connect the new edge to the target if one exists, otherwise remove temp line\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: '_finishConnect',\n    value: function _finishConnect(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n\n      // remember the edge id\n      var connectFromId = undefined;\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n\n      // get the overlapping node but NOT the temporary node;\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        // if the node id is NOT a temporary node, accept the node.\n        if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n\n      // clean temporary nodes and edges.\n      this._cleanupTemporaryNodesAndEdges();\n\n      // perform the connection\n      if (node !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);\n        } else {\n          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {\n            this._performAddEdge(connectFromId, node.id);\n          }\n        }\n      }\n\n      event.controlEdge = { from: connectFromId, to: node ? node.id : undefined };\n      this.selectionHandler._generateClickEvent('controlNodeDragEnd', event, pointer);\n\n      // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.\n      this.body.emitter.emit('_redraw');\n    }\n\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: '_dragStartEdge',\n    value: function _dragStartEdge(event) {\n      var pointer = this.lastTouch;\n      this.selectionHandler._generateClickEvent('dragStart', event, pointer, undefined, true);\n    }\n\n    // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//\n\n    // ------------------------------ Performing all the actual data manipulation ------------------------//\n\n    /**\n     * Adds a node on the specified location\n     *\n     * @param {Object} clickData\n     * @private\n     */\n\n  }, {\n    key: '_performAddNode',\n    value: function _performAddNode(clickData) {\n      var _this4 = this;\n\n      var defaultData = {\n        id: util.randomUUID(),\n        x: clickData.pointer.canvas.x,\n        y: clickData.pointer.canvas.y,\n        label: 'new'\n      };\n\n      if (typeof this.options.addNode === 'function') {\n        if (this.options.addNode.length === 2) {\n          this.options.addNode(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === 'addNode') {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this4.body.data.nodes.getDataSet().add(finalizedData);\n            }\n            _this4.showManipulatorToolbar();\n          });\n        } else {\n          this.showManipulatorToolbar();\n          throw new Error('The function for add does not support two arguments (data,callback)');\n        }\n      } else {\n        this.body.data.nodes.getDataSet().add(defaultData);\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n\n  }, {\n    key: '_performAddEdge',\n    value: function _performAddEdge(sourceNodeId, targetNodeId) {\n      var _this5 = this;\n\n      var defaultData = { from: sourceNodeId, to: targetNodeId };\n      if (typeof this.options.addEdge === 'function') {\n        if (this.options.addEdge.length === 2) {\n          this.options.addEdge(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === 'addEdge') {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this5.body.data.edges.getDataSet().add(finalizedData);\n              _this5.selectionHandler.unselectAll();\n              _this5.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error('The function for connect does not support two arguments (data,callback)');\n        }\n      } else {\n        this.body.data.edges.getDataSet().add(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n\n  }, {\n    key: '_performEditEdge',\n    value: function _performEditEdge(sourceNodeId, targetNodeId) {\n      var _this6 = this;\n\n      var defaultData = {\n        id: this.edgeBeingEditedId,\n        from: sourceNodeId,\n        to: targetNodeId,\n        label: this.body.data.edges._data[this.edgeBeingEditedId].label\n      };\n      var eeFunct = this.options.editEdge;\n      if ((typeof eeFunct === 'undefined' ? 'undefined' : (0, _typeof3['default'])(eeFunct)) === 'object') {\n        eeFunct = eeFunct.editWithoutDrag;\n      }\n      if (typeof eeFunct === 'function') {\n        if (eeFunct.length === 2) {\n          eeFunct(defaultData, function (finalizedData) {\n            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== 'editEdge') {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this6.body.edges[defaultData.id].updateEdgeType();\n              _this6.body.emitter.emit('_redraw');\n              _this6.showManipulatorToolbar();\n            } else {\n              _this6.body.data.edges.getDataSet().update(finalizedData);\n              _this6.selectionHandler.unselectAll();\n              _this6.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error('The function for edit does not support two arguments (data, callback)');\n        }\n      } else {\n        this.body.data.edges.getDataSet().update(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n  }]);\n  return ManipulationSystem;\n}();\n\nexports['default'] = ManipulationSystem;\n\n/***/ }),\n/* 191 */\n/***/ (function(module, exports, __nested_webpack_require_1213829__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = __nested_webpack_require_1213829__(23);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _typeof2 = __nested_webpack_require_1213829__(7);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _classCallCheck2 = __nested_webpack_require_1213829__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1213829__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar util = __nested_webpack_require_1213829__(2);\n\nvar ColorPicker = __nested_webpack_require_1213829__(192)['default'];\n\n/**\n * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.\n * Boolean options are recognised as Boolean\n * Number options should be written as array: [default value, min value, max value, stepsize]\n * Colors should be written as array: ['color', '#ffffff']\n * Strings with should be written as array: [option1, option2, option3, ..]\n *\n * The options are matched with their counterparts in each of the modules and the values used in the configuration are\n */\n\nvar Configurator = function () {\n  /**\n   * @param {Object} parentModule        | the location where parentModule.setOptions() can be called\n   * @param {Object} defaultContainer    | the default container of the module\n   * @param {Object} configureOptions    | the fully configured and predefined options set found in allOptions.js\n   * @param {number} pixelRatio          | canvas pixel ratio\n   */\n  function Configurator(parentModule, defaultContainer, configureOptions) {\n    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    (0, _classCallCheck3['default'])(this, Configurator);\n\n    this.parent = parentModule;\n    this.changedOptions = [];\n    this.container = defaultContainer;\n    this.allowCreation = false;\n\n    this.options = {};\n    this.initialized = false;\n    this.popupCounter = 0;\n    this.defaultOptions = {\n      enabled: false,\n      filter: true,\n      container: undefined,\n      showButton: true\n    };\n    util.extend(this.options, this.defaultOptions);\n\n    this.configureOptions = configureOptions;\n    this.moduleOptions = {};\n    this.domElements = [];\n    this.popupDiv = {};\n    this.popupLimit = 5;\n    this.popupHistory = {};\n    this.colorPicker = new ColorPicker(pixelRatio);\n    this.wrapper = undefined;\n  }\n\n  /**\n   * refresh all options.\n   * Because all modules parse their options by themselves, we just use their options. We copy them here.\n   *\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(Configurator, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // reset the popup history because the indices may have been changed.\n        this.popupHistory = {};\n        this._removePopup();\n\n        var enabled = true;\n        if (typeof options === 'string') {\n          this.options.filter = options;\n        } else if (options instanceof Array) {\n          this.options.filter = options.join();\n        } else if ((typeof options === 'undefined' ? 'undefined' : (0, _typeof3['default'])(options)) === 'object') {\n          if (options == null) {\n            throw new TypeError('options cannot be null');\n          }\n          if (options.container !== undefined) {\n            this.options.container = options.container;\n          }\n          if (options.filter !== undefined) {\n            this.options.filter = options.filter;\n          }\n          if (options.showButton !== undefined) {\n            this.options.showButton = options.showButton;\n          }\n          if (options.enabled !== undefined) {\n            enabled = options.enabled;\n          }\n        } else if (typeof options === 'boolean') {\n          this.options.filter = true;\n          enabled = options;\n        } else if (typeof options === 'function') {\n          this.options.filter = options;\n          enabled = true;\n        }\n        if (this.options.filter === false) {\n          enabled = false;\n        }\n\n        this.options.enabled = enabled;\n      }\n      this._clean();\n    }\n\n    /**\n     *\n     * @param {Object} moduleOptions\n     */\n\n  }, {\n    key: 'setModuleOptions',\n    value: function setModuleOptions(moduleOptions) {\n      this.moduleOptions = moduleOptions;\n      if (this.options.enabled === true) {\n        this._clean();\n        if (this.options.container !== undefined) {\n          this.container = this.options.container;\n        }\n        this._create();\n      }\n    }\n\n    /**\n     * Create all DOM elements\n     * @private\n     */\n\n  }, {\n    key: '_create',\n    value: function _create() {\n      this._clean();\n      this.changedOptions = [];\n\n      var filter = this.options.filter;\n      var counter = 0;\n      var show = false;\n      for (var option in this.configureOptions) {\n        if (this.configureOptions.hasOwnProperty(option)) {\n          this.allowCreation = false;\n          show = false;\n          if (typeof filter === 'function') {\n            show = filter(option, []);\n            show = show || this._handleObject(this.configureOptions[option], [option], true);\n          } else if (filter === true || filter.indexOf(option) !== -1) {\n            show = true;\n          }\n\n          if (show !== false) {\n            this.allowCreation = true;\n\n            // linebreak between categories\n            if (counter > 0) {\n              this._makeItem([]);\n            }\n            // a header for the category\n            this._makeHeader(option);\n\n            // get the sub options\n            this._handleObject(this.configureOptions[option], [option]);\n          }\n          counter++;\n        }\n      }\n      this._makeButton();\n      this._push();\n      //~ this.colorPicker.insertTo(this.container);\n    }\n\n    /**\n     * draw all DOM elements on the screen\n     * @private\n     */\n\n  }, {\n    key: '_push',\n    value: function _push() {\n      this.wrapper = document.createElement('div');\n      this.wrapper.className = 'vis-configuration-wrapper';\n      this.container.appendChild(this.wrapper);\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.appendChild(this.domElements[i]);\n      }\n\n      this._showPopupIfNeeded();\n    }\n\n    /**\n     * delete all DOM elements\n     * @private\n     */\n\n  }, {\n    key: '_clean',\n    value: function _clean() {\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.removeChild(this.domElements[i]);\n      }\n\n      if (this.wrapper !== undefined) {\n        this.container.removeChild(this.wrapper);\n        this.wrapper = undefined;\n      }\n      this.domElements = [];\n\n      this._removePopup();\n    }\n\n    /**\n     * get the value from the actualOptions if it exists\n     * @param {array} path    | where to look for the actual option\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: '_getValue',\n    value: function _getValue(path) {\n      var base = this.moduleOptions;\n      for (var i = 0; i < path.length; i++) {\n        if (base[path[i]] !== undefined) {\n          base = base[path[i]];\n        } else {\n          base = undefined;\n          break;\n        }\n      }\n      return base;\n    }\n\n    /**\n     * all option elements are wrapped in an item\n     * @param {Array} path    | where to look for the actual option\n     * @param {Array.<Element>} domElements\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_makeItem',\n    value: function _makeItem(path) {\n      if (this.allowCreation === true) {\n        var item = document.createElement('div');\n        item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;\n\n        for (var _len = arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          domElements[_key - 1] = arguments[_key];\n        }\n\n        domElements.forEach(function (element) {\n          item.appendChild(element);\n        });\n        this.domElements.push(item);\n        return this.domElements.length;\n      }\n      return 0;\n    }\n\n    /**\n     * header for major subjects\n     * @param {string} name\n     * @private\n     */\n\n  }, {\n    key: '_makeHeader',\n    value: function _makeHeader(name) {\n      var div = document.createElement('div');\n      div.className = 'vis-configuration vis-config-header';\n      div.innerHTML = name;\n      this._makeItem([], div);\n    }\n\n    /**\n     * make a label, if it is an object label, it gets different styling.\n     * @param {string} name\n     * @param {array} path    | where to look for the actual option\n     * @param {string} objectLabel\n     * @returns {HTMLElement}\n     * @private\n     */\n\n  }, {\n    key: '_makeLabel',\n    value: function _makeLabel(name, path) {\n      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var div = document.createElement('div');\n      div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;\n      if (objectLabel === true) {\n        div.innerHTML = '<i><b>' + name + ':</b></i>';\n      } else {\n        div.innerHTML = name + ':';\n      }\n      return div;\n    }\n\n    /**\n     * make a dropdown list for multiple possible string optoins\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_makeDropdown',\n    value: function _makeDropdown(arr, value, path) {\n      var select = document.createElement('select');\n      select.className = 'vis-configuration vis-config-select';\n      var selectedValue = 0;\n      if (value !== undefined) {\n        if (arr.indexOf(value) !== -1) {\n          selectedValue = arr.indexOf(value);\n        }\n      }\n\n      for (var i = 0; i < arr.length; i++) {\n        var option = document.createElement('option');\n        option.value = arr[i];\n        if (i === selectedValue) {\n          option.selected = 'selected';\n        }\n        option.innerHTML = arr[i];\n        select.appendChild(option);\n      }\n\n      var me = this;\n      select.onchange = function () {\n        me._update(this.value, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, select);\n    }\n\n    /**\n     * make a range object for numeric options\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_makeRange',\n    value: function _makeRange(arr, value, path) {\n      var defaultValue = arr[0];\n      var min = arr[1];\n      var max = arr[2];\n      var step = arr[3];\n      var range = document.createElement('input');\n      range.className = 'vis-configuration vis-config-range';\n      try {\n        range.type = 'range'; // not supported on IE9\n        range.min = min;\n        range.max = max;\n      } catch (err) {}\n      // TODO: Add some error handling and remove this lint exception\n      // eslint-disable-line no-empty\n      range.step = step;\n\n      // set up the popup settings in case they are needed.\n      var popupString = '';\n      var popupValue = 0;\n\n      if (value !== undefined) {\n        var factor = 1.2;\n        if (value < 0 && value * factor < min) {\n          range.min = Math.ceil(value * factor);\n          popupValue = range.min;\n          popupString = 'range increased';\n        } else if (value / factor < min) {\n          range.min = Math.ceil(value / factor);\n          popupValue = range.min;\n          popupString = 'range increased';\n        }\n        if (value * factor > max && max !== 1) {\n          range.max = Math.ceil(value * factor);\n          popupValue = range.max;\n          popupString = 'range increased';\n        }\n        range.value = value;\n      } else {\n        range.value = defaultValue;\n      }\n\n      var input = document.createElement('input');\n      input.className = 'vis-configuration vis-config-rangeinput';\n      input.value = range.value;\n\n      var me = this;\n      range.onchange = function () {\n        input.value = this.value;\n        me._update(Number(this.value), path);\n      };\n      range.oninput = function () {\n        input.value = this.value;\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n      var itemIndex = this._makeItem(path, label, range, input);\n\n      // if a popup is needed AND it has not been shown for this value, show it.\n      if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {\n        this.popupHistory[itemIndex] = popupValue;\n        this._setupPopup(popupString, itemIndex);\n      }\n    }\n\n    /**\n     * make a button object\n     * @private\n     */\n\n  }, {\n    key: '_makeButton',\n    value: function _makeButton() {\n      var _this = this;\n\n      if (this.options.showButton === true) {\n        var generateButton = document.createElement('div');\n        generateButton.className = 'vis-configuration vis-config-button';\n        generateButton.innerHTML = 'generate options';\n        generateButton.onclick = function () {\n          _this._printOptions();\n        };\n        generateButton.onmouseover = function () {\n          generateButton.className = 'vis-configuration vis-config-button hover';\n        };\n        generateButton.onmouseout = function () {\n          generateButton.className = 'vis-configuration vis-config-button';\n        };\n\n        this.optionsContainer = document.createElement('div');\n        this.optionsContainer.className = 'vis-configuration vis-config-option-container';\n\n        this.domElements.push(this.optionsContainer);\n        this.domElements.push(generateButton);\n      }\n    }\n\n    /**\n     * prepare the popup\n     * @param {string} string\n     * @param {number} index\n     * @private\n     */\n\n  }, {\n    key: '_setupPopup',\n    value: function _setupPopup(string, index) {\n      var _this2 = this;\n\n      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {\n        var div = document.createElement('div');\n        div.id = 'vis-configuration-popup';\n        div.className = 'vis-configuration-popup';\n        div.innerHTML = string;\n        div.onclick = function () {\n          _this2._removePopup();\n        };\n        this.popupCounter += 1;\n        this.popupDiv = { html: div, index: index };\n      }\n    }\n\n    /**\n     * remove the popup from the dom\n     * @private\n     */\n\n  }, {\n    key: '_removePopup',\n    value: function _removePopup() {\n      if (this.popupDiv.html !== undefined) {\n        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);\n        clearTimeout(this.popupDiv.hideTimeout);\n        clearTimeout(this.popupDiv.deleteTimeout);\n        this.popupDiv = {};\n      }\n    }\n\n    /**\n     * Show the popup if it is needed.\n     * @private\n     */\n\n  }, {\n    key: '_showPopupIfNeeded',\n    value: function _showPopupIfNeeded() {\n      var _this3 = this;\n\n      if (this.popupDiv.html !== undefined) {\n        var correspondingElement = this.domElements[this.popupDiv.index];\n        var rect = correspondingElement.getBoundingClientRect();\n        this.popupDiv.html.style.left = rect.left + 'px';\n        this.popupDiv.html.style.top = rect.top - 30 + 'px'; // 30 is the height;\n        document.body.appendChild(this.popupDiv.html);\n        this.popupDiv.hideTimeout = setTimeout(function () {\n          _this3.popupDiv.html.style.opacity = 0;\n        }, 1500);\n        this.popupDiv.deleteTimeout = setTimeout(function () {\n          _this3._removePopup();\n        }, 1800);\n      }\n    }\n\n    /**\n     * make a checkbox for boolean options.\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_makeCheckbox',\n    value: function _makeCheckbox(defaultValue, value, path) {\n      var checkbox = document.createElement('input');\n      checkbox.type = 'checkbox';\n      checkbox.className = 'vis-configuration vis-config-checkbox';\n      checkbox.checked = defaultValue;\n      if (value !== undefined) {\n        checkbox.checked = value;\n        if (value !== defaultValue) {\n          if ((typeof defaultValue === 'undefined' ? 'undefined' : (0, _typeof3['default'])(defaultValue)) === 'object') {\n            if (value !== defaultValue.enabled) {\n              this.changedOptions.push({ path: path, value: value });\n            }\n          } else {\n            this.changedOptions.push({ path: path, value: value });\n          }\n        }\n      }\n\n      var me = this;\n      checkbox.onchange = function () {\n        me._update(this.checked, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, checkbox);\n    }\n\n    /**\n     * make a text input field for string options.\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_makeTextInput',\n    value: function _makeTextInput(defaultValue, value, path) {\n      var checkbox = document.createElement('input');\n      checkbox.type = 'text';\n      checkbox.className = 'vis-configuration vis-config-text';\n      checkbox.value = value;\n      if (value !== defaultValue) {\n        this.changedOptions.push({ path: path, value: value });\n      }\n\n      var me = this;\n      checkbox.onchange = function () {\n        me._update(this.value, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, checkbox);\n    }\n\n    /**\n     * make a color field with a color picker for color fields\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_makeColorField',\n    value: function _makeColorField(arr, value, path) {\n      var _this4 = this;\n\n      var defaultColor = arr[1];\n      var div = document.createElement('div');\n      value = value === undefined ? defaultColor : value;\n\n      if (value !== 'none') {\n        div.className = 'vis-configuration vis-config-colorBlock';\n        div.style.backgroundColor = value;\n      } else {\n        div.className = 'vis-configuration vis-config-colorBlock none';\n      }\n\n      value = value === undefined ? defaultColor : value;\n      div.onclick = function () {\n        _this4._showColorPicker(value, div, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, div);\n    }\n\n    /**\n     * used by the color buttons to call the color picker.\n     * @param {number} value\n     * @param {HTMLElement} div\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_showColorPicker',\n    value: function _showColorPicker(value, div, path) {\n      var _this5 = this;\n\n      // clear the callback from this div\n      div.onclick = function () {};\n\n      this.colorPicker.insertTo(div);\n      this.colorPicker.show();\n\n      this.colorPicker.setColor(value);\n      this.colorPicker.setUpdateCallback(function (color) {\n        var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';\n        div.style.backgroundColor = colorString;\n        _this5._update(colorString, path);\n      });\n\n      // on close of the colorpicker, restore the callback.\n      this.colorPicker.setCloseCallback(function () {\n        div.onclick = function () {\n          _this5._showColorPicker(value, div, path);\n        };\n      });\n    }\n\n    /**\n     * parse an object and draw the correct items\n     * @param {Object} obj\n     * @param {array} [path=[]]    | where to look for the actual option\n     * @param {boolean} [checkOnly=false]\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_handleObject',\n    value: function _handleObject(obj) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var show = false;\n      var filter = this.options.filter;\n      var visibleInSet = false;\n      for (var subObj in obj) {\n        if (obj.hasOwnProperty(subObj)) {\n          show = true;\n          var item = obj[subObj];\n          var newPath = util.copyAndExtendArray(path, subObj);\n          if (typeof filter === 'function') {\n            show = filter(subObj, path);\n\n            // if needed we must go deeper into the object.\n            if (show === false) {\n              if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {\n                this.allowCreation = false;\n                show = this._handleObject(item, newPath, true);\n                this.allowCreation = checkOnly === false;\n              }\n            }\n          }\n\n          if (show !== false) {\n            visibleInSet = true;\n            var value = this._getValue(newPath);\n\n            if (item instanceof Array) {\n              this._handleArray(item, value, newPath);\n            } else if (typeof item === 'string') {\n              this._makeTextInput(item, value, newPath);\n            } else if (typeof item === 'boolean') {\n              this._makeCheckbox(item, value, newPath);\n            } else if (item instanceof Object) {\n              // collapse the physics options that are not enabled\n              var draw = true;\n              if (path.indexOf('physics') !== -1) {\n                if (this.moduleOptions.physics.solver !== subObj) {\n                  draw = false;\n                }\n              }\n\n              if (draw === true) {\n                // initially collapse options with an disabled enabled option.\n                if (item.enabled !== undefined) {\n                  var enabledPath = util.copyAndExtendArray(newPath, 'enabled');\n                  var enabledValue = this._getValue(enabledPath);\n                  if (enabledValue === true) {\n                    var label = this._makeLabel(subObj, newPath, true);\n                    this._makeItem(newPath, label);\n                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                  } else {\n                    this._makeCheckbox(item, enabledValue, newPath);\n                  }\n                } else {\n                  var _label = this._makeLabel(subObj, newPath, true);\n                  this._makeItem(newPath, _label);\n                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                }\n              }\n            } else {\n              console.error('dont know how to handle', item, subObj, newPath);\n            }\n          }\n        }\n      }\n      return visibleInSet;\n    }\n\n    /**\n     * handle the array type of option\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_handleArray',\n    value: function _handleArray(arr, value, path) {\n      if (typeof arr[0] === 'string' && arr[0] === 'color') {\n        this._makeColorField(arr, value, path);\n        if (arr[1] !== value) {\n          this.changedOptions.push({ path: path, value: value });\n        }\n      } else if (typeof arr[0] === 'string') {\n        this._makeDropdown(arr, value, path);\n        if (arr[0] !== value) {\n          this.changedOptions.push({ path: path, value: value });\n        }\n      } else if (typeof arr[0] === 'number') {\n        this._makeRange(arr, value, path);\n        if (arr[0] !== value) {\n          this.changedOptions.push({ path: path, value: Number(value) });\n        }\n      }\n    }\n\n    /**\n     * called to update the network with the new settings.\n     * @param {number} value\n     * @param {array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: '_update',\n    value: function _update(value, path) {\n      var options = this._constructOptions(value, path);\n\n      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {\n        this.parent.body.emitter.emit('configChange', options);\n      }\n      this.initialized = true;\n      this.parent.setOptions(options);\n    }\n\n    /**\n     *\n     * @param {string|Boolean} value\n     * @param {Array.<string>} path\n     * @param {{}} optionsObj\n     * @returns {{}}\n     * @private\n     */\n\n  }, {\n    key: '_constructOptions',\n    value: function _constructOptions(value, path) {\n      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var pointer = optionsObj;\n\n      // when dropdown boxes can be string or boolean, we typecast it into correct types\n      value = value === 'true' ? true : value;\n      value = value === 'false' ? false : value;\n\n      for (var i = 0; i < path.length; i++) {\n        if (path[i] !== 'global') {\n          if (pointer[path[i]] === undefined) {\n            pointer[path[i]] = {};\n          }\n          if (i !== path.length - 1) {\n            pointer = pointer[path[i]];\n          } else {\n            pointer[path[i]] = value;\n          }\n        }\n      }\n      return optionsObj;\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_printOptions',\n    value: function _printOptions() {\n      var options = this.getOptions();\n      this.optionsContainer.innerHTML = '<pre>var options = ' + (0, _stringify2['default'])(options, null, 2) + '</pre>';\n    }\n\n    /**\n     *\n     * @returns {{}} options\n     */\n\n  }, {\n    key: 'getOptions',\n    value: function getOptions() {\n      var options = {};\n      for (var i = 0; i < this.changedOptions.length; i++) {\n        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);\n      }\n      return options;\n    }\n  }]);\n  return Configurator;\n}();\n\nexports['default'] = Configurator;\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports, __nested_webpack_require_1239979__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = __nested_webpack_require_1239979__(23);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _classCallCheck2 = __nested_webpack_require_1239979__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1239979__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar Hammer = __nested_webpack_require_1239979__(24);\nvar hammerUtil = __nested_webpack_require_1239979__(36);\nvar util = __nested_webpack_require_1239979__(2);\n\nvar htmlColors = {\n  black: '#000000',\n  navy: '#000080',\n  darkblue: '#00008B',\n  mediumblue: '#0000CD',\n  blue: '#0000FF',\n  darkgreen: '#006400',\n  green: '#008000',\n  teal: '#008080',\n  darkcyan: '#008B8B',\n  deepskyblue: '#00BFFF',\n  darkturquoise: '#00CED1',\n  mediumspringgreen: '#00FA9A',\n  lime: '#00FF00',\n  springgreen: '#00FF7F',\n  aqua: '#00FFFF',\n  cyan: '#00FFFF',\n  midnightblue: '#191970',\n  dodgerblue: '#1E90FF',\n  lightseagreen: '#20B2AA',\n  forestgreen: '#228B22',\n  seagreen: '#2E8B57',\n  darkslategray: '#2F4F4F',\n  limegreen: '#32CD32',\n  mediumseagreen: '#3CB371',\n  turquoise: '#40E0D0',\n  royalblue: '#4169E1',\n  steelblue: '#4682B4',\n  darkslateblue: '#483D8B',\n  mediumturquoise: '#48D1CC',\n  indigo: '#4B0082',\n  darkolivegreen: '#556B2F',\n  cadetblue: '#5F9EA0',\n  cornflowerblue: '#6495ED',\n  mediumaquamarine: '#66CDAA',\n  dimgray: '#696969',\n  slateblue: '#6A5ACD',\n  olivedrab: '#6B8E23',\n  slategray: '#708090',\n  lightslategray: '#778899',\n  mediumslateblue: '#7B68EE',\n  lawngreen: '#7CFC00',\n  chartreuse: '#7FFF00',\n  aquamarine: '#7FFFD4',\n  maroon: '#800000',\n  purple: '#800080',\n  olive: '#808000',\n  gray: '#808080',\n  skyblue: '#87CEEB',\n  lightskyblue: '#87CEFA',\n  blueviolet: '#8A2BE2',\n  darkred: '#8B0000',\n  darkmagenta: '#8B008B',\n  saddlebrown: '#8B4513',\n  darkseagreen: '#8FBC8F',\n  lightgreen: '#90EE90',\n  mediumpurple: '#9370D8',\n  darkviolet: '#9400D3',\n  palegreen: '#98FB98',\n  darkorchid: '#9932CC',\n  yellowgreen: '#9ACD32',\n  sienna: '#A0522D',\n  brown: '#A52A2A',\n  darkgray: '#A9A9A9',\n  lightblue: '#ADD8E6',\n  greenyellow: '#ADFF2F',\n  paleturquoise: '#AFEEEE',\n  lightsteelblue: '#B0C4DE',\n  powderblue: '#B0E0E6',\n  firebrick: '#B22222',\n  darkgoldenrod: '#B8860B',\n  mediumorchid: '#BA55D3',\n  rosybrown: '#BC8F8F',\n  darkkhaki: '#BDB76B',\n  silver: '#C0C0C0',\n  mediumvioletred: '#C71585',\n  indianred: '#CD5C5C',\n  peru: '#CD853F',\n  chocolate: '#D2691E',\n  tan: '#D2B48C',\n  lightgrey: '#D3D3D3',\n  palevioletred: '#D87093',\n  thistle: '#D8BFD8',\n  orchid: '#DA70D6',\n  goldenrod: '#DAA520',\n  crimson: '#DC143C',\n  gainsboro: '#DCDCDC',\n  plum: '#DDA0DD',\n  burlywood: '#DEB887',\n  lightcyan: '#E0FFFF',\n  lavender: '#E6E6FA',\n  darksalmon: '#E9967A',\n  violet: '#EE82EE',\n  palegoldenrod: '#EEE8AA',\n  lightcoral: '#F08080',\n  khaki: '#F0E68C',\n  aliceblue: '#F0F8FF',\n  honeydew: '#F0FFF0',\n  azure: '#F0FFFF',\n  sandybrown: '#F4A460',\n  wheat: '#F5DEB3',\n  beige: '#F5F5DC',\n  whitesmoke: '#F5F5F5',\n  mintcream: '#F5FFFA',\n  ghostwhite: '#F8F8FF',\n  salmon: '#FA8072',\n  antiquewhite: '#FAEBD7',\n  linen: '#FAF0E6',\n  lightgoldenrodyellow: '#FAFAD2',\n  oldlace: '#FDF5E6',\n  red: '#FF0000',\n  fuchsia: '#FF00FF',\n  magenta: '#FF00FF',\n  deeppink: '#FF1493',\n  orangered: '#FF4500',\n  tomato: '#FF6347',\n  hotpink: '#FF69B4',\n  coral: '#FF7F50',\n  darkorange: '#FF8C00',\n  lightsalmon: '#FFA07A',\n  orange: '#FFA500',\n  lightpink: '#FFB6C1',\n  pink: '#FFC0CB',\n  gold: '#FFD700',\n  peachpuff: '#FFDAB9',\n  navajowhite: '#FFDEAD',\n  moccasin: '#FFE4B5',\n  bisque: '#FFE4C4',\n  mistyrose: '#FFE4E1',\n  blanchedalmond: '#FFEBCD',\n  papayawhip: '#FFEFD5',\n  lavenderblush: '#FFF0F5',\n  seashell: '#FFF5EE',\n  cornsilk: '#FFF8DC',\n  lemonchiffon: '#FFFACD',\n  floralwhite: '#FFFAF0',\n  snow: '#FFFAFA',\n  yellow: '#FFFF00',\n  lightyellow: '#FFFFE0',\n  ivory: '#FFFFF0',\n  white: '#FFFFFF'\n\n  /**\n   * @param {number} [pixelRatio=1]\n   */\n};\nvar ColorPicker = function () {\n  /**\n   * @param {number} [pixelRatio=1]\n   */\n  function ColorPicker() {\n    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    (0, _classCallCheck3['default'])(this, ColorPicker);\n\n    this.pixelRatio = pixelRatio;\n    this.generated = false;\n    this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };\n    this.r = 289 * 0.49;\n    this.color = { r: 255, g: 255, b: 255, a: 1.0 };\n    this.hueCircle = undefined;\n    this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };\n    this.previousColor = undefined;\n    this.applied = false;\n\n    // bound by\n    this.updateCallback = function () {};\n    this.closeCallback = function () {};\n\n    // create all DOM elements\n    this._create();\n  }\n\n  /**\n   * this inserts the colorPicker into a div from the DOM\n   * @param {Element} container\n   */\n\n\n  (0, _createClass3['default'])(ColorPicker, [{\n    key: 'insertTo',\n    value: function insertTo(container) {\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n        this.hammer = undefined;\n      }\n      this.container = container;\n      this.container.appendChild(this.frame);\n      this._bindHammer();\n\n      this._setSize();\n    }\n\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     * @param {function} callback\n     */\n\n  }, {\n    key: 'setUpdateCallback',\n    value: function setUpdateCallback(callback) {\n      if (typeof callback === 'function') {\n        this.updateCallback = callback;\n      } else {\n        throw new Error('Function attempted to set as colorPicker update callback is not a function.');\n      }\n    }\n\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     * @param {function} callback\n     */\n\n  }, {\n    key: 'setCloseCallback',\n    value: function setCloseCallback(callback) {\n      if (typeof callback === 'function') {\n        this.closeCallback = callback;\n      } else {\n        throw new Error('Function attempted to set as colorPicker closing callback is not a function.');\n      }\n    }\n\n    /**\n     *\n     * @param {string} color\n     * @returns {String}\n     * @private\n     */\n\n  }, {\n    key: '_isColorString',\n    value: function _isColorString(color) {\n      if (typeof color === 'string') {\n        return htmlColors[color];\n      }\n    }\n\n    /**\n     * Set the color of the colorPicker\n     * Supported formats:\n     * 'red'                   --> HTML color string\n     * '#ffffff'               --> hex string\n     * 'rgb(255,255,255)'      --> rgb string\n     * 'rgba(255,255,255,1.0)' --> rgba string\n     * {r:255,g:255,b:255}     --> rgb object\n     * {r:255,g:255,b:255,a:1.0} --> rgba object\n     * @param {string|Object} color\n     * @param {boolean} [setInitial=true]\n     */\n\n  }, {\n    key: 'setColor',\n    value: function setColor(color) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (color === 'none') {\n        return;\n      }\n\n      var rgba = void 0;\n\n      // if a html color shorthand is used, convert to hex\n      var htmlColor = this._isColorString(color);\n      if (htmlColor !== undefined) {\n        color = htmlColor;\n      }\n\n      // check format\n      if (util.isString(color) === true) {\n        if (util.isValidRGB(color) === true) {\n          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');\n          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };\n        } else if (util.isValidRGBA(color) === true) {\n          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');\n          rgba = {\n            r: _rgbaArray[0],\n            g: _rgbaArray[1],\n            b: _rgbaArray[2],\n            a: _rgbaArray[3]\n          };\n        } else if (util.isValidHex(color) === true) {\n          var rgbObj = util.hexToRGB(color);\n          rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };\n        }\n      } else {\n        if (color instanceof Object) {\n          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {\n            var alpha = color.a !== undefined ? color.a : '1.0';\n            rgba = { r: color.r, g: color.g, b: color.b, a: alpha };\n          }\n        }\n      }\n\n      // set color\n      if (rgba === undefined) {\n        throw new Error('Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: ' + (0, _stringify2['default'])(color));\n      } else {\n        this._setColor(rgba, setInitial);\n      }\n    }\n\n    /**\n     * this shows the color picker.\n     * The hue circle is constructed once and stored.\n     */\n\n  }, {\n    key: 'show',\n    value: function show() {\n      if (this.closeCallback !== undefined) {\n        this.closeCallback();\n        this.closeCallback = undefined;\n      }\n\n      this.applied = false;\n      this.frame.style.display = 'block';\n      this._generateHueCircle();\n    }\n\n    // ------------------------------------------ PRIVATE ----------------------------- //\n\n    /**\n     * Hide the picker. Is called by the cancel button.\n     * Optional boolean to store the previous color for easy access later on.\n     * @param {boolean} [storePrevious=true]\n     * @private\n     */\n\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      var _this = this;\n\n      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      // store the previous color for next time;\n      if (storePrevious === true) {\n        this.previousColor = util.extend({}, this.color);\n      }\n\n      if (this.applied === true) {\n        this.updateCallback(this.initialColor);\n      }\n\n      this.frame.style.display = 'none';\n\n      // call the closing callback, restoring the onclick method.\n      // this is in a setTimeout because it will trigger the show again before the click is done.\n      setTimeout(function () {\n        if (_this.closeCallback !== undefined) {\n          _this.closeCallback();\n          _this.closeCallback = undefined;\n        }\n      }, 0);\n    }\n\n    /**\n     * bound to the save button. Saves and hides.\n     * @private\n     */\n\n  }, {\n    key: '_save',\n    value: function _save() {\n      this.updateCallback(this.color);\n      this.applied = false;\n      this._hide();\n    }\n\n    /**\n     * Bound to apply button. Saves but does not close. Is undone by the cancel button.\n     * @private\n     */\n\n  }, {\n    key: '_apply',\n    value: function _apply() {\n      this.applied = true;\n      this.updateCallback(this.color);\n      this._updatePicker(this.color);\n    }\n\n    /**\n     * load the color from the previous session.\n     * @private\n     */\n\n  }, {\n    key: '_loadLast',\n    value: function _loadLast() {\n      if (this.previousColor !== undefined) {\n        this.setColor(this.previousColor, false);\n      } else {\n        alert('There is no last color to load...');\n      }\n    }\n\n    /**\n     * set the color, place the picker\n     * @param {Object} rgba\n     * @param {boolean} [setInitial=true]\n     * @private\n     */\n\n  }, {\n    key: '_setColor',\n    value: function _setColor(rgba) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // store the initial color\n      if (setInitial === true) {\n        this.initialColor = util.extend({}, rgba);\n      }\n\n      this.color = rgba;\n      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);\n\n      var angleConvert = 2 * Math.PI;\n      var radius = this.r * hsv.s;\n      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);\n      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);\n\n      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';\n      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';\n\n      this._updatePicker(rgba);\n    }\n\n    /**\n     * bound to opacity control\n     * @param {number} value\n     * @private\n     */\n\n  }, {\n    key: '_setOpacity',\n    value: function _setOpacity(value) {\n      this.color.a = value / 100;\n      this._updatePicker(this.color);\n    }\n\n    /**\n     * bound to brightness control\n     * @param {number} value\n     * @private\n     */\n\n  }, {\n    key: '_setBrightness',\n    value: function _setBrightness(value) {\n      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.v = value / 100;\n      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba['a'] = this.color.a;\n      this.color = rgba;\n      this._updatePicker();\n    }\n\n    /**\n     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.\n     * @param {Object} rgba\n     * @private\n     */\n\n  }, {\n    key: '_updatePicker',\n    value: function _updatePicker() {\n      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;\n\n      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var ctx = this.colorPickerCanvas.getContext('2d');\n      if (this.pixelRation === undefined) {\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n      }\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n\n      // clear the canvas\n      var w = this.colorPickerCanvas.clientWidth;\n      var h = this.colorPickerCanvas.clientHeight;\n      ctx.clearRect(0, 0, w, h);\n\n      ctx.putImageData(this.hueCircle, 0, 0);\n      ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';\n      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n      ctx.fill();\n\n      this.brightnessRange.value = 100 * hsv.v;\n      this.opacityRange.value = 100 * rgba.a;\n\n      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';\n      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';\n    }\n\n    /**\n     * used by create to set the size of the canvas.\n     * @private\n     */\n\n  }, {\n    key: '_setSize',\n    value: function _setSize() {\n      this.colorPickerCanvas.style.width = '100%';\n      this.colorPickerCanvas.style.height = '100%';\n\n      this.colorPickerCanvas.width = 289 * this.pixelRatio;\n      this.colorPickerCanvas.height = 289 * this.pixelRatio;\n    }\n\n    /**\n     * create all dom elements\n     * TODO: cleanup, lots of similar dom elements\n     * @private\n     */\n\n  }, {\n    key: '_create',\n    value: function _create() {\n      this.frame = document.createElement('div');\n      this.frame.className = 'vis-color-picker';\n\n      this.colorPickerDiv = document.createElement('div');\n      this.colorPickerSelector = document.createElement('div');\n      this.colorPickerSelector.className = 'vis-selector';\n      this.colorPickerDiv.appendChild(this.colorPickerSelector);\n\n      this.colorPickerCanvas = document.createElement('canvas');\n      this.colorPickerDiv.appendChild(this.colorPickerCanvas);\n\n      if (!this.colorPickerCanvas.getContext) {\n        var noCanvas = document.createElement('DIV');\n        noCanvas.style.color = 'red';\n        noCanvas.style.fontWeight = 'bold';\n        noCanvas.style.padding = '10px';\n        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';\n        this.colorPickerCanvas.appendChild(noCanvas);\n      } else {\n        var ctx = this.colorPickerCanvas.getContext('2d');\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        this.colorPickerCanvas.getContext('2d').setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      }\n\n      this.colorPickerDiv.className = 'vis-color';\n\n      this.opacityDiv = document.createElement('div');\n      this.opacityDiv.className = 'vis-opacity';\n\n      this.brightnessDiv = document.createElement('div');\n      this.brightnessDiv.className = 'vis-brightness';\n\n      this.arrowDiv = document.createElement('div');\n      this.arrowDiv.className = 'vis-arrow';\n\n      this.opacityRange = document.createElement('input');\n      try {\n        this.opacityRange.type = 'range'; // Not supported on IE9\n        this.opacityRange.min = '0';\n        this.opacityRange.max = '100';\n      } catch (err) {}\n      // TODO: Add some error handling and remove this lint exception\n      // eslint-disable-line no-empty\n      this.opacityRange.value = '100';\n      this.opacityRange.className = 'vis-range';\n\n      this.brightnessRange = document.createElement('input');\n      try {\n        this.brightnessRange.type = 'range'; // Not supported on IE9\n        this.brightnessRange.min = '0';\n        this.brightnessRange.max = '100';\n      } catch (err) {}\n      // TODO: Add some error handling and remove this lint exception\n      // eslint-disable-line no-empty\n      this.brightnessRange.value = '100';\n      this.brightnessRange.className = 'vis-range';\n\n      this.opacityDiv.appendChild(this.opacityRange);\n      this.brightnessDiv.appendChild(this.brightnessRange);\n\n      var me = this;\n      this.opacityRange.onchange = function () {\n        me._setOpacity(this.value);\n      };\n      this.opacityRange.oninput = function () {\n        me._setOpacity(this.value);\n      };\n      this.brightnessRange.onchange = function () {\n        me._setBrightness(this.value);\n      };\n      this.brightnessRange.oninput = function () {\n        me._setBrightness(this.value);\n      };\n\n      this.brightnessLabel = document.createElement('div');\n      this.brightnessLabel.className = 'vis-label vis-brightness';\n      this.brightnessLabel.innerHTML = 'brightness:';\n\n      this.opacityLabel = document.createElement('div');\n      this.opacityLabel.className = 'vis-label vis-opacity';\n      this.opacityLabel.innerHTML = 'opacity:';\n\n      this.newColorDiv = document.createElement('div');\n      this.newColorDiv.className = 'vis-new-color';\n      this.newColorDiv.innerHTML = 'new';\n\n      this.initialColorDiv = document.createElement('div');\n      this.initialColorDiv.className = 'vis-initial-color';\n      this.initialColorDiv.innerHTML = 'initial';\n\n      this.cancelButton = document.createElement('div');\n      this.cancelButton.className = 'vis-button vis-cancel';\n      this.cancelButton.innerHTML = 'cancel';\n      this.cancelButton.onclick = this._hide.bind(this, false);\n\n      this.applyButton = document.createElement('div');\n      this.applyButton.className = 'vis-button vis-apply';\n      this.applyButton.innerHTML = 'apply';\n      this.applyButton.onclick = this._apply.bind(this);\n\n      this.saveButton = document.createElement('div');\n      this.saveButton.className = 'vis-button vis-save';\n      this.saveButton.innerHTML = 'save';\n      this.saveButton.onclick = this._save.bind(this);\n\n      this.loadButton = document.createElement('div');\n      this.loadButton.className = 'vis-button vis-load';\n      this.loadButton.innerHTML = 'load last';\n      this.loadButton.onclick = this._loadLast.bind(this);\n\n      this.frame.appendChild(this.colorPickerDiv);\n      this.frame.appendChild(this.arrowDiv);\n      this.frame.appendChild(this.brightnessLabel);\n      this.frame.appendChild(this.brightnessDiv);\n      this.frame.appendChild(this.opacityLabel);\n      this.frame.appendChild(this.opacityDiv);\n      this.frame.appendChild(this.newColorDiv);\n      this.frame.appendChild(this.initialColorDiv);\n\n      this.frame.appendChild(this.cancelButton);\n      this.frame.appendChild(this.applyButton);\n      this.frame.appendChild(this.saveButton);\n      this.frame.appendChild(this.loadButton);\n    }\n\n    /**\n     * bind hammer to the color picker\n     * @private\n     */\n\n  }, {\n    key: '_bindHammer',\n    value: function _bindHammer() {\n      var _this2 = this;\n\n      this.drag = {};\n      this.pinch = {};\n      this.hammer = new Hammer(this.colorPickerCanvas);\n      this.hammer.get('pinch').set({ enable: true });\n\n      hammerUtil.onTouch(this.hammer, function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on('tap', function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on('panstart', function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on('panmove', function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on('panend', function (event) {\n        _this2._moveSelector(event);\n      });\n    }\n\n    /**\n     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.\n     * @private\n     */\n\n  }, {\n    key: '_generateHueCircle',\n    value: function _generateHueCircle() {\n      if (this.generated === false) {\n        var ctx = this.colorPickerCanvas.getContext('2d');\n        if (this.pixelRation === undefined) {\n          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        }\n        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n\n        // clear the canvas\n        var w = this.colorPickerCanvas.clientWidth;\n        var h = this.colorPickerCanvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n\n        // draw hue circle\n        var x = void 0,\n            y = void 0,\n            hue = void 0,\n            sat = void 0;\n        this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };\n        this.r = 0.49 * w;\n        var angleConvert = 2 * Math.PI / 360;\n        var hfac = 1 / 360;\n        var sfac = 1 / this.r;\n        var rgb = void 0;\n        for (hue = 0; hue < 360; hue++) {\n          for (sat = 0; sat < this.r; sat++) {\n            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);\n            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);\n            rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);\n            ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';\n            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);\n          }\n        }\n        ctx.strokeStyle = 'rgba(0,0,0,1)';\n        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n        ctx.stroke();\n\n        this.hueCircle = ctx.getImageData(0, 0, w, h);\n      }\n      this.generated = true;\n    }\n\n    /**\n     * move the selector. This is called by hammer functions.\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: '_moveSelector',\n    value: function _moveSelector(event) {\n      var rect = this.colorPickerDiv.getBoundingClientRect();\n      var left = event.center.x - rect.left;\n      var top = event.center.y - rect.top;\n\n      var centerY = 0.5 * this.colorPickerDiv.clientHeight;\n      var centerX = 0.5 * this.colorPickerDiv.clientWidth;\n\n      var x = left - centerX;\n      var y = top - centerY;\n\n      var angle = Math.atan2(x, y);\n      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);\n\n      var newTop = Math.cos(angle) * radius + centerY;\n      var newLeft = Math.sin(angle) * radius + centerX;\n\n      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';\n      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';\n\n      // set color\n      var h = angle / (2 * Math.PI);\n      h = h < 0 ? h + 1 : h;\n      var s = radius / this.r;\n      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.h = h;\n      hsv.s = s;\n      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba['a'] = this.color.a;\n      this.color = rgba;\n\n      // update previews\n      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';\n      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';\n    }\n  }]);\n  return ColorPicker;\n}();\n\nexports['default'] = ColorPicker;\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports, __nested_webpack_require_1264437__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = __nested_webpack_require_1264437__(15);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _classCallCheck2 = __nested_webpack_require_1264437__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1264437__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _FloydWarshall = __nested_webpack_require_1264437__(194);\n\nvar _FloydWarshall2 = _interopRequireDefault(_FloydWarshall);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * KamadaKawai positions the nodes initially based on\n *\n * \"AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS\"\n * -- Tomihisa KAMADA and Satoru KAWAI in 1989\n *\n * Possible optimizations in the distance calculation can be implemented.\n */\nvar KamadaKawai = function () {\n  /**\n   * @param {Object} body\n   * @param {number} edgeLength\n   * @param {number} edgeStrength\n   */\n  function KamadaKawai(body, edgeLength, edgeStrength) {\n    (0, _classCallCheck3['default'])(this, KamadaKawai);\n\n    this.body = body;\n    this.springLength = edgeLength;\n    this.springConstant = edgeStrength;\n    this.distanceSolver = new _FloydWarshall2['default']();\n  }\n\n  /**\n   * Not sure if needed but can be used to update the spring length and spring constant\n   * @param {Object} options\n   */\n\n\n  (0, _createClass3['default'])(KamadaKawai, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (options) {\n        if (options.springLength) {\n          this.springLength = options.springLength;\n        }\n        if (options.springConstant) {\n          this.springConstant = options.springConstant;\n        }\n      }\n    }\n\n    /**\n     * Position the system\n     * @param {Array.<Node>} nodesArray\n     * @param {Array.<vis.Edge>} edgesArray\n     * @param {boolean} [ignoreClusters=false]\n     */\n\n  }, {\n    key: 'solve',\n    value: function solve(nodesArray, edgesArray) {\n      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      // get distance matrix\n      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix\n\n      // get the L Matrix\n      this._createL_matrix(D_matrix);\n\n      // get the K Matrix\n      this._createK_matrix(D_matrix);\n\n      // initial E Matrix\n      this._createE_matrix();\n\n      // calculate positions\n      var threshold = 0.01;\n      var innerThreshold = 1;\n      var iterations = 0;\n      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));\n      var maxInnerIterations = 5;\n\n      var maxEnergy = 1e9;\n      var highE_nodeId = 0,\n          dE_dx = 0,\n          dE_dy = 0,\n          delta_m = 0,\n          subIterations = 0;\n\n      while (maxEnergy > threshold && iterations < maxIterations) {\n        iterations += 1;\n        var _getHighestEnergyNode2 = this._getHighestEnergyNode(ignoreClusters);\n\n        var _getHighestEnergyNode3 = (0, _slicedToArray3['default'])(_getHighestEnergyNode2, 4);\n\n        highE_nodeId = _getHighestEnergyNode3[0];\n        maxEnergy = _getHighestEnergyNode3[1];\n        dE_dx = _getHighestEnergyNode3[2];\n        dE_dy = _getHighestEnergyNode3[3];\n\n        delta_m = maxEnergy;\n        subIterations = 0;\n        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {\n          subIterations += 1;\n          this._moveNode(highE_nodeId, dE_dx, dE_dy);\n          var _getEnergy2 = this._getEnergy(highE_nodeId);\n\n          var _getEnergy3 = (0, _slicedToArray3['default'])(_getEnergy2, 3);\n\n          delta_m = _getEnergy3[0];\n          dE_dx = _getEnergy3[1];\n          dE_dy = _getEnergy3[2];\n        }\n      }\n    }\n\n    /**\n     * get the node with the highest energy\n     * @param {boolean} ignoreClusters\n     * @returns {number[]}\n     * @private\n     */\n\n  }, {\n    key: '_getHighestEnergyNode',\n    value: function _getHighestEnergyNode(ignoreClusters) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var maxEnergy = 0;\n      var maxEnergyNodeId = nodesArray[0];\n      var dE_dx_max = 0,\n          dE_dy_max = 0;\n\n      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {\n        var m = nodesArray[nodeIdx];\n        // by not evaluating nodes with predefined positions we should only move nodes that have no positions.\n        if (nodes[m].predefinedPosition === false || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x === true || nodes[m].options.fixed.y === true) {\n          var _getEnergy4 = this._getEnergy(m),\n              _getEnergy5 = (0, _slicedToArray3['default'])(_getEnergy4, 3),\n              delta_m = _getEnergy5[0],\n              dE_dx = _getEnergy5[1],\n              dE_dy = _getEnergy5[2];\n\n          if (maxEnergy < delta_m) {\n            maxEnergy = delta_m;\n            maxEnergyNodeId = m;\n            dE_dx_max = dE_dx;\n            dE_dy_max = dE_dy;\n          }\n        }\n      }\n\n      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];\n    }\n\n    /**\n     * calculate the energy of a single node\n     * @param {Node.id} m\n     * @returns {number[]}\n     * @private\n     */\n\n  }, {\n    key: '_getEnergy',\n    value: function _getEnergy(m) {\n      var _E_sums$m = (0, _slicedToArray3['default'])(this.E_sums[m], 2),\n          dE_dx = _E_sums$m[0],\n          dE_dy = _E_sums$m[1];\n\n      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));\n      return [delta_m, dE_dx, dE_dy];\n    }\n\n    /**\n     * move the node based on it's energy\n     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai\n     * @param {number} m\n     * @param {number} dE_dx\n     * @param {number} dE_dy\n     * @private\n     */\n\n  }, {\n    key: '_moveNode',\n    value: function _moveNode(m, dE_dx, dE_dy) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var d2E_dx2 = 0;\n      var d2E_dxdy = 0;\n      var d2E_dy2 = 0;\n\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var km = this.K_matrix[m];\n      var lm = this.L_matrix[m];\n\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var kmat = km[i];\n          var lmat = lm[i];\n          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);\n          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);\n          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);\n          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);\n        }\n      }\n      // make the variable names easier to make the solving of the linear system easier to read\n      var A = d2E_dx2,\n          B = d2E_dxdy,\n          C = dE_dx,\n          D = d2E_dy2,\n          E = dE_dy;\n\n      // solve the linear system for dx and dy\n      var dy = (C / A + E / B) / (B / A - D / B);\n      var dx = -(B * dy + C) / A;\n\n      // move the node\n      nodes[m].x += dx;\n      nodes[m].y += dy;\n\n      // Recalculate E_matrix (should be incremental)\n      this._updateE_matrix(m);\n    }\n\n    /**\n     * Create the L matrix: edge length times shortest path\n     * @param {Object} D_matrix\n     * @private\n     */\n\n  }, {\n    key: '_createL_matrix',\n    value: function _createL_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeLength = this.springLength;\n\n      this.L_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.L_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];\n        }\n      }\n    }\n\n    /**\n     * Create the K matrix: spring constants times shortest path\n     * @param {Object} D_matrix\n     * @private\n     */\n\n  }, {\n    key: '_createK_matrix',\n    value: function _createK_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeStrength = this.springConstant;\n\n      this.K_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.K_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);\n        }\n      }\n    }\n\n    /**\n     *  Create matrix with all energies between nodes\n     *  @private\n     */\n\n  }, {\n    key: '_createE_matrix',\n    value: function _createE_matrix() {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      this.E_matrix = {};\n      this.E_sums = {};\n      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {\n        this.E_matrix[nodesArray[mIdx]] = [];\n      }\n      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {\n        var m = nodesArray[_mIdx];\n        var x_m = nodes[m].x;\n        var y_m = nodes[m].y;\n        var dE_dx = 0;\n        var dE_dy = 0;\n        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {\n          var i = nodesArray[iIdx];\n          if (i !== m) {\n            var x_i = nodes[i].x;\n            var y_i = nodes[i].y;\n            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];\n            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];\n            dE_dx += this.E_matrix[m][iIdx][0];\n            dE_dy += this.E_matrix[m][iIdx][1];\n          }\n        }\n        //Store sum\n        this.E_sums[m] = [dE_dx, dE_dy];\n      }\n    }\n\n    /**\n     * Update method, just doing single column (rows are auto-updated) (update all sums)\n     *\n     * @param {number} m\n     * @private\n     */\n\n  }, {\n    key: '_updateE_matrix',\n    value: function _updateE_matrix(m) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var colm = this.E_matrix[m];\n      var kcolm = this.K_matrix[m];\n      var lcolm = this.L_matrix[m];\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var dE_dx = 0;\n      var dE_dy = 0;\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          //Keep old energy value for sum modification below\n          var cell = colm[iIdx];\n          var oldDx = cell[0];\n          var oldDy = cell[1];\n\n          //Calc new energy:\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);\n          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);\n          colm[iIdx] = [dx, dy];\n          dE_dx += dx;\n          dE_dy += dy;\n\n          //add new energy to sum of each column\n          var sum = this.E_sums[i];\n          sum[0] += dx - oldDx;\n          sum[1] += dy - oldDy;\n        }\n      }\n      //Store sum at -1 index\n      this.E_sums[m] = [dE_dx, dE_dy];\n    }\n  }]);\n  return KamadaKawai;\n}(); // distance finding algorithm\n\n\nexports['default'] = KamadaKawai;\n\n/***/ }),\n/* 194 */\n/***/ (function(module, exports, __nested_webpack_require_1275973__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = __nested_webpack_require_1275973__(0);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __nested_webpack_require_1275973__(1);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n *  The FloydWarshall algorithm is an algorithm for finding shortest paths in\n *  a weighted graph with positive or negative edge weights (but with no negative\n *  cycles). - https://en.wikipedia.org/wiki/FloydWarshall_algorithm\n */\nvar FloydWarshall = function () {\n  /**\n   * @ignore\n   */\n  function FloydWarshall() {\n    (0, _classCallCheck3[\"default\"])(this, FloydWarshall);\n  }\n\n  /**\n   *\n   * @param {Object} body\n   * @param {Array.<Node>} nodesArray\n   * @param {Array.<Edge>} edgesArray\n   * @returns {{}}\n   */\n\n\n  (0, _createClass3[\"default\"])(FloydWarshall, [{\n    key: \"getDistances\",\n    value: function getDistances(body, nodesArray, edgesArray) {\n      var D_matrix = {};\n      var edges = body.edges;\n\n      // prepare matrix with large numbers\n      for (var i = 0; i < nodesArray.length; i++) {\n        var node = nodesArray[i];\n        var cell = {};\n        D_matrix[node] = cell;\n        for (var j = 0; j < nodesArray.length; j++) {\n          cell[nodesArray[j]] = i == j ? 0 : 1e9;\n        }\n      }\n\n      // put the weights for the edges in. This assumes unidirectionality.\n      for (var _i = 0; _i < edgesArray.length; _i++) {\n        var edge = edges[edgesArray[_i]];\n        // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix\n        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {\n          D_matrix[edge.fromId][edge.toId] = 1;\n          D_matrix[edge.toId][edge.fromId] = 1;\n        }\n      }\n\n      var nodeCount = nodesArray.length;\n\n      // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.\n      for (var k = 0; k < nodeCount; k++) {\n        var knode = nodesArray[k];\n        var kcolm = D_matrix[knode];\n        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {\n          var inode = nodesArray[_i2];\n          var icolm = D_matrix[inode];\n          for (var _j = _i2 + 1; _j < nodeCount; _j++) {\n            var jnode = nodesArray[_j];\n            var jcolm = D_matrix[jnode];\n\n            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);\n            icolm[jnode] = val;\n            jcolm[inode] = val;\n          }\n        }\n      }\n\n      return D_matrix;\n    }\n  }]);\n  return FloydWarshall;\n}();\n\nexports[\"default\"] = FloydWarshall;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=vis.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9jYWNoZS92aXNqcy1uZXR3b3JrLW5wbS00LjI1LjAtMmU5MGVmYWVlZC00MGJmY2JiZjJiLnppcC9ub2RlX21vZHVsZXMvdmlzanMtbmV0d29yay9kaXN0L3Zpcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUtvQjtBQUMxQixDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSwrQkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSwrQkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsK0JBQW1CO0FBQzdCLGVBQWUsK0JBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLCtCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0JBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSwrQkFBbUI7QUFDN0I7QUFDQTtBQUNBLGlCQUFpQiwrQkFBbUIsQ0FBQywrQkFBbUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQywrQkFBbUI7O0FBRXBEOzs7QUFHQTs7QUFFQSxzQkFBc0IsK0JBQW1COztBQUV6Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsK0JBQW1COztBQUVwRDs7O0FBR0Esb0JBQW9CLCtCQUFtQjs7QUFFdkM7O0FBRUEsY0FBYywrQkFBbUI7O0FBRWpDOztBQUVBLFlBQVksK0JBQW1COztBQUUvQjs7QUFFQSxlQUFlLCtCQUFtQjs7QUFFbEM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLCtCQUFtQjtBQUNoQyxXQUFXLCtCQUFtQjs7QUFFOUI7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0MsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw4REFBOEQ7QUFDekUsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsVUFBVTtBQUNWLG9EQUFvRDtBQUNwRDtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsVUFBVTtBQUNWLGlDQUFpQztBQUNqQztBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsVUFBVTtBQUNWLDBDQUEwQztBQUMxQztBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxVQUFVO0FBQ1YsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0EsSUFBSTtBQUNKLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QixJQUFJO0FBQ0osK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixFQUFFLGVBQWUsRUFBRTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUk7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSw2QkFBNkI7QUFDekMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsZ0VBQWdFO0FBQ3JJOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRCxtQkFBbUIsV0FBVyxnQ0FBbUI7O0FBRWpELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQTs7QUFFQSxlQUFlLGdDQUFtQjs7QUFFbEM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0E7O0FBRUEsc0JBQXNCLGdDQUFtQjs7QUFFekM7O0FBRUEsY0FBYyxnQ0FBbUI7O0FBRWpDOztBQUVBLGVBQWUsZ0NBQW1COztBQUVsQzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qix3Q0FBd0M7OztBQUd4QyxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0E7O0FBRUEsZ0JBQWdCLGdDQUFtQjs7QUFFbkM7O0FBRUEsY0FBYyxnQ0FBbUI7O0FBRWpDOztBQUVBLGtIQUFrSCxxQkFBcUIsbUJBQW1COztBQUUxSix1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQsWUFBWSxnQ0FBbUI7QUFDL0IsVUFBVSxnQ0FBbUI7QUFDN0IsYUFBYSxnQ0FBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBELG1CQUFtQixXQUFXLGdDQUFtQjs7QUFFakQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7O0FBRzFDLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBELGFBQWEsZ0NBQW1CO0FBQ2hDLFdBQVcsZ0NBQW1CO0FBQzlCLFVBQVUsZ0NBQW1CO0FBQzdCLFdBQVcsZ0NBQW1CO0FBQzlCLFVBQVUsZ0NBQW1CO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQsZUFBZSxnQ0FBbUI7QUFDbEMscUJBQXFCLGdDQUFtQjtBQUN4QyxrQkFBa0IsZ0NBQW1CO0FBQ3JDOztBQUVBLFlBQVksZ0NBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEO0FBQ0Esa0JBQWtCLGdDQUFtQjtBQUNyQyxpQ0FBaUMsU0FBUyxtQkFBbUIsYUFBYTtBQUMxRSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0E7O0FBRUEsbUJBQW1CLGdDQUFtQjs7QUFFdEM7O0FBRUEsb0JBQW9CLGdDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELCtCQUErQjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSxnQ0FBbUI7O0FBRWxDOztBQUVBLHVCQUF1QixnQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixnQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxjQUFjO0FBQzdCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsY0FBYztBQUM3Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLGNBQWM7QUFDN0I7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsY0FBYztBQUM3Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLGNBQWM7QUFDN0I7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxjQUFjO0FBQzdCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLGNBQWM7QUFDN0I7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsa0JBQWtCO0FBQ2xCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9COztBQUVBLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQixnQ0FBbUI7O0FBRXpDOztBQUVBLHVCQUF1QixnQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixnQ0FBbUI7O0FBRXZDOztBQUVBLGtDQUFrQyxnQ0FBbUI7O0FBRXJEOztBQUVBLGlCQUFpQixnQ0FBbUI7O0FBRXBDOztBQUVBLGlCQUFpQixnQ0FBbUI7O0FBRXBDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVEsU0FBUyx3QkFBd0I7QUFDdEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsY0FBYztBQUM3QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEO0FBQ0EsY0FBYyxnQ0FBbUI7QUFDakMsY0FBYyxnQ0FBbUI7QUFDakM7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRCxTQUFTLGdDQUFtQjtBQUM1QixpQkFBaUIsZ0NBQW1CO0FBQ3BDLGlCQUFpQixnQ0FBbUI7QUFDcEM7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRCxlQUFlLGdDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRCxtQkFBbUIsV0FBVyxnQ0FBbUI7O0FBRWpELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLG1DQUFtQyxnQ0FBbUI7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7QUFDQSxZQUFZLGdDQUFtQjtBQUMvQixrQkFBa0IsZ0NBQW1COztBQUVyQztBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDtBQUNBLGNBQWMsZ0NBQW1CO0FBQ2pDO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQsbUJBQW1CLFdBQVcsZ0NBQW1COztBQUVqRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxjQUFjOzs7QUFHZCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0EsaUJBQWlCLGdDQUFtQjs7QUFFcEM7O0FBRUEsZUFBZSxnQ0FBbUI7O0FBRWxDOztBQUVBLFlBQVksZ0NBQW1COztBQUUvQjs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxXQUFXLGdDQUFtQjtBQUM5QixZQUFZLGdDQUFtQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRCxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixpREFBaUQ7QUFDakQsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0QsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLHFDQUFxQyxRQUFRO0FBQzdDLHFDQUFxQyxlQUFlO0FBQ3BELHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQixJQUFJLHFCQUFxQjtBQUN6QixJQUFJLFFBQVE7QUFDWixJQUFJLFFBQVE7QUFDWjtBQUNBLElBQUkseUJBQXlCO0FBQzdCLElBQUksVUFBVTtBQUNkLElBQUksVUFBVTtBQUNkLElBQUksbUJBQW1CO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGlDQUFpQyxVQUFVO0FBQzNDLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGlDQUFpQyx5QkFBeUI7QUFDMUQsaUNBQWlDLFVBQVU7QUFDM0MsaUNBQWlDLFVBQVU7QUFDM0MsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsaUNBQWlDLHlCQUF5QjtBQUMxRCxpQ0FBaUMsVUFBVTtBQUMzQyxpQ0FBaUMsVUFBVTtBQUMzQyxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGtEQUFrRDtBQUM3RDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsMENBQTBDO0FBQ3hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLDRCQUE0Qjs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxXQUFXLGlDQUFtQjs7QUFFOUIsWUFBWSxpQ0FBbUI7QUFDL0Isb0JBQW9CLGlDQUFtQjtBQUN2QyxVQUFVLGlDQUFtQjtBQUM3QixhQUFhLGlDQUFtQjtBQUNoQyxvQkFBb0IsaUNBQW1CO0FBQ3ZDLGVBQWUsaUNBQW1CO0FBQ2xDLGNBQWMsaUNBQW1CO0FBQ2pDLFVBQVUsaUNBQW1CO0FBQzdCLGNBQWMsaUNBQW1CO0FBQ2pDLFdBQVcsaUNBQW1CO0FBQzlCLFlBQVksaUNBQW1CO0FBQy9CLGFBQWEsaUNBQW1CO0FBQ2hDLGNBQWMsaUNBQW1CO0FBQ2pDLFdBQVcsaUNBQW1CO0FBQzlCLFdBQVcsaUNBQW1CO0FBQzlCLGVBQWUsaUNBQW1CO0FBQ2xDLG1CQUFtQixpQ0FBbUI7O0FBRXRDLGVBQWUsaUNBQW1CO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxnREFBZ0Q7QUFDckUsYUFBYSxRQUFRLHFEQUFxRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0IsK0hBQStILGVBQWUsd0VBQXdFLE9BQU87QUFDL087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsMENBQTBDO0FBQzNEOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixhQUFhO0FBQzdCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixhQUFhO0FBQzdCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7O0FBRUEseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUSxpQkFBaUI7QUFDeEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNFQUFzRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0U7QUFDcEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSxpQ0FBbUI7O0FBRWxDOztBQUVBLHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLFdBQVcsaUNBQW1COztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUyxzREFBc0Q7QUFDOUUsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRyxxQkFBcUI7QUFDdkMsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxpQ0FBbUI7QUFDbkIsYUFBYSxpQ0FBbUI7QUFDaEMsV0FBVyxpQ0FBbUI7QUFDOUIsZ0JBQWdCLGlDQUFtQjtBQUNuQyxvQkFBb0IsaUNBQW1COztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQSxlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQSxlQUFlLGlDQUFtQjtBQUNsQyxVQUFVLGlDQUFtQjtBQUM3QixrQkFBa0IsaUNBQW1CO0FBQ3JDLGVBQWUsaUNBQW1CO0FBQ2xDLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpQ0FBbUI7QUFDckIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxhQUFhLGlDQUFtQjtBQUNoQyxVQUFVLGlDQUFtQjtBQUM3QjtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELFdBQVcsaUNBQW1CO0FBQzlCLGFBQWEsaUNBQW1CO0FBQ2hDO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLHFFQUFxRTtBQUNyRSxDQUFDO0FBQ0Q7QUFDQSxRQUFRLGlDQUFtQjtBQUMzQjtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxVQUFVLGlDQUFtQjtBQUM3QixVQUFVLGlDQUFtQjtBQUM3QixVQUFVLGlDQUFtQjs7QUFFN0I7QUFDQSxxRUFBcUUsZ0NBQWdDO0FBQ3JHOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQSxVQUFVLGlDQUFtQjs7QUFFN0I7QUFDQSxpQ0FBbUI7QUFDbkIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFdBQVc7QUFDWCxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxZQUFZLGlDQUFtQjs7O0FBRy9CLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELGFBQWEsaUNBQW1CO0FBQ2hDLFdBQVcsaUNBQW1CO0FBQzlCLGNBQWMsaUNBQW1CO0FBQ2pDLGFBQWEsaUNBQW1CO0FBQ2hDLHFCQUFxQixpQ0FBbUI7QUFDeEM7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGLG1GQUFtRix1QkFBdUI7QUFDMUc7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0EsWUFBWSxpQ0FBbUI7O0FBRS9COztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLFdBQVcsaUNBQW1CO0FBQzlCLGNBQWMsaUNBQW1COztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0Esd0JBQXdCO0FBQ3hCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwrQ0FBK0M7QUFDN0U7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsK0NBQStDO0FBQzdFLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBMEM7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckIsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSxRQUFRO0FBQ1osaUNBQWlDLFFBQVE7QUFDekM7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFELGlDQUFpQyxVQUFVO0FBQzNDLGlDQUFpQyxVQUFVO0FBQzNDLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsaUNBQWlDLFVBQVU7QUFDM0MsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsaUNBQWlDLHlCQUF5QjtBQUMxRCxpQ0FBaUMsVUFBVTtBQUMzQyxpQ0FBaUMsVUFBVTtBQUMzQyxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0EsZ0NBQWdDLDBEQUEwRDtBQUMxRjtBQUNBO0FBQ0EsZ0NBQWdDLDBDQUEwQztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQUssRUFRTjtBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsTUFBTSxpQ0FBaUM7QUFDbEU7QUFDQSxpQkFBaUIsU0FBUyxNQUFNLGlDQUFpQztBQUNqRTtBQUNBLGlCQUFpQixVQUFVLE1BQU0saUJBQWlCO0FBQ2xEO0FBQ0EsaUJBQWlCLFdBQVcsTUFBTSxrQkFBa0I7QUFDcEQ7QUFDQSxpQkFBaUIsVUFBVSxNQUFNLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQ0FBb0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCLGlDQUFtQjs7QUFFekM7O0FBRUEsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsa0NBQWtDLGlDQUFtQjs7QUFFckQ7O0FBRUEsaUJBQWlCLGlDQUFtQjs7QUFFcEM7O0FBRUEsaUJBQWlCLGlDQUFtQjs7QUFFcEM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyxvQkFBb0I7QUFDMUMsZUFBZSxpQkFBaUIsc0JBQXNCO0FBQ3REOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0I7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLGNBQWM7QUFDN0I7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLGlDQUFtQjs7QUFFcEM7O0FBRUEsZUFBZSxpQ0FBbUI7O0FBRWxDOztBQUVBLFlBQVksaUNBQW1COztBQUUvQjs7QUFFQSx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxXQUFXLGlDQUFtQjs7QUFFOUI7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSw2RUFBNkU7QUFDNUYsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0MsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQyxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGlCQUFpQixpQ0FBbUI7O0FBRXBDOztBQUVBLGVBQWUsaUNBQW1COztBQUVsQzs7QUFFQSxjQUFjLGlDQUFtQjs7QUFFakM7O0FBRUEsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsV0FBVyxpQ0FBbUI7QUFDOUIsWUFBWSxpQ0FBbUI7QUFDL0Isb0JBQW9CLGlDQUFtQjtBQUN2QyxzQkFBc0IsaUNBQW1CO0FBQ3pDLHdCQUF3QixpQ0FBbUI7QUFDM0MsdUJBQXVCLGlDQUFtQjtBQUMxQyxtQkFBbUIsaUNBQW1COztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IseUJBQXlCOztBQUV6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsY0FBYztBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVEsaUJBQWlCO0FBQ3hDLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0I7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxNQUFNO0FBQ3JCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQiwwQ0FBMEM7QUFDM0Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsYUFBYTtBQUM3Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUiwrRUFBK0U7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlGQUFpRjtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUiwrRUFBK0U7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQixpQ0FBbUI7O0FBRXpDOztBQUVBLHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLGtDQUFrQyxpQ0FBbUI7O0FBRXJEOztBQUVBLGlCQUFpQixpQ0FBbUI7O0FBRXBDOztBQUVBLGlCQUFpQixpQ0FBbUI7O0FBRXBDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLE1BQU07QUFDbkIsZUFBZTtBQUNmO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLEdBQUcsS0FBSyxFQUFFO0FBQzNCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLFdBQVcsaUNBQW1COztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsY0FBYztBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0Isa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxlQUFlLFFBQVEsU0FBUztBQUNoQyxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELG1CQUFtQixXQUFXLGlDQUFtQjs7QUFFakQsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQSxVQUFVLGlDQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsY0FBYyxpQ0FBbUI7QUFDakMsY0FBYyxpQ0FBbUI7QUFDakMsZUFBZSxpQ0FBbUI7QUFDbEMsV0FBVyxpQ0FBbUI7QUFDOUIsZ0JBQWdCLGlDQUFtQjtBQUNuQyxrQkFBa0IsaUNBQW1CO0FBQ3JDLHFCQUFxQixpQ0FBbUI7QUFDeEMscUJBQXFCLGlDQUFtQjtBQUN4QyxlQUFlLGlDQUFtQjtBQUNsQywrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4Q0FBOEM7QUFDOUMsTUFBTSw0QkFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0EsZ0JBQWdCLGlDQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELGtCQUFrQixpQ0FBbUIsU0FBUyxpQ0FBbUI7QUFDakUsK0JBQStCLGlDQUFtQixvQkFBb0IsbUJBQW1CLGFBQWE7QUFDdEcsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsZUFBZSxpQ0FBbUI7QUFDbEMsZUFBZSxpQ0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsaUJBQWlCLGlDQUFtQjs7O0FBR3BDLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELFVBQVUsaUNBQW1CO0FBQzdCLGdCQUFnQixpQ0FBbUI7QUFDbkMsbUJBQW1CLGlDQUFtQjtBQUN0QyxlQUFlLGlDQUFtQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDtBQUNBLFVBQVUsaUNBQW1CO0FBQzdCLGVBQWUsaUNBQW1CO0FBQ2xDLGVBQWUsaUNBQW1CO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0EsVUFBVSxpQ0FBbUI7QUFDN0IsVUFBVSxpQ0FBbUI7QUFDN0I7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksWUFBWTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQSxjQUFjLGlDQUFtQjtBQUNqQyxXQUFXLGlDQUFtQjtBQUM5QixZQUFZLGlDQUFtQjtBQUMvQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0EsWUFBWSxpQ0FBbUI7QUFDL0IsaUJBQWlCLGlDQUFtQjs7QUFFcEM7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxVQUFVLGlDQUFtQjtBQUM3QixpQkFBaUIsaUNBQW1CO0FBQ3BDLGdCQUFnQixpQ0FBbUI7QUFDbkMsa0JBQWtCLGlDQUFtQjtBQUNyQyxVQUFVLGlDQUFtQjtBQUM3QixxQkFBcUIsaUNBQW1CO0FBQ3hDOztBQUVBLFlBQVksaUNBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0Esc0VBQXNFLGlDQUFtQjs7QUFFekYsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLDJCQUEyQixHQUFHLDZDQUE2QztBQUNsRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQyxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0EsY0FBYyxpQ0FBbUI7O0FBRWpDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLDZCQUE2QixVQUFVO0FBQ3ZDLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0YsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxlQUFlO0FBQ2YsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQ0FBb0MsVUFBVSxVQUFVO0FBQ3hEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVywwQkFBMEI7QUFDckMsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBLG1DQUFtQyxTQUFTOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLE1BQU07QUFDTixvQkFBb0I7QUFDcEIsTUFBTTtBQUNOLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQiwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRCxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hELG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hELG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQSx1QkFBdUIsc0NBQXNDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DLE9BQU87QUFDcEUsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLEtBQUs7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOENBQThDO0FBQ25FLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLG1CQUFtQixpQ0FBbUI7O0FBRXRDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxzQkFBc0IsaUNBQW1COztBQUV6Qzs7QUFFQSxlQUFlLGlDQUFtQjs7QUFFbEM7O0FBRUEsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsV0FBVyxpQ0FBbUI7QUFDOUIsb0JBQW9CLGlDQUFtQjtBQUN2QyxvQkFBb0IsaUNBQW1COztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUEyRDtBQUMzRTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QyxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsZUFBZTtBQUNoQztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixVQUFVO0FBQ1Y7QUFDQSwrQkFBK0I7QUFDL0IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsa0JBQWtCO0FBQ2xCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixnREFBZ0Q7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixrQkFBa0IsMkdBQTJHLE9BQU87QUFDcEk7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsbUJBQW1CLFdBQVcsaUNBQW1COztBQUVqRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCLGlDQUFtQjs7QUFFekM7O0FBRUEsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsV0FBVyxpQ0FBbUI7QUFDOUIsZ0JBQWdCLGlDQUFtQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQix1QkFBdUI7QUFDdkMsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLHVCQUF1QjtBQUN2QyxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsUUFBUTtBQUN2QixrQkFBa0I7QUFDbEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsa0JBQWtCLFFBQVEsZ0NBQWdDLFdBQVcsZ0NBQWdDO0FBQ3JHOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxjQUFjO0FBQzdCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixrQkFBa0IsaUJBQWlCLHFCQUFxQjtBQUN4RDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUEscUVBQXFFO0FBQ3JFLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxjQUFjO0FBQzdCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLGNBQWM7QUFDN0I7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxjQUFjO0FBQzdCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGdCQUFnQix5RUFBeUUsT0FBTyxnTkFBZ04sT0FBTyxnRUFBZ0UsT0FBTyx5RkFBeUYsT0FBTywwTEFBMEwsUUFBUSwwRkFBMEYsZ0JBQWdCLGlLQUFpSyxlQUFlLGNBQWM7QUFDeDhCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxlQUFlO0FBQzlCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCLGlDQUFtQjs7QUFFekM7O0FBRUEsa0NBQWtDLGlDQUFtQjs7QUFFckQ7O0FBRUEsaUJBQWlCLGlDQUFtQjs7QUFFcEM7O0FBRUEsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZLElBQUksZUFBZSxJQUFJLGVBQWUsSUFBSSxnQkFBZ0I7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYSxJQUFJLGNBQWMsSUFBSSxlQUFlLElBQUksZUFBZTs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWUsSUFBSSxlQUFlLElBQUksZ0JBQWdCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsSUFBSSxlQUFlLElBQUksYUFBYTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjLElBQUksZUFBZSxJQUFJLG1CQUFtQixJQUFJLGtCQUFrQjs7QUFFcEc7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjLElBQUksZUFBZSxJQUFJLGtCQUFrQixJQUFJLGlCQUFpQjs7QUFFbEc7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZLElBQUksa0JBQWtCLElBQUksYUFBYSxJQUFJLGlCQUFpQjs7QUFFOUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlLElBQUksZUFBZSxJQUFJLGdCQUFnQixJQUFJLFlBQVk7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsMkJBQTJCO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsT0FBTyxlQUFlLHFCQUFxQix3QkFBd0IsdURBQXVELDZDQUE2QyxXQUFXLDREQUE0RDtBQUNoUTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQSxpQkFBaUIsZ0RBQWdEO0FBQ2pFO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsaUJBQWlCLGlDQUFtQjs7QUFFcEMsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixjQUFjLHFFQUFxRTtBQUNuRixpQkFBaUIsVUFBVTtBQUMzQixrQkFBa0IsZUFBZTtBQUNqQyxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHVCQUF1QixnQkFBZ0I7QUFDdkMsZ0JBQWdCLG1CQUFtQjtBQUNuQyxvQkFBb0I7QUFDcEIsT0FBTztBQUNQO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsdUJBQXVCLGdCQUFnQjtBQUN2QyxnQkFBZ0IsbUJBQW1CO0FBQ25DLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1A7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLGdCQUFnQixtQkFBbUI7QUFDbkMsb0JBQW9CO0FBQ3BCLE9BQU87QUFDUCxrQkFBa0I7QUFDbEIsS0FBSztBQUNMLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsZUFBZSxnQkFBZ0I7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsZ0JBQWdCLDZCQUE2QjtBQUM3QyxrQkFBa0I7QUFDbEIsS0FBSztBQUNMO0FBQ0EsZUFBZSx1Q0FBdUM7QUFDdEQsY0FBYyx1Q0FBdUM7QUFDckQsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLG1CQUFtQixnQkFBZ0I7QUFDbkMsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCLCtDQUErQztBQUNoRSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixvQkFBb0IsZ0JBQWdCO0FBQ3BDLHFCQUFxQixnQkFBZ0I7QUFDckMscUJBQXFCLGdCQUFnQjtBQUNyQyxlQUFlLG1EQUFtRDtBQUNsRSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZUFBZSxnQkFBZ0I7QUFDL0IsbUJBQW1CLGdCQUFnQjtBQUNuQyxvQkFBb0I7QUFDcEIsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZUFBZSxnQkFBZ0I7QUFDL0IsbUJBQW1CLGdCQUFnQjtBQUNuQyxvQkFBb0I7QUFDcEIsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZUFBZSxnQkFBZ0I7QUFDL0IsbUJBQW1CLGdCQUFnQjtBQUNuQyxvQkFBb0I7QUFDcEIsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZUFBZSxnQkFBZ0I7QUFDL0IsbUJBQW1CLGdCQUFnQjtBQUNuQyxvQkFBb0I7QUFDcEIsT0FBTztBQUNQLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsY0FBYyxlQUFlO0FBQzdCLGtCQUFrQix3Q0FBd0M7QUFDMUQsYUFBYSx3Q0FBd0M7QUFDckQsMEJBQTBCLGVBQWU7QUFDekMsY0FBYyx3Q0FBd0M7QUFDdEQsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixzQkFBc0IsZ0JBQWdCO0FBQ3RDLHlCQUF5QixnQkFBZ0I7QUFDekMsb0JBQW9CO0FBQ3BCLE9BQU87QUFDUCwrQkFBK0Isd0JBQXdCO0FBQ3ZELGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsc0JBQXNCLHdDQUF3QztBQUM5RCx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsZUFBZSxnQkFBZ0I7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxnQkFBZ0I7QUFDM0Isa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxhQUFhLHdDQUF3QztBQUNyRCxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsZ0JBQWdCLGVBQWU7QUFDL0IsdUJBQXVCLGVBQWU7QUFDdEMsdUJBQXVCLGVBQWU7QUFDdEMsdUJBQXVCLGVBQWU7QUFDdEMsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGdCQUFnQjtBQUM3QixnQkFBZ0IsZ0JBQWdCO0FBQ2hDLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1Asc0JBQXNCLGVBQWU7QUFDckMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxtQkFBbUIsZUFBZTtBQUNsQyx5QkFBeUIsZUFBZTtBQUN4QyxrQkFBa0IsZUFBZTtBQUNqQyw0QkFBNEIsZUFBZTtBQUMzQywyQkFBMkIsZUFBZTtBQUMxQyxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixlQUFlO0FBQy9CLGlCQUFpQixnQkFBZ0I7QUFDakMsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBLGtCQUFrQix3Q0FBd0M7QUFDMUQsc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQyx5QkFBeUIsZ0JBQWdCO0FBQ3pDLHFCQUFxQixnQkFBZ0I7QUFDckMscUJBQXFCLGdCQUFnQjtBQUNyQyx1QkFBdUIsZUFBZTtBQUN0QywwQkFBMEIsZUFBZTtBQUN6Qyw4QkFBOEIsZUFBZTtBQUM3QyxtQkFBbUIsa0NBQWtDO0FBQ3JELG9CQUFvQixpQ0FBaUM7QUFDckQsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLHVCQUF1QixlQUFlO0FBQ3RDLGVBQWUsdUNBQXVDO0FBQ3RELGVBQWUsdUNBQXVDO0FBQ3RELGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pELGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsa0JBQWtCLHVDQUF1QztBQUN6RCxrQkFBa0IsdUNBQXVDO0FBQ3pEO0FBQ0EsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkMsMkJBQTJCLHdDQUF3QztBQUNuRSxtQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0EsZUFBZSx1Q0FBdUM7QUFDdEQsY0FBYyx1Q0FBdUM7QUFDckQsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEMsc0JBQXNCLGdCQUFnQjtBQUN0QyxvQkFBb0I7QUFDcEIsT0FBTztBQUNQO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxzQkFBc0IsZ0JBQWdCO0FBQ3RDLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1Asa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsZ0JBQWdCO0FBQzlCLG9CQUFvQixnQkFBZ0I7QUFDcEMscUJBQXFCLGdCQUFnQjtBQUNyQyxxQkFBcUIsZ0JBQWdCO0FBQ3JDLGlCQUFpQixnQkFBZ0I7QUFDakMsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQWdCLGdCQUFnQjtBQUNoQyxlQUFlLGdCQUFnQjtBQUMvQixtQkFBbUIsZ0JBQWdCO0FBQ25DLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQWdCLGdCQUFnQjtBQUNoQyxlQUFlLGdCQUFnQjtBQUMvQixtQkFBbUIsZ0JBQWdCO0FBQ25DLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQWdCLGdCQUFnQjtBQUNoQyxlQUFlLGdCQUFnQjtBQUMvQixtQkFBbUIsZ0JBQWdCO0FBQ25DLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQWdCLGdCQUFnQjtBQUNoQyxlQUFlLGdCQUFnQjtBQUMvQixtQkFBbUIsZ0JBQWdCO0FBQ25DLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1Asa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxhQUFhLHdEQUF3RDtBQUNyRTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsZ0JBQWdCLGdCQUFnQjtBQUNoQyxrQkFBa0I7QUFDbEIsS0FBSztBQUNMLGNBQWMsZUFBZTtBQUM3QjtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsZ0JBQWdCO0FBQzlCLGVBQWUsZ0JBQWdCO0FBQy9CLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQSxrQkFBa0Isd0NBQXdDO0FBQzFELG9CQUFvQix3Q0FBd0M7QUFDNUQsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxhQUFhLHdDQUF3QztBQUNyRCwwQkFBMEIsZUFBZTtBQUN6QyxhQUFhLHdDQUF3QztBQUNyRDtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWUsZ0JBQWdCO0FBQy9CLGdCQUFnQixnQkFBZ0I7QUFDaEMsY0FBYyxnQkFBZ0I7QUFDOUIsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxZQUFZLGdCQUFnQjtBQUM1QixlQUFlLGVBQWU7QUFDOUI7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLHNCQUFzQixnQkFBZ0I7QUFDdEMseUJBQXlCLGdCQUFnQjtBQUN6QyxvQkFBb0I7QUFDcEIsT0FBTztBQUNQLCtCQUErQix3QkFBd0I7QUFDdkQsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLGVBQWUsZ0JBQWdCO0FBQy9CLGNBQWMsZ0JBQWdCO0FBQzlCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsZ0JBQWdCO0FBQzNCLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQsc0JBQXNCLGdCQUFnQjtBQUN0Qyx1QkFBdUIsZUFBZTtBQUN0QyxzQkFBc0IsZUFBZTtBQUNyQyw0QkFBNEIsZUFBZTtBQUMzQyxrQkFBa0I7QUFDbEIsS0FBSztBQUNMLFlBQVksZ0JBQWdCO0FBQzVCLGFBQWEsa0RBQWtEO0FBQy9ELGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsU0FBUyxnQkFBZ0I7QUFDekIsU0FBUyxnQkFBZ0I7QUFDekIsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0Msd0JBQXdCLGdCQUFnQjtBQUN4QyxzQkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF3QixnQkFBZ0I7QUFDeEMsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsZ0JBQWdCO0FBQ3RDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DLHdCQUF3QixnQkFBZ0I7QUFDeEMsc0JBQXNCLGdCQUFnQjtBQUN0Qyx3QkFBd0IsZ0JBQWdCO0FBQ3hDLGlCQUFpQixnQkFBZ0I7QUFDakMsc0JBQXNCLGdCQUFnQjtBQUN0QyxrQkFBa0I7QUFDbEIsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QyxzQkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF3QixnQkFBZ0I7QUFDeEMsc0JBQXNCLGdCQUFnQjtBQUN0QyxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLHNCQUFzQixnQkFBZ0I7QUFDdEMsd0JBQXdCLGdCQUFnQjtBQUN4QyxzQkFBc0IsZ0JBQWdCO0FBQ3RDLGlCQUFpQixnQkFBZ0I7QUFDakMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxtQkFBbUIsZ0JBQWdCO0FBQ25DLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLG9CQUFvQixnQkFBZ0I7QUFDcEMsd0JBQXdCLGdCQUFnQjtBQUN4QywwQkFBMEIsZUFBZTtBQUN6QyxhQUFhLGVBQWU7QUFDNUIsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTCxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLHdCQUF3QixlQUFlO0FBQ3ZDLGdCQUFnQjtBQUNoQixHQUFHOztBQUVIO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLGVBQWU7QUFDL0IsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSCxZQUFZLGdCQUFnQjtBQUM1QixXQUFXLGdCQUFnQjtBQUMzQixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSw2REFBNkQ7QUFDekUsZ0JBQWdCLDZEQUE2RDtBQUM3RSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQSxXQUFXLGlDQUFtQjs7QUFFOUI7QUFDQSxxQkFBcUIsaUNBQW1COztBQUV4QyxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxpQ0FBbUI7QUFDbkIsaUNBQW1CO0FBQ25CLGlCQUFpQixpQ0FBbUI7OztBQUdwQyxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQSx1QkFBdUIsaUNBQW1CO0FBQzFDLFdBQVcsaUNBQW1CO0FBQzlCLGdCQUFnQixpQ0FBbUI7QUFDbkMsZ0JBQWdCLGlDQUFtQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQW1CO0FBQ3BDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0JBQStCOzs7QUFHL0IsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQSxhQUFhLGlDQUFtQjtBQUNoQyxpQkFBaUIsaUNBQW1CO0FBQ3BDLHFCQUFxQixpQ0FBbUI7QUFDeEM7O0FBRUE7QUFDQSxpQ0FBbUIsd0JBQXdCLGlDQUFtQiwrQkFBK0IsY0FBYzs7QUFFM0c7QUFDQSxzREFBc0QsMkJBQTJCO0FBQ2pGO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELFNBQVMsaUNBQW1CO0FBQzVCLGVBQWUsaUNBQW1CO0FBQ2xDLGNBQWMsaUNBQW1COztBQUVqQyxpQkFBaUIsaUNBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQW1CO0FBQ25DLGVBQWUsaUNBQW1CO0FBQ2xDLHNCQUFzQixpQ0FBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsZ0JBQWdCO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0EsZ0JBQWdCLGlDQUFtQjtBQUNuQztBQUNBO0FBQ0EsNERBQTREO0FBQzVEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxnQkFBZ0IsaUNBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsZUFBZSxpQ0FBbUI7QUFDbEM7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELGdCQUFnQixpQ0FBbUI7QUFDbkMsY0FBYyxpQ0FBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxlQUFlLGlDQUFtQjtBQUNsQyxVQUFVLGlDQUFtQjtBQUM3QixpQkFBaUIsaUNBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxjQUFjLGlDQUFtQjtBQUNqQyxlQUFlLGlDQUFtQjtBQUNsQyxnQkFBZ0IsaUNBQW1CO0FBQ25DLGlCQUFpQixpQ0FBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELGlDQUFtQjtBQUNuQixjQUFjLGlDQUFtQjtBQUNqQztBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELGNBQWMsaUNBQW1CO0FBQ2pDO0FBQ0EsK0JBQStCLFFBQVEsaUNBQW1CLE1BQU07OztBQUdoRSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxpQ0FBbUI7QUFDbkIsaUJBQWlCLGlDQUFtQjs7O0FBR3BDLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0EsZUFBZSxpQ0FBbUI7QUFDbEMsWUFBWSxpQ0FBbUI7O0FBRS9CLGlDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxtQkFBbUIsV0FBVyxpQ0FBbUI7O0FBRWpELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELGlDQUFtQjtBQUNuQixpQ0FBbUI7QUFDbkIsaUJBQWlCLGlDQUFtQjs7O0FBR3BDLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELG1CQUFtQixXQUFXLGlDQUFtQjs7QUFFakQsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsaUNBQW1CO0FBQ25CLGlDQUFtQjtBQUNuQixpQ0FBbUI7QUFDbkIsaUNBQW1CO0FBQ25CLGlCQUFpQixpQ0FBbUI7OztBQUdwQyxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQTtBQUNBLGFBQWEsaUNBQW1CO0FBQ2hDLFVBQVUsaUNBQW1CO0FBQzdCLGtCQUFrQixpQ0FBbUI7QUFDckMsY0FBYyxpQ0FBbUI7QUFDakMsZUFBZSxpQ0FBbUI7QUFDbEMsV0FBVyxpQ0FBbUI7QUFDOUIsYUFBYSxpQ0FBbUI7QUFDaEMsYUFBYSxpQ0FBbUI7QUFDaEMscUJBQXFCLGlDQUFtQjtBQUN4QyxVQUFVLGlDQUFtQjtBQUM3QixVQUFVLGlDQUFtQjtBQUM3QixhQUFhLGlDQUFtQjtBQUNoQyxnQkFBZ0IsaUNBQW1CO0FBQ25DLGVBQWUsaUNBQW1CO0FBQ2xDLGNBQWMsaUNBQW1CO0FBQ2pDLGVBQWUsaUNBQW1CO0FBQ2xDLGVBQWUsaUNBQW1CO0FBQ2xDLGdCQUFnQixpQ0FBbUI7QUFDbkMsa0JBQWtCLGlDQUFtQjtBQUNyQyxpQkFBaUIsaUNBQW1CO0FBQ3BDLGNBQWMsaUNBQW1CO0FBQ2pDLGNBQWMsaUNBQW1CO0FBQ2pDLFlBQVksaUNBQW1CO0FBQy9CLFVBQVUsaUNBQW1CO0FBQzdCLFlBQVksaUNBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLHVCQUF1QixVQUFVO0FBQ3hELEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RCxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsK0JBQStCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRSxpQ0FBbUI7QUFDckIsRUFBRSxpQ0FBbUI7QUFDckIsRUFBRSxpQ0FBbUI7O0FBRXJCLHNCQUFzQixpQ0FBbUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQsaUJBQWlCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCOztBQUUzQyxxREFBcUQsNEJBQTRCOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkJBQTJCLGdCQUFnQjtBQUMzQywyQkFBMkI7QUFDM0IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU0sUUFBUSxpQ0FBaUM7QUFDcEcsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQ0FBb0MsaUNBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsV0FBVyxpQ0FBbUI7QUFDOUIsZUFBZSxpQ0FBbUI7QUFDbEMsVUFBVSxpQ0FBbUI7QUFDN0IsY0FBYyxpQ0FBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFtQjtBQUNqQyxpREFBaUQ7QUFDakQsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0EsY0FBYyxpQ0FBbUI7QUFDakMsV0FBVyxpQ0FBbUI7QUFDOUIsVUFBVSxpQ0FBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDtBQUNBLFVBQVUsaUNBQW1CO0FBQzdCO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQSxnQkFBZ0IsaUNBQW1CO0FBQ25DLFdBQVcsaUNBQW1CO0FBQzlCLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxpQ0FBbUI7OztBQUduQixPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxpQ0FBbUI7OztBQUduQixPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCw4Q0FBOEMsWUFBWTs7QUFFMUQsQ0FBQztBQUNELEtBQUssS0FBSTtBQUNULElBQUksQ0FDeUI7QUFDN0IsQ0FBQyxzQkFBc0I7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzREFBc0QsNkJBQTZCLFVBQVU7QUFDako7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUUsSUFBSSxFQUFFO0FBQ25ELHdDQUF3QyxFQUFFLElBQUksRUFBRTs7QUFFaEQ7O0FBRUE7QUFDQSxpQ0FBaUMsRUFBRTtBQUNuQywyQkFBMkIsRUFBRTtBQUM3Qiw2QkFBNkIsRUFBRTtBQUMvQiwyQkFBMkIsRUFBRTtBQUM3Qix5QkFBeUIsRUFBRSxJQUFJLEVBQUU7QUFDakMsd0JBQXdCLEVBQUU7QUFDMUIsK0JBQStCLEdBQUc7QUFDbEMseUJBQXlCLEVBQUU7QUFDM0I7QUFDQSwyQkFBMkIsRUFBRSxJQUFJLEVBQUU7QUFDbkMsMEJBQTBCLEVBQUUsSUFBSSxFQUFFO0FBQ2xDLHdCQUF3QixFQUFFO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsSUFBSSwwREFBMEQsSUFBSSxxRUFBcUUsRUFBRTs7QUFFdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlELDBEQUEwRDtBQUMxRCxnRUFBZ0U7QUFDaEUseURBQXlELE9BQU87QUFDaEUseURBQXlELE9BQU87QUFDaEUsd0RBQXdELE9BQU87QUFDL0Qsb0VBQW9FLE9BQU87QUFDM0Usc0VBQXNFLE9BQU87QUFDN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQsNEJBQTRCLGVBQWUsaUNBQW1COztBQUU5RCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUSxJQUFJO0FBQ3ZCLFdBQVcsUUFBUSxJQUFJO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDLDJCQUEyQixjQUFjO0FBQ3pDLDJCQUEyQixnQ0FBZ0M7QUFDM0QseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsbUdBQW1HLElBQUk7QUFDdkc7O0FBRUEsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBLEtBQUssZ0JBQWdCLGlDQUFtQjtBQUN4QztBQUNBLEVBQUUsS0FBSyxFQUlOOztBQUVELENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsbUJBQW1CLFdBQVcsaUNBQW1COztBQUVqRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxpQ0FBbUI7QUFDbkIsY0FBYyxpQ0FBbUI7QUFDakM7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxjQUFjLGlDQUFtQjtBQUNqQztBQUNBLGlDQUFpQyxpQ0FBbUIsa0JBQWtCLGdCQUFnQixpQ0FBbUIsUUFBUTs7O0FBR2pILE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLFdBQVcsaUNBQW1COztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsZUFBZTtBQUNmLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGVBQWUsMkNBQTJDO0FBQzFELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLFdBQVcsaUNBQW1CO0FBQzlCLGNBQWMsaUNBQW1CO0FBQ2pDLGVBQWUsaUNBQW1CO0FBQ2xDLFdBQVcsaUNBQW1COztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFD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QUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esd0RBQXdELHVCQUF1QjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnREFBZ0Q7QUFDdEU7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixLQUFJOztBQUVsQztBQUNBOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQWdEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdFQUFnRSxtQkFBbUI7QUFDakcsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdFQUFnRSxtQkFBbUI7QUFDakcsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxzQkFBc0IsaUNBQW1COztBQUV6Qzs7QUFFQSx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSxrQ0FBa0MsaUNBQW1COztBQUVyRDs7QUFFQSxpQkFBaUIsaUNBQW1COztBQUVwQzs7QUFFQSx3QkFBd0IsaUNBQW1COztBQUUzQzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCLGlDQUFtQjs7QUFFekM7O0FBRUEsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsa0NBQWtDLGlDQUFtQjs7QUFFckQ7O0FBRUEsaUJBQWlCLGlDQUFtQjs7QUFFcEM7O0FBRUEsNkJBQTZCLGlDQUFtQjs7QUFFaEQ7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdFQUFnRSxtQkFBbUI7QUFDakcsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWSxpQ0FBbUI7O0FBRS9COztBQUVBLGVBQWUsaUNBQW1COztBQUVsQzs7QUFFQSx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTs7QUFFQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QztBQUN6Qzs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsbUVBQW1FO0FBQ25FOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsV0FBVyxpQ0FBbUI7QUFDOUIsa0JBQWtCLGlDQUFtQjtBQUNyQyxjQUFjLGlDQUFtQjtBQUNqQyxXQUFXLGlDQUFtQixpQkFBaUI7QUFDL0MsV0FBVyxpQ0FBbUIsaUJBQWlCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0NBQWdDLDRDQUE0QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQyxnQkFBZ0Isd0JBQXdCO0FBQ3hDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsd0NBQXdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVcscUNBQXFDO0FBQy9ELGVBQWUsV0FBVztBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGVBQWU7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDRDQUE0QztBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLHdHQUF3Ryw4QkFBOEI7QUFDdEksWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLHFCQUFxQjtBQUN0Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JELG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQixpQ0FBbUI7O0FBRXpDOztBQUVBLHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLGtDQUFrQyxpQ0FBbUI7O0FBRXJEOztBQUVBLGlCQUFpQixpQ0FBbUI7O0FBRXBDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLFdBQVcsaUNBQW1CO0FBQzlCLFdBQVcsaUNBQW1COztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxpQ0FBbUI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDs7QUFFQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxhQUFhLGlDQUFtQjtBQUNoQyxpQkFBaUIsaUNBQW1COztBQUVwQyxXQUFXLGlDQUFtQjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0EsbUNBQW1DLCtDQUErQzs7QUFFbEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWMsaUNBQW1COztBQUVqQzs7QUFFQSx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxXQUFXLGlDQUFtQjs7QUFFOUIsa0JBQWtCLGlDQUFtQjs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsV0FBVztBQUNoQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLFdBQVcsYUFBYTtBQUMvQyxlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsZ0NBQWdDLHNCQUFzQjtBQUM3RTtBQUNBLHVEQUF1RCxzQkFBc0I7QUFDN0Usd0RBQXdELHdDQUF3QztBQUNoRzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsZ0NBQWdDLHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1RkFBdUY7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsa0NBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdUJBQXVCLGtDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGtDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsV0FBVyxrQ0FBbUI7QUFDOUIsd0JBQXdCLGtDQUFtQjtBQUMzQyxZQUFZLGtDQUFtQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUErQztBQUMvRCxnQkFBZ0IsK0NBQStDO0FBQy9ELGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsK0JBQStCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxvQ0FBb0M7O0FBRTlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxvQ0FBb0M7QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsa0NBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdUJBQXVCLGtDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGtDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsYUFBYSxrQ0FBbUI7QUFDaEMsaUJBQWlCLGtDQUFtQjtBQUNwQyxlQUFlLGtDQUFtQjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLHlDQUF5QztBQUM5RSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFLLFlBUU47QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsWUFBWTtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CLFFBQVEseUJBQXlCO0FBQ2pDLGVBQWUsZUFBZTtBQUM5QixlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUhBQXVILGtCQUFrQjtBQUN6SSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvdmlzanMtbmV0d29yay1ucG0tNC4yNS4wLTJlOTBlZmFlZWQtNDBiZmNiYmYyYi56aXAvbm9kZV9tb2R1bGVzL3Zpc2pzLW5ldHdvcmsvZGlzdC92aXMuanM/NjhiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZpcy5qc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2FsbWVuZGUvdmlzXG4gKlxuICogQSBkeW5hbWljLCBicm93c2VyLWJhc2VkIHZpc3VhbGl6YXRpb24gbGlicmFyeS5cbiAqXG4gKiBAdmVyc2lvbiA0LjI1LjBcbiAqIEBkYXRlICAgIDIwMTgtMDktMjBcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChDKSAyMDExLTIwMTcgQWxtZW5kZSBCLlYsIGh0dHA6Ly9hbG1lbmRlLmNvbVxuICpcbiAqIFZpcy5qcyBpcyBkdWFsIGxpY2Vuc2VkIHVuZGVyIGJvdGhcbiAqXG4gKiAqIFRoZSBBcGFjaGUgMi4wIExpY2Vuc2VcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogYW5kXG4gKlxuICogKiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIFZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmlzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZpc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODUpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMCk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxudmFyIF9jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG52YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbi8vIHVzZSB0aGlzIGluc3RhbmNlLiBFbHNlLCBsb2FkIHZpYSBjb21tb25qcy5cblxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xudmFyIHV1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOSk7XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG51bWJlclxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzTnVtYmVyXG4gKi9cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdHlwZW9mIG9iamVjdCA9PSAnbnVtYmVyJztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGV2ZXJ5dGhpbmcgaW4gdGhlIERPTSBvYmplY3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gRE9Nb2JqZWN0XG4gKi9cbmV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlID0gZnVuY3Rpb24gKERPTW9iamVjdCkge1xuICBpZiAoRE9Nb2JqZWN0KSB7XG4gICAgd2hpbGUgKERPTW9iamVjdC5oYXNDaGlsZE5vZGVzKCkgPT09IHRydWUpIHtcbiAgICAgIGV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICAgIERPTW9iamVjdC5yZW1vdmVDaGlsZChET01vYmplY3QuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc1N0cmluZ1xuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBvYmplY3QgPT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBEYXRlLCBvciBhIFN0cmluZyBjb250YWluaW5nIGEgRGF0ZVxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzRGF0ZVxuICovXG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAvLyB0ZXN0IHdoZXRoZXIgdGhpcyBzdHJpbmcgY29udGFpbnMgYSBkYXRlXG4gICAgdmFyIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWlzTmFOKERhdGUucGFyc2Uob2JqZWN0KSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgVVVJRFxuICogQHJldHVybiB7c3RyaW5nfSB1dWlkXG4gKi9cbmV4cG9ydHMucmFuZG9tVVVJRCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHV1aWQudjQoKTtcbn07XG5cbi8qKlxuICogQ29weSBwcm9wZXJ0eSBmcm9tIGIgdG8gYSBpZiBwcm9wZXJ0eSBwcmVzZW50IGluIGEuXG4gKiBJZiBwcm9wZXJ0eSBpbiBiIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwsIGRlbGV0ZSBpdCBpZiBgYWxsb3dEZWxldGlvbmAgc2V0LlxuICpcbiAqIEludGVybmFsIGhlbHBlciByb3V0aW5lLCBzaG91bGQgbm90IGJlIGV4cG9ydGVkLiBOb3QgYWRkZWQgdG8gYGV4cG9ydHNgIGZvciB0aGF0IHJlYXNvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYSAgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IGIgIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wICBuYW1lIG9mIHByb3BlcnR5IHRvIGNvcHkgdG8gYVxuICogQHBhcmFtIHtib29sZWFufSBhbGxvd0RlbGV0aW9uICBpZiB0cnVlLCBkZWxldGUgcHJvcGVydHkgaW4gYSBpZiBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKSB7XG4gIHZhciBkb0RlbGV0aW9uID0gZmFsc2U7XG4gIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgZG9EZWxldGlvbiA9IGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGRvRGVsZXRpb24pIHtcbiAgICBkZWxldGUgYVtwcm9wXTtcbiAgfSBlbHNlIHtcbiAgICBhW3Byb3BdID0gYltwcm9wXTsgLy8gUmVtZW1iZXIsIHRoaXMgaXMgYSByZWZlcmVuY2UgY29weSFcbiAgfVxufVxuXG4vKipcbiAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuXG4gKlxuICogT25seSBjb3BpZXMgdmFsdWVzIGZvciB0aGUgcHJvcGVydGllcyBhbHJlYWR5IHByZXNlbnQgaW4gYS5cbiAqIFRoYXQgbWVhbnMgYW4gb2JqZWN0IGlzIG5vdCBjcmVhdGVkIG9uIGEgcHJvcGVydHkgaWYgb25seSB0aGUgYiBvYmplY3QgaGFzIGl0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dEZWxldGlvbj1mYWxzZV0gIGlmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0aWVzIGluIGEgdGhhdCBhcmUgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiXG4gKi9cbmV4cG9ydHMuZmlsbElmRGVmaW5lZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiBpdGVyYXRpb24gb2YgcHJvcGVydGllcyBvZiBhXG4gIC8vIE5PVEU6IHByb3RvdHlwZSBwcm9wZXJ0aWVzIGl0ZXJhdGVkIG92ZXIgYXMgd2VsbFxuICBmb3IgKHZhciBwcm9wIGluIGEpIHtcbiAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYltwcm9wXSA9PT0gbnVsbCB8fCAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkoYltwcm9wXSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vdGU6IHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKGFbcHJvcF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGV4cG9ydHMuZmlsbElmRGVmaW5lZChhW3Byb3BdLCBiW3Byb3BdLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHsuLi5PYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChhIC8qIGIgKi8pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEgLyogYiAqLykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IHdpdGggcHJvcGVydHkgbmFtZXMgZXhwZWN0ZWQgYXMgZmlyc3QgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgIGlmIChvdGhlciAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZC5cbiAqXG4gKiAqKk5vdGU6KiogUHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIHJvdXRpbmUgaW1wbGllZCB0aGF0IG11bHRpcGxlIHNvdXJjZSBvYmplY3RzXG4gKiAgICAgICAgICAgY291bGQgYmUgdXNlZDsgaG93ZXZlciwgdGhlIGltcGxlbWVudGF0aW9uIHdhcyAqKndyb25nKiouXG4gKiAgICAgICAgICAgU2luY2UgbXVsdGlwbGUgKD4xKSBzb3VyY2VzIHdlcmVuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgYHZpcy5qc2AgY29kZSxcbiAqICAgICAgICAgICB0aGlzIGhhcyBiZWVuIHJlbW92ZWRcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwcm9wcyBuYW1lcyBvZiBmaXJzdC1sZXZlbCBwcm9wZXJ0aWVzIHRvIGNvcHkgb3ZlclxuICogQHBhcmFtIHtvYmplY3R9IGEgIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBiICBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXSAgaWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlRGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgfVxuXG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBgYWAgd2l0aCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBgYmAsIGlnbm9yaW5nIHByb3BlcnRpZXMgd2hpY2ggYXJlIGV4cGxpY2l0bHlcbiAqIHNwZWNpZmllZCB0byBiZSBleGNsdWRlZC5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBvZiBgYmAgYXJlIGNvbnNpZGVyZWQgZm9yIGNvcHlpbmcuXG4gKiBQcm9wZXJ0aWVzIHdoaWNoIGFyZSB0aGVtc2VsdmVzIG9iamVjdHMgYXJlIGFyZSBhbHNvIGV4dGVuZGVkLlxuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHByb3BzVG9FeGNsdWRlICBuYW1lcyBvZiBwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCAqbm90KiBiZSBjb3BpZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICBhICBvYmplY3QgdG8gZXh0ZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgYiAgb2JqZWN0IHRvIHRha2UgcHJvcGVydGllcyBmcm9tIGZvciBleHRlbnNpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RGVsZXRpb249ZmFsc2VdICBpZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlTm90RGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wc1RvRXhjbHVkZSwgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIC8vIE5PVEU6IGFycmF5IHByb3BlcnRpZXMgaGF2ZSBhbiBlbHNlLWJlbG93OyBhcHBhcmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gaGVyZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKCFiLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTsgLy8gSGFuZGxlIGxvY2FsIHByb3BlcnRpZXMgb25seVxuICAgIGlmIChwcm9wc1RvRXhjbHVkZS5pbmRleE9mKHByb3ApICE9PSAtMSkgY29udGludWU7IC8vIEluIGV4Y2x1c2lvbiBsaXN0LCBza2lwXG5cbiAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSk7IC8vIE5PVEU6IGFsbG93RGVsZXRpb24gbm90IHByb3BhZ2F0ZWQhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICBhW3Byb3BdID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3RvRXh0ZW5kPWZhbHNlXSAgSWYgdHJ1ZSwgdGhlIHByb3RvdHlwZSB2YWx1ZXMgd2lsbCBhbHNvIGJlIGV4dGVuZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChpZS4gdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGUgaW5oZXJpdGVkIG9wdGlvbnMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgdmFsdWVzIG9mIGZpZWxkcyB0aGF0IGFyZSBudWxsIHdpbGwgYmUgZGVsZXRlZFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIHByb3RvRXh0ZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3RvRXh0ZW5kID09PSB0cnVlKSB7XG4gICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICBhW3Byb3BdID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFbcHJvcF0ucHVzaChiW3Byb3BdW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFsbCBlbGVtZW50cyBpbiB0d28gYXJyYXlzIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBib3RoIGFycmF5cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgc2FtZVxuICogICAgICAgICAgICAgICAgICAgZWxlbWVudHMuXG4gKi9cbmV4cG9ydHMuZXF1YWxBcnJheSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGFub3RoZXIgdHlwZVxuICogQHBhcmFtIHtib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgRGF0ZSB8IE1vbWVudCB8IE51bGwgfCB1bmRlZmluZWR9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHR5cGUgICBOYW1lIG9mIHRoZSB0eXBlLiBBdmFpbGFibGUgdHlwZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCb29sZWFuJywgJ051bWJlcicsICdTdHJpbmcnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGF0ZScsICdNb21lbnQnLCBJU09EYXRlJywgJ0FTUERhdGUnLlxuICogQHJldHVybiB7Kn0gb2JqZWN0XG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cbmV4cG9ydHMuY29udmVydCA9IGZ1bmN0aW9uIChvYmplY3QsIHR5cGUpIHtcbiAgdmFyIG1hdGNoO1xuXG4gIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBpZiAoISh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpICYmICEodHlwZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkgJiYgIWlzTmFOKERhdGUucGFyc2Uob2JqZWN0KSkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpLnZhbHVlT2YoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIFN0cmluZyhvYmplY3QpO1xuXG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfSBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG5ldyBEYXRlKG9iamVjdCkpLnRvRGF0ZSgpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnTW9tZW50JzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QudmFsdWVPZigpKTtcbiAgICAgIH0gZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBtb21lbnQoTnVtYmVyKG1hdGNoWzFdKSk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ0lTT0RhdGUnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0KTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKG1vbWVudC5pc01vbWVudChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpLnRvSVNPU3RyaW5nKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KS5mb3JtYXQoKTsgLy8gSVNPIDg2MDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgSVNPRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQVNQRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdCArICcpLyc7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0LnZhbHVlT2YoKSArICcpLyc7XG4gICAgICB9IGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKS52YWx1ZU9mKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUob2JqZWN0KS52YWx1ZU9mKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIHZhbHVlICsgJykvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIEFTUERhdGUnKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBcIicgKyB0eXBlICsgJ1wiJyk7XG4gIH1cbn07XG5cbi8vIHBhcnNlIEFTUC5OZXQgRGF0ZSBwYXR0ZXJuLFxuLy8gZm9yIGV4YW1wbGUgJy9EYXRlKDExOTg5MDg3MTcwNTYpLycgb3IgJy9EYXRlKDExOTg5MDg3MTcwNTYtMDcwMCkvJ1xuLy8gY29kZSBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vXG52YXIgQVNQRGF0ZVJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LCBmb3IgZXhhbXBsZSBleHBvcnRzLmdldFR5cGUoW10pIHJldHVybnMgJ0FycmF5J1xuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge3N0cmluZ30gdHlwZVxuICovXG5leHBvcnRzLmdldFR5cGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShvYmplY3QpO1xuXG4gIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuICdTdHJpbmcnO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gJ0FycmF5JztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnRGF0ZSc7XG4gICAgfVxuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfSBlbHNlIGlmICh0eXBlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICdOdW1iZXInO1xuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuICdCb29sZWFuJztcbiAgfSBlbHNlIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICdTdHJpbmcnO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWVcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5jb3B5QW5kRXh0ZW5kQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBuZXdWYWx1ZSkge1xuICB2YXIgbmV3QXJyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgfVxuICBuZXdBcnIucHVzaChuZXdWYWx1ZSk7XG4gIHJldHVybiBuZXdBcnI7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnRzLmNvcHlBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIG5ld0FyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld0Fycjtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSBsZWZ0ICAgICAgICBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAqL1xuZXhwb3J0cy5nZXRBYnNvbHV0ZUxlZnQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xufTtcblxuZXhwb3J0cy5nZXRBYnNvbHV0ZVJpZ2h0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSB0b3AgICAgICAgIFRoZSBhYnNvbHV0ZSB0b3AgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gKi9cbmV4cG9ydHMuZ2V0QWJzb2x1dGVUb3AgPSBmdW5jdGlvbiAoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG59O1xuXG4vKipcbiAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZXNcbiAqL1xuZXhwb3J0cy5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NOYW1lcykge1xuICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIHZhciBuZXdDbGFzc2VzID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpO1xuICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQobmV3Q2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA8IDA7XG4gIH0pKTtcbiAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lc1xuICovXG5leHBvcnRzLnJlbW92ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChlbGVtLCBjbGFzc05hbWVzKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgdmFyIG9sZENsYXNzZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG4gIGNsYXNzZXMgPSBjbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIG9sZENsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpIDwgMDtcbiAgfSk7XG4gIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXG4gKiBJbiBjYXNlIG9mIGFuIGFycmF5LCB0aGUgYnVpbHQtaW4gQXJyYXkuZm9yRWFjaCgpIGlzIGFwcGxpZWQuICgqKk5vLCBpdCdzIG5vdCEqKilcbiAqIEluIGNhc2Ugb2YgYW4gT2JqZWN0LCB0aGUgbWV0aG9kIGxvb3BzIG92ZXIgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IG9iamVjdCAgIEFuIE9iamVjdCBvciBBcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgQ2FsbGJhY2sgbWV0aG9kLCBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9iamVjdCBvciBhcnJheSB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIG9iamVjdClcbiAqL1xuZXhwb3J0cy5mb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGksIGxlbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIC8vIGFycmF5XG4gICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG9iamVjdFxuICAgIGZvciAoaSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGFycmF5OiBhbGwgb2JqZWN0cyBwcm9wZXJ0aWVzIGFyZSBwdXQgaW50byB0aGVcbiAqIGFycmF5LiBUaGUgcmVzdWx0aW5nIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAqL1xuZXhwb3J0cy50b0FycmF5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgYXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkpIGFycmF5LnB1c2gob2JqZWN0W3Byb3BdKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgcHJvcGVydHkgaW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbmV4cG9ydHMudXBkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChvYmplY3Rba2V5XSAhPT0gdmFsdWUpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaHJvdHRsZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYmUgb25seSBleGVjdXRlZCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IFJldHVybnMgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICovXG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBhbmQgZXZlbnQgbGlzdGVuZXIuIFdvcmtzIGZvciBhbGwgYnJvd3NlcnNcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgQW4gaHRtbCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgIFRoZSBhY3Rpb24sIGZvciBleGFtcGxlIFwiY2xpY2tcIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCB0aGUgcHJlZml4IFwib25cIlxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXVxuICovXG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gJ21vdXNld2hlZWwnICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID49IDApIHtcbiAgICAgIGFjdGlvbiA9ICdET01Nb3VzZVNjcm9sbCc7IC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGFjdGlvbiwgbGlzdGVuZXIpOyAvLyBJRSBicm93c2Vyc1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgICAgICBBbiBodG1sIGRvbSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBcIm1vdXNlZG93blwiXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgICAgICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAqL1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vIG5vbi1JRSBicm93c2Vyc1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHVzZUNhcHR1cmUgPSBmYWxzZTtcblxuICAgIGlmIChhY3Rpb24gPT09ICdtb3VzZXdoZWVsJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+PSAwKSB7XG4gICAgICBhY3Rpb24gPSAnRE9NTW91c2VTY3JvbGwnOyAvLyBGb3IgRmlyZWZveFxuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJRSBicm93c2Vyc1xuICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGFjdGlvbiwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbmNlbHMgdGhlIGV2ZW50IGlmIGl0IGlzIGNhbmNlbGFibGUsIHdpdGhvdXQgc3RvcHBpbmcgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICovXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghZXZlbnQpIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIG5vbi1JRSBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vIElFIGJyb3dzZXJzXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IEhUTUwgZWxlbWVudCB3aGljaCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9IHRhcmdldCBlbGVtZW50XG4gKi9cbmV4cG9ydHMuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGNvZGUgZnJvbSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgaWYgKCFldmVudCkge1xuICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuICB9XG5cbiAgdmFyIHRhcmdldDtcblxuICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB9IGVsc2UgaWYgKGV2ZW50LnNyY0VsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICB9XG5cbiAgaWYgKHRhcmdldC5ub2RlVHlwZSAhPSB1bmRlZmluZWQgJiYgdGFyZ2V0Lm5vZGVUeXBlID09IDMpIHtcbiAgICAvLyBkZWZlYXQgU2FmYXJpIGJ1Z1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4gZWxlbWVudCBjb250YWlucyBnaXZlbiBwYXJlbnQgc29tZXdoZXJlIGluIHRoZSBET00gdHJlZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaGFzUGFyZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICB2YXIgZSA9IGVsZW1lbnQ7XG5cbiAgd2hpbGUgKGUpIHtcbiAgICBpZiAoZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZSA9IGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMub3B0aW9uID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBib29sZWFuXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtCb29sZWFufSBib29sXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIG51bWJlclxuICogQHBhcmFtIHtCb29sZWFuIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtudW1iZXJ9IG51bWJlclxuICovXG5leHBvcnRzLm9wdGlvbi5hc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2l6ZSBvciBsb2NhdGlvbiBpbnRvIGEgc3RyaW5nIHdpdGggcGl4ZWxzIG9yIGEgcGVyY2VudGFnZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge1N0cmluZ30gc2l6ZVxuICovXG5leHBvcnRzLm9wdGlvbi5hc1NpemUgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAoZXhwb3J0cy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAoZXhwb3J0cy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH0gZG9tXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzRWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSB8fCBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2JcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7e3I6ICosIGc6ICosIGI6ICp9fSB8IDI1NSByYW5nZVxuICovXG5leHBvcnRzLmhleFRvUkdCID0gZnVuY3Rpb24gKGhleCkge1xuICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0ZcIikgdG8gZnVsbCBmb3JtIChlLmcuIFwiMDAzM0ZGXCIpXG4gIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIGhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCBmdW5jdGlvbiAobSwgciwgZywgYikge1xuICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG4gIH0pO1xuICB2YXIgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHJldHVybiByZXN1bHQgPyB7XG4gICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXG4gICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNilcbiAgfSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgY29sb3IgaW4gaGV4IGZvcm1hdCBvciByZ2IoKSBvciByZ2JhKCkgZm9ybWF0IGFuZCBvdmVycmlkZXMgdGhlIG9wYWNpdHkuIFJldHVybnMgcmdiYSgpIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMub3ZlcnJpZGVPcGFjaXR5ID0gZnVuY3Rpb24gKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHZhciByZ2I7XG4gIGlmIChjb2xvci5pbmRleE9mKCdyZ2JhJykgIT0gLTEpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH0gZWxzZSBpZiAoY29sb3IuaW5kZXhPZigncmdiJykgIT0gLTEpIHtcbiAgICByZ2IgPSBjb2xvci5zdWJzdHIoY29sb3IuaW5kZXhPZignKCcpICsgMSkucmVwbGFjZSgnKScsICcnKS5zcGxpdCgnLCcpO1xuICAgIHJldHVybiAncmdiYSgnICsgcmdiWzBdICsgJywnICsgcmdiWzFdICsgJywnICsgcmdiWzJdICsgJywnICsgb3BhY2l0eSArICcpJztcbiAgfSBlbHNlIHtcbiAgICByZ2IgPSBleHBvcnRzLmhleFRvUkdCKGNvbG9yKTtcbiAgICBpZiAocmdiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnLCcgKyBvcGFjaXR5ICsgJyknO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlZCAgICAgMCAtLSAyNTVcbiAqIEBwYXJhbSB7bnVtYmVyfSBncmVlbiAgIDAgLS0gMjU1XG4gKiBAcGFyYW0ge251bWJlcn0gYmx1ZSAgICAwIC0tIDI1NVxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLlJHQlRvSGV4ID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmV0dXJuICcjJyArICgoMSA8PCAyNCkgKyAocmVkIDw8IDE2KSArIChncmVlbiA8PCA4KSArIGJsdWUpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBjb2xvciBwcm9wZXJ0eSBpbnRvIGFuIG9iamVjdCB3aXRoIGJvcmRlciwgYmFja2dyb3VuZCwgYW5kXG4gKiBoaWdobGlnaHQgY29sb3JzXG4gKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZ30gY29sb3JcbiAqIEByZXR1cm4ge09iamVjdH0gY29sb3JPYmplY3RcbiAqL1xuZXhwb3J0cy5wYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciBjO1xuICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHJnYiA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGNvbG9yID0gZXhwb3J0cy5SR0JUb0hleChyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIHZhciBoc3YgPSBleHBvcnRzLmhleFRvSFNWKGNvbG9yKTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIU1YgPSB7XG4gICAgICAgIGg6IGhzdi5oLFxuICAgICAgICBzOiBoc3YucyAqIDAuOCxcbiAgICAgICAgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKVxuICAgICAgfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhTViA9IHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IE1hdGgubWluKDEsIGhzdi5zICogMS4yNSksXG4gICAgICAgIHY6IGhzdi52ICogMC44XG4gICAgICB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIZXggPSBleHBvcnRzLkhTVlRvSGV4KGxpZ2h0ZXJDb2xvckhTVi5oLCBsaWdodGVyQ29sb3JIU1YucywgbGlnaHRlckNvbG9ySFNWLnYpO1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXgsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjogY29sb3IsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMgPSB7fTtcbiAgICBjLmJhY2tncm91bmQgPSBjb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICBjLmJvcmRlciA9IGNvbG9yLmJvcmRlciB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvci5oaWdobGlnaHQpKSB7XG4gICAgICBjLmhpZ2hsaWdodCA9IHtcbiAgICAgICAgYm9yZGVyOiBjb2xvci5oaWdobGlnaHQsXG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLmhpZ2hsaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYy5oaWdobGlnaHQgPSB7fTtcbiAgICAgIGMuaGlnaGxpZ2h0LmJhY2tncm91bmQgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5oaWdobGlnaHQuYm9yZGVyID0gY29sb3IuaGlnaGxpZ2h0ICYmIGNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhvdmVyKSkge1xuICAgICAgYy5ob3ZlciA9IHtcbiAgICAgICAgYm9yZGVyOiBjb2xvci5ob3ZlcixcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaG92ZXJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGMuaG92ZXIgPSB7fTtcbiAgICAgIGMuaG92ZXIuYmFja2dyb3VuZCA9IGNvbG9yLmhvdmVyICYmIGNvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5ob3Zlci5ib3JkZXIgPSBjb2xvci5ob3ZlciAmJiBjb2xvci5ob3Zlci5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdyZWVuXG4gKiBAcGFyYW0ge251bWJlcn0gYmx1ZVxuICogQHJldHVybnMge3toOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyfX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLlJHQlRvSFNWID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmVkID0gcmVkIC8gMjU1O1xuICBncmVlbiA9IGdyZWVuIC8gMjU1O1xuICBibHVlID0gYmx1ZSAvIDI1NTtcbiAgdmFyIG1pblJHQiA9IE1hdGgubWluKHJlZCwgTWF0aC5taW4oZ3JlZW4sIGJsdWUpKTtcbiAgdmFyIG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTtcblxuICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gIGlmIChtaW5SR0IgPT0gbWF4UkdCKSB7XG4gICAgcmV0dXJuIHsgaDogMCwgczogMCwgdjogbWluUkdCIH07XG4gIH1cblxuICAvLyBDb2xvcnMgb3RoZXIgdGhhbiBibGFjay1ncmF5LXdoaXRlOlxuICB2YXIgZCA9IHJlZCA9PSBtaW5SR0IgPyBncmVlbiAtIGJsdWUgOiBibHVlID09IG1pblJHQiA/IHJlZCAtIGdyZWVuIDogYmx1ZSAtIHJlZDtcbiAgdmFyIGggPSByZWQgPT0gbWluUkdCID8gMyA6IGJsdWUgPT0gbWluUkdCID8gMSA6IDU7XG4gIHZhciBodWUgPSA2MCAqIChoIC0gZCAvIChtYXhSR0IgLSBtaW5SR0IpKSAvIDM2MDtcbiAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKSAvIG1heFJHQjtcbiAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICByZXR1cm4geyBoOiBodWUsIHM6IHNhdHVyYXRpb24sIHY6IHZhbHVlIH07XG59O1xuXG52YXIgY3NzVXRpbCA9IHtcbiAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGludG8gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICBzcGxpdDogZnVuY3Rpb24gc3BsaXQoY3NzVGV4dCkge1xuICAgIHZhciBzdHlsZXMgPSB7fTtcblxuICAgIGNzc1RleHQuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlLnRyaW0oKSAhPSAnJykge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHlsZS5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5ID0gcGFydHNbMF0udHJpbSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LFxuXG4gIC8vIGJ1aWxkIGEgY3NzIHRleHQgc3RyaW5nIGZyb20gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHN0eWxlcykge1xuICAgIHJldHVybiAoMCwgX2tleXMyWydkZWZhdWx0J10pKHN0eWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgKyAnOiAnICsgc3R5bGVzW2tleV07XG4gICAgfSkuam9pbignOyAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIHRvIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqL1xufTtleHBvcnRzLmFkZENzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICB2YXIgY3VycmVudFN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoZWxlbWVudC5zdHlsZS5jc3NUZXh0KTtcbiAgdmFyIG5ld1N0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XG4gIHZhciBzdHlsZXMgPSBleHBvcnRzLmV4dGVuZChjdXJyZW50U3R5bGVzLCBuZXdTdHlsZXMpO1xuXG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGNzc1V0aWwuam9pbihzdHlsZXMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGZyb20gYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICovXG5leHBvcnRzLnJlbW92ZUNzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICB2YXIgc3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICB2YXIgcmVtb3ZlU3R5bGVzID0gY3NzVXRpbC5zcGxpdChjc3NUZXh0KTtcblxuICBmb3IgKHZhciBrZXkgaW4gcmVtb3ZlU3R5bGVzKSB7XG4gICAgaWYgKHJlbW92ZVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVXRpbC5qb2luKHN0eWxlcyk7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qaWphY2tzb24vNTMxMTI1NlxuICogQHBhcmFtIHtudW1iZXJ9IGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gKiBAcGFyYW0ge251bWJlcn0gdlxuICogQHJldHVybnMge3tyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyfX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLkhTVlRvUkdCID0gZnVuY3Rpb24gKGgsIHMsIHYpIHtcbiAgdmFyIHIsIGcsIGI7XG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgdmFyIGYgPSBoICogNiAtIGk7XG4gIHZhciBwID0gdiAqICgxIC0gcyk7XG4gIHZhciBxID0gdiAqICgxIC0gZiAqIHMpO1xuICB2YXIgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOlxuICAgICAgO3IgPSB2LCBnID0gdCwgYiA9IHA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICA7ciA9IHEsIGcgPSB2LCBiID0gcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIDtyID0gcCwgZyA9IHYsIGIgPSB0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgO3IgPSBwLCBnID0gcSwgYiA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICA7ciA9IHQsIGcgPSBwLCBiID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIDtyID0gdiwgZyA9IHAsIGIgPSBxO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHI6IE1hdGguZmxvb3IociAqIDI1NSksXG4gICAgZzogTWF0aC5mbG9vcihnICogMjU1KSxcbiAgICBiOiBNYXRoLmZsb29yKGIgKiAyNTUpXG4gIH07XG59O1xuXG5leHBvcnRzLkhTVlRvSGV4ID0gZnVuY3Rpb24gKGgsIHMsIHYpIHtcbiAgdmFyIHJnYiA9IGV4cG9ydHMuSFNWVG9SR0IoaCwgcywgdik7XG4gIHJldHVybiBleHBvcnRzLlJHQlRvSGV4KHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufTtcblxuZXhwb3J0cy5oZXhUb0hTViA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgdmFyIHJnYiA9IGV4cG9ydHMuaGV4VG9SR0IoaGV4KTtcbiAgcmV0dXJuIGV4cG9ydHMuUkdCVG9IU1YocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59O1xuXG5leHBvcnRzLmlzVmFsaWRIZXggPSBmdW5jdGlvbiAoaGV4KSB7XG4gIHZhciBpc09rID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoaGV4KTtcbiAgcmV0dXJuIGlzT2s7XG59O1xuXG5leHBvcnRzLmlzVmFsaWRSR0IgPSBmdW5jdGlvbiAocmdiKSB7XG4gIHJnYiA9IHJnYi5yZXBsYWNlKCcgJywgJycpO1xuICB2YXIgaXNPayA9IC9yZ2JcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KVxcKS9pLnRlc3QocmdiKTtcbiAgcmV0dXJuIGlzT2s7XG59O1xuZXhwb3J0cy5pc1ZhbGlkUkdCQSA9IGZ1bmN0aW9uIChyZ2JhKSB7XG4gIHJnYmEgPSByZ2JhLnJlcGxhY2UoJyAnLCAnJyk7XG4gIHZhciBpc09rID0gL3JnYmFcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KSwoLnsxLDN9KVxcKS9pLnRlc3QocmdiYSk7XG4gIHJldHVybiBpc09rO1xufTtcblxuLyoqXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0XG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBmaWVsZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPYmplY3RcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZUJyaWRnZU9iamVjdCA9IGZ1bmN0aW9uIChmaWVsZHMsIHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAocmVmZXJlbmNlT2JqZWN0ICE9PSBudWxsICYmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKHJlZmVyZW5jZU9iamVjdCkpID09PSAnb2JqZWN0Jykge1xuICAgIC8vICEhISB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICB2YXIgb2JqZWN0VG8gPSAoMCwgX2NyZWF0ZTJbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShmaWVsZHNbaV0pKSB7XG4gICAgICAgIGlmICgoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0W2ZpZWxkc1tpXV0pID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb2JqZWN0VG9bZmllbGRzW2ldXSA9IGV4cG9ydHMuYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtmaWVsZHNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9iamVjdFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuYnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAocmVmZXJlbmNlT2JqZWN0ICE9PSBudWxsICYmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKHJlZmVyZW5jZU9iamVjdCkpID09PSAnb2JqZWN0Jykge1xuICAgIC8vICEhISB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICB2YXIgb2JqZWN0VG8gPSAoMCwgX2NyZWF0ZTJbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0KTtcbiAgICBpZiAocmVmZXJlbmNlT2JqZWN0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgLy8gQXZvaWQgYnJpZGdpbmcgRE9NIG9iamVjdHNcbiAgICAgIG9iamVjdFRvID0gcmVmZXJlbmNlT2JqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RUbyA9ICgwLCBfY3JlYXRlMlsnZGVmYXVsdCddKShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGlmICgoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0W2ldKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb2JqZWN0VG9baV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBzdGFibGUgc29ydCBpbXBsZW1lbnRhdGlvbiwgdmVyeSBmYXN0IGZvciBwcmVzb3J0ZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJlIGFuIG9yZGVyIGNvbXBhcmF0b3JcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5pbnNlcnRTb3J0ID0gZnVuY3Rpb24gKGEsIGNvbXBhcmUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGsgPSBhW2ldO1xuICAgIGZvciAodmFyIGogPSBpOyBqID4gMCAmJiBjb21wYXJlKGssIGFbaiAtIDFdKSA8IDA7IGotLSkge1xuICAgICAgYVtqXSA9IGFbaiAtIDFdO1xuICAgIH1cbiAgICBhW2pdID0gaztcbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgb3B0aW9ucyBvZiBzdWJvYmplY3RzIGluIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHMgaXMgdGhhdCB0aGV5IGhhdmUgYW4gJ2VuYWJsZWQnIGVsZW1lbnRcbiAqIHdoaWNoIGlzIG9wdGlvbmFsIGZvciB0aGUgdXNlciBidXQgbWFuZGF0b3J5IGZvciB0aGUgcHJvZ3JhbS5cbiAqXG4gKiBUaGUgYWRkZWQgdmFsdWUgaGVyZSBvZiB0aGUgbWVyZ2UgaXMgdGhhdCBvcHRpb24gJ2VuYWJsZWQnIGlzIHNldCBhcyByZXF1aXJlZC5cbiAqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1lcmdlVGFyZ2V0ICAgfCBlaXRoZXIgdGhpcy5vcHRpb25zIG9yIHRoZSBvcHRpb25zIHVzZWQgZm9yIHRoZSBncm91cHMuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICB8IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb24gICAgICAgIHwgb3B0aW9uIGtleSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudFxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnMgfCBnbG9iYWwgb3B0aW9ucywgcGFzc2VkIGluIHRvIGRldGVybWluZSB2YWx1ZSBvZiBvcHRpb24gJ2VuYWJsZWQnXG4gKi9cbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIC8vIExvY2FsIGhlbHBlcnNcbiAgdmFyIGlzUHJlc2VudCA9IGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkob2JqKSkgPT09ICdvYmplY3QnO1xuICB9O1xuXG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4Ny8xMjIzNTMxXG4gIHZhciBpc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciB4IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSh4KSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBHdWFyZHNcbiAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBtZXJnZVRhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGlmICghaXNQcmVzZW50KG9wdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBvcHRpb24gbXVzdCBoYXZlIGEgdmFsdWUnKTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBnbG9iYWxPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvL1xuICAvLyBBY3R1YWwgbWVyZ2Ugcm91dGluZSwgc2VwYXJhdGVkIGZyb20gbWFpbiBsb2dpY1xuICAvLyBPbmx5IGEgc2luZ2xlIGxldmVsIG9mIG9wdGlvbnMgaXMgbWVyZ2VkLiBEZWVwZXIgbGV2ZWxzIGFyZSByZWYnZC4gVGhpcyBtYXkgYWN0dWFsbHkgYmUgYW4gaXNzdWUuXG4gIC8vXG4gIHZhciBkb01lcmdlID0gZnVuY3Rpb24gZG9NZXJnZSh0YXJnZXQsIG9wdGlvbnMsIG9wdGlvbikge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICB0YXJnZXRbb3B0aW9uXSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzcmMgPSBvcHRpb25zW29wdGlvbl07XG4gICAgdmFyIGRzdCA9IHRhcmdldFtvcHRpb25dO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGRzdFtwcm9wXSA9IHNyY1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTG9jYWwgaW5pdGlhbGl6YXRpb25cbiAgdmFyIHNyY09wdGlvbiA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgdmFyIGdsb2JhbFBhc3NlZCA9IGlzT2JqZWN0KGdsb2JhbE9wdGlvbnMpICYmICFpc0VtcHR5KGdsb2JhbE9wdGlvbnMpO1xuICB2YXIgZ2xvYmFsT3B0aW9uID0gZ2xvYmFsUGFzc2VkID8gZ2xvYmFsT3B0aW9uc1tvcHRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgZ2xvYmFsRW5hYmxlZCA9IGdsb2JhbE9wdGlvbiA/IGdsb2JhbE9wdGlvbi5lbmFibGVkIDogdW5kZWZpbmVkO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcm91dGluZVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBpZiAoc3JjT3B0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3JjT3B0aW9uID09PSAnYm9vbGVhbicpIHtcbiAgICBpZiAoIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0ge307XG4gICAgfVxuXG4gICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gc3JjT3B0aW9uO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzcmNPcHRpb24gPT09IG51bGwgJiYgIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIGV4cGxpY2l0IGNvcHkgZnJvbSBnbG9iYWxzXG4gICAgaWYgKGlzUHJlc2VudChnbG9iYWxPcHRpb24pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gKDAsIF9jcmVhdGUyWydkZWZhdWx0J10pKGdsb2JhbE9wdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkb1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPYmplY3Qoc3JjT3B0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vXG4gIC8vIEVuc3VyZSB0aGF0ICdlbmFibGVkJyBpcyBwcm9wZXJseSBzZXQuIEl0IGlzIHJlcXVpcmVkIGludGVybmFsbHlcbiAgLy8gTm90ZSB0aGF0IHRoZSB2YWx1ZSBmcm9tIG9wdGlvbnMgd2lsbCBhbHdheXMgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAvL1xuICB2YXIgZW5hYmxlZCA9IHRydWU7IC8vIGRlZmF1bHQgdmFsdWVcblxuICBpZiAoc3JjT3B0aW9uLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuYWJsZWQgPSBzcmNPcHRpb24uZW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUYWtlIGZyb20gZ2xvYmFscywgaWYgcHJlc2VudFxuICAgIGlmIChnbG9iYWxFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuYWJsZWQgPSBnbG9iYWxPcHRpb24uZW5hYmxlZDtcbiAgICB9XG4gIH1cblxuICBkb01lcmdlKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pO1xuICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBlbmFibGVkO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHZpc2libGUgaXRlbSBpbiBhIHNvcnRlZCBsaXN0LiBJZiB3ZSBmaW5kIGEgdmlzaWJsZSBpdGVtLCB0aGUgY29kZSB0aGF0IHVzZXNcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCB0aGVuIGl0ZXJhdGUgaW4gYm90aCBkaXJlY3Rpb25zIG92ZXIgdGhpcyBzb3J0ZWQgbGlzdCB0byBmaW5kIGFsbCB2aXNpYmxlIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7SXRlbVtdfSBvcmRlcmVkSXRlbXMgICAgICAgfCBJdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yICAgICAgIHwgLTEgaXMgbG93ZXIsIDAgaXMgZXF1YWwsIDEgaXMgaGlnaGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZDJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmFyeVNlYXJjaEN1c3RvbSA9IGZ1bmN0aW9uIChvcmRlcmVkSXRlbXMsIGNvbXBhcmF0b3IsIGZpZWxkLCBmaWVsZDIpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG5cbiAgICB2YXIgaXRlbSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdO1xuICAgIHZhciB2YWx1ZSA9IGZpZWxkMiA9PT0gdW5kZWZpbmVkID8gaXRlbVtmaWVsZF0gOiBpdGVtW2ZpZWxkXVtmaWVsZDJdO1xuXG4gICAgdmFyIHNlYXJjaFJlc3VsdCA9IGNvbXBhcmF0b3IodmFsdWUpO1xuICAgIGlmIChzZWFyY2hSZXN1bHQgPT0gMCkge1xuICAgICAgLy8gamloYWEsIGZvdW5kIGEgdmlzaWJsZSBpdGVtIVxuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9IGVsc2UgaWYgKHNlYXJjaFJlc3VsdCA9PSAtMSkge1xuICAgICAgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH1cblxuICAgIGl0ZXJhdGlvbisrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHNwZWNpZmljIHZhbHVlIGluIGEgc29ydGVkIGFycmF5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCBidXQgaXMgaW4gYmV0d2VlbiBvZlxuICogdHdvIHZhbHVlcywgd2UgcmV0dXJuIGVpdGhlciB0aGUgb25lIGJlZm9yZSBvciB0aGUgb25lIGFmdGVyLCBkZXBlbmRpbmcgb24gdXNlciBpbnB1dFxuICogSWYgaXQgaXMgZm91bmQsIHdlIHJldHVybiB0aGUgaW5kZXgsIGVsc2UgLTEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3JkZXJlZEl0ZW1zXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lkZVByZWZlcmVuY2UgICAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yIGFuIG9wdGlvbmFsIGNvbXBhcmF0b3IsIHJldHVybmluZyAtMSwwLDEgZm9yIDwsPT0sPi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmFyeVNlYXJjaFZhbHVlID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgdGFyZ2V0LCBmaWVsZCwgc2lkZVByZWZlcmVuY2UsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuICB2YXIgcHJldlZhbHVlLCB2YWx1ZSwgbmV4dFZhbHVlLCBtaWRkbGU7XG5cbiAgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgIT0gdW5kZWZpbmVkID8gY29tcGFyYXRvciA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhIDwgYiA/IC0xIDogMTtcbiAgfTtcblxuICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgIC8vIGdldCBhIG5ldyBndWVzc1xuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoMC41ICogKGhpZ2ggKyBsb3cpKTtcbiAgICBwcmV2VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5tYXgoMCwgbWlkZGxlIC0gMSldW2ZpZWxkXTtcbiAgICB2YWx1ZSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdW2ZpZWxkXTtcbiAgICBuZXh0VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpXVtmaWVsZF07XG5cbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA9PSAwKSB7XG4gICAgICAvLyB3ZSBmb3VuZCB0aGUgdGFyZ2V0XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvcihwcmV2VmFsdWUsIHRhcmdldCkgPCAwICYmIGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPiAwKSB7XG4gICAgICAvLyB0YXJnZXQgaXMgaW4gYmV0d2VlbiBvZiB0aGUgcHJldmlvdXMgYW5kIHRoZSBjdXJyZW50XG4gICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBNYXRoLm1heCgwLCBtaWRkbGUgLSAxKSA6IG1pZGRsZTtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPCAwICYmIGNvbXBhcmF0b3IobmV4dFZhbHVlLCB0YXJnZXQpID4gMCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGluIGJldHdlZW4gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBuZXh0XG4gICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBtaWRkbGUgOiBNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRpZG50IGZpbmQgdGhlIHRhcmdldCwgd2UgbmVlZCB0byBjaGFuZ2Ugb3VyIGJvdW5kYXJpZXMuXG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA8IDApIHtcbiAgICAgICAgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdGlvbisrO1xuICB9XG5cbiAgLy8gZGlkbnQgZmluZCBhbnl0aGluZy4gUmV0dXJuIC0xLlxuICByZXR1cm4gLTE7XG59O1xuXG4vKlxuICogRWFzaW5nIEZ1bmN0aW9ucyAtIGluc3BpcmVkIGZyb20gaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXG4gKiBvbmx5IGNvbnNpZGVyaW5nIHRoZSB0IHZhbHVlIGZvciB0aGUgcmFuZ2UgWzAsIDFdID0+IFswLCAxXVxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcbiAqL1xuZXhwb3J0cy5lYXNpbmdGdW5jdGlvbnMgPSB7XG4gIC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG4gIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiBlYXNlSW5RdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gZWFzZUluT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gZWFzZUluQ3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gZWFzZU91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCkge1xuICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uIGVhc2VJblF1aW50KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWludDogZnVuY3Rpb24gZWFzZU91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH1cbn07XG5cbmV4cG9ydHMuZ2V0U2Nyb2xsQmFyV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIGlubmVyLnN0eWxlLmhlaWdodCA9ICcyMDBweCc7XG5cbiAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG91dGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgb3V0ZXIuc3R5bGUudG9wID0gJzBweCc7XG4gIG91dGVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgb3V0ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBvdXRlci5zdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gIG91dGVyLnN0eWxlLmhlaWdodCA9ICcxNTBweCc7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcbiAgdmFyIHcxID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gIHZhciB3MiA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBpZiAodzEgPT0gdzIpIHcyID0gb3V0ZXIuY2xpZW50V2lkdGg7XG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG5cbiAgcmV0dXJuIHcxIC0gdzI7XG59O1xuXG5leHBvcnRzLnRvcE1vc3QgPSBmdW5jdGlvbiAocGlsZSwgYWNjZXNzb3JzKSB7XG4gIHZhciBjYW5kaWRhdGUgPSB2b2lkIDA7XG4gIGlmICghQXJyYXkuaXNBcnJheShhY2Nlc3NvcnMpKSB7XG4gICAgYWNjZXNzb3JzID0gW2FjY2Vzc29yc107XG4gIH1cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gKDAsIF9nZXRJdGVyYXRvcjNbJ2RlZmF1bHQnXSkocGlsZSksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBtZW1iZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICBjYW5kaWRhdGUgPSBtZW1iZXJbYWNjZXNzb3JzWzBdXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhY2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVbYWNjZXNzb3JzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlO1xufTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxNDUpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ3KTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuNycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCk7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSgnd2tzJyk7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCkuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGhhcyhleHBvcnRzLCBrZXkpKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pc0l0ZXJhYmxlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTM2KTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKGFyciksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pc0l0ZXJhYmxlMy5kZWZhdWx0KShPYmplY3QoYXJyKSkpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIEJhc2UgY2xhc3MgZm9yIGFsbCBOb2Rlcy5cbiAqL1xudmFyIE5vZGVCYXNlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgTm9kZUJhc2UpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWFyZ2luID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IHsgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShOb2RlQmFzZSwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0TWFyZ2lucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKSB7XG4gICAgICB0aGlzLm1hcmdpbiA9IHt9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgaWYgKCgwLCBfdHlwZW9mM1snZGVmYXVsdCddKSh0aGlzLm9wdGlvbnMubWFyZ2luKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW4udG9wO1xuICAgICAgICAgIHRoaXMubWFyZ2luLnJpZ2h0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5yaWdodDtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5ib3R0b20gPSB0aGlzLm9wdGlvbnMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ubGVmdCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsTW9kdWxlLmFkanVzdFNpemVzKHRoaXMubWFyZ2luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVTaGFkb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93KSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHZhbHVlcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB2YWx1ZXMuc2hhZG93U2l6ZTtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB2YWx1ZXMuc2hhZG93WDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB2YWx1ZXMuc2hhZG93WTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVTaGFkb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdykge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVCb3JkZXJEYXNoZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGFzaGVzID0gdmFsdWVzLmJvcmRlckRhc2hlcztcbiAgICAgICAgICBpZiAoZGFzaGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkYXNoZXMgPSBbNSwgMTVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuJyk7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVCb3JkZXJEYXNoZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLicpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgICAgdmFsdWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBzaGFwZSBvZiBhIG5vZGUgbmVlZHMgdG8gYmUgcmVjYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ25lZWRzUmVmcmVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLnJlZnJlc2hOZWVkZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3QgbG9jYXRpb24gdG8gcmVzZXQgdGhpcyBtZW1iZXIuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGluIHRoZSBjdXJyZW50IGxvZ2ljLCBpdCBpcyB0aGUgbW9zdCBjb252ZW5pZW50IG9uZS5cbiAgICAgICAgdGhpcy5yZWZyZXNoTmVlZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRDb250ZXh0Rm9yRHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcykge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdmFsdWVzLmJvcmRlcldpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVzLmNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGVyZm9ybVN0cm9rZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHZhbHVlcy5ib3JkZXJXaWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuXG4gICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTtcbiAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcbiAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwZXJmb3JtRmlsbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKSB7XG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMucGVyZm9ybVN0cm9rZShjdHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FkZEJvdW5kaW5nQm94TWFyZ2luJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvdW5kaW5nQm94TWFyZ2luKG1hcmdpbikge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0IC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wIC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICs9IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgKz0gbWFyZ2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAqXG4gICAgICogRG9pbmcgaXQgbGlrZSB0aGlzIG1ha2VzIGl0IGVhc2llciB0byBvdmVycmlkZVxuICAgICAqIGluIHRoZSBjaGlsZCBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlQm91bmRpbmdCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgKiBUaGlzIGFjdHMgYXMgYSBzdHViIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGltZW5zaW9ucyB0byB1c2UgZm9yIG5vZGVzIHdpdGggYW4gaW50ZXJuYWwgbGFiZWxcbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSwgdGhlc2UgYXJlOiBDaXJjbGUsIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcbiAgICAgKiBUaGUgb3RoZXIgbm9kZXMgaGF2ZSBleHRlcm5hbCBsYWJlbHMsIGFuZCB3aWxsIG5vdCBjYWxsIHRoaXMgbWV0aG9kXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBsYWJlbCwgZGVjZW50IGRlZmF1bHQgdmFsdWVzIGFyZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOm51bWJlciwgaGVpZ2h0Om51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldERpbWVuc2lvbnNGcm9tTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAvLyBOT1RFOiBwcmV2aW91c2x5ICd0ZXh0U2l6ZScgd2FzIG5vdCBwdXQgaW4gJ3RoaXMnIGZvciBFbGxpcHNlXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIHRoZSBjb25zZXF1ZW5jZXMuXG4gICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0O1xuXG4gICAgICB2YXIgREVGQVVMVF9TSVpFID0gMTQ7XG4gICAgICBpZiAod2lkdGggPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbGFiZWwgdGV4dCBzZXRcbiAgICAgICAgd2lkdGggPSBERUZBVUxUX1NJWkU7IC8vIHVzZSBhIGRlY2VudCBkZWZhdWx0XG4gICAgICAgIGhlaWdodCA9IERFRkFVTFRfU0laRTsgLy8gaWYgd2lkdGggemVybywgdGhlbiBoZWlnaHQgYWxzbyBhbHdheXMgemVyb1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb2RlQmFzZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTm9kZUJhc2U7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RydWN0aW5nIE5vZGUvQ2x1c3RlciBTaGFwZXMuXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIFNoYXBlQmFzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoU2hhcGVCYXNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU2hhcGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgU2hhcGVCYXNlKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoU2hhcGVCYXNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShTaGFwZUJhc2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVzPXtzaXplOiB0aGlzLm9wdGlvbnMuc2l6ZX1dXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU2hhcGVCYXNlLCBbe1xuICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHsgc2l6ZTogdGhpcy5vcHRpb25zLnNpemUgfTtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBzaXplID0gMiAqIHZhbHVlcy5zaXplO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVNdWx0aXBsaWVyIC0gVW51c2VkISBUT0RPOiBSZW1vdmUgbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3U2hhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1NoYXBlKGN0eCwgc2hhcGUsIHNpemVNdWx0aXBsaWVyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eFtzaGFwZV0oeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCA/ICdib2xkICcgOiAnJykgKyB0aGlzLmhlaWdodCAvIDIgKyAncHggJyArICh0aGlzLm9wdGlvbnMuaWNvbi5mYWNlIHx8ICdGb250QXdlc29tZScpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvbi5jb2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOZWVkIHRvIGNhbGwgZm9sbG93aW5nIGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHZhbHVlIGZvciBgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodGBcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHgsIHksICdoYW5naW5nJyk7XG4gICAgICAgIHZhciB5TGFiZWwgPSB5ICsgMC41ICogdGhpcy5oZWlnaHQgKyAwLjUgKiB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCBob3ZlciwgJ2hhbmdpbmcnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTaGFwZUJhc2U7XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNoYXBlQmFzZTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMyksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIFNldHVwIGEgbW9jayBoYW1tZXIuanMgb2JqZWN0LCBmb3IgdW5pdCB0ZXN0aW5nLlxuICpcbiAqIEluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL3B1bGwvNjU4XG4gKlxuICogQHJldHVybnMge3tvbjogbm9vcCwgb2ZmOiBub29wLCBkZXN0cm95OiBub29wLCBlbWl0OiBub29wLCBnZXQ6IGdldH19XG4gKi9cbmZ1bmN0aW9uIGhhbW1lck1vY2soKSB7XG4gIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gIHJldHVybiB7XG4gICAgb246IG5vb3AsXG4gICAgb2ZmOiBub29wLFxuICAgIGRlc3Ryb3k6IG5vb3AsXG4gICAgZW1pdDogbm9vcCxcblxuICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQobSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0OiBub29wXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBwcm9wYWdhdGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3KTtcbiAgdmFyIEhhbW1lciA9IHdpbmRvd1snSGFtbWVyJ10gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb3BhZ2F0aW5nKEhhbW1lciwge1xuICAgIHByZXZlbnREZWZhdWx0OiAnbW91c2UnXG4gIH0pO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuIFJlcGxhY2luZyBpdCB3aXRoIGEgbW9jayBvYmplY3QuXG4gICAgcmV0dXJuIGhhbW1lck1vY2soKTtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTAwKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuLyoqXG4gKiBEYXRhU2V0XG4gKiAvLyBUT0RPOiBhZGQgYSBEYXRhU2V0IGNvbnN0cnVjdG9yIERhdGFTZXQoZGF0YSwgb3B0aW9ucylcbiAqXG4gKiBVc2FnZTpcbiAqICAgICB2YXIgZGF0YVNldCA9IG5ldyBEYXRhU2V0KHtcbiAqICAgICAgICAgZmllbGRJZDogJ19pZCcsXG4gKiAgICAgICAgIHR5cGU6IHtcbiAqICAgICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGRhdGFTZXQuYWRkKGl0ZW0pO1xuICogICAgIGRhdGFTZXQuYWRkKGRhdGEpO1xuICogICAgIGRhdGFTZXQudXBkYXRlKGl0ZW0pO1xuICogICAgIGRhdGFTZXQudXBkYXRlKGRhdGEpO1xuICogICAgIGRhdGFTZXQucmVtb3ZlKGlkKTtcbiAqICAgICBkYXRhU2V0LnJlbW92ZShpZHMpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcyk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZHMsIG9wdGlvbnMsIGRhdGEpO1xuICogICAgIGRhdGFTZXQuY2xlYXIoKTtcbiAqXG4gKiBBIGRhdGEgc2V0IGNhbjpcbiAqIC0gYWRkL3JlbW92ZS91cGRhdGUgZGF0YVxuICogLSBnaXZlcyB0cmlnZ2VycyB1cG9uIGNoYW5nZXMgaW4gdGhlIGRhdGFcbiAqIC0gY2FuICBpbXBvcnQvZXhwb3J0IGRhdGEgaW4gdmFyaW91cyBkYXRhIGZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbZGF0YV0gICAgT3B0aW9uYWwgYXJyYXkgd2l0aCBpbml0aWFsIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBmaWVsZElkIEZpZWxkIG5hbWUgb2YgdGhlIGlkIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMsICdpZCcgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBtYXAgd2l0aCBmaWVsZCBuYW1lcyBhcyBrZXksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGZpZWxkIHR5cGUgYXMgdmFsdWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gcXVldWUgICBRdWV1ZSBjaGFuZ2VzIHRvIHRoZSBEYXRhU2V0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2ggdGhlbSBhbGwgYXQgb25jZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IGRlbGF5ICBEZWxheSBpbiBtcywgbnVsbCBieSBkZWZhdWx0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IG1heCAgICBNYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBxdWV1ZSwgSW5maW5pdHkgYnkgZGVmYXVsdFxuICogQGNvbnN0cnVjdG9yIERhdGFTZXRcbiAqL1xuZnVuY3Rpb24gRGF0YVNldChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGNvcnJlY3RseSByZWFkIG9wdGlvbmFsIGFyZ3VtZW50c1xuICBpZiAoZGF0YSAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIG9wdGlvbnMgPSBkYXRhO1xuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2RhdGEgPSB7fTsgLy8gbWFwIHdpdGggZGF0YSBpbmRleGVkIGJ5IGlkXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG4gIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJzsgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuICB0aGlzLl90eXBlID0ge307IC8vIGludGVybmFsIGZpZWxkIHR5cGVzIChOT1RFOiB0aGlzIGNhbiBkaWZmZXIgZnJvbSB0aGlzLl9vcHRpb25zLnR5cGUpXG5cbiAgLy8gYWxsIHZhcmlhbnRzIG9mIGEgRGF0ZSBhcmUgaW50ZXJuYWxseSBzdG9yZWQgYXMgRGF0ZSwgc28gd2UgY2FuIGNvbnZlcnRcbiAgLy8gZnJvbSBldmVyeXRoaW5nIHRvIGV2ZXJ5dGhpbmcgKGFsc28gZnJvbSBJU09EYXRlIHRvIE51bWJlciBmb3IgZXhhbXBsZSlcbiAgaWYgKHRoaXMuX29wdGlvbnMudHlwZSkge1xuICAgIHZhciBmaWVsZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuX29wdGlvbnMudHlwZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fb3B0aW9ucy50eXBlW2ZpZWxkXTtcbiAgICAgIGlmICh2YWx1ZSA9PSAnRGF0ZScgfHwgdmFsdWUgPT0gJ0lTT0RhdGUnIHx8IHZhbHVlID09ICdBU1BEYXRlJykge1xuICAgICAgICB0aGlzLl90eXBlW2ZpZWxkXSA9ICdEYXRlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgLy8gZXZlbnQgc3Vic2NyaWJlcnNcblxuICAvLyBhZGQgaW5pdGlhbCBkYXRhIHdoZW4gcHJvdmlkZWRcbiAgaWYgKGRhdGEpIHtcbiAgICB0aGlzLmFkZChkYXRhKTtcbiAgfVxuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHF1ZXVlICAgUXVldWUgY2hhbmdlcyB0byB0aGUgRGF0YVNldCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWV1ZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBkZWxheSAgRGVsYXkgaW4gbXMsIG51bGwgYnkgZGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgLy8gZGVsZXRlIHF1ZXVlIGlmIGxvYWRlZFxuICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgcXVldWUgYW5kIHVwZGF0ZSBpdHMgb3B0aW9uc1xuICAgICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFF1ZXVlLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgcmVwbGFjZTogWydhZGQnLCAndXBkYXRlJywgJ3JlbW92ZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKG9wdGlvbnMucXVldWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLl9xdWV1ZS5zZXRPcHRpb25zKG9wdGlvbnMucXVldWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQsIGFkZCBhbiBldmVudCBsaXN0ZW5lclxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50ICAgICAgICBFdmVudCBuYW1lLiBBdmFpbGFibGUgZXZlbnRzOiAnYWRkJywgJ3VwZGF0ZScsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZW1vdmUnXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrIG1ldGhvZC4gQ2FsbGVkIHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGV2ZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nIHwgbnVtYmVyfSBzZW5kZXJJZFxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycztcbiAgfVxuXG4gIHN1YnNjcmliZXJzLnB1c2goe1xuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbGJhY2sgIT0gY2FsbGJhY2s7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICogQHBhcmFtIHtzdHJpbmd9IFtzZW5kZXJJZF0gICAgICAgT3B0aW9uYWwgaWQgb2YgdGhlIHNlbmRlci5cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl90cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gIGlmIChldmVudCA9PSAnKicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0cmlnZ2VyIGV2ZW50IConKTtcbiAgfVxuXG4gIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuICBpZiAoZXZlbnQgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmNvbmNhdCh0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0pO1xuICB9XG4gIGlmICgnKicgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmNvbmNhdCh0aGlzLl9zdWJzY3JpYmVyc1snKiddKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3Vic2NyaWJlcnNbaV07XG4gICAgaWYgKHN1YnNjcmliZXIuY2FsbGJhY2spIHtcbiAgICAgIHN1YnNjcmliZXIuY2FsbGJhY2soZXZlbnQsIHBhcmFtcywgc2VuZGVySWQgfHwgbnVsbCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBkYXRhLlxuICogQWRkaW5nIGFuIGl0ZW0gd2lsbCBmYWlsIHdoZW4gdGhlcmUgYWxyZWFkeSBpcyBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQuXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8bnVtYmVyPn0gYWRkZWRJZHMgICAgICBBcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICB2YXIgYWRkZWRJZHMgPSBbXSxcbiAgICAgIGlkLFxuICAgICAgbWUgPSB0aGlzO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgLy8gQXJyYXlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBtZS5fYWRkSXRlbShkYXRhW2ldKTtcbiAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gU2luZ2xlIGl0ZW1cbiAgICBpZCA9IG1lLl9hZGRJdGVtKGRhdGEpO1xuICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkYXRhVHlwZScpO1xuICB9XG5cbiAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiBhZGRlZElkcztcbn07XG5cbi8qKlxuICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfG51bWJlcj59IHVwZGF0ZWRJZHMgICAgIFRoZSBpZHMgb2YgdGhlIGFkZGVkIG9yIHVwZGF0ZWQgaXRlbXNcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIERhdGF0eXBlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgdmFyIG9sZERhdGEgPSBbXTtcbiAgdmFyIHVwZGF0ZWREYXRhID0gW107XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBmaWVsZElkID0gbWUuX2ZpZWxkSWQ7XG5cbiAgdmFyIGFkZE9yVXBkYXRlID0gZnVuY3Rpb24gYWRkT3JVcGRhdGUoaXRlbSkge1xuICAgIHZhciBpZCA9IGl0ZW1bZmllbGRJZF07XG4gICAgaWYgKG1lLl9kYXRhW2lkXSkge1xuICAgICAgdmFyIG9sZEl0ZW0gPSB1dGlsLmV4dGVuZCh7fSwgbWUuX2RhdGFbaWRdKTtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICBpZCA9IG1lLl91cGRhdGVJdGVtKGl0ZW0pO1xuICAgICAgdXBkYXRlZElkcy5wdXNoKGlkKTtcbiAgICAgIHVwZGF0ZWREYXRhLnB1c2goaXRlbSk7XG4gICAgICBvbGREYXRhLnB1c2gob2xkSXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFkZCBuZXcgaXRlbVxuICAgICAgaWQgPSBtZS5fYWRkSXRlbShpdGVtKTtcbiAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIC8vIEFycmF5XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChkYXRhW2ldICYmICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShkYXRhW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWRkT3JVcGRhdGUoZGF0YVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0lnbm9yaW5nIGlucHV0IGl0ZW0sIHdoaWNoIGlzIG5vdCBhbiBvYmplY3QgYXQgaW5kZXggJyArIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gU2luZ2xlIGl0ZW1cbiAgICBhZGRPclVwZGF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YVR5cGUnKTtcbiAgfVxuXG4gIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7IGl0ZW1zOiBhZGRlZElkcyB9LCBzZW5kZXJJZCk7XG4gIH1cbiAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgdmFyIHByb3BzID0geyBpdGVtczogdXBkYXRlZElkcywgb2xkRGF0YTogb2xkRGF0YSwgZGF0YTogdXBkYXRlZERhdGFcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIHByb3BlcnR5ICdkYXRhJyBzb21lIGRheVxuICAgICAgLy9PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdkYXRhJywge1xuICAgICAgLy8gICdnZXQnOiAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5IGRhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQuZ2V0KGlkcykgdG8gcmV0cmlldmUgdGhlIG5ldyBkYXRhLCB1c2UgdGhlIG9sZERhdGEgcHJvcGVydHkgb24gdGhpcyBvYmplY3QgdG8gZ2V0IHRoZSBvbGQgZGF0YScpO1xuICAgICAgLy8gICAgcmV0dXJuIHVwZGF0ZWREYXRhO1xuICAgICAgLy8gIH0pLmJpbmQodGhpcylcbiAgICAgIC8vfSk7XG4gICAgfTt0aGlzLl90cmlnZ2VyKCd1cGRhdGUnLCBwcm9wcywgc2VuZGVySWQpO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVkSWRzLmNvbmNhdCh1cGRhdGVkSWRzKTtcbn07XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuLyoqXG4gKiBHZXQgYSBkYXRhIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIGdldCgpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiAgICAgZ2V0KGlkOiBudW1iZXIgfCBzdHJpbmcpXG4gKiAgICAgZ2V0KGlkOiBudW1iZXIgfCBzdHJpbmcsIG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiAgICAgZ2V0KGlkczogbnVtYmVyW10gfCBzdHJpbmdbXSlcbiAqICAgICBnZXQoaWRzOiBudW1iZXJbXSB8IHN0cmluZ1tdLCBvcHRpb25zOiBPYmplY3QpXG4gKlxuICogV2hlcmU6XG4gKlxuICoge251bWJlciB8IHN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICoge251bWJlcltdIHwgc3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqIHtzdHJpbmd9IFtyZXR1cm5UeXBlXSAgICAgICAgVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ0FycmF5JyAoZGVmYXVsdCkgb3IgJ09iamVjdCcuXG4gKiB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFt0eXBlXVxuICoge3N0cmluZ1tdfSBbZmllbGRzXSAgICAgICAgICBmaWVsZCBuYW1lcyB0byBiZSByZXR1cm5lZFxuICoge2Z1bmN0aW9ufSBbZmlsdGVyXSAgICAgICAgICBmaWx0ZXIgaXRlbXNcbiAqIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSAgT3JkZXIgdGhlIGl0ZW1zIGJ5IGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm5zIHtEYXRhU2V0fVxuICogQHRocm93cyBFcnJvclxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICB2YXIgaWQsIGlkcywgb3B0aW9ucztcbiAgdmFyIGZpcnN0VHlwZSA9IHV0aWwuZ2V0VHlwZShhcmd1bWVudHNbMF0pO1xuICBpZiAoZmlyc3RUeXBlID09ICdTdHJpbmcnIHx8IGZpcnN0VHlwZSA9PSAnTnVtYmVyJykge1xuICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICBpZCA9IGFyZ3VtZW50c1swXTtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgLy8gZ2V0KGlkcyBbLCBvcHRpb25zXSlcbiAgICBpZHMgPSBhcmd1bWVudHNbMF07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnZXQoWywgb3B0aW9uc10pXG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGVcbiAgdmFyIHJldHVyblR5cGU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSkge1xuICAgIHZhciBhbGxvd2VkVmFsdWVzID0gWydBcnJheScsICdPYmplY3QnXTtcbiAgICByZXR1cm5UeXBlID0gYWxsb3dlZFZhbHVlcy5pbmRleE9mKG9wdGlvbnMucmV0dXJuVHlwZSkgPT0gLTEgPyAnQXJyYXknIDogb3B0aW9ucy5yZXR1cm5UeXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVyblR5cGUgPSAnQXJyYXknO1xuICB9XG5cbiAgLy8gYnVpbGQgb3B0aW9uc1xuICB2YXIgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZTtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gIHZhciBpdGVtcyA9IFtdLFxuICAgICAgaXRlbSxcbiAgICAgIGl0ZW1JZHMsXG4gICAgICBpdGVtSWQsXG4gICAgICBpLFxuICAgICAgbGVuO1xuXG4gIC8vIGNvbnZlcnQgaXRlbXNcbiAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgIC8vIHJldHVybiBhIHNpbmdsZSBpdGVtXG4gICAgaXRlbSA9IG1lLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICBpZiAoaXRlbSAmJiBmaWx0ZXIgJiYgIWZpbHRlcihpdGVtKSkge1xuICAgICAgaXRlbSA9IG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlkcyAhPSB1bmRlZmluZWQpIHtcbiAgICAvLyByZXR1cm4gYSBzdWJzZXQgb2YgaXRlbXNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpZHNbaV0sIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHJldHVybiBhbGwgaXRlbXNcbiAgICBpdGVtSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKSh0aGlzLl9kYXRhKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtSWQgPSBpdGVtSWRzW2ldO1xuICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGl0ZW1JZCwgdHlwZSk7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciB0aGUgcmVzdWx0c1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICB9XG5cbiAgLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWVsZHMpIHtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgaXRlbSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtLCBmaWVsZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtc1tpXSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtc1tpXSwgZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gdGhlIHJlc3VsdHNcbiAgaWYgKHJldHVyblR5cGUgPT0gJ09iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIHJlc3VsdGFudDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0YW50ID0gaXRlbXNbaV07XG4gICAgICByZXN1bHRbcmVzdWx0YW50LmlkXSA9IHJlc3VsdGFudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhIHNpbmdsZSBpdGVtXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCByZXR1cm4gb3VyIGFycmF5XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfG51bWJlcj59IGlkc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgaXRlbUlkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoZGF0YSksXG4gICAgICBpLFxuICAgICAgbGVuLFxuICAgICAgaWQsXG4gICAgICBpdGVtLFxuICAgICAgaXRlbXMsXG4gICAgICBpZHMgPSBbXTtcblxuICBpZiAoZmlsdGVyKSB7XG4gICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgaWYgKGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZHMucHVzaChpdGVtc1tpXVt0aGlzLl9maWVsZElkXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgaWYgKGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGdldCBhbGwgaXRlbXNcbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgIGl0ZW1zID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgaXRlbXMucHVzaChkYXRhW2lkXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWRzLnB1c2goaXRlbXNbaV1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICBpdGVtID0gZGF0YVtpZF07XG4gICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERhdGFTZXQgaXRzZWxmLiBJcyBvdmVyd3JpdHRlbiBmb3IgZXhhbXBsZSBieSB0aGUgRGF0YVZpZXcsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBEYXRhU2V0IGl0IGlzIGNvbm5lY3RlZCB0byBpbnN0ZWFkLlxuICogQHJldHVybnMge0RhdGFTZXR9XG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmdldERhdGFTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBbdHlwZV1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIGl0ZW1JZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKGRhdGEpLFxuICAgICAgaSxcbiAgICAgIGxlbixcbiAgICAgIGl0ZW0sXG4gICAgICBpZDtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgLy8gZXhlY3V0ZSBmb3JFYWNoIG9uIG9yZGVyZWQgbGlzdFxuICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KG9wdGlvbnMpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcbiAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdW5vcmRlcmVkXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBbdHlwZV1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdFtdfSBtYXBwZWRJdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgbWFwcGVkSXRlbXMgPSBbXSxcbiAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgaXRlbUlkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoZGF0YSksXG4gICAgICBpLFxuICAgICAgbGVuLFxuICAgICAgaWQsXG4gICAgICBpdGVtO1xuXG4gIC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgIG1hcHBlZEl0ZW1zLnB1c2goY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciBpdGVtc1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgdGhpcy5fc29ydChtYXBwZWRJdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gIH1cblxuICByZXR1cm4gbWFwcGVkSXRlbXM7XG59O1xuXG4vKipcbiAqIEZpbHRlciB0aGUgZmllbGRzIG9mIGFuIGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gaXRlbVxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGRzICAgICBGaWVsZCBuYW1lc1xuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gZmlsdGVyZWRJdGVtIG9yIG51bGwgaWYgbm8gaXRlbSBpcyBwcm92aWRlZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX2ZpbHRlckZpZWxkcyA9IGZ1bmN0aW9uIChpdGVtLCBmaWVsZHMpIHtcbiAgaWYgKCFpdGVtKSB7XG4gICAgLy8gaXRlbSBpcyBudWxsXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICB2YXIgZmlsdGVyZWRJdGVtID0ge30sXG4gICAgICBpdGVtRmllbGRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShpdGVtKSxcbiAgICAgIGxlbiA9IGl0ZW1GaWVsZHMubGVuZ3RoLFxuICAgICAgaSxcbiAgICAgIGZpZWxkO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZpZWxkID0gaXRlbUZpZWxkc1tpXTtcbiAgICAgIGlmIChmaWVsZHMuaW5kZXhPZihmaWVsZCkgIT0gLTEpIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZpZWxkID0gaXRlbUZpZWxkc1tpXTtcbiAgICAgIGlmIChmaWVsZHMuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZHNbZmllbGRdXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZEl0ZW07XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIHByb3ZpZGVkIGFycmF5IHdpdGggaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9ufSBvcmRlciAgICAgIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9zb3J0ID0gZnVuY3Rpb24gKGl0ZW1zLCBvcmRlcikge1xuICBpZiAodXRpbC5pc1N0cmluZyhvcmRlcikpIHtcbiAgICAvLyBvcmRlciBieSBwcm92aWRlZCBmaWVsZCBuYW1lXG4gICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBhdiA9IGFbbmFtZV07XG4gICAgICB2YXIgYnYgPSBiW25hbWVdO1xuICAgICAgcmV0dXJuIGF2ID4gYnYgPyAxIDogYXYgPCBidiA/IC0xIDogMDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgaXRlbXMuc29ydChvcmRlcik7XG4gIH1cbiAgLy8gVE9ETzogZXh0ZW5kIG9yZGVyIGJ5IGFuIE9iamVjdCB7ZmllbGQ6c3RyaW5nLCBkaXJlY3Rpb246c3RyaW5nfVxuICAvLyAgICAgICB3aGVyZSBkaXJlY3Rpb24gY2FuIGJlICdhc2MnIG9yICdkZXNjJ1xuICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09yZGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIG9iamVjdCBieSBwb2ludGVyIG9yIGJ5IGlkXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IE9iamVjdCB8IEFycmF5LjxzdHJpbmd8bnVtYmVyPn0gaWQgT2JqZWN0IG9yIGlkLCBvciBhbiBhcnJheSB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RzIG9yIGlkcyB0byBiZSByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8bnVtYmVyPn0gcmVtb3ZlZElkc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaWQsIHNlbmRlcklkKSB7XG4gIHZhciByZW1vdmVkSWRzID0gW10sXG4gICAgICByZW1vdmVkSXRlbXMgPSBbXSxcbiAgICAgIGlkcyA9IFtdLFxuICAgICAgaSxcbiAgICAgIGxlbixcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGl0ZW07XG5cbiAgLy8gZm9yY2UgZXZlcnl0aGluZyB0byBiZSBhbiBhcnJheSBmb3Igc2ltcGxpY2l0eVxuICBpZHMgPSBBcnJheS5pc0FycmF5KGlkKSA/IGlkIDogW2lkXTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpdGVtID0gdGhpcy5fcmVtb3ZlKGlkc1tpXSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGl0ZW1JZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gICAgICBpZiAoaXRlbUlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICByZW1vdmVkSWRzLnB1c2goaXRlbUlkKTtcbiAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywgeyBpdGVtczogcmVtb3ZlZElkcywgb2xkRGF0YTogcmVtb3ZlZEl0ZW1zIH0sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkSWRzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWRcbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgT2JqZWN0fSBpZCAgIGlkIG9yIGl0ZW1cbiAqIEByZXR1cm5zIHtudW1iZXIgfCBzdHJpbmcgfCBudWxsfSBpZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgaXRlbSwgaWRlbnQ7XG5cbiAgLy8gY29uZmlybSB0aGUgaWQgdG8gdXNlIGJhc2VkIG9uIHRoZSBhcmdzIHR5cGVcbiAgaWYgKHV0aWwuaXNOdW1iZXIoaWQpIHx8IHV0aWwuaXNTdHJpbmcoaWQpKSB7XG4gICAgaWRlbnQgPSBpZDtcbiAgfSBlbHNlIGlmIChpZCAmJiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKGlkKSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWRlbnQgPSBpZFt0aGlzLl9maWVsZElkXTsgLy8gbG9vayBmb3IgdGhlIGlkZW50aWZpZXIgZmllbGQgdXNpbmcgX2ZpZWxkSWRcbiAgfVxuXG4gIC8vIGRvIHRoZSByZW1vdmUgaWYgdGhlIGl0ZW0gaXMgZm91bmRcbiAgaWYgKGlkZW50ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZGF0YVtpZGVudF0pIHtcbiAgICBpdGVtID0gdGhpcy5fZGF0YVtpZGVudF07XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFbaWRlbnRdO1xuICAgIHRoaXMubGVuZ3RoLS07XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8bnVtYmVyPn0gcmVtb3ZlZElkcyAgICBUaGUgaWRzIG9mIGFsbCByZW1vdmVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHNlbmRlcklkKSB7XG4gIHZhciBpLCBsZW47XG4gIHZhciBpZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuX2RhdGEpO1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX2RhdGFbaWRzW2ldXSk7XG4gIH1cblxuICB0aGlzLl9kYXRhID0ge307XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiBpZHMsIG9sZERhdGE6IGl0ZW1zIH0sIHNlbmRlcklkKTtcblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBpdGVtIHdpdGggbWF4aW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShkYXRhKSxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBtYXhGaWVsZCA9IG51bGwsXG4gICAgICBpLFxuICAgICAgbGVuO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1heCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgIG1heCA9IGl0ZW07XG4gICAgICBtYXhGaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4O1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBpdGVtIHdpdGggbWluaW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShkYXRhKSxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtaW5GaWVsZCA9IG51bGwsXG4gICAgICBpLFxuICAgICAgbGVuO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1pbiB8fCBpdGVtRmllbGQgPCBtaW5GaWVsZCkpIHtcbiAgICAgIG1pbiA9IGl0ZW07XG4gICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7QXJyYXl9IHZhbHVlcyAgQXJyYXkgY29udGFpbmluZyBhbGwgZGlzdGluY3QgdmFsdWVzLiBJZiBkYXRhIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFyZSBpZ25vcmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJldHVybmVkIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgaXRlbUlkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoZGF0YSk7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX29wdGlvbnMudHlwZSAmJiB0aGlzLl9vcHRpb25zLnR5cGVbZmllbGRdIHx8IG51bGw7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBpLCBqLCBsZW47XG5cbiAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG4gICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICB2YXIgdmFsdWUgPSBpdGVtW2ZpZWxkXTtcbiAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmICh2YWx1ZXNbal0gPT0gdmFsdWUpIHtcbiAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZXhpc3RzICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSkge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gdXRpbC5jb252ZXJ0KHZhbHVlc1tpXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge3N0cmluZ30gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcblxuICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlkIGlzIGFscmVhZHkgdGFrZW5cbiAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBnZW5lcmF0ZSBhbiBpZFxuICAgIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgaXRlbVt0aGlzLl9maWVsZElkXSA9IGlkO1xuICB9XG5cbiAgdmFyIGQgPSB7fSxcbiAgICAgIGZpZWxkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoaXRlbSksXG4gICAgICBpLFxuICAgICAgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgfVxuICB0aGlzLl9kYXRhW2lkXSA9IGQ7XG4gIHRoaXMubGVuZ3RoKys7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gaXRlbS4gRmllbGRzIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBzcGVjaWZpYyB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFt0eXBlc10gIGZpZWxkIHR5cGVzIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW1cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9nZXRJdGVtID0gZnVuY3Rpb24gKGlkLCB0eXBlcykge1xuICB2YXIgZmllbGQsIHZhbHVlLCBpLCBsZW47XG5cbiAgLy8gZ2V0IHRoZSBpdGVtIGZyb20gdGhlIGRhdGFzZXRcbiAgdmFyIHJhdyA9IHRoaXMuX2RhdGFbaWRdO1xuICBpZiAoIXJhdykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gY29udmVydCB0aGUgaXRlbXMgZmllbGQgdHlwZXNcbiAgdmFyIGNvbnZlcnRlZCA9IHt9LFxuICAgICAgZmllbGRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShyYXcpO1xuXG4gIGlmICh0eXBlcykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICBjb252ZXJ0ZWRbZmllbGRdID0gdXRpbC5jb252ZXJ0KHZhbHVlLCB0eXBlc1tmaWVsZF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBubyBmaWVsZCB0eXBlcyBzcGVjaWZpZWQsIG5vIGNvbnZlcnRpbmcgbmVlZGVkXG4gICAgZm9yIChpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgIHZhbHVlID0gcmF3W2ZpZWxkXTtcbiAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnZlcnRlZFt0aGlzLl9maWVsZElkXSkge1xuICAgIGNvbnZlcnRlZFt0aGlzLl9maWVsZElkXSA9IHJhdy5pZDtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXG4gKiBXaWxsIGZhaWwgd2hlbiB0aGUgaXRlbSBoYXMgbm8gaWQsIG9yIHdoZW4gdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gaXRlbVxuICogd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdXBkYXRlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06ICcgKyAoMCwgX3N0cmluZ2lmeTJbJ2RlZmF1bHQnXSkoaXRlbSkgKyAnKScpO1xuICB9XG4gIHZhciBkID0gdGhpcy5fZGF0YVtpZF07XG4gIGlmICghZCkge1xuICAgIC8vIGl0ZW0gZG9lc24ndCBleGlzdFxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBpdGVtOiBubyBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBmb3VuZCcpO1xuICB9XG5cbiAgLy8gbWVyZ2Ugd2l0aCBjdXJyZW50IGl0ZW1cbiAgdmFyIGZpZWxkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoaXRlbSk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgfVxuXG4gIHJldHVybiBpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNldDtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgTGFiZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KVsnZGVmYXVsdCddO1xudmFyIENvbXBvbmVudFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVsnZGVmYXVsdCddO1xudmFyIEJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KVsnZGVmYXVsdCddO1xudmFyIENpcmNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUxKVsnZGVmYXVsdCddO1xudmFyIENpcmN1bGFySW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MilbJ2RlZmF1bHQnXTtcbnZhciBEYXRhYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUzKVsnZGVmYXVsdCddO1xudmFyIERpYW1vbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NClbJ2RlZmF1bHQnXTtcbnZhciBEb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NSlbJ2RlZmF1bHQnXTtcbnZhciBFbGxpcHNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTYpWydkZWZhdWx0J107XG52YXIgSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU3KVsnZGVmYXVsdCddO1xudmFyIEltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTgpWydkZWZhdWx0J107XG52YXIgU3F1YXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkpWydkZWZhdWx0J107XG52YXIgSGV4YWdvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYwKVsnZGVmYXVsdCddO1xudmFyIFN0YXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MSlbJ2RlZmF1bHQnXTtcbnZhciBUZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjIpWydkZWZhdWx0J107XG52YXIgVHJpYW5nbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MylbJ2RlZmF1bHQnXTtcbnZhciBUcmlhbmdsZURvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NClbJ2RlZmF1bHQnXTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksXG4gICAgcHJpbnRTdHlsZSA9IF9yZXF1aXJlLnByaW50U3R5bGU7XG5cbi8qKlxuICogQSBub2RlLiBBIG5vZGUgY2FuIGJlIGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyB2aWEgb25lIG9yIG11bHRpcGxlIGVkZ2VzLlxuICovXG5cblxudmFyIE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGUgbm9kZS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBleGNlcHQgZm9yIHRoZSBpZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBpZCAgICAgSWQgb2YgdGhlIG5vZGUuIFJlcXVpcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbGFiZWwgIFRleHQgbGFiZWwgZm9yIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geCAgICAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB5ICAgICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBzaGFwZSAgTm9kZSBzaGFwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGltYWdlICBBbiBpbWFnZSB1cmxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSB0aXRsZSAgQSB0aXRsZSB0ZXh0LCBjYW4gYmUgSFRNTFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHthbnl0eXBlfSBncm91cCBBIGdyb3VwIG5hbWUgb3IgbnVtYmVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5ICAgICAgICAgICAgICAgU2hhcmVkIHN0YXRlIG9mIGN1cnJlbnQgbmV0d29yayBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgIEEgbGlzdCB3aXRoIGltYWdlcy4gT25seSBuZWVkZWQgd2hlbiB0aGUgbm9kZSBoYXMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtHcm91cHN9IGdyb3VwbGlzdCAgICAgICAgICBBIGxpc3Qgd2l0aCBncm91cHMuIE5lZWRlZCBmb3IgcmV0cmlldmluZyBncm91cCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnbG9iYWxPcHRpb25zICAgICAgQ3VycmVudCBnbG9iYWwgbm9kZSBvcHRpb25zOyB0aGVzZSBzZXJ2ZSBhcyBkZWZhdWx0cyBmb3IgdGhlIG5vZGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRPcHRpb25zICAgICBHbG9iYWwgZGVmYXVsdCBvcHRpb25zIGZvciBub2Rlczsgbm90ZSB0aGF0IHRoaXMgaXMgYWxzbyB0aGUgcHJvdG90eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBhcmFtZXRlciBgZ2xvYmFsT3B0aW9uc2AuXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE5vZGUpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5icmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIHRoaXMuZWRnZXMgPSBbXTsgLy8gYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGVcblxuICAgIC8vIHNldCBkZWZhdWx0cyBmb3IgdGhlIG9wdGlvbnNcbiAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW1hZ2VsaXN0ID0gaW1hZ2VsaXN0O1xuICAgIHRoaXMuZ3JvdXBsaXN0ID0gZ3JvdXBsaXN0O1xuXG4gICAgLy8gc3RhdGUgb3B0aW9uc1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMub3B0aW9ucy5zaXplO1xuICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlOyAvLyB1c2VkIHRvIGNoZWNrIGlmIGluaXRpYWwgZml0IHNob3VsZCBqdXN0IHRha2UgdGhlIHJhbmdlIG9yIGFwcHJveGltYXRlXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgTGFiZWwodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIGZhbHNlIC8qIE5vdCBlZGdlIGxhYmVsICovXG4gICAgKTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGEgZWRnZSB0byB0aGUgbm9kZVxuICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShOb2RlLCBbe1xuICAgIGtleTogJ2F0dGFjaEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hFZGdlKGVkZ2UpIHtcbiAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYSBlZGdlIGZyb20gdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXRhY2hFZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoRWRnZShlZGdlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgdGhpcy5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFNoYXBlID0gdGhpcy5vcHRpb25zLnNoYXBlO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm90ZSB0aGF0IHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSAndW5kZWZpbmVkJyEgVGhpcyBpcyBPSy5cbiAgICAgIH1cblxuICAgICAgLy8gYmFzaWMgb3B0aW9uc1xuICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgbXVzdCBoYXZlIGFuIGlkJyk7XG4gICAgICB9XG5cbiAgICAgIE5vZGUuY2hlY2tNYXNzKG9wdGlvbnMsIHRoaXMuaWQpO1xuXG4gICAgICAvLyBzZXQgdGhlc2Ugb3B0aW9ucyBsb2NhbGx5XG4gICAgICAvLyBjbGVhciB4IGFuZCB5IHBvc2l0aW9uc1xuICAgICAgaWYgKG9wdGlvbnMueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnggPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnggPSBwYXJzZUludChvcHRpb25zLngpO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnkgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnkgPSBwYXJzZUludChvcHRpb25zLnkpO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZVNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMudmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGlzIHRyYW5zZm9ybXMgYWxsIHNob3J0aGFuZHMgaW50byBmdWxseSBkZWZpbmVkIG9wdGlvbnNcbiAgICAgIE5vZGUucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5nbG9iYWxPcHRpb25zLCB0aGlzLmdyb3VwbGlzdCk7XG5cbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBDb21wb25lbnRVdGlsLmNob29zaWZ5KCdub2RlJywgcGlsZSk7XG5cbiAgICAgIHRoaXMuX2xvYWRfaW1hZ2VzKCk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpO1xuICAgICAgdGhpcy51cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpO1xuXG4gICAgICByZXR1cm4gb3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBpbWFnZXMgZnJvbSB0aGUgb3B0aW9ucywgZm9yIHRoZSBub2RlcyB0aGF0IG5lZWQgdGhlbS5cbiAgICAgKlxuICAgICAqIEltYWdlcyBhcmUgYWx3YXlzIGxvYWRlZCwgZXZlbiBpZiB0aGV5IGFyZSBub3QgdXNlZCBpbiB0aGUgY3VycmVudCBzaGFwZS5cbiAgICAgKiBUaGUgdXNlciBtYXkgc3dpdGNoIHRvIGFuIGltYWdlIHNoYXBlIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2xvYWRfaW1hZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRfaW1hZ2VzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gJ2NpcmN1bGFySW1hZ2UnIHx8IHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gaW1hZ2UgbXVzdCBiZSBkZWZpbmVkIGZvciBub2RlIHR5cGUgJ1wiICsgdGhpcy5vcHRpb25zLnNoYXBlICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmltYWdlbGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgRXJyb3I6IE5vIGltYWdlcyBwcm92aWRlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVuc2VsZWN0ZWQgaW1hZ2UgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS5zZWxlY3RlZCwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBncm91cCBvcHRpb24gdmFsdWVzIGludG8gdGhlIG5vZGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBncm91cCBvcHRpb25zIG92ZXJyaWRlIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zLCBzbyB0aGUgY29weSBvZiBncm91cCBvcHRpb25zXG4gICAgICogIG11c3QgaGFwcGVuICphZnRlciogdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG11c3QgYWxzbyBiZSBjYWxsZWQgYWxzbyBpZiB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucyBoYXZlIGNoYW5nZWQgYW5kIHRoZSBncm91cCBvcHRpb25zIGRpZCBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPcHRpb25zICBuZXcgdmFsdWVzIGZvciB0aGUgb3B0aW9ucywgY3VycmVudGx5IG9ubHkgcGFzc2VkIGluIGZvciBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncm91cExpc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0dGluZ1ZhbHVlcycsXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tjb2xvcjogKiwgYm9yZGVyV2lkdGg6ICosIGJvcmRlckNvbG9yOiAqLCBzaXplOiAqLCBib3JkZXJEYXNoZXM6IChib29sZWFufEFycmF5fGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlc3x7Ym9vbGVhbiwgYXJyYXl9KSwgYm9yZGVyUmFkaXVzOiAobnVtYmVyfGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1c3x7bnVtYmVyfXxBcnJheSksIHNoYWRvdzogKiwgc2hhZG93Q29sb3I6ICosIHNoYWRvd1NpemU6ICosIHNoYWRvd1g6ICosIHNoYWRvd1k6ICp9fVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgY29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXJXaWR0aDogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcixcbiAgICAgICAgc2l6ZTogdGhpcy5vcHRpb25zLnNpemUsXG4gICAgICAgIGJvcmRlckRhc2hlczogdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMsXG4gICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXMsXG4gICAgICAgIHNoYWRvdzogdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLFxuICAgICAgICBzaGFkb3dDb2xvcjogdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcixcbiAgICAgICAgc2hhZG93U2l6ZTogdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplLFxuICAgICAgICBzaGFkb3dYOiB0aGlzLm9wdGlvbnMuc2hhZG93LngsXG4gICAgICAgIHNoYWRvd1k6IHRoaXMub3B0aW9ucy5zaGFkb3cueVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYm9yZGVyV2lkdGggKj0gMjtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaG92ZXIpIHtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kO1xuICAgICAgICAgICAgdmFsdWVzLmJvcmRlckNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNob29zZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmNob29zZXIodmFsdWVzLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3dDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCB2YWx1ZXMuc2hhZG93U2l6ZSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplIHx8IHZhbHVlcy5zaGFkb3dYICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnggfHwgdmFsdWVzLnNoYWRvd1kgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlTGFiZWxNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmxhYmVsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sYWJlbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMuZ3JvdXBsaXN0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIE5vdGU6VGhlIHByb3RvdHlwZSBjaGFpbiBmb3IgdGhpcy5vcHRpb25zIGlzOlxuICAgICAgLy9cbiAgICAgIC8vIHRoaXMub3B0aW9ucyAtPiAgICBOb2Rlc0hhbmRsZXIub3B0aW9ucyAgICAtPiBOb2Rlc0hhbmRsZXIuZGVmYXVsdE9wdGlvbnNcbiAgICAgIC8vICAgICAgICAgICAgICAgICAoYWxzbzogdGhpcy5nbG9iYWxPcHRpb25zKVxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcHJvdG90eXBlcyBhcmUgbWVudGlvbmVkIGV4cGxpY2l0bHkgaW4gdGhlIHBpbGUgbGlzdCBiZWxvdztcbiAgICAgIC8vIFdFIERPTidUIFdBTlQgVEhFIE9SREVSIE9GIFRIRSBQUk9UT1RZUEVTISEhISBBdCBsZWFzdCwgbm90IGZvciBmb250IGhhbmRsaW5nIG9mIGxhYmVscy5cbiAgICAgIC8vIFRoaXMgaXMgYSBnb29kIGluZGljYXRpb24gdGhhdCB0aGUgcHJvdG90eXBlIHVzYWdlIG9mIG9wdGlvbnMgaXMgZGVmaWNpZW50LlxuICAgICAgLy9cbiAgICAgIHZhciBjdXJyZW50R3JvdXAgPSB0aGlzLmdyb3VwbGlzdC5nZXQodGhpcy5vcHRpb25zLmdyb3VwLCBmYWxzZSk7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCAvLyBuZXcgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zLCAvLyBjdXJyZW50IG5vZGUgb3B0aW9ucywgc2VlIGNvbW1lbnQgYWJvdmUgZm9yIHByb3RvdHlwZVxuICAgICAgY3VycmVudEdyb3VwLCAvLyBncm91cCBvcHRpb25zLCBpZiBhbnlcbiAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucywgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgbm9kZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zIC8vIERlZmF1bHQgZ2xvYmFsIG5vZGUgb3B0aW9uc1xuICAgICAgXTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUudXBkYXRlKHRoaXMub3B0aW9ucywgcGlsZSk7XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRTaGFwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVTaGFwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNoYXBlKGN1cnJlbnRTaGFwZSkge1xuICAgICAgaWYgKGN1cnJlbnRTaGFwZSA9PT0gdGhpcy5vcHRpb25zLnNoYXBlICYmIHRoaXMuc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaG9vc2UgZHJhdyBtZXRob2QgZGVwZW5kaW5nIG9uIHRoZSBzaGFwZVxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEJveCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBDaXJjbGUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2lyY3VsYXJJbWFnZSc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IENpcmN1bGFySW1hZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGF0YWJhc2UnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEYXRhYmFzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRGlhbW9uZCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkb3QnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEb3QodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEVsbGlwc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEljb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBJbWFnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTcXVhcmUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaGV4YWdvbic6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEhleGFnb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3Rhcic6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFN0YXIodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRleHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndHJpYW5nbGUnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0cmlhbmdsZURvd24nOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZURvd24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRWxsaXBzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhpcyBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1bnNlbGVjdCB0aGlzIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5zZWxlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmVlZHNSZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgbm9kZSwgZm9yY2VzIGl0IHRvIHJlY2FsY3VsYXRlIGl0cyBzaXplXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ25lZWRzUmVmcmVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuc2hhcGUucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIG5vZGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aXRsZSAgICBUaGUgdGl0bGUgb2YgdGhlIG5vZGUsIG9yIHVuZGVmaW5lZCB3aGVuIG5vIHRpdGxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFRpdGxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlIGJvcmRlciBvZiB0aGUgTm9kZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAgICAgICAgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlICAgRGlzdGFuY2UgdG8gdGhlIGJvcmRlciBpbiBwaXhlbHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG5vZGUgaGFzIGEgZml4ZWQgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgdHJ1ZSBpZiBmaXhlZCwgZmFsc2UgaWYgbm90XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzRml4ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpeGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maXhlZC54ICYmIHRoaXMub3B0aW9ucy5maXhlZC55O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gc2VsZWN0ZWQgICBUcnVlIGlmIG5vZGUgaXMgc2VsZWN0ZWQsIGVsc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNTZWxlY3RlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIG5vZGUuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICogQHJldHVybiB7cmVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGFiZWxTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWxNb2R1bGUuc2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIG5vZGUuIFRoZSBub2RlIHdpbGwgYWRqdXN0IGl0J3Mgc2l6ZVxuICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZVJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWVSYW5nZShtaW4sIG1heCwgdG90YWwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICB2YXIgc2l6ZURpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiBzaXplRGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5iYXNlU2l6ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcbiAgICAgIHRoaXMuc2hhcGUuZHJhdyhjdHgsIHRoaXMueCwgdGhpcy55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBzaGFwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgdGhpcy5zaGFwZS51cGRhdGVCb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSwgY3R4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICB0aGlzLnNoYXBlLnJlc2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB2aXN1YWwgZWxlbWVudHMgb2YgdGhpcyBub2RlIGluc3RhbmNlLCBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICAgKiBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGJvdW5kaW5nIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtPn0gbGlzdCB3aXRoIHRoZSBpdGVtcyB3aGljaCBhcmUgb24gdGhlIHBvaW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEl0ZW1zT25Qb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1zT25Qb2ludChwb2ludCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS52aXNpYmxlKCkpIHtcbiAgICAgICAgaWYgKENvbXBvbmVudFV0aWwucG9pbnRJblJlY3QodGhpcy5sYWJlbE1vZHVsZS5nZXRTaXplKCksIHBvaW50KSkge1xuICAgICAgICAgIHJldC5wdXNoKHsgbm9kZUlkOiB0aGlzLmlkLCBsYWJlbElkOiAwIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChDb21wb25lbnRVdGlsLnBvaW50SW5SZWN0KHRoaXMuc2hhcGUuYm91bmRpbmdCb3gsIHBvaW50KSkge1xuICAgICAgICByZXQucHVzaCh7IG5vZGVJZDogdGhpcy5pZCB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNPdmVybGFwcGluZ1dpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmxlZnQgPCBvYmoucmlnaHQgJiYgdGhpcy5zaGFwZS5sZWZ0ICsgdGhpcy5zaGFwZS53aWR0aCA+IG9iai5sZWZ0ICYmIHRoaXMuc2hhcGUudG9wIDwgb2JqLmJvdHRvbSAmJiB0aGlzLnNoYXBlLnRvcCArIHRoaXMuc2hhcGUuaGVpZ2h0ID4gb2JqLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQgPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20gPiBvYmoudG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkIHZhbHVlcyBmb3IgbWFzc1xuICAgICAqXG4gICAgICogVGhlIG1hc3MgbWF5IG5vdCBiZSBuZWdhdGl2ZSBvciB6ZXJvLiBJZiBpdCBpcywgcmVzZXQgdG8gMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGlkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogJ3VwZGF0ZUdyb3VwT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUdyb3VwT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBncm91cExpc3QpIHtcbiAgICAgIGlmIChncm91cExpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBObyBncm91cHMsIG5vdGhpbmcgdG8gZG9cblxuICAgICAgdmFyIGdyb3VwID0gcGFyZW50T3B0aW9ucy5ncm91cDtcblxuICAgICAgLy8gcGFyYW5vaWE6IHRoZSBzZWxlY3RlZCBncm91cCBpcyBhbHJlYWR5IG1lcmdlZCBpbnRvIG5vZGUgb3B0aW9ucywgY2hlY2suXG4gICAgICBpZiAobmV3T3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZ3JvdXAgIT09IHVuZGVmaW5lZCAmJiBncm91cCAhPT0gbmV3T3B0aW9ucy5ncm91cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cGRhdGVHcm91cE9wdGlvbnM6IGdyb3VwIHZhbHVlcyBpbiBvcHRpb25zIGRvbid0IG1hdGNoLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0dyb3VwID0gdHlwZW9mIGdyb3VwID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZ3JvdXAgPT09ICdzdHJpbmcnICYmIGdyb3VwICE9ICcnO1xuICAgICAgaWYgKCFoYXNHcm91cCkgcmV0dXJuOyAvLyBjdXJyZW50IG5vZGUgaGFzIG5vIGdyb3VwLCBubyBuZWVkIHRvIG1lcmdlXG5cbiAgICAgIHZhciBncm91cE9iaiA9IGdyb3VwTGlzdC5nZXQoZ3JvdXApO1xuXG4gICAgICAvLyBTa2lwIG1lcmdpbmcgb2YgZ3JvdXAgZm9udCBvcHRpb25zIGludG8gcGFyZW50OyB0aGVzZSBhcmUgcmVxdWlyZWQgdG8gYmUgZGlzdGluY3QgZm9yIGxhYmVsc1xuICAgICAgLy8gQWxzbyBza2lwIG1lcmdpbiBvZiBjb2xvciBJRiBpdCBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIG5vZGUgaXRzZWxmLiBUaGlzIGlzIHRvIGF2b2lkIHRoZSBjb2xvciBvZiB0aGVcbiAgICAgIC8vIGdyb3VwIG92ZXJyaWRpbmcgdGhlIGNvbG9yIHNldCBhdCB0aGUgbm9kZSBsZXZlbFxuICAgICAgLy8gVE9ETzogSXQgbWlnaHQgbm90IGJlIGEgZ29vZCBpZGVhIGVpdGhlciB0byBtZXJnZSB0aGUgcmVzdCBvZiB0aGUgb3B0aW9ucywgaW52ZXN0aWdhdGUgdGhpcy5cbiAgICAgIHZhciBza2lwUHJvcGVydGllcyA9IFsnZm9udCddO1xuICAgICAgaWYgKG5ld09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPSBudWxsKSBza2lwUHJvcGVydGllcy5wdXNoKCdjb2xvcicpO1xuICAgICAgdXRpbC5zZWxlY3RpdmVOb3REZWVwRXh0ZW5kKHNraXBQcm9wZXJ0aWVzLCBwYXJlbnRPcHRpb25zLCBncm91cE9iaik7XG5cbiAgICAgIC8vIHRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gYmUgY29tcGxldGVseSBkZWZpbmVkLlxuICAgICAgLy8gU2luY2UgZ3JvdXBzIGNhbiBwYXJ0aWFsbHkgb3ZlcndyaXRlIHRoZSBjb2xvcnMsIHdlIHBhcnNlIGl0IGFnYWluLCBqdXN0IGluIGNhc2UuXG4gICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gdXRpbC5wYXJzZUNvbG9yKHBhcmVudE9wdGlvbnMuY29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvY2VzcyBhbGwgcG9zc2libGUgc2hvcnRoYW5kcyBpbiB0aGUgbmV3IG9wdGlvbnMgYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgcGFyZW50T3B0aW9ucyBhcmUgZnVsbHkgZGVmaW5lZC5cbiAgICAgKiBTdGF0aWMgc28gaXQgY2FuIGFsc28gYmUgdXNlZCBieSB0aGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dyb3VwTGlzdF1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgZ3JvdXBMaXN0ID0gYXJndW1lbnRzWzRdO1xuXG4gICAgICB2YXIgZmllbGRzID0gWydjb2xvcicsICdmaXhlZCcsICdzaGFkb3cnXTtcbiAgICAgIHV0aWwuc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuXG4gICAgICBOb2RlLmNoZWNrTWFzcyhuZXdPcHRpb25zKTtcblxuICAgICAgLy8gbWVyZ2UgdGhlIHNoYWRvdyBvcHRpb25zIGludG8gdGhlIHBhcmVudC5cbiAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsICdzaGFkb3cnLCBnbG9iYWxPcHRpb25zKTtcblxuICAgICAgLy8gaW5kaXZpZHVhbCBzaGFwZSBuZXdPcHRpb25zXG4gICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcnNlZENvbG9yID0gdXRpbC5wYXJzZUNvbG9yKG5ld09wdGlvbnMuY29sb3IpO1xuICAgICAgICB1dGlsLmZpbGxJZkRlZmluZWQocGFyZW50T3B0aW9ucy5jb2xvciwgcGFyc2VkQ29sb3IpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgdGhlIGZpeGVkIG9wdGlvbnNcbiAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5maXhlZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuZml4ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC54ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC55ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIE5vZGUudXBkYXRlR3JvdXBPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGdyb3VwTGlzdCk7XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgc2NhbGluZyBvcHRpb25zLCBzcGVjaWZpY2FsbHkgdGhlIGxhYmVsIHBhcnRcbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgJ2xhYmVsJywgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja01hc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja01hc3Mob3B0aW9ucywgaWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLm1hc3MgPD0gMCkge1xuICAgICAgICB2YXIgc3RySWQgPSAnJztcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJJZCA9ICcgaW4gbm9kZSBpZDogJyArIGlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCclY05lZ2F0aXZlIG9yIHplcm8gbWFzcyBkaXNhbGxvd2VkJyArIHN0cklkICsgJywgc2V0dGluZyBtYXNzIHRvIDEuJywgcHJpbnRTdHlsZSk7XG4gICAgICAgIG9wdGlvbnMubWFzcyA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbXBvbmVudHNcbiAqIEBjbGFzc1xuICovXG5cbnZhciBDb21wb25lbnRVdGlsID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnRVdGlsKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENvbXBvbmVudFV0aWwpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ29tcG9uZW50VXRpbCwgbnVsbCwgW3tcbiAgICBrZXk6ICdjaG9vc2lmeScsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdmFsdWVzIHRvIHVzZSBmb3IgKHN1YilvcHRpb25zIG9mICdjaG9zZW4nLlxuICAgICAqXG4gICAgICogVGhpcyBvcHRpb24gaXMgZWl0aGVyIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSBleGFtaW5lZCBmdXJ0aGVyLlxuICAgICAqIFRoZSByZWxldmFudCBzdHJ1Y3R1cmVzIGFyZTpcbiAgICAgKlxuICAgICAqIC0gY2hvc2VuOiA8Ym9vbGVhbiB2YWx1ZT5cbiAgICAgKiAtIGNob3NlbjogeyBzdWJPcHRpb246IDxib29sZWFuIG9yIGZ1bmN0aW9uPiB9XG4gICAgICpcbiAgICAgKiBXaGVyZSBzdWJPcHRpb24gaXMgJ25vZGUnLCAnZWRnZScgb3IgJ2xhYmVsJy5cbiAgICAgKlxuICAgICAqIFRoZSBpbnRlbnRpb24gb2YgdGhpcyBtZXRob2QgYXBwZWFycyB0byBiZSB0byBzZXQgYSBzcGVjaWZpYyBwcmlvcml0eSB0byB0aGUgb3B0aW9ucztcbiAgICAgKiBTaW5jZSBtb3N0IHByb3BlcnRpZXMgYXJlIGVpdGhlciBicmlkZ2VkIG9yIG1lcmdlZCBpbnRvIHRoZSBsb2NhbCBvcHRpb25zIG9iamVjdHMsIHRoZXJlXG4gICAgICogaXMgbm90IG11Y2ggcG9pbnQgaW4gaGFuZGxpbmcgdGhlbSBzZXBhcmF0ZWx5LlxuICAgICAqIFRPRE86IGV4YW1pbmUgaWYgJ21vc3QnIGluIHByZXZpb3VzIHNlbnRlbmNlIGNhbiBiZSByZXBsYWNlZCB3aXRoICdhbGwnLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgICogICAgICAgc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgc3ViT3B0aW9uICBvcHRpb24gd2l0aGluIG9iamVjdCAnY2hvc2VuJyB0byBjb25zaWRlcjsgZWl0aGVyICdub2RlJywgJ2VkZ2UnIG9yICdsYWJlbCdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIHBpbGUgICAgICAgYXJyYXkgb2Ygb3B0aW9ucyBvYmplY3RzIHRvIGNvbnNpZGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufGZ1bmN0aW9ufSAgdmFsdWUgZm9yIHBhc3NlZCBzdWJPcHRpb24gb2YgJ2Nob3NlbicgdG8gdXNlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNob29zaWZ5KHN1Yk9wdGlvbiwgcGlsZSkge1xuICAgICAgLy8gYWxsb3dlZCB2YWx1ZXMgZm9yIHN1Yk9wdGlvblxuICAgICAgdmFyIGFsbG93ZWQgPSBbJ25vZGUnLCAnZWRnZScsICdsYWJlbCddO1xuICAgICAgdmFyIHZhbHVlID0gdHJ1ZTtcblxuICAgICAgdmFyIGNob3NlbiA9IHV0aWwudG9wTW9zdChwaWxlLCAnY2hvc2VuJyk7XG4gICAgICBpZiAodHlwZW9mIGNob3NlbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhbHVlID0gY2hvc2VuO1xuICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGNob3NlbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShjaG9zZW4pKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQuaW5kZXhPZihzdWJPcHRpb24pID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNob29zaWZ5OiBzdWJPcHRpb24gJ1wiICsgc3ViT3B0aW9uICsgXCInIHNob3VsZCBiZSBvbmUgb2YgXCIgKyBcIidcIiArIGFsbG93ZWQuam9pbihcIicsICdcIikgKyBcIidcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hvc2VuRWRnZSA9IHV0aWwudG9wTW9zdChwaWxlLCBbJ2Nob3NlbicsIHN1Yk9wdGlvbl0pO1xuICAgICAgICBpZiAodHlwZW9mIGNob3NlbkVkZ2UgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgY2hvc2VuRWRnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhbHVlID0gY2hvc2VuRWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtyZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcGFyYW0ge3JvdGF0aW9uUG9pbnR9IFtyb3RhdGlvblBvaW50XSBpZiBzcGVjaWZpZWQsIHRoZSByb3RhdGlvbiB0aGF0IGFwcGxpZXMgdG8gdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gIHRydWUgaWYgcG9pbnQgd2l0aGluIHJlY3RhbmdsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwb2ludEluUmVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvaW50SW5SZWN0KHJlY3QsIHBvaW50LCByb3RhdGlvblBvaW50KSB7XG4gICAgICBpZiAocmVjdC53aWR0aCA8PSAwIHx8IHJlY3QuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBlYXJseSBvdXRcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uUG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IHRoZSBzYW1lIGFtb3VudCBhcyB0aGUgcmVjdGFuZ2xlXG4gICAgICAgIHZhciB0bXAgPSB7XG4gICAgICAgICAgeDogcG9pbnQueCAtIHJvdGF0aW9uUG9pbnQueCxcbiAgICAgICAgICB5OiBwb2ludC55IC0gcm90YXRpb25Qb2ludC55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uUG9pbnQuYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgdGhlIGNvb3JkaW5hdGVzIHRoZSBzYW1lLCB5b3UgbmVlZCB0b1xuICAgICAgICAgIC8vIHJvdGF0ZSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgICAgICB2YXIgYW5nbGUgPSAtcm90YXRpb25Qb2ludC5hbmdsZTtcblxuICAgICAgICAgIHZhciB0bXAyID0ge1xuICAgICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogdG1wLnggLSBNYXRoLnNpbihhbmdsZSkgKiB0bXAueSxcbiAgICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIHRtcC54ICsgTWF0aC5jb3MoYW5nbGUpICogdG1wLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHBvaW50ID0gdG1wMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpZiBhIHJvdGF0aW9uIGlzIHNwZWNpZmllZCwgdGhlIHJlY3RhbmdsZSBjb29yZGluYXRlc1xuICAgICAgICAvLyBhcmUgKipub3QqIHRoZSBmdWxsIGNhbnZhcyBjb29yZGluYXRlcy4gVGhleSBhcmUgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgIC8vIHJvdGF0aW9uUG9pbnQuIEhlbmNlLCB0aGUgcG9pbnQgY29vcmRpbmF0ZXMgbmVlZCBub3QgYmUgdHJhbnNsYXRlZFxuICAgICAgICAvLyBiYWNrIGluIHRoaXMgY2FzZS5cbiAgICAgIH1cblxuICAgICAgdmFyIHJpZ2h0ID0gcmVjdC54ICsgcmVjdC53aWR0aDtcbiAgICAgIHZhciBib3R0b20gPSByZWN0LnkgKyByZWN0LndpZHRoO1xuXG4gICAgICByZXR1cm4gcmVjdC5sZWZ0IDwgcG9pbnQueCAmJiByaWdodCA+IHBvaW50LnggJiYgcmVjdC50b3AgPCBwb2ludC55ICYmIGJvdHRvbSA+IHBvaW50Lnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZ2l2ZW4gdmFsdWUgaXMgYWNjZXB0YWJsZSBhcyBhIGxhYmVsIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHRleHQgdmFsdWUgdG8gY2hlY2s7IGNhbiBiZSBhbnl0aGluZyBhdCB0aGlzIHBvaW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQgbGFiZWwgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc1ZhbGlkTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkTGFiZWwodGV4dCkge1xuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgcXVpdGUgc3RyaWN0OiB0eXBlcyB0aGF0ICptaWdodCogYmUgY29udmVydGVkIHRvIHN0cmluZyBhcmUgZGlzYWxsb3dlZFxuICAgICAgcmV0dXJuIHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyAmJiB0ZXh0ICE9PSAnJztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbXBvbmVudFV0aWw7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbXBvbmVudFV0aWw7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9uVG91Y2ggPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgcmVsZWFzZSBldmVudCwgdGFraW5nIHBsYWNlIGFmdGVyIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMub25SZWxlYXNlID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmluYWwpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9mZlRvdWNoID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgaGFtbWVyLm9mZignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub2ZmUmVsZWFzZSA9IGV4cG9ydHMub2ZmVG91Y2g7XG5cbi8qKlxuICogSGFjayB0aGUgUGluY2hSZWNvZ25pemVyIHN1Y2ggdGhhdCBpdCBkb2Vzbid0IHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvclxuICogZm9yIHZlcnRpY2FsIHBhbm5pbmcuXG4gKlxuICogWWVhaCAuLi4gdGhpcyBpcyBxdWl0ZSBhIGhhY2sgLi4uIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGFtbWVyanMvaGFtbWVyLmpzL2lzc3Vlcy85MzJcbiAqXG4gKiBAcGFyYW0ge0hhbW1lci5QaW5jaH0gcGluY2hSZWNvZ25pemVyXG4gKiBAcmV0dXJuIHtIYW1tZXIuUGluY2h9IHJldHVybnMgdGhlIHBpbmNoUmVjb2duaXplclxuICovXG5leHBvcnRzLmRpc2FibGVQcmV2ZW50RGVmYXVsdFZlcnRpY2FsbHkgPSBmdW5jdGlvbiAocGluY2hSZWNvZ25pemVyKSB7XG4gIHZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuXG4gIHBpbmNoUmVjb2duaXplci5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBkZWZhdWx0IG1ldGhvZCByZXR1cm5zIFtUT1VDSF9BQ1RJT05fTk9ORV1cbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gIH07XG5cbiAgcmV0dXJuIHBpbmNoUmVjb2duaXplcjtcbn07XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xudmFyIFRPX1NUUklOR19UQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgZFBzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSgna2V5cycpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE4IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRhdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDYwKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG52YXIgd2tzRXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG4vKipcbiAqIERhdGFWaWV3XG4gKlxuICogYSBkYXRhdmlldyBvZmZlcnMgYSBmaWx0ZXJlZCB2aWV3IG9uIGEgZGF0YXNldCBvciBhbiBvdGhlciBkYXRhdmlldy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOiBzZWUgbWV0aG9kIGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvciBEYXRhVmlld1xuICovXG5mdW5jdGlvbiBEYXRhVmlldyhkYXRhLCBvcHRpb25zKSB7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB0aGlzLl9pZHMgPSB7fTsgLy8gaWRzIG9mIHRoZSBpdGVtcyBjdXJyZW50bHkgaW4gbWVtb3J5IChqdXN0IGNvbnRhaW5zIGEgYm9vbGVhbiB0cnVlKVxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgRGF0YVZpZXdcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2ZpZWxkSWQgPSAnaWQnOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gIHRoaXMuX3N1YnNjcmliZXJzID0ge307IC8vIGV2ZW50IHN1YnNjcmliZXJzXG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBtZS5fb25FdmVudC5hcHBseShtZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59XG5cbi8vIFRPRE86IGltcGxlbWVudCBhIGZ1bmN0aW9uIC5jb25maWcoKSB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhpbmdzIGxpa2UgY29uZmlndXJlZCBmaWx0ZXJcbi8vIGFuZCB0cmlnZ2VyIGNoYW5nZXMgYWNjb3JkaW5nbHlcblxuLyoqXG4gKiBTZXQgYSBkYXRhIHNvdXJjZSBmb3IgdGhlIHZpZXdcbiAqIEBwYXJhbSB7RGF0YVNldCB8IERhdGFWaWV3fSBkYXRhXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGlkcywgaWQsIGksIGxlbiwgaXRlbXM7XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgIGlmICh0aGlzLl9kYXRhLm9mZikge1xuICAgICAgdGhpcy5fZGF0YS5vZmYoJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGEgcmVtb3ZlIG9mIGFsbCBpdGVtcyBpbiBtZW1vcnlcbiAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7IGZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlciB9KTtcbiAgICBpdGVtcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMuX2RhdGEuX2RhdGFbaWRzW2ldXSk7XG4gICAgfVxuXG4gICAgdGhpcy5faWRzID0ge307XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IGlkcywgb2xkRGF0YTogaXRlbXMgfSk7XG4gIH1cblxuICB0aGlzLl9kYXRhID0gZGF0YTtcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIC8vIHVwZGF0ZSBmaWVsZElkXG4gICAgdGhpcy5fZmllbGRJZCA9IHRoaXMuX29wdGlvbnMuZmllbGRJZCB8fCB0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEub3B0aW9ucyAmJiB0aGlzLl9kYXRhLm9wdGlvbnMuZmllbGRJZCB8fCAnaWQnO1xuXG4gICAgLy8gdHJpZ2dlciBhbiBhZGQgb2YgYWxsIGFkZGVkIGl0ZW1zXG4gICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoeyBmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXIgfSk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IGlkc1tpXTtcbiAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IGlkcy5sZW5ndGg7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogaWRzIH0pO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgIHRoaXMuX2RhdGEub24oJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb25cbiAqIGNvbnRhaW5pbmcgYSB2YXJpYWJsZSBwYXJhbWV0ZXIuXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQsIGksIGxlbjtcbiAgdmFyIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICBmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXJcbiAgfSksXG4gICAgICBvbGRJZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuX2lkcyksXG4gICAgICBuZXdJZHMgPSB7fSxcbiAgICAgIGFkZGVkSWRzID0gW10sXG4gICAgICByZW1vdmVkSWRzID0gW10sXG4gICAgICByZW1vdmVkSXRlbXMgPSBbXTtcblxuICAvLyBjaGVjayBmb3IgYWRkaXRpb25zXG4gIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlkID0gaWRzW2ldO1xuICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuICAgIGlmICghdGhpcy5faWRzW2lkXSkge1xuICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBmb3IgcmVtb3ZhbHNcbiAgZm9yIChpID0gMCwgbGVuID0gb2xkSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWQgPSBvbGRJZHNbaV07XG4gICAgaWYgKCFuZXdJZHNbaWRdKSB7XG4gICAgICByZW1vdmVkSWRzLnB1c2goaWQpO1xuICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2godGhpcy5fZGF0YS5fZGF0YVtpZF0pO1xuICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7XG5cbiAgLy8gdHJpZ2dlciBldmVudHNcbiAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0pO1xuICB9XG4gIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWRJZHMsIG9sZERhdGE6IHJlbW92ZWRJdGVtcyB9KTtcbiAgfVxufTtcblxuLy8gcHJldHRpZXItaWdub3JlXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIGRhdGEgdmlld1xuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBnZXQoKVxuICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZDogTnVtYmVyKVxuICogICAgIGdldChpZDogTnVtYmVyLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZHM6IE51bWJlcltdKVxuICogICAgIGdldChpZHM6IE51bWJlcltdLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogV2hlcmU6XG4gKlxuICoge251bWJlciB8IHN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICoge251bWJlcltdIHwgc3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gW3R5cGVdIFR5cGUgb2YgZGF0YSB0byBiZSByZXR1cm5lZC4gQ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSAnRGF0YVRhYmxlJyBvciAnQXJyYXknIChkZWZhdWx0KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFtjb252ZXJ0XVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nW119IFtmaWVsZHNdIGZpZWxkIG5hbWVzIHRvIGJlIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIHtBcnJheSB8IERhdGFUYWJsZX0gW2RhdGFdICAgSWYgcHJvdmlkZWQsIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSBvciB0YWJsZS4gUmVxdWlyZWQgaW4gY2FzZSBvZiBHb29nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YVRhYmxlLlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RGF0YVNldHxEYXRhVmlld31cbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gIHZhciBpZHMsIG9wdGlvbnMsIGRhdGE7XG4gIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicgfHwgZmlyc3RUeXBlID09ICdBcnJheScpIHtcbiAgICAvLyBnZXQoaWQocykgWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgaWRzID0gYXJndW1lbnRzWzBdOyAvLyBjYW4gYmUgYSBzaW5nbGUgaWQgb3IgYW4gYXJyYXkgd2l0aCBpZHNcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgIGRhdGEgPSBhcmd1bWVudHNbMl07XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2V0KFssIG9wdGlvbnNdIFssIGRhdGFdKVxuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuXG4gIC8vIGV4dGVuZCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgYW5kIHByb3ZpZGVkIG9wdGlvbnNcbiAgdmFyIHZpZXdPcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBhIGNvbWJpbmVkIGZpbHRlciBtZXRob2Qgd2hlbiBuZWVkZWRcbiAgaWYgKHRoaXMuX29wdGlvbnMuZmlsdGVyICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICB2aWV3T3B0aW9ucy5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIG1lLl9vcHRpb25zLmZpbHRlcihpdGVtKSAmJiBvcHRpb25zLmZpbHRlcihpdGVtKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gYnVpbGQgdXAgdGhlIGNhbGwgdG8gdGhlIGxpbmtlZCBkYXRhIHNldFxuICB2YXIgZ2V0QXJndW1lbnRzID0gW107XG4gIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgZ2V0QXJndW1lbnRzLnB1c2goaWRzKTtcbiAgfVxuICBnZXRBcmd1bWVudHMucHVzaCh2aWV3T3B0aW9ucyk7XG4gIGdldEFyZ3VtZW50cy5wdXNoKGRhdGEpO1xuXG4gIHJldHVybiB0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuZ2V0LmFwcGx5KHRoaXMuX2RhdGEsIGdldEFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfG51bWJlcj59IGlkc1xuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0SWRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGlkcztcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHZhciBkZWZhdWx0RmlsdGVyID0gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgfVxuXG4gICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWRzID0gW107XG4gIH1cblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBNYXAgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFt0eXBlXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0W119IG1hcHBlZEl0ZW1zXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIG1hcHBlZEl0ZW1zID0gW107XG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICB2YXIgZmlsdGVyO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB9XG5cbiAgICBtYXBwZWRJdGVtcyA9IHRoaXMuX2RhdGEubWFwKGNhbGxiYWNrLCB7XG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXBwZWRJdGVtcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBlZEl0ZW1zO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIERhdGFTZXQgdG8gd2hpY2ggdGhpcyBEYXRhVmlldyBpcyBjb25uZWN0ZWQuIEluIGNhc2UgdGhlcmUgaXMgYSBjaGFpblxuICogb2YgbXVsdGlwbGUgRGF0YVZpZXdzLCB0aGUgcm9vdCBEYXRhU2V0IG9mIHRoaXMgY2hhaW4gaXMgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtEYXRhU2V0fSBkYXRhU2V0XG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5nZXREYXRhU2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YVNldCA9IHRoaXM7XG4gIHdoaWxlIChkYXRhU2V0IGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBkYXRhU2V0ID0gZGF0YVNldC5fZGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YVNldCB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBFdmVudCBsaXN0ZW5lci4gV2lsbCBwcm9wYWdhdGUgYWxsIGV2ZW50cyBmcm9tIHRoZSBjb25uZWN0ZWQgZGF0YSBzZXQgdG9cbiAqIHRoZSBzdWJzY3JpYmVycyBvZiB0aGUgRGF0YVZpZXcsIGJ1dCB3aWxsIGZpbHRlciB0aGUgaXRlbXMgYW5kIG9ubHkgdHJpZ2dlclxuICogd2hlbiB0aGVyZSBhcmUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VuZGVySWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5fb25FdmVudCA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICB2YXIgaSwgbGVuLCBpZCwgaXRlbTtcbiAgdmFyIGlkcyA9IHBhcmFtcyAmJiBwYXJhbXMuaXRlbXM7XG4gIHZhciBhZGRlZElkcyA9IFtdLFxuICAgICAgdXBkYXRlZElkcyA9IFtdLFxuICAgICAgcmVtb3ZlZElkcyA9IFtdLFxuICAgICAgb2xkSXRlbXMgPSBbXSxcbiAgICAgIHVwZGF0ZWRJdGVtcyA9IFtdLFxuICAgICAgcmVtb3ZlZEl0ZW1zID0gW107XG5cbiAgaWYgKGlkcyAmJiB0aGlzLl9kYXRhKSB7XG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnQgZnJvbSB0aGUgdmlld3Mgdmlld3BvaW50OiBhbiB1cGRhdGVkXG4gICAgICAgIC8vIGl0ZW0gY2FuIGJlIGFkZGVkLCB1cGRhdGVkLCBvciByZW1vdmVkIGZyb20gdGhpcyB2aWV3LlxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5wdXNoKHBhcmFtcy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgb2xkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGZvciBtZSA6LShcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCArPSBhZGRlZElkcy5sZW5ndGggLSByZW1vdmVkSWRzLmxlbmd0aDtcblxuICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCd1cGRhdGUnLCB7IGl0ZW1zOiB1cGRhdGVkSWRzLCBvbGREYXRhOiBvbGRJdGVtcywgZGF0YTogdXBkYXRlZEl0ZW1zIH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiByZW1vdmVkSWRzLCBvbGREYXRhOiByZW1vdmVkSXRlbXMgfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY29weSBzdWJzY3JpcHRpb24gZnVuY3Rpb25hbGl0eSBmcm9tIERhdGFTZXRcbkRhdGFWaWV3LnByb3RvdHlwZS5vbiA9IERhdGFTZXQucHJvdG90eXBlLm9uO1xuRGF0YVZpZXcucHJvdG90eXBlLm9mZiA9IERhdGFTZXQucHJvdG90eXBlLm9mZjtcbkRhdGFWaWV3LnByb3RvdHlwZS5fdHJpZ2dlciA9IERhdGFTZXQucHJvdG90eXBlLl90cmlnZ2VyO1xuXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIChyZXBsYWNlZCB3aXRoIGBvbmAgYW5kIGBvZmZgIHNpbmNlIHZlcnNpb24gMC41KVxuRGF0YVZpZXcucHJvdG90eXBlLnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vbjtcbkRhdGFWaWV3LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vZmY7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgQWxleCBvbiAxMS82LzIwMTQuXHJcbiAqL1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzI0w0MC1MNjBcclxuLy8gaWYgdGhlIG1vZHVsZSBoYXMgbm8gZGVwZW5kZW5jaWVzLCB0aGUgYWJvdmUgcGF0dGVybiBjYW4gYmUgc2ltcGxpZmllZCB0b1xyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHJ1ZSkge1xyXG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcclxuICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxyXG4gICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXHJcbiAgICByb290LmtleWNoYXJtID0gZmFjdG9yeSgpO1xyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGtleWNoYXJtKG9wdGlvbnMpIHtcclxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCB8fCBmYWxzZTtcclxuXHJcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCB3aW5kb3c7XHJcblxyXG4gICAgdmFyIF9leHBvcnRGdW5jdGlvbnMgPSB7fTtcclxuICAgIHZhciBfYm91bmQgPSB7a2V5ZG93bjp7fSwga2V5dXA6e319O1xyXG4gICAgdmFyIF9rZXlzID0ge307XHJcbiAgICB2YXIgaTtcclxuXHJcbiAgICAvLyBhIC0gelxyXG4gICAgZm9yIChpID0gOTc7IGkgPD0gMTIyOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOjY1ICsgKGkgLSA5NyksIHNoaWZ0OiBmYWxzZX07fVxyXG4gICAgLy8gQSAtIFpcclxuICAgIGZvciAoaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOmksIHNoaWZ0OiB0cnVlfTt9XHJcbiAgICAvLyAwIC0gOVxyXG4gICAgZm9yIChpID0gMDsgIGkgPD0gOTsgICBpKyspIHtfa2V5c1snJyArIGldID0ge2NvZGU6NDggKyBpLCBzaGlmdDogZmFsc2V9O31cclxuICAgIC8vIEYxIC0gRjEyXHJcbiAgICBmb3IgKGkgPSAxOyAgaSA8PSAxMjsgICBpKyspIHtfa2V5c1snRicgKyBpXSA9IHtjb2RlOjExMSArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG4gICAgLy8gbnVtMCAtIG51bTlcclxuICAgIGZvciAoaSA9IDA7ICBpIDw9IDk7ICAgaSsrKSB7X2tleXNbJ251bScgKyBpXSA9IHtjb2RlOjk2ICsgaSwgc2hpZnQ6IGZhbHNlfTt9XHJcblxyXG4gICAgLy8gbnVtcGFkIG1pc2NcclxuICAgIF9rZXlzWydudW0qJ10gPSB7Y29kZToxMDYsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snbnVtKyddID0ge2NvZGU6MTA3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ251bS0nXSA9IHtjb2RlOjEwOSwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydudW0vJ10gPSB7Y29kZToxMTEsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snbnVtLiddID0ge2NvZGU6MTEwLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgLy8gYXJyb3dzXHJcbiAgICBfa2V5c1snbGVmdCddICA9IHtjb2RlOjM3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ3VwJ10gICAgPSB7Y29kZTozOCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydyaWdodCddID0ge2NvZGU6MzksIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snZG93biddICA9IHtjb2RlOjQwLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgLy8gZXh0cmEga2V5c1xyXG4gICAgX2tleXNbJ3NwYWNlJ10gPSB7Y29kZTozMiwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydlbnRlciddID0ge2NvZGU6MTMsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snc2hpZnQnXSA9IHtjb2RlOjE2LCBzaGlmdDogdW5kZWZpbmVkfTtcclxuICAgIF9rZXlzWydlc2MnXSAgID0ge2NvZGU6MjcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snYmFja3NwYWNlJ10gPSB7Y29kZTo4LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ3RhYiddICAgICAgID0ge2NvZGU6OSwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydjdHJsJ10gICAgICA9IHtjb2RlOjE3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ2FsdCddICAgICAgID0ge2NvZGU6MTgsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snZGVsZXRlJ10gICAgPSB7Y29kZTo0Niwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydwYWdldXAnXSAgICA9IHtjb2RlOjMzLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ3BhZ2Vkb3duJ10gID0ge2NvZGU6MzQsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAvLyBzeW1ib2xzXHJcbiAgICBfa2V5c1snPSddICAgICA9IHtjb2RlOjE4Nywgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWyctJ10gICAgID0ge2NvZGU6MTg5LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ10nXSAgICAgPSB7Y29kZToyMjEsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snWyddICAgICA9IHtjb2RlOjIxOSwgc2hpZnQ6IGZhbHNlfTtcclxuXHJcblxyXG5cclxuICAgIHZhciBkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5ZG93bicpO307XHJcbiAgICB2YXIgdXAgPSBmdW5jdGlvbihldmVudCkge2hhbmRsZUV2ZW50KGV2ZW50LCdrZXl1cCcpO307XHJcblxyXG4gICAgLy8gaGFuZGxlIHRoZSBhY3R1YWx5IGJvdW5kIGtleSB3aXRoIHRoZSBldmVudFxyXG4gICAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsdHlwZSkge1xyXG4gICAgICBpZiAoX2JvdW5kW3R5cGVdW2V2ZW50LmtleUNvZGVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGJvdW5kW2ldLnNoaWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoYm91bmRbaV0uc2hpZnQgPT0gdHJ1ZSAmJiBldmVudC5zaGlmdEtleSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBiaW5kIGEga2V5IHRvIGEgY2FsbGJhY2tcclxuICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZCA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcclxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHR5cGUgPSAna2V5ZG93bic7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXS5wdXNoKHtmbjpjYWxsYmFjaywgc2hpZnQ6X2tleXNba2V5XS5zaGlmdH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gYmluZCBhbGwga2V5cyB0byBhIGNhbGwgYmFjayAoZGVtbyBwdXJwb3NlcylcclxuICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZEFsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xyXG4gICAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQoa2V5LGNhbGxiYWNrLHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBnZXQgdGhlIGtleSBsYWJlbCBmcm9tIGFuIGV2ZW50XHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLmdldEtleSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xyXG4gICAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlICYmIGtleSA9PSAnc2hpZnQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBcInVua25vd24ga2V5LCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB1bmJpbmQgZWl0aGVyIGEgc3BlY2lmaWMgY2FsbGJhY2sgZnJvbSBhIGtleSBvciBhbGwgb2YgdGhlbSAoYnkgbGVhdmluZyBjYWxsYmFjayB1bmRlZmluZWQpXHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLnVuYmluZCA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcclxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHR5cGUgPSAna2V5ZG93bic7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIG5ld0JpbmRpbmdzID0gW107XHJcbiAgICAgICAgdmFyIGJvdW5kID0gX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV07XHJcbiAgICAgICAgaWYgKGJvdW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCEoYm91bmRbaV0uZm4gPT0gY2FsbGJhY2sgJiYgYm91bmRbaV0uc2hpZnQgPT0gX2tleXNba2V5XS5zaGlmdCkpIHtcclxuICAgICAgICAgICAgICBuZXdCaW5kaW5ncy5wdXNoKF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IG5ld0JpbmRpbmdzO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gcmVzZXQgYWxsIGJvdW5kIHZhcmlhYmxlcy5cclxuICAgIF9leHBvcnRGdW5jdGlvbnMucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdW5iaW5kIGFsbCBsaXN0ZW5lcnMgYW5kIHJlc2V0IGFsbCB2YXJpYWJsZXMuXHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXAsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjcmVhdGUgbGlzdGVuZXJzLlxyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLGRvd24sdHJ1ZSk7XHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLHVwLHRydWUpO1xyXG5cclxuICAgIC8vIHJldHVybiB0aGUgcHVibGljIGZ1bmN0aW9ucy5cclxuICAgIHJldHVybiBfZXhwb3J0RnVuY3Rpb25zO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGtleWNoYXJtO1xyXG59KSk7XHJcblxyXG5cclxuXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogTk9URTogVGhpcyBpcyBhIGJhZCBiYXNlIGNsYXNzXG4gKlxuICogQ2hpbGQgY2xhc3NlcyBhcmU6XG4gKlxuICogICBJbWFnZSAgICAgICAtIHVzZXMgKm9ubHkqIGltYWdlIG1ldGhvZHNcbiAqICAgQ2lyY2xlICAgICAgLSB1c2VzICpvbmx5KiBfZHJhd1Jhd0NpcmNsZVxuICogICBDaXJjbGVJbWFnZSAtIHVzZXMgYWxsXG4gKlxuICogVE9ETzogUmVmYWN0b3IsIG1vdmUgX2RyYXdSYXdDaXJjbGUgdG8gZGlmZmVyZW50IG1vZHVsZSwgZGVyaXZlIENpcmNsZSBmcm9tIE5vZGVCYXNlXG4gKiAgICAgICBSZW5hbWUgdGhpcyB0byBJbWFnZUJhc2VcbiAqICAgICAgIENvbnNvbGlkYXRlIGNvbW1vbiBjb2RlIGluIEltYWdlIGFuZCBDaXJjbGVJbWFnZSB0byBiYXNlIGNsYXNzXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIENpcmNsZUltYWdlQmFzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoQ2lyY2xlSW1hZ2VCYXNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlSW1hZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKENpcmNsZUltYWdlQmFzZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2lyY2xlSW1hZ2VCYXNlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMubGFiZWxPZmZzZXQgPSAwO1xuICAgIF90aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1hZ2VPYmpdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1hZ2VPYmpBbHRdXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2lyY2xlSW1hZ2VCYXNlLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgaWYgKCEoaW1hZ2VPYmogPT09IHVuZGVmaW5lZCAmJiBpbWFnZU9iakFsdCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW1hZ2VzIGZvciB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGUgaW1hZ2VzIGNhbiBiZSB1cGRhdGVkIGFmdGVyIHRoZSBpbml0aWFsIHNldHRpbmcgb2Ygb3B0aW9ucztcbiAgICAgKiB0aGVyZWZvcmUsIHRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIHJlZW50cmFudC5cbiAgICAgKlxuICAgICAqIEZvciBjb3JyZWN0IHdvcmtpbmcgaW4gZXJyb3IgY2FzZXMsIGl0IGlzIG5lY2Vzc2FyeSB0byBwcm9wZXJseSBzZXRcbiAgICAgKiBmaWVsZCAnbm9kZXMuYnJva2VuSW1hZ2UnIGluIHRoZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmogIHJlcXVpcmVkOyBtYWluIGltYWdlIHRvIHNob3cgZm9yIHRoaXMgbm9kZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V8dW5kZWZpbmVkfSBpbWFnZU9iakFsdCBvcHRpb25hbDsgaW1hZ2UgdG8gc2hvdyB3aGVuIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0SW1hZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgaWYgKGltYWdlT2JqQWx0ICYmIHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VPYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSBpbWFnZU9iakFsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2VsZWN0aW9uIGFuZCBzd2l0Y2ggYmV0d2VlbiB0aGUgYmFzZSBhbmQgdGhlIHNlbGVjdGVkIGltYWdlLlxuICAgICAqXG4gICAgICogRG8gdGhlIHN3aXRjaCBvbmx5IGlmIGltYWdlT2JqQWx0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgdmFsdWUgb2YgbmV3IHNlbGVjdGVkIHN0YXRlIGZvciBjdXJyZW50IG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3dpdGNoSW1hZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uX2NoYW5nZWQgPSBzZWxlY3RlZCAmJiAhdGhpcy5zZWxlY3RlZCB8fCAhc2VsZWN0ZWQgJiYgdGhpcy5zZWxlY3RlZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDsgLy8gUmVtZW1iZXIgbmV3IHNlbGVjdGlvblxuXG4gICAgICBpZiAodGhpcy5pbWFnZU9iakFsdCAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGlvbl9jaGFuZ2VkKSB7XG4gICAgICAgIHZhciBpbWFnZVRtcCA9IHRoaXMuaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VUbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBub2RlIGRpbWVuc2lvbnMgZm9yIGEgbG9hZGVkIGltYWdlLlxuICAgICAqXG4gICAgICogUHJlOiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZXNpemVJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVJbWFnZSgpIHtcbiAgICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VJbWFnZVNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2l6ZSBwcm9wZXJ0eVxuICAgICAgICB2YXIgcmF0aW9fd2lkdGggPSAxO1xuICAgICAgICB2YXIgcmF0aW9faGVpZ2h0ID0gMTtcblxuICAgICAgICAvLyBPbmx5IGNhbGN1bGF0ZSB0aGUgcHJvcGVyIHJhdGlvIGlmIGJvdGggd2lkdGggYW5kIGhlaWdodCBub3QgemVyb1xuICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAmJiB0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoID4gdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJhdGlvX3dpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXRpb19oZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodCAvIHRoaXMuaW1hZ2VPYmoud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDIgKiByYXRpb193aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW9faGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBpbWFnZSBzaXplXG4gICAgICAgIHdpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5pbWFnZU9iai5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3UmF3Q2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5jaXJjbGUoeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3SW1hZ2VBdFBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoICE9IDApIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuXG4gICAgICAgIHZhciBmYWN0b3IgPSAxO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5pbnRlcnBvbGF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZmFjdG9yID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMud2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VPYmouZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIGZhY3RvciwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3SW1hZ2VMYWJlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIHlMYWJlbDtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICBpZiAobGFiZWxEaW1lbnNpb25zLmxpbmVDb3VudCA+PSAxKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGxhYmVsRGltZW5zaW9ucy5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHlMYWJlbCA9IHkgKyBvZmZzZXQ7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwpIHtcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsIGhvdmVyLCAnaGFuZ2luZycpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2lyY2xlSW1hZ2VCYXNlO1xufShfTm9kZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDaXJjbGVJbWFnZUJhc2U7XG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucHJpbnRTdHlsZSA9IHVuZGVmaW5lZDtcblxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGVycm9yRm91bmQgPSBmYWxzZTtcbnZhciBhbGxPcHRpb25zID0gdm9pZCAwO1xudmFyIHByaW50U3R5bGUgPSAnYmFja2dyb3VuZDogI0ZGZWVlZTsgY29sb3I6ICNkZDAwMDAnO1xuLyoqXG4gKiAgVXNlZCB0byB2YWxpZGF0ZSBvcHRpb25zLlxuICovXG5cbnZhciBWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBWYWxpZGF0b3IoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgVmFsaWRhdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3ViT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmFsaWRhdG9yLCBudWxsLCBbe1xuICAgIGtleTogJ3ZhbGlkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgICBlcnJvckZvdW5kID0gZmFsc2U7XG4gICAgICBhbGxPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9ucztcbiAgICAgIHZhciB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICBpZiAoc3ViT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zW3N1Yk9iamVjdF07XG4gICAgICB9XG4gICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9ucywgdXNlZE9wdGlvbnMsIFtdKTtcbiAgICAgIHJldHVybiBlcnJvckZvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgdHJhdmVyc2UgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IGFuZCBjaGVjayBldmVyeSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgIFZhbGlkYXRvci5jaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZXZlcnkgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGNhbGwgdGhlIHBhcnNlIGZ1bmN0aW9uIG9uIHRoYXQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjaGVjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFZhbGlkYXRvci5nZXRTdWdnZXN0aW9uKG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZmVyZW5jZU9wdGlvbiA9IG9wdGlvbjtcbiAgICAgIHZhciBpc19vYmplY3QgPSB0cnVlO1xuXG4gICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IHRyaWdnZXJzIGlmIHRoZSBfX2FueV9fIGlzIGluIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAvLyAgICAgICBUSEFUJ1MgQSBSRUFMTFkgQkFEIFBMQUNFIFRPIEFMTE9XIElUISEhIVxuICAgICAgICAvLyBUT0RPOiBFeGFtaW5lIGlmIG5lZWRlZCwgcmVtb3ZlIGlmIHBvc3NpYmxlXG5cbiAgICAgICAgLy8gX19hbnlfXyBpcyBhIHdpbGRjYXJkLiBBbnkgdmFsdWUgaXMgYWNjZXB0ZWQgYW5kIHdpbGwgYmUgZnVydGhlciBhbmFseXNlZCBieSByZWZlcmVuY2UuXG4gICAgICAgIHJlZmVyZW5jZU9wdGlvbiA9ICdfX2FueV9fJztcblxuICAgICAgICAvLyBpZiB0aGUgYW55LXN1Ymdyb3VwIGlzIG5vdCBhIHByZWRlZmluZWQgb2JqZWN0IGluIHRoZSBjb25maWd1cmF0b3IsXG4gICAgICAgIC8vIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgIGlzX29iamVjdCA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSkgPT09ICdvYmplY3QnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luY2UgYWxsIG9wdGlvbnMgaW4gdGhlIHJlZmVyZW5jZSBhcmUgb2JqZWN0cywgd2UgY2FuIGNoZWNrIHdoZXRoZXJcbiAgICAgICAgLy8gdGhleSBhcmUgc3VwcG9zZWQgdG8gYmUgdGhlIG9iamVjdCB0byBsb29rIGZvciB0aGUgX190eXBlX18gZmllbGQuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gb2JqZWN0LCB3ZSBjaGVjayBpZiB0aGUgY29ycmVjdCB0eXBlIGhhcyBiZWVuIHN1cHBsaWVkIHRvIGFjY291bnQgZm9yIHNob3J0aGFuZCBvcHRpb25zLlxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmT3B0aW9uT2JqID0gcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dO1xuICAgICAgaWYgKGlzX29iamVjdCAmJiByZWZPcHRpb25PYmouX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWZPcHRpb25PYmogPSByZWZPcHRpb25PYmouX190eXBlX187XG4gICAgICB9XG5cbiAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgb3B0aW9uICAgICAgICAgICB8IHRoZSBvcHRpb24gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnMgICAgICAgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIHJlZmVyZW5jZU9wdGlvbnMgfCBUaGUgcmVmZXJlbmNlIG9wdGlvbnMgY29udGFpbmluZyBhbGwgb3B0aW9ucyBhbmQgdGhlaXIgYWxsb3dlZCBmb3JtYXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZlcmVuY2VPcHRpb24gIHwgVXN1YWxseSB0aGlzIGlzIHRoZSBzYW1lIGFzIG9wdGlvbiwgZXhjZXB0IHdoZW4gaGFuZGxpbmcgYW4gX19hbnlfXyB0YWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZPcHRpb25PYmogICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIHBhdGggICAgICAgICAgICAgfCB3aGVyZSBpbiB0aGUgb2JqZWN0IGlzIHRoZSBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrRmllbGRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgICAgdmFyIGxvZyA9IGZ1bmN0aW9uIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCclYycgKyBtZXNzYWdlICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb3B0aW9uVHlwZSA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSk7XG4gICAgICB2YXIgcmVmT3B0aW9uVHlwZSA9IHJlZk9wdGlvbk9ialtvcHRpb25UeXBlXTtcblxuICAgICAgaWYgKHJlZk9wdGlvblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUocmVmT3B0aW9uVHlwZSkgPT09ICdhcnJheScgJiYgcmVmT3B0aW9uVHlwZS5pbmRleE9mKG9wdGlvbnNbb3B0aW9uXSkgPT09IC0xKSB7XG4gICAgICAgICAgbG9nKCdJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgKyBvcHRpb24gKyAnXCIuJyArICcgQWxsb3dlZCB2YWx1ZXMgYXJlOicgKyBWYWxpZGF0b3IucHJpbnQocmVmT3B0aW9uVHlwZSkgKyAnIG5vdCBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCIuICcpO1xuICAgICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvblR5cGUgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gJ19fYW55X18nKSB7XG4gICAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnNbb3B0aW9uXSwgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWZPcHRpb25PYmpbJ2FueSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdHlwZSBvZiB0aGUgZmllbGQgaXMgaW5jb3JyZWN0IGFuZCB0aGUgZmllbGQgY2Fubm90IGJlIGFueVxuICAgICAgICBsb2coJ0ludmFsaWQgdHlwZSByZWNlaXZlZCBmb3IgXCInICsgb3B0aW9uICsgJ1wiLiBFeHBlY3RlZDogJyArIFZhbGlkYXRvci5wcmludCgoMCwgX2tleXMyWydkZWZhdWx0J10pKHJlZk9wdGlvbk9iaikpICsgJy4gUmVjZWl2ZWQgWycgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyk7XG4gICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfEFycmF5LjxudW1iZXI+fERhdGV8Tm9kZXxNb21lbnR8dW5kZWZpbmVkfG51bGx9IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZShvYmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShvYmplY3QpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAnZG9tJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Ll9pc0FNb21lbnRPYmplY3QgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gJ21vbWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTdWdnZXN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbihvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciBsb2NhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCwgZmFsc2UpO1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgYWxsT3B0aW9ucywgW10sIHRydWUpO1xuXG4gICAgICB2YXIgbG9jYWxTZWFyY2hUaHJlc2hvbGQgPSA4O1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG5cbiAgICAgIHZhciBtc2cgPSB2b2lkIDA7XG4gICAgICBpZiAobG9jYWxTZWFyY2guaW5kZXhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1zZyA9ICcgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgJycpICsgJ1BlcmhhcHMgaXQgd2FzIGluY29tcGxldGU/IERpZCB5b3UgbWVhbjogXCInICsgbG9jYWxTZWFyY2guaW5kZXhNYXRjaCArICdcIj9cXG5cXG4nO1xuICAgICAgfSBlbHNlIGlmIChnbG9iYWxTZWFyY2guZGlzdGFuY2UgPD0gZ2xvYmFsU2VhcmNoVGhyZXNob2xkICYmIGxvY2FsU2VhcmNoLmRpc3RhbmNlID4gZ2xvYmFsU2VhcmNoLmRpc3RhbmNlKSB7XG4gICAgICAgIG1zZyA9ICcgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgJycpICsgJ1BlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24oZ2xvYmFsU2VhcmNoLnBhdGgsIGdsb2JhbFNlYXJjaC5jbG9zZXN0TWF0Y2gsICcnKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgICAgbXNnID0gJy4gRGlkIHlvdSBtZWFuIFwiJyArIGxvY2FsU2VhcmNoLmNsb3Nlc3RNYXRjaCArICdcIj8nICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9ICcuIERpZCB5b3UgbWVhbiBvbmUgb2YgdGhlc2U6ICcgKyBWYWxpZGF0b3IucHJpbnQoKDAsIF9rZXlzMlsnZGVmYXVsdCddKShvcHRpb25zKSkgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiJyArIG1zZywgcHJpbnRTdHlsZSk7XG4gICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmRJbk9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoID0gJyc7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoUGF0aCA9IFtdO1xuICAgICAgdmFyIGxvd2VyQ2FzZU9wdGlvbiA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGluZGV4TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICBmb3IgKHZhciBvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3BdLl9fdHlwZV9fICE9PSB1bmRlZmluZWQgJiYgcmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9uc1tvcF0sIHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wKSk7XG4gICAgICAgICAgaWYgKG1pbiA+IHJlc3VsdC5kaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICAgIG1pbiA9IHJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgaW5kZXhNYXRjaCA9IG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvci5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuICAgICAgICAgIGlmIChtaW4gPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gb3A7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gdXRpbC5jb3B5QXJyYXkocGF0aCk7XG4gICAgICAgICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3Nlc3RNYXRjaDogY2xvc2VzdE1hdGNoLFxuICAgICAgICBwYXRoOiBjbG9zZXN0TWF0Y2hQYXRoLFxuICAgICAgICBkaXN0YW5jZTogbWluLFxuICAgICAgICBpbmRleE1hdGNoOiBpbmRleE1hdGNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcmludExvY2F0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdQcm9ibGVtIHZhbHVlIGZvdW5kIGF0OiBcXG4nO1xuXG4gICAgICB2YXIgc3RyID0gJ1xcblxcbicgKyBwcmVmaXggKyAnb3B0aW9ucyA9IHtcXG4nO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBwYXRoW2ldICsgJzoge1xcbic7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcGF0aC5sZW5ndGggKyAxOyBfaisrKSB7XG4gICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgfVxuICAgICAgc3RyICs9IG9wdGlvbiArICdcXG4nO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhdGgubGVuZ3RoICsgMTsgX2krKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBwYXRoLmxlbmd0aCAtIF9pOyBfajIrKykge1xuICAgICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnfVxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyICsgJ1xcblxcbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJpbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKG9wdGlvbnMpLnJlcGxhY2UoLyhcXFwiKXwoXFxbKXwoXFxdKXwoLFwiX190eXBlX19cIikvZywgJycpLnJlcGxhY2UoLyhcXCwpL2csICcsICcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzXG4gICAgICogaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vU3RyaW5ncy9MZXZlbnNodGVpbl9kaXN0YW5jZSNKYXZhU2NyaXB0XG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTEgQW5kcmVpIE1hY2tlbnppZVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGV2ZW5zaHRlaW5EaXN0YW5jZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldmVuc2h0ZWluRGlzdGFuY2UoYSwgYikge1xuICAgICAgaWYgKGEubGVuZ3RoID09PSAwKSByZXR1cm4gYi5sZW5ndGg7XG4gICAgICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiBhLmxlbmd0aDtcblxuICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gICAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNyZW1lbnQgZWFjaCBjb2x1bW4gaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbWF0cml4WzBdW2pdID0gajtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgbWF0cml4XG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGIuY2hhckF0KGkgLSAxKSA9PSBhLmNoYXJBdChqIC0gMSkpIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihtYXRyaXhbaSAtIDFdW2ogLSAxXSArIDEsIC8vIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgTWF0aC5taW4obWF0cml4W2ldW2ogLSAxXSArIDEsIC8vIGluc2VydGlvblxuICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeFtiLmxlbmd0aF1bYS5sZW5ndGhdO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmFsaWRhdG9yO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBWYWxpZGF0b3I7XG5leHBvcnRzLnByaW50U3R5bGUgPSBwcmludFN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIExhYmVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NylbJ2RlZmF1bHQnXTtcbnZhciBDb21wb25lbnRVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlbJ2RlZmF1bHQnXTtcbnZhciBDdWJpY0JlemllckVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NilbJ2RlZmF1bHQnXTtcbnZhciBCZXppZXJFZGdlRHluYW1pYyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY4KVsnZGVmYXVsdCddO1xudmFyIEJlemllckVkZ2VTdGF0aWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OSlbJ2RlZmF1bHQnXTtcbnZhciBTdHJhaWdodEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MClbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBBbiBlZGdlIGNvbm5lY3RzIHR3byBub2RlcyBhbmQgaGFzIGEgc3BlY2lmaWMgZGlyZWN0aW9uLlxuICovXG5cbnZhciBFZGdlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgIHZhbHVlcyBzcGVjaWZpYyB0byB0aGlzIGVkZ2UsIG11c3QgY29udGFpbiBhdCBsZWFzdCAnZnJvbScgYW5kICd0bydcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHkgICAgICAgICAgIHNoYXJlZCBzdGF0ZSBmcm9tIE5ldHdvcmsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGdsb2JhbE9wdGlvbnMgIG9wdGlvbnMgZnJvbSB0aGUgRWRnZXNIYW5kbGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9ucyBkZWZhdWx0IG9wdGlvbnMgZnJvbSB0aGUgRWRnZUhhbmRsZXIgaW5zdGFuY2UuIFZhbHVlIGFuZCByZWZlcmVuY2UgYXJlIGNvbnN0YW50XG4gICAqL1xuICBmdW5jdGlvbiBFZGdlKG9wdGlvbnMsIGJvZHksIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRWRnZSk7XG5cbiAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGJvZHkgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBnbG9iYWxPcHRpb25zIGlzIGNvbnN0YW50IGluIHZhbHVlcyBhcyB3ZWxsIGFzIHJlZmVyZW5jZSxcbiAgICAvLyBGb2xsb3dpbmcgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcbiAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnJvbUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9JZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob3ZlciA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxEaXJ0eSA9IHRydWU7XG5cbiAgICB0aGlzLmJhc2VXaWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG5cbiAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuICAgIHRoaXMudG8gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuXG4gICAgdGhpcy5lZGdlVHlwZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbmV3IExhYmVsKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCB0cnVlIC8qIEl0J3MgYW4gZWRnZSBsYWJlbCAqL1xuICAgICk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIGVkZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICogQHJldHVybnMge251bGx8Ym9vbGVhbn0gbnVsbCBpZiBubyBvcHRpb25zLCBib29sZWFuIGlmIGRhdGUgY2hhbmdlZFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVkZ2UsIFt7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgRWRnZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCB0cnVlLCB0aGlzLmdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJvbUlkID0gb3B0aW9ucy5mcm9tO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRvSWQgPSBvcHRpb25zLnRvO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9ucy52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBDb21wb25lbnRVdGlsLmNob29zaWZ5KCdlZGdlJywgcGlsZSk7XG5cbiAgICAgIC8vIHVwZGF0ZSBsYWJlbCBNb2R1bGVcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7XG5cbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IHRoaXMudXBkYXRlRWRnZVR5cGUoKTtcblxuICAgICAgLy8gaWYgYW55dGhpbmcgaGFzIGJlZW4gdXBkYXRlcywgcmVzZXQgdGhlIHNlbGVjdGlvbiB3aWR0aCBhbmQgdGhlIGhvdmVyIHdpZHRoXG4gICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuXG4gICAgICAvLyBBIG5vZGUgaXMgY29ubmVjdGVkIHdoZW4gaXQgaGFzIGEgZnJvbSBhbmQgdG8gbm9kZSB0aGF0IGJvdGggZXhpc3QgaW4gdGhlIG5ldHdvcmsuYm9keS5ub2Rlcy5cbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhQ2hhbmdlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb3B5RnJvbUdsb2JhbHM9ZmFsc2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZvcm1hdHRpbmdWYWx1ZXMnLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJvd09wdGlvbnN9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRpbmdWYWx1ZXMoKSB7XG4gICAgICB2YXIgdG9BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MudG8gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy50by5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIGZyb21BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbSA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBtaWRkbGVBcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgaW5oZXJpdHNDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5pbmhlcml0O1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgdG9BcnJvdzogdG9BcnJvdyxcbiAgICAgICAgdG9BcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yLFxuICAgICAgICB0b0Fycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy50by50eXBlLFxuICAgICAgICBtaWRkbGVBcnJvdzogbWlkZGxlQXJyb3csXG4gICAgICAgIG1pZGRsZUFycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNjYWxlRmFjdG9yLFxuICAgICAgICBtaWRkbGVBcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnR5cGUsXG4gICAgICAgIGZyb21BcnJvdzogZnJvbUFycm93LFxuICAgICAgICBmcm9tQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yLFxuICAgICAgICBmcm9tQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20udHlwZSxcbiAgICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoLFxuICAgICAgICBjb2xvcjogaW5oZXJpdHNDb2xvciA/IHVuZGVmaW5lZCA6IHRoaXMub3B0aW9ucy5jb2xvci5jb2xvcixcbiAgICAgICAgaW5oZXJpdHNDb2xvcjogaW5oZXJpdHNDb2xvcixcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHksXG4gICAgICAgIGhpZGRlbjogdGhpcy5vcHRpb25zLmhpZGRlbixcbiAgICAgICAgbGVuZ3RoOiB0aGlzLm9wdGlvbnMubGVuZ3RoLFxuICAgICAgICBzaGFkb3c6IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxcbiAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IsXG4gICAgICAgIHNoYWRvd1NpemU6IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxcbiAgICAgICAgc2hhZG93WDogdGhpcy5vcHRpb25zLnNoYWRvdy54LFxuICAgICAgICBzaGFkb3dZOiB0aGlzLm9wdGlvbnMuc2hhZG93LnksXG4gICAgICAgIGRhc2hlczogdGhpcy5vcHRpb25zLmRhc2hlcyxcbiAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy53aWR0aCxcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuZW5hYmxlZCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5jb2xvcixcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLnNpemUsXG4gICAgICAgIGJhY2tncm91bmREYXNoZXM6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmRhc2hlc1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRXaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRXaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBzZWxlY3RlZFdpZHRoKHZhbHVlcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggKz0gc2VsZWN0ZWRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgICAgdmFsdWVzLmNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdmVyKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBob3ZlcldpZHRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IGhvdmVyV2lkdGgodmFsdWVzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdmVyV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCArPSBob3ZlcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jaG9vc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5jaG9vc2VyKHZhbHVlcywgdGhpcy5vcHRpb25zLmlkLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgICBpZiAodmFsdWVzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5pbmhlcml0c0NvbG9yID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3dDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCB2YWx1ZXMuc2hhZG93U2l6ZSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplIHx8IHZhbHVlcy5zaGFkb3dYICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnggfHwgdmFsdWVzLnNoYWRvd1kgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIG9wdGlvbnMgaW4gdGhlIGxhYmVsIG1vZHVsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlTGFiZWxNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKSB7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuZ2xvYmFsT3B0aW9ucywgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgZWRnZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zXTtcblxuICAgICAgdGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLCBwaWxlKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBlZGdlIHR5cGUsIHNldCB0aGUgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVFZGdlVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2VUeXBlKCkge1xuICAgICAgdmFyIHNtb290aCA9IHRoaXMub3B0aW9ucy5zbW9vdGg7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjaGFuZ2VJblR5cGUgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VEeW5hbWljICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSAnZHluYW1pYycgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEN1YmljQmV6aWVyRWRnZSAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gJ2N1YmljQmV6aWVyJyB8fCB0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgQmV6aWVyRWRnZVN0YXRpYyAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSAhPT0gJ2R5bmFtaWMnICYmIHNtb290aC50eXBlICE9PSAnY3ViaWNCZXppZXInIHx8IHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBTdHJhaWdodEVkZ2UgJiYgc21vb3RoLnR5cGUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjaGFuZ2VJblR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlSW5UeXBlID09PSB0cnVlKSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoc21vb3RoLnR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBCZXppZXJFZGdlRHluYW1pYyh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzbW9vdGgudHlwZSA9PT0gJ2N1YmljQmV6aWVyJykge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBDdWJpY0JlemllckVkZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEJlemllckVkZ2VTdGF0aWModGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IFN0cmFpZ2h0RWRnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdGhpbmcgY2hhbmdlcywgd2UganVzdCBzZXQgdGhlIG9wdGlvbnMuXG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgYW4gZWRnZSB0byBpdHMgbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY29ubmVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgdGhpcy5mcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuZnJvbUlkXSB8fCB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudG9JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0aGlzLmZyb20gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmZyb20uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50by5hdHRhY2hFZGdlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICAgIHRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgICAgdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZVR5cGUuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgYW4gZWRnZSBmcm9tIGl0cyBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNjb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgIHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50byA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgZWRnZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgZWRnZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHNldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGl0bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gc2VsZWN0ZWQgICBUcnVlIGlmIG5vZGUgaXMgc2VsZWN0ZWQsIGVsc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNTZWxlY3RlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGVkZ2UuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIGVkZ2UuIFRoZSBlZGdlIHdpbGwgYWRqdXN0IGl0J3Mgd2lkdGhcbiAgICAgKiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWVSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHdpZHRoRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiB3aWR0aERpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLmJhc2VXaWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldEludGVyYWN0aW9uV2lkdGhzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEludGVyYWN0aW9uV2lkdGhzKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhIGVkZ2VcbiAgICAgKiBEcmF3IHRoaXMgZWRnZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuICAgICAgaWYgKHZhbHVlcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIHZpYSBub2RlIGZyb20gdGhlIGVkZ2UgdHlwZVxuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTtcbiAgICAgIHZhciBhcnJvd0RhdGEgPSB7fTtcblxuICAgICAgLy8gcmVzdG9yZSBlZGdlIHRhcmdldHMgdG8gZGVmYXVsdHNcbiAgICAgIHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50ID0gdGhpcy5lZGdlVHlwZS5mcm9tO1xuICAgICAgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gdGhpcy5lZGdlVHlwZS50bztcblxuICAgICAgLy8gZnJvbSBhbmQgdG8gYXJyb3dzIGdpdmUgYSBkaWZmZXJlbnQgZW5kIHBvaW50IGZvciBlZGdlcy4gd2Ugc2V0IHRoZW0gaGVyZVxuICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLmZyb20gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsICdmcm9tJywgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHZhbHVlcy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IGFycm93RGF0YS5mcm9tLmNvcmU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLnRvQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLnRvID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCAndG8nLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHRoaXMuZWRnZVR5cGUudG9Qb2ludCA9IGFycm93RGF0YS50by5jb3JlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgbWlkZGxlIGFycm93IGRlcGVuZHMgb24gdGhlIGxpbmUsIHdoaWNoIGNhbiBkZXBlbmQgb24gdGhlIHRvIGFuZCBmcm9tIGFycm93cyBzbyB3ZSBkbyB0aGlzIG9uZSBsYXN0bHkuXG4gICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93KSB7XG4gICAgICAgIGFycm93RGF0YS5taWRkbGUgPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsICdtaWRkbGUnLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IGV2ZXJ5dGhpbmdcbiAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZpYU5vZGUpO1xuICAgICAgdGhpcy5kcmF3QXJyb3dzKGN0eCwgYXJyb3dEYXRhLCB2YWx1ZXMpO1xuICAgICAgdGhpcy5kcmF3TGFiZWwoY3R4LCB2aWFOb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyb3dEYXRhXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3QXJyb3dzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Fycm93cyhjdHgsIGFycm93RGF0YSwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmZyb21BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5mcm9tKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEubWlkZGxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXMudG9BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS50byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXdMYWJlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMYWJlbChjdHgsIHZpYU5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZXQgc3R5bGVcbiAgICAgICAgdmFyIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLnRvO1xuXG4gICAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmRpZmZlcmVudFN0YXRlKHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUxLmlkICE9IG5vZGUyLmlkKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoMC41LCB2aWFOb2RlKTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgdmFyIHJvdGF0aW9uUG9pbnQgPSB0aGlzLl9nZXRSb3RhdGlvbihjdHgpO1xuICAgICAgICAgIGlmIChyb3RhdGlvblBvaW50LmFuZ2xlICE9IDApIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocm90YXRpb25Qb2ludC54LCByb3RhdGlvblBvaW50LnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvblBvaW50LmFuZ2xlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkcmF3IHRoZSBsYWJlbFxuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHBvaW50LngsIHBvaW50LnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICAvLyBVc2VmdWwgZGVidWcgY29kZTogZHJhdyBhIGJvcmRlciBhcm91bmQgdGhlIGxhYmVsXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgKipub3QqKiBiZSBlbmFibGVkIGluIHByb2R1Y3Rpb24hXG4gICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKTs7IC8vIDs7IGludGVudGlvbmFsIHNvIGxpbnQgY2F0Y2hlcyBpdFxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI2ZmMDAwMFwiO1xuICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHNpemUubGVmdCwgc2l6ZS50b3AsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAvLyBFbmQgIGRlYnVnIGNvZGVcbiAgICAgICAgICAqL1xuXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZ25vcmUgdGhlIG9yaWVudGF0aW9ucy5cbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgICAgIGlmIChub2RlMS5zaGFwZS53aWR0aCA+IG5vZGUxLnNoYXBlLmhlaWdodCkge1xuICAgICAgICAgICAgeCA9IG5vZGUxLnggKyBub2RlMS5zaGFwZS53aWR0aCAqIDAuNTtcbiAgICAgICAgICAgIHkgPSBub2RlMS55IC0gcmFkaXVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gbm9kZTEueCArIHJhZGl1cztcbiAgICAgICAgICAgIHkgPSBub2RlMS55IC0gbm9kZTEuc2hhcGUuaGVpZ2h0ICogMC41O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCAwLjEyNSk7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHZpc3VhbCBlbGVtZW50cyBvZiB0aGlzIGVkZ2UgaW5zdGFuY2UsIGluIHdoaWNoIHRoZSBnaXZlblxuICAgICAqIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgYm91bmRpbmcgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48ZWRnZUNsaWNrSXRlbXxlZGdlTGFiZWxDbGlja0l0ZW0+fSBsaXN0IHdpdGggdGhlIGl0ZW1zIHdoaWNoIGFyZSBvbiB0aGUgcG9pbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0SXRlbXNPblBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbXNPblBvaW50KHBvaW50KSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGlmIChDb21wb25lbnRVdGlsLnBvaW50SW5SZWN0KHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLCBwb2ludCwgcm90YXRpb25Qb2ludCkpIHtcbiAgICAgICAgICByZXQucHVzaCh7IGVkZ2VJZDogdGhpcy5pZCwgbGFiZWxJZDogMCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBsZWZ0OiBwb2ludC54LFxuICAgICAgICB0b3A6IHBvaW50LnlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzT3ZlcmxhcHBpbmdXaXRoKG9iaikpIHtcbiAgICAgICAgcmV0LnB1c2goeyBlZGdlSWQ6IHRoaXMuaWQgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiB0aGUgZWRnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBkaXN0TWF4ID0gMTA7XG4gICAgICAgIHZhciB4RnJvbSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB2YXIgeUZyb20gPSB0aGlzLmZyb20ueTtcbiAgICAgICAgdmFyIHhUbyA9IHRoaXMudG8ueDtcbiAgICAgICAgdmFyIHlUbyA9IHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHhPYmogPSBvYmoubGVmdDtcbiAgICAgICAgdmFyIHlPYmogPSBvYmoudG9wO1xuXG4gICAgICAgIHZhciBkaXN0ID0gdGhpcy5lZGdlVHlwZS5nZXREaXN0YW5jZVRvRWRnZSh4RnJvbSwgeUZyb20sIHhUbywgeVRvLCB4T2JqLCB5T2JqKTtcblxuICAgICAgICByZXR1cm4gZGlzdCA8IGRpc3RNYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSByb3RhdGlvbiBwb2ludCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdIGlmIHBhc3NlZCwgZG8gYSByZWNhbGN1bGF0aW9uIG9mIHRoZSBsYWJlbCBzaXplXG4gICAgICogQHJldHVybnMge3JvdGF0aW9uUG9pbnR9IHRoZSBwb2ludCB0byByb3RhdGUgYXJvdW5kIGFuZCB0aGUgYW5nbGUgaW4gcmFkaWFucyB0byByb3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Um90YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb24oY3R4KSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpO1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5lZGdlVHlwZS5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuXG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgeTogdGhpcy5sYWJlbE1vZHVsZS5zaXplLnlMaW5lLFxuICAgICAgICBhbmdsZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm4gcmV0OyAvLyBEb24ndCBldmVuIGJvdGhlciBkb2luZyB0aGUgYXRhbjIsIHRoZXJlJ3Mgbm90aGluZyB0byBkcmF3XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udC5hbGlnbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHJldHVybiByZXQ7IC8vIE5vIG5lZWQgdG8gY2FsY3VsYXRlIGFuZ2xlXG4gICAgICB9XG5cbiAgICAgIHZhciBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgdmFyIGR4ID0gdGhpcy5mcm9tLnggLSB0aGlzLnRvLng7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7IC8vIHJhZGlhbnNcblxuICAgICAgLy8gcm90YXRlIHNvIHRoYXQgbGFiZWwgaXMgcmVhZGFibGVcbiAgICAgIGlmIChhbmdsZSA8IC0xICYmIGR4IDwgMCB8fCBhbmdsZSA+IDAgJiYgZHggPCAwKSB7XG4gICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XG4gICAgICB9XG4gICAgICByZXQuYW5nbGUgPSBhbmdsZTtcblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnRhZ2UgVmFsdWUgYmV0d2VlbiAwIChsaW5lIHN0YXJ0KSBhbmQgMSAobGluZSBlbmQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wb2ludE9uQ2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwZXJjZW50YWdlKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwZXJjZW50YWdlICogMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0ZWQgc3RhdGUgdG8gdHJ1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHN0YXRlIHRvIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vuc2VsZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xlYW5zIGFsbCByZXF1aXJlZCB0aGluZ3Mgb24gZGVsZXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFudXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZVR5cGUuY2xlYW51cCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlZGdlIGZyb20gdGhlIGxpc3QgYW5kIHBlcmZvcm0gbmVjZXNzYXJ5IGNsZWFudXAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMuaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGJvdGggY29ubmVjdGluZyBub2RlcyBleGlzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmRQb2ludHNWYWxpZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZFBvaW50c1ZhbGlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncGFyc2VPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIHZhciBjb3B5RnJvbUdsb2JhbHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gICAgICB2YXIgZmllbGRzID0gWydhcnJvd1N0cmlrZXRocm91Z2gnLCAnaWQnLCAnZnJvbScsICdoaWRkZW4nLCAnaG92ZXJXaWR0aCcsICdsYWJlbEhpZ2hsaWdodEJvbGQnLCAnbGVuZ3RoJywgJ2xpbmUnLCAnb3BhY2l0eScsICdwaHlzaWNzJywgJ3NjYWxpbmcnLCAnc2VsZWN0aW9uV2lkdGgnLCAnc2VsZlJlZmVyZW5jZVNpemUnLCAndG8nLCAndGl0bGUnLCAndmFsdWUnLCAnd2lkdGgnLCAnZm9udCcsICdjaG9zZW4nLCAnd2lkdGhDb25zdHJhaW50J107XG5cbiAgICAgIC8vIG9ubHkgZGVlcCBleHRlbmQgdGhlIGl0ZW1zIGluIHRoZSBmaWVsZCBhcnJheS4gVGhlc2UgZG8gbm90IGhhdmUgc2hvcnRoYW5kLlxuICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgcGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgYWxsb3dEZWxldGlvbik7XG5cbiAgICAgIC8vIE9ubHkgY29weSBsYWJlbCBpZiBpdCdzIGEgbGVnYWwgdmFsdWUuXG4gICAgICBpZiAoQ29tcG9uZW50VXRpbC5pc1ZhbGlkTGFiZWwobmV3T3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5sYWJlbCA9IG5ld09wdGlvbnMubGFiZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmxhYmVsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnc21vb3RoJywgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnc2hhZG93JywgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnYmFja2dyb3VuZCcsIGdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICBpZiAobmV3T3B0aW9ucy5kYXNoZXMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmRhc2hlcyAhPT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmRhc2hlcyA9IG5ld09wdGlvbnMuZGFzaGVzO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZGFzaGVzID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gKDAsIF9jcmVhdGUyWydkZWZhdWx0J10pKGdsb2JhbE9wdGlvbnMuZGFzaGVzKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBzY2FsaW5nIG5ld09wdGlvbnNcbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLnNjYWxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZy5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZy5taW4gPSBuZXdPcHRpb25zLnNjYWxpbmcubWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWF4ID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1heDtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgJ2xhYmVsJywgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLnNjYWxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nID0gKDAsIF9jcmVhdGUyWydkZWZhdWx0J10pKGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgYXJyb3dzXG4gICAgICBpZiAobmV3T3B0aW9ucy5hcnJvd3MgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmFycm93cyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuYXJyb3dzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBhcnJvd3MgPSBuZXdPcHRpb25zLmFycm93cy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPSBhcnJvd3MuaW5kZXhPZigndG8nKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9IGFycm93cy5pbmRleE9mKCdtaWRkbGUnKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5mcm9tLmVuYWJsZWQgPSBhcnJvd3MuaW5kZXhPZignZnJvbScpICE9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKCgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShuZXdPcHRpb25zLmFycm93cykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCAndG8nLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCAnbWlkZGxlJywgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgJ2Zyb20nLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXJyb3cgbmV3T3B0aW9ucyBjYW4gb25seSBiZSBhbiBvYmplY3Qgb3IgYSBzdHJpbmcuIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLiBZb3UgdXNlZDonICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKG5ld09wdGlvbnMuYXJyb3dzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmFycm93cyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cyA9ICgwLCBfY3JlYXRlMlsnZGVmYXVsdCddKShnbG9iYWxPcHRpb25zLmFycm93cyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgY29sb3JcbiAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZnJvbUNvbG9yID0gbmV3T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgdmFyIHRvQ29sb3IgPSBwYXJlbnRPcHRpb25zLmNvbG9yO1xuXG4gICAgICAgIC8vIElmIHBhc3NlZCwgZmlsbCBpbiB2YWx1ZXMgZnJvbSBkZWZhdWx0IG9wdGlvbnMgLSByZXF1aXJlZCBpbiB0aGUgY2FzZSBvZiBubyBwcm90b3R5cGUgYnJpZGdpbmdcbiAgICAgICAgaWYgKGNvcHlGcm9tR2xvYmFscykge1xuICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZCh0b0NvbG9yLCBnbG9iYWxPcHRpb25zLmNvbG9yLCBmYWxzZSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xlYXIgbG9jYWwgcHJvcGVydGllcyAtIG5lZWQgdG8gZG8gaXQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIHJldGFpbiBwcm90b3R5cGUgYnJpZGdlc1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdG9Db2xvcikge1xuICAgICAgICAgICAgaWYgKHRvQ29sb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRvQ29sb3JbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodG9Db2xvcikpIHtcbiAgICAgICAgICB0b0NvbG9yLmNvbG9yID0gdG9Db2xvcjtcbiAgICAgICAgICB0b0NvbG9yLmhpZ2hsaWdodCA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5ob3ZlciA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5vcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3Iub3BhY2l0eSA9IDEuMDsgLy8gc2V0IGRlZmF1bHRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbG9yc0RlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuY29sb3IgPSBmcm9tQ29sb3IuY29sb3I7XG4gICAgICAgICAgICBjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5oaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5oaWdobGlnaHQgPSBmcm9tQ29sb3IuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgY29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5ob3ZlciA9IGZyb21Db2xvci5ob3ZlcjtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmluaGVyaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZnJvbUNvbG9yLmluaGVyaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ29sb3Iub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLm9wYWNpdHkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmcm9tQ29sb3Iub3BhY2l0eSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2xvcnNEZWZpbmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvQ29sb3IuaW5oZXJpdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9ICdmcm9tJzsgLy8gU2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmNvbG9yKTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFZGdlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG5cbnZhciBfRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBCYXNlIENsYXNzIGZvciBhbGwgQmV6aWVyIGVkZ2VzLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aFxuICogZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cbiAqXG4gKiBAZXh0ZW5kcyBFZGdlQmFzZVxuICovXG52YXIgQmV6aWVyRWRnZUJhc2UgPSBmdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKEJlemllckVkZ2VCYXNlLCBfRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBCZXppZXJFZGdlQmFzZSk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEJlemllckVkZ2VCYXNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShCZXppZXJFZGdlQmFzZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGJlemllciBjdXJ2ZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbmVhck5vZGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQmV6aWVyRWRnZUJhc2UsIFt7XG4gICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG5cbiAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICAgIHZhciBsb3cgPSAwO1xuICAgICAgdmFyIGhpZ2ggPSAxO1xuICAgICAgdmFyIHBvcywgYW5nbGUsIGRpc3RhbmNlVG9Cb3JkZXIsIGRpc3RhbmNlVG9Qb2ludCwgZGlmZmVyZW5jZTtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjI7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMudG87XG4gICAgICB2YXIgZnJvbSA9IGZhbHNlO1xuICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuZnJvbTtcbiAgICAgICAgZnJvbSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG5cbiAgICAgICAgcG9zID0gdGhpcy5nZXRQb2ludChtaWRkbGUsIHZpYU5vZGUpO1xuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgZGlzdGFuY2VUb0JvcmRlciA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICB9XG4gICAgICBwb3MudCA9IG1pZGRsZTtcblxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMseTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tXG4gICAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIGZyb20geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDIgdG8geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MiB0byB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTMgcG9pbnQgdG8gY2hlY2sgeVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IHZvaWQgMDtcbiAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgIHQgPSB2b2lkIDAsXG4gICAgICAgICAgeCA9IHZvaWQgMCxcbiAgICAgICAgICB5ID0gdm9pZCAwO1xuICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICB2YXIgbGFzdFkgPSB5MTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueCArIE1hdGgucG93KHQsIDIpICogeDI7XG4gICAgICAgIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB5MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS55ICsgTWF0aC5wb3codCwgMikgKiB5MjtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlID8gZGlzdGFuY2UgOiBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbkRpc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBiZXppZXIgY3VydmUgYmV0d2VlbiB0d28gbm9kZXNcbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYWNjZXB0cyB6ZXJvLCBvbmUgb3IgdHdvIGNvbnRyb2wgcG9pbnRzLlxuICAgICAqIFBhc3NpbmcgemVybyBjb250cm9sIHBvaW50cyBqdXN0IGRyYXdzIGEgc3RyYWlnaHQgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgdmFsdWVzICAgfCBvcHRpb25zIGZvciBzaGFkb3cgZHJhd2luZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gdmlhTm9kZTEgfCBmaXJzdCBjb250cm9sIHBvaW50IGZvciBjdXJ2ZSBkcmF3aW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSB2aWFOb2RlMiB8IHNlY29uZCBjb250cm9sIHBvaW50IGZvciBjdXJ2ZSBkcmF3aW5nXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19iZXppZXJDdXJ2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZTEsIHZpYU5vZGUyKSB7XG4gICAgICB2YXIgaGFzTm9kZTEgPSB2aWFOb2RlMSAhPT0gdW5kZWZpbmVkICYmIHZpYU5vZGUxLnggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBoYXNOb2RlMiA9IHZpYU5vZGUyICE9PSB1bmRlZmluZWQgJiYgdmlhTm9kZTIueCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuXG4gICAgICBpZiAoaGFzTm9kZTEgJiYgaGFzTm9kZTIpIHtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdmlhTm9kZTIueCwgdmlhTm9kZTIueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTm9kZTEpIHtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIG5vcm1hbCBzdHJhaWdodCBlZGdlXG4gICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH1cbiAgICAgIC8vIGRyYXcgYSBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKGN0eCwgdmFsdWVzKTtcblxuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfHt4LCB5fXx7eDogdW5kZWZpbmVkLCB5OiB1bmRlZmluZWR9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWaWFOb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmV6aWVyRWRnZUJhc2U7XG59KF9FZGdlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJlemllckVkZ2VCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKlxuICogVXRpbGl0eSBDbGFzc1xuICovXG5cbnZhciBOZXR3b3JrVXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIE5ldHdvcmtVdGlsKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE5ldHdvcmtVdGlsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5ldHdvcmsgY29uc2lkZXJpbmcgdGhlIGJvdW5kaW5nIGJveGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBhbGxOb2Rlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gW3NwZWNpZmljTm9kZXM9W11dXG4gICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICogQHN0YXRpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKE5ldHdvcmtVdGlsLCBudWxsLCBbe1xuICAgIGtleTogJ2dldFJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoYWxsTm9kZXMpIHtcbiAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgbWluWCA9IDFlOSxcbiAgICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgICBub2RlO1xuICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG4gICAgICAgICAgaWYgKG1pblggPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQpIHtcbiAgICAgICAgICAgIG1pblggPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC50b3ApIHtcbiAgICAgICAgICAgIG1pblkgPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgaWYgKG1heFkgPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluWCA9PT0gMWU5ICYmIG1heFggPT09IC0xZTkgJiYgbWluWSA9PT0gMWU5ICYmIG1heFkgPT09IC0xZTkpIHtcbiAgICAgICAgO21pblkgPSAwLCBtYXhZID0gMCwgbWluWCA9IDAsIG1heFggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IGFsbE5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IFtzcGVjaWZpY05vZGVzPVtdXVxuICAgICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFJhbmdlQ29yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlQ29yZShhbGxOb2Rlcykge1xuICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgICB2YXIgbWluWSA9IDFlOSxcbiAgICAgICAgICBtYXhZID0gLTFlOSxcbiAgICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICAgIG1heFggPSAtMWU5LFxuICAgICAgICAgIG5vZGU7XG4gICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcbiAgICAgICAgICBpZiAobWluWCA+IG5vZGUueCkge1xuICAgICAgICAgICAgbWluWCA9IG5vZGUueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heFggPCBub2RlLngpIHtcbiAgICAgICAgICAgIG1heFggPSBub2RlLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS55KSB7XG4gICAgICAgICAgICBtaW5ZID0gbm9kZS55O1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgICBpZiAobWF4WSA8IG5vZGUueSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUueTtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pblggPT09IDFlOSAmJiBtYXhYID09PSAtMWU5ICYmIG1pblkgPT09IDFlOSAmJiBtYXhZID09PSAtMWU5KSB7XG4gICAgICAgIDttaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmFuZ2UgPSB7bWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WX07XG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaW5kQ2VudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZENlbnRlcihyYW5nZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMC41ICogKHJhbmdlLm1heFggKyByYW5nZS5taW5YKSxcbiAgICAgICAgeTogMC41ICogKHJhbmdlLm1heFkgKyByYW5nZS5taW5ZKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJldHVybnMgYSBjbG9uZSBvZiB0aGUgb3B0aW9ucyBvciBvcHRpb25zIG9mIHRoZSBlZGdlIG9yIG5vZGUgdG8gYmUgdXNlZCBmb3IgY29uc3RydWN0aW9uIG9mIG5ldyBlZGdlcyBvciBjaGVjayBmdW5jdGlvbnMgZm9yIG5ldyBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge3Zpcy5JdGVtfSBpdGVtXG4gICAgICogQHBhcmFtIHsnbm9kZSd8dW5kZWZpbmVkfSB0eXBlXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xvbmVPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVPcHRpb25zKGl0ZW0sIHR5cGUpIHtcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0ge307XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09ICdub2RlJykge1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy54ID0gaXRlbS54O1xuICAgICAgICBjbG9uZWRPcHRpb25zLnkgPSBpdGVtLnk7XG4gICAgICAgIGNsb25lZE9wdGlvbnMuYW1vdW50T2ZDb25uZWN0aW9ucyA9IGl0ZW0uZWRnZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkT3B0aW9ucztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5ldHdvcmtVdGlsO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBOZXR3b3JrVXRpbDtcblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oODYpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbnZhciAkaXRlckNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oMTMpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXyg2MykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGFycmF5SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSkuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGZpcnN0IGNoZWNrIGlmIG1vbWVudC5qcyBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlciB3aW5kb3csIGlmIHNvLFxuLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbJ21vbWVudCddIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEEgcXVldWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gKiBAY29uc3RydWN0b3IgUXVldWVcbiAqL1xuZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAvLyBvcHRpb25zXG4gIHRoaXMuZGVsYXkgPSBudWxsO1xuICB0aGlzLm1heCA9IEluZmluaXR5O1xuXG4gIC8vIHByb3BlcnRpZXNcbiAgdGhpcy5fcXVldWUgPSBbXTtcbiAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBxdWV1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAqL1xuUXVldWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcbiAgfVxuXG4gIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHF1ZXVpbmcgZnVuY3Rpb25hbGl0eS5cbiAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZFxuICogaW4gb3B0aW9ucy5yZXBsYWNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIHJlcGxhY2U6IEFycmF5LjxzdHJpbmc+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIGxpc3Qgd2l0aCBtZXRob2QgbmFtZXMgb2YgdGhlIG1ldGhvZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZSBvYmplY3QgdG8gYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAqICAgICAgICAgICAgLSBkZWxheTogbnVtYmVyICAgIFdoZW4gcHJvdmlkZWQsIHRoZSBxdWV1ZSB3aWxsIGJlIGZsdXNoZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW4gaW5hY3Rpdml0eSBvZiB0aGlzIGRlbGF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIG51bGwuXG4gKiAgICAgICAgICAgIC0gbWF4OiBudW1iZXIgICAgICBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgb2YgbWF4IGlzIEluZmluaXR5LlxuICogQHJldHVybiB7UXVldWV9IFJldHVybnMgdGhlIGNyZWF0ZWQgcXVldWVcbiAqL1xuUXVldWUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0aW9ucykge1xuICB2YXIgcXVldWUgPSBuZXcgUXVldWUob3B0aW9ucyk7XG5cbiAgaWYgKG9iamVjdC5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGEgcHJvcGVydHkgZmx1c2gnKTtcbiAgfVxuICBvYmplY3QuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcXVldWUuZmx1c2goKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IFt7XG4gICAgbmFtZTogJ2ZsdXNoJyxcbiAgICBvcmlnaW5hbDogdW5kZWZpbmVkXG4gIH1dO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMucmVwbGFjZVtpXTtcbiAgICAgIG1ldGhvZHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG9yaWdpbmFsOiBvYmplY3RbbmFtZV1cbiAgICAgIH0pO1xuICAgICAgcXVldWUucmVwbGFjZShvYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlLl9leHRlbmRlZCA9IHtcbiAgICBvYmplY3Q6IG9iamVjdCxcbiAgICBtZXRob2RzOiBtZXRob2RzXG4gIH07XG5cbiAgcmV0dXJuIHF1ZXVlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBxdWV1ZS4gVGhlIHF1ZXVlIHdpbGwgZmlyc3QgZmx1c2ggYWxsIHF1ZXVlZCBhY3Rpb25zLCBhbmQgaW5cbiAqIGNhc2UgaXQgaGFzIGV4dGVuZGVkIGFuIG9iamVjdCwgd2lsbCByZXN0b3JlIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgaWYgKHRoaXMuX2V4dGVuZGVkKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMuX2V4dGVuZGVkLm9iamVjdDtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMuX2V4dGVuZGVkLm1ldGhvZHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICAgIGlmIChtZXRob2Qub3JpZ2luYWwpIHtcbiAgICAgICAgb2JqZWN0W21ldGhvZC5uYW1lXSA9IG1ldGhvZC5vcmlnaW5hbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbWV0aG9kLm5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9leHRlbmRlZCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIG1ldGhvZCBvbiBhbiBvYmplY3Qgd2l0aCBhIHF1ZXVlZCB2ZXJzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICAgT2JqZWN0IGhhdmluZyB0aGUgbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kICAgVGhlIG1ldGhvZCBuYW1lXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG9iamVjdCwgbWV0aG9kKSB7XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgJyArIG1ldGhvZCArICcgdW5kZWZpbmVkJyk7XG4gIH1cblxuICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjcmVhdGUgYW4gQXJyYXkgd2l0aCB0aGUgYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdGhpcyBjYWxsIHRvIHRoZSBxdWV1ZVxuICAgIG1lLnF1ZXVlKHtcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICBmbjogb3JpZ2luYWwsXG4gICAgICBjb250ZXh0OiB0aGlzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFF1ZXVlIGEgY2FsbFxuICogQHBhcmFtIHtmdW5jdGlvbiB8IHtmbjogZnVuY3Rpb24sIGFyZ3M6IEFycmF5fSB8IHtmbjogZnVuY3Rpb24sIGFyZ3M6IEFycmF5LCBjb250ZXh0OiBPYmplY3R9fSBlbnRyeVxuICovXG5RdWV1ZS5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogZW50cnkgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChlbnRyeSk7XG4gIH1cblxuICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHF1ZXVlIG5lZWRzIHRvIGJlIGZsdXNoZWRcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fZmx1c2hJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZmx1c2ggd2hlbiB0aGUgbWF4aW11bSBpcyBleGNlZWRlZC5cbiAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG5cbiAgLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHRoaXMuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5mbHVzaCgpO1xuICAgIH0sIHRoaXMuZGVsYXkpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHNcbiAqL1xuUXVldWUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgZW50cnkuZm4uYXBwbHkoZW50cnkuY29udGV4dCB8fCBlbnRyeS5mbiwgZW50cnkuYXJncyB8fCBbXSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFBhcnNlIGEgdGV4dCBzb3VyY2UgY29udGFpbmluZyBkYXRhIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKiBUaGUgb2JqZWN0IGNvbnRhaW5zIHR3byBsaXN0czogb25lIHdpdGggbm9kZXMgYW5kIG9uZSB3aXRoIGVkZ2VzLlxuICpcbiAqIERPVCBsYW5ndWFnZSByZWZlcmVuY2U6IGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2xhbmcuaHRtbFxuICpcbiAqIERPVCBsYW5ndWFnZSBhdHRyaWJ1dGVzOiBodHRwOi8vZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXR0cnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdyYXBoICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3RbXX0gZWRnZXNcbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUT0RPXG4gKiA9PT09XG4gKlxuICogRm9yIGxhYmVsIGhhbmRsaW5nLCB0aGlzIGlzIGFuIGluY29tcGxldGUgaW1wbGVtZW50YXRpb24uIEZyb20gZG9jcyAocXVvdGUgIzMwMTUpOlxuICpcbiAqID4gdGhlIGVzY2FwZSBzZXF1ZW5jZXMgXCJcXG5cIiwgXCJcXGxcIiBhbmQgXCJcXHJcIiBkaXZpZGUgdGhlIGxhYmVsIGludG8gbGluZXMsIGNlbnRlcmVkLFxuICogPiBsZWZ0LWp1c3RpZmllZCwgYW5kIHJpZ2h0LWp1c3RpZmllZCwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIFNvdXJjZTogaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvY29udGVudC9hdHRycyNrZXNjU3RyaW5nXG4gKlxuICogPiBBcyBhbm90aGVyIGFpZCBmb3IgcmVhZGFiaWxpdHksIGRvdCBhbGxvd3MgZG91YmxlLXF1b3RlZCBzdHJpbmdzIHRvIHNwYW4gbXVsdGlwbGUgcGh5c2ljYWxcbiAqID4gbGluZXMgdXNpbmcgdGhlIHN0YW5kYXJkIEMgY29udmVudGlvbiBvZiBhIGJhY2tzbGFzaCBpbW1lZGlhdGVseSBwcmVjZWRpbmcgYSBuZXdsaW5lXG4gKiA+IGNoYXJhY3RlclxuICogPiBJbiBhZGRpdGlvbiwgZG91YmxlLXF1b3RlZCBzdHJpbmdzIGNhbiBiZSBjb25jYXRlbmF0ZWQgdXNpbmcgYSAnKycgb3BlcmF0b3IuXG4gKiA+IEFzIEhUTUwgc3RyaW5ncyBjYW4gY29udGFpbiBuZXdsaW5lIGNoYXJhY3RlcnMsIHdoaWNoIGFyZSB1c2VkIHNvbGVseSBmb3IgZm9ybWF0dGluZyxcbiAqID4gdGhlIGxhbmd1YWdlIGRvZXMgbm90IGFsbG93IGVzY2FwZWQgbmV3bGluZXMgb3IgY29uY2F0ZW5hdGlvbiBvcGVyYXRvcnMgdG8gYmUgdXNlZFxuICogPiB3aXRoaW4gdGhlbS5cbiAqXG4gKiAtIEN1cnJlbnRseSwgb25seSAnXFxcXG4nIGlzIGhhbmRsZWRcbiAqIC0gTm90ZSB0aGF0IHRleHQgZXhwbGljaXRseSBzYXlzICdsYWJlbHMnOyB0aGUgZG90IHBhcnNlciBjdXJyZW50bHkgaGFuZGxlcyBlc2NhcGVcbiAqICAgc2VxdWVuY2VzIGluICoqYWxsKiogc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VET1QoZGF0YSkge1xuICBkb3QgPSBkYXRhO1xuICByZXR1cm4gcGFyc2VHcmFwaCgpO1xufVxuXG4vLyBtYXBwaW5nIG9mIGF0dHJpYnV0ZXMgZnJvbSBET1QgKHRoZSBrZXlzKSB0byB2aXMuanMgKHRoZSB2YWx1ZXMpXG52YXIgTk9ERV9BVFRSX01BUFBJTkcgPSB7XG4gIGZvbnRzaXplOiAnZm9udC5zaXplJyxcbiAgZm9udGNvbG9yOiAnZm9udC5jb2xvcicsXG4gIGxhYmVsZm9udGNvbG9yOiAnZm9udC5jb2xvcicsXG4gIGZvbnRuYW1lOiAnZm9udC5mYWNlJyxcbiAgY29sb3I6IFsnY29sb3IuYm9yZGVyJywgJ2NvbG9yLmJhY2tncm91bmQnXSxcbiAgZmlsbGNvbG9yOiAnY29sb3IuYmFja2dyb3VuZCcsXG4gIHRvb2x0aXA6ICd0aXRsZScsXG4gIGxhYmVsdG9vbHRpcDogJ3RpdGxlJ1xufTtcbnZhciBFREdFX0FUVFJfTUFQUElORyA9ICgwLCBfY3JlYXRlMlsnZGVmYXVsdCddKShOT0RFX0FUVFJfTUFQUElORyk7XG5FREdFX0FUVFJfTUFQUElORy5jb2xvciA9ICdjb2xvci5jb2xvcic7XG5FREdFX0FUVFJfTUFQUElORy5zdHlsZSA9ICdkYXNoZXMnO1xuXG4vLyB0b2tlbiB0eXBlcyBlbnVtZXJhdGlvblxudmFyIFRPS0VOVFlQRSA9IHtcbiAgTlVMTDogMCxcbiAgREVMSU1JVEVSOiAxLFxuICBJREVOVElGSUVSOiAyLFxuICBVTktOT1dOOiAzXG5cbiAgLy8gbWFwIHdpdGggYWxsIGRlbGltaXRlcnNcbn07dmFyIERFTElNSVRFUlMgPSB7XG4gICd7JzogdHJ1ZSxcbiAgJ30nOiB0cnVlLFxuICAnWyc6IHRydWUsXG4gICddJzogdHJ1ZSxcbiAgJzsnOiB0cnVlLFxuICAnPSc6IHRydWUsXG4gICcsJzogdHJ1ZSxcblxuICAnLT4nOiB0cnVlLFxuICAnLS0nOiB0cnVlXG59O1xuXG52YXIgZG90ID0gJyc7IC8vIGN1cnJlbnQgZG90IGZpbGVcbnZhciBpbmRleCA9IDA7IC8vIGN1cnJlbnQgaW5kZXggaW4gZG90IGZpbGVcbnZhciBjID0gJyc7IC8vIGN1cnJlbnQgdG9rZW4gY2hhcmFjdGVyIGluIGV4cHJcbnZhciB0b2tlbiA9ICcnOyAvLyBjdXJyZW50IHRva2VuXG52YXIgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7IC8vIHR5cGUgb2YgdGhlIHRva2VuXG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAqL1xuZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGluZGV4ID0gMDtcbiAgYyA9IGRvdC5jaGFyQXQoMCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICovXG5mdW5jdGlvbiBuZXh0KCkge1xuICBpbmRleCsrO1xuICBjID0gZG90LmNoYXJBdChpbmRleCk7XG59XG5cbi8qKlxuICogUHJldmlldyB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNOZXh0XG4gKi9cbmZ1bmN0aW9uIG5leHRQcmV2aWV3KCkge1xuICByZXR1cm4gZG90LmNoYXJBdChpbmRleCArIDEpO1xufVxuXG52YXIgcmVnZXhBbHBoYU51bWVyaWMgPSAvW2EtekEtWl8wLTkuOiNdLztcbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIGNoYXJhY3RlciBpcyBhbHBoYWJldGljIG9yIG51bWVyaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjXG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc0FscGhhTnVtZXJpY1xuICovXG5mdW5jdGlvbiBpc0FscGhhTnVtZXJpYyhjKSB7XG4gIHJldHVybiByZWdleEFscGhhTnVtZXJpYy50ZXN0KGMpO1xufVxuXG4vKipcbiAqIE1lcmdlIGFsbCBvcHRpb25zIG9mIG9iamVjdCBiIGludG8gb2JqZWN0IGJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgaWYgKCFhKSB7XG4gICAgYSA9IHt9O1xuICB9XG5cbiAgaWYgKGIpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGIpIHtcbiAgICAgIGlmIChiLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGFbbmFtZV0gPSBiW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBTZXQgYSB2YWx1ZSBpbiBhbiBvYmplY3QsIHdoZXJlIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgbmFtZSBjYW4gYmUgYVxuICogcGF0aCB3aXRoIG5lc3RlZCBwYXJhbWV0ZXJzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIG9iaiA9IHthOiAyfTtcbiAqICAgICBzZXRWYWx1ZShvYmosICdiLmMnLCAzKTsgICAgIC8vIG9iaiA9IHthOiAyLCBiOiB7YzogM319XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggIEEgcGFyYW1ldGVyIG5hbWUgb3IgZG90LXNlcGFyYXRlZCBwYXJhbWV0ZXIgcGF0aCxcbiAqICAgICAgICAgICAgICAgICAgICAgIGxpa2UgXCJjb2xvci5oaWdobGlnaHQuYm9yZGVyXCIuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBvID0gb2JqO1xuICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICB2YXIga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcyBpc24ndCB0aGUgZW5kIHBvaW50XG4gICAgICBpZiAoIW9ba2V5XSkge1xuICAgICAgICBvW2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIG8gPSBvW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBwb2ludFxuICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIGEgbm9kZSB0byBhIGdyYXBoIG9iamVjdC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aFxuICogdGhlIHNhbWUgaWQsIHRoZWlyIGF0dHJpYnV0ZXMgd2lsbCBiZSBtZXJnZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKi9cbmZ1bmN0aW9uIGFkZE5vZGUoZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIGksIGxlbjtcbiAgdmFyIGN1cnJlbnQgPSBudWxsO1xuXG4gIC8vIGZpbmQgcm9vdCBncmFwaCAoaW4gY2FzZSBvZiBzdWJncmFwaClcbiAgdmFyIGdyYXBocyA9IFtncmFwaF07IC8vIGxpc3Qgd2l0aCBhbGwgZ3JhcGhzIGZyb20gY3VycmVudCBncmFwaCB0byByb290IGdyYXBoXG4gIHZhciByb290ID0gZ3JhcGg7XG4gIHdoaWxlIChyb290LnBhcmVudCkge1xuICAgIGdyYXBocy5wdXNoKHJvb3QucGFyZW50KTtcbiAgICByb290ID0gcm9vdC5wYXJlbnQ7XG4gIH1cblxuICAvLyBmaW5kIGV4aXN0aW5nIG5vZGUgKGF0IHJvb3QgbGV2ZWwpIGJ5IGl0cyBpZFxuICBpZiAocm9vdC5ub2Rlcykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJvb3Qubm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChub2RlLmlkID09PSByb290Lm5vZGVzW2ldLmlkKSB7XG4gICAgICAgIGN1cnJlbnQgPSByb290Lm5vZGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWN1cnJlbnQpIHtcbiAgICAvLyB0aGlzIGlzIGEgbmV3IG5vZGVcbiAgICBjdXJyZW50ID0ge1xuICAgICAgaWQ6IG5vZGUuaWRcbiAgICB9O1xuICAgIGlmIChncmFwaC5ub2RlKSB7XG4gICAgICAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlKGN1cnJlbnQuYXR0ciwgZ3JhcGgubm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIG5vZGUgdG8gdGhpcyAoc3ViKWdyYXBoIGFuZCBhbGwgaXRzIHBhcmVudCBncmFwaHNcbiAgZm9yIChpID0gZ3JhcGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGcgPSBncmFwaHNbaV07XG5cbiAgICBpZiAoIWcubm9kZXMpIHtcbiAgICAgIGcubm9kZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKGcubm9kZXMuaW5kZXhPZihjdXJyZW50KSA9PT0gLTEpIHtcbiAgICAgIGcubm9kZXMucHVzaChjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gIGlmIChub2RlLmF0dHIpIHtcbiAgICBjdXJyZW50LmF0dHIgPSBtZXJnZShjdXJyZW50LmF0dHIsIG5vZGUuYXR0cik7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gZWRnZVxuICovXG5mdW5jdGlvbiBhZGRFZGdlKGdyYXBoLCBlZGdlKSB7XG4gIGlmICghZ3JhcGguZWRnZXMpIHtcbiAgICBncmFwaC5lZGdlcyA9IFtdO1xuICB9XG4gIGdyYXBoLmVkZ2VzLnB1c2goZWRnZSk7XG4gIGlmIChncmFwaC5lZGdlKSB7XG4gICAgdmFyIGF0dHIgPSBtZXJnZSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgIGVkZ2UuYXR0ciA9IG1lcmdlKGF0dHIsIGVkZ2UuYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgT2JqZWN0fSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IE9iamVjdH0gdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IGF0dHJcbiAqIEByZXR1cm4ge09iamVjdH0gZWRnZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlKGdyYXBoLCBmcm9tLCB0bywgdHlwZSwgYXR0cikge1xuICB2YXIgZWRnZSA9IHtcbiAgICBmcm9tOiBmcm9tLFxuICAgIHRvOiB0byxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG5cbiAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICBlZGdlLmF0dHIgPSBtZXJnZSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICB9XG4gIGVkZ2UuYXR0ciA9IG1lcmdlKGVkZ2UuYXR0ciB8fCB7fSwgYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcblxuICAvLyBNb3ZlIGFycm93cyBhdHRyaWJ1dGUgZnJvbSBhdHRyIHRvIGVkZ2UgdGVtcG9yYWxseSBjcmVhdGVkIGluXG4gIC8vIHBhcnNlQXR0cmlidXRlTGlzdCgpLlxuICBpZiAoYXR0ciAhPSBudWxsKSB7XG4gICAgaWYgKGF0dHIuaGFzT3duUHJvcGVydHkoJ2Fycm93cycpKSB7XG4gICAgICBlZGdlWydhcnJvd3MnXSA9IHsgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogYXR0ci5hcnJvd3MudHlwZSB9IH07XG4gICAgICBhdHRyWydhcnJvd3MnXSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG4vKipcbiAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IGRvdCBmaWxlLlxuICogVGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIGFyZSBhdmFpbGFibGUgYXMgdG9rZW4gYW5kIHRva2VuVHlwZVxuICovXG5mdW5jdGlvbiBnZXRUb2tlbigpIHtcbiAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7XG4gIHRva2VuID0gJyc7XG5cbiAgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG4gIHdoaWxlIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicpIHtcbiAgICAvLyBzcGFjZSwgdGFiLCBlbnRlclxuICAgIG5leHQoKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB2YXIgaXNDb21tZW50ID0gZmFsc2U7XG5cbiAgICAvLyBza2lwIGNvbW1lbnRcbiAgICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAvLyBmaW5kIHRoZSBwcmV2aW91cyBub24tc3BhY2UgY2hhcmFjdGVyXG4gICAgICB2YXIgaSA9IGluZGV4IC0gMTtcbiAgICAgIHdoaWxlIChkb3QuY2hhckF0KGkpID09PSAnICcgfHwgZG90LmNoYXJBdChpKSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgaWYgKGRvdC5jaGFyQXQoaSkgPT09ICdcXG4nIHx8IGRvdC5jaGFyQXQoaSkgPT09ICcnKSB7XG4gICAgICAgIC8vIHRoZSAjIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUsIHRoaXMgaXMgaW5kZWVkIGEgbGluZSBjb21tZW50XG4gICAgICAgIHdoaWxlIChjICE9ICcnICYmIGMgIT0gJ1xcbicpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPT09ICcvJyAmJiBuZXh0UHJldmlldygpID09PSAnLycpIHtcbiAgICAgIC8vIHNraXAgbGluZSBjb21tZW50XG4gICAgICB3aGlsZSAoYyAhPSAnJyAmJiBjICE9ICdcXG4nKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjID09PSAnLycgJiYgbmV4dFByZXZpZXcoKSA9PT0gJyonKSB7XG4gICAgICAvLyBza2lwIGJsb2NrIGNvbW1lbnRcbiAgICAgIHdoaWxlIChjICE9ICcnKSB7XG4gICAgICAgIGlmIChjID09PSAnKicgJiYgbmV4dFByZXZpZXcoKSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gZW5kIG9mIGJsb2NrIGNvbW1lbnQgZm91bmQuIHNraXAgdGhlc2UgbGFzdCB0d28gY2hhcmFjdGVyc1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuICAgIHdoaWxlIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicpIHtcbiAgICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9IHdoaWxlIChpc0NvbW1lbnQpO1xuXG4gIC8vIGNoZWNrIGZvciBlbmQgb2YgZG90IGZpbGVcbiAgaWYgKGMgPT09ICcnKSB7XG4gICAgLy8gdG9rZW4gaXMgc3RpbGwgZW1wdHlcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMiBjaGFyYWN0ZXJzXG4gIHZhciBjMiA9IGMgKyBuZXh0UHJldmlldygpO1xuICBpZiAoREVMSU1JVEVSU1tjMl0pIHtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHRva2VuID0gYzI7XG4gICAgbmV4dCgpO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDEgY2hhcmFjdGVyXG4gIGlmIChERUxJTUlURVJTW2NdKSB7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICB0b2tlbiA9IGM7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBhbiBpZGVudGlmaWVyIChudW1iZXIgb3Igc3RyaW5nKVxuICAvLyBUT0RPOiBtb3JlIHByZWNpc2UgcGFyc2luZyBvZiBudW1iZXJzL3N0cmluZ3MgKGFuZCB0aGUgcG9ydCBzZXBhcmF0b3IgJzonKVxuICBpZiAoaXNBbHBoYU51bWVyaWMoYykgfHwgYyA9PT0gJy0nKSB7XG4gICAgdG9rZW4gKz0gYztcbiAgICBuZXh0KCk7XG5cbiAgICB3aGlsZSAoaXNBbHBoYU51bWVyaWMoYykpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PT0gJ2ZhbHNlJykge1xuICAgICAgdG9rZW4gPSBmYWxzZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ3RydWUnKSB7XG4gICAgICB0b2tlbiA9IHRydWU7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcih0b2tlbikpKSB7XG4gICAgICB0b2tlbiA9IE51bWJlcih0b2tlbik7IC8vIGNvbnZlcnQgdG8gbnVtYmVyXG4gICAgfVxuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBhIHN0cmluZyBlbmNsb3NlZCBieSBkb3VibGUgcXVvdGVzXG4gIGlmIChjID09PSAnXCInKSB7XG4gICAgbmV4dCgpO1xuICAgIHdoaWxlIChjICE9ICcnICYmIChjICE9ICdcIicgfHwgYyA9PT0gJ1wiJyAmJiBuZXh0UHJldmlldygpID09PSAnXCInKSkge1xuICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgLy8gc2tpcCB0aGUgZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09ICdcXFxcJyAmJiBuZXh0UHJldmlldygpID09PSAnbicpIHtcbiAgICAgICAgLy8gSG9ub3IgYSBuZXdsaW5lIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICB0b2tlbiArPSAnXFxuJztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgaWYgKGMgIT0gJ1wiJykge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0VuZCBvZiBzdHJpbmcgXCIgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNvbWV0aGluZyB1bmtub3duIGlzIGZvdW5kLCB3cm9uZyBjaGFyYWN0ZXJzLCBhIHN5bnRheCBlcnJvclxuICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcbiAgd2hpbGUgKGMgIT0gJycpIHtcbiAgICB0b2tlbiArPSBjO1xuICAgIG5leHQoKTtcbiAgfVxuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIicpO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgZ3JhcGguXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBncmFwaFxuICovXG5mdW5jdGlvbiBwYXJzZUdyYXBoKCkge1xuICB2YXIgZ3JhcGggPSB7fTtcblxuICBmaXJzdCgpO1xuICBnZXRUb2tlbigpO1xuXG4gIC8vIG9wdGlvbmFsIHN0cmljdCBrZXl3b3JkXG4gIGlmICh0b2tlbiA9PT0gJ3N0cmljdCcpIHtcbiAgICBncmFwaC5zdHJpY3QgPSB0cnVlO1xuICAgIGdldFRva2VuKCk7XG4gIH1cblxuICAvLyBncmFwaCBvciBkaWdyYXBoIGtleXdvcmRcbiAgaWYgKHRva2VuID09PSAnZ3JhcGgnIHx8IHRva2VuID09PSAnZGlncmFwaCcpIHtcbiAgICBncmFwaC50eXBlID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuXG4gIC8vIG9wdGlvbmFsIGdyYXBoIGlkXG4gIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgZ3JhcGguaWQgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICB9XG5cbiAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gIGlmICh0b2tlbiAhPSAneycpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQW5nbGUgYnJhY2tldCB7IGV4cGVjdGVkJyk7XG4gIH1cbiAgZ2V0VG9rZW4oKTtcblxuICAvLyBzdGF0ZW1lbnRzXG4gIHBhcnNlU3RhdGVtZW50cyhncmFwaCk7XG5cbiAgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuICBpZiAodG9rZW4gIT0gJ30nKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0FuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZCcpO1xuICB9XG4gIGdldFRva2VuKCk7XG5cbiAgLy8gZW5kIG9mIGZpbGVcbiAgaWYgKHRva2VuICE9PSAnJykge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFbmQgb2YgZmlsZSBleHBlY3RlZCcpO1xuICB9XG4gIGdldFRva2VuKCk7XG5cbiAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcbiAgZGVsZXRlIGdyYXBoLm5vZGU7XG4gIGRlbGV0ZSBncmFwaC5lZGdlO1xuICBkZWxldGUgZ3JhcGguZ3JhcGg7XG5cbiAgcmV0dXJuIGdyYXBoO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCB3aXRoIHN0YXRlbWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRzKGdyYXBoKSB7XG4gIHdoaWxlICh0b2tlbiAhPT0gJycgJiYgdG9rZW4gIT0gJ30nKSB7XG4gICAgcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpO1xuICAgIGlmICh0b2tlbiA9PT0gJzsnKSB7XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC4gQ2FuIGJlIGEgYW4gYXR0cmlidXRlIHN0YXRlbWVudCwgbm9kZVxuICogc3RhdGVtZW50LCBhIHNlcmllcyBvZiBub2RlIHN0YXRlbWVudHMgYW5kIGVkZ2Ugc3RhdGVtZW50cywgb3IgYVxuICogcGFyYW1ldGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KGdyYXBoKSB7XG4gIC8vIHBhcnNlIHN1YmdyYXBoXG4gIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICBwYXJzZUVkZ2UoZ3JhcGgsIHN1YmdyYXBoKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnRcbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCk7XG4gIGlmIChhdHRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcGFyc2Ugbm9kZVxuICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0lkZW50aWZpZXIgZXhwZWN0ZWQnKTtcbiAgfVxuICB2YXIgaWQgPSB0b2tlbjsgLy8gaWQgY2FuIGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyXG4gIGdldFRva2VuKCk7XG5cbiAgaWYgKHRva2VuID09PSAnPScpIHtcbiAgICAvLyBpZCBzdGF0ZW1lbnRcbiAgICBnZXRUb2tlbigpO1xuICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJZGVudGlmaWVyIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdyYXBoW2lkXSA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGNvbW1hIHNlcGFyYXRlZCBsaXN0IHdpdGggXCJhX2xpc3Q6IElEPUlEIFsnLCddIFthX2xpc3RdIFwiXG4gIH0gZWxzZSB7XG4gICAgcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN1YmdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGggICAgcGFyZW50IGdyYXBoIG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gc3ViZ3JhcGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdWJncmFwaChncmFwaCkge1xuICB2YXIgc3ViZ3JhcGggPSBudWxsO1xuXG4gIC8vIG9wdGlvbmFsIHN1YmdyYXBoIGtleXdvcmRcbiAgaWYgKHRva2VuID09PSAnc3ViZ3JhcGgnKSB7XG4gICAgc3ViZ3JhcGggPSB7fTtcbiAgICBzdWJncmFwaC50eXBlID0gJ3N1YmdyYXBoJztcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gb3B0aW9uYWwgZ3JhcGggaWRcbiAgICBpZiAodG9rZW5UeXBlID09PSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgc3ViZ3JhcGguaWQgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gIGlmICh0b2tlbiA9PT0gJ3snKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIGlmICghc3ViZ3JhcGgpIHtcbiAgICAgIHN1YmdyYXBoID0ge307XG4gICAgfVxuICAgIHN1YmdyYXBoLnBhcmVudCA9IGdyYXBoO1xuICAgIHN1YmdyYXBoLm5vZGUgPSBncmFwaC5ub2RlO1xuICAgIHN1YmdyYXBoLmVkZ2UgPSBncmFwaC5lZGdlO1xuICAgIHN1YmdyYXBoLmdyYXBoID0gZ3JhcGguZ3JhcGg7XG5cbiAgICAvLyBzdGF0ZW1lbnRzXG4gICAgcGFyc2VTdGF0ZW1lbnRzKHN1YmdyYXBoKTtcblxuICAgIC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcbiAgICBpZiAodG9rZW4gIT0gJ30nKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuICAgIGRlbGV0ZSBzdWJncmFwaC5ub2RlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5lZGdlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5ncmFwaDtcbiAgICBkZWxldGUgc3ViZ3JhcGgucGFyZW50O1xuXG4gICAgLy8gcmVnaXN0ZXIgYXQgdGhlIHBhcmVudCBncmFwaFxuICAgIGlmICghZ3JhcGguc3ViZ3JhcGhzKSB7XG4gICAgICBncmFwaC5zdWJncmFwaHMgPSBbXTtcbiAgICB9XG4gICAgZ3JhcGguc3ViZ3JhcGhzLnB1c2goc3ViZ3JhcGgpO1xuICB9XG5cbiAgcmV0dXJuIHN1YmdyYXBoO1xufVxuXG4vKipcbiAqIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnQgbGlrZSBcIm5vZGUgW3NoYXBlPWNpcmNsZSBmb250U2l6ZT0xNl1cIi5cbiAqIEF2YWlsYWJsZSBrZXl3b3JkcyBhcmUgJ25vZGUnLCAnZWRnZScsICdncmFwaCcuXG4gKiBUaGUgcHJldmlvdXMgbGlzdCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyB3aWxsIGJlIHJlcGxhY2VkXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEByZXR1cm5zIHtTdHJpbmcgfCBudWxsfSBrZXl3b3JkIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhcnNlZCBhdHRyaWJ1dGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLCBlZGdlLCBncmFwaCksIG9yIG51bGwgaWYgbm90aGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFyc2VkLlxuICovXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCkge1xuICAvLyBhdHRyaWJ1dGUgc3RhdGVtZW50c1xuICBpZiAodG9rZW4gPT09ICdub2RlJykge1xuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBub2RlIGF0dHJpYnV0ZXNcbiAgICBncmFwaC5ub2RlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuICdub2RlJztcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ2VkZ2UnKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIGVkZ2UgYXR0cmlidXRlc1xuICAgIGdyYXBoLmVkZ2UgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICByZXR1cm4gJ2VkZ2UnO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnZ3JhcGgnKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIGdyYXBoIGF0dHJpYnV0ZXNcbiAgICBncmFwaC5ncmFwaCA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiAnZ3JhcGgnO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogcGFyc2UgYSBub2RlIHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gaWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCkge1xuICAvLyBub2RlIHN0YXRlbWVudFxuICB2YXIgbm9kZSA9IHtcbiAgICBpZDogaWRcbiAgfTtcbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgaWYgKGF0dHIpIHtcbiAgICBub2RlLmF0dHIgPSBhdHRyO1xuICB9XG4gIGFkZE5vZGUoZ3JhcGgsIG5vZGUpO1xuXG4gIC8vIGVkZ2Ugc3RhdGVtZW50c1xuICBwYXJzZUVkZ2UoZ3JhcGgsIGlkKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBlZGdlIG9yIGEgc2VyaWVzIG9mIGVkZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBmcm9tICAgICAgICBJZCBvZiB0aGUgZnJvbSBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRWRnZShncmFwaCwgZnJvbSkge1xuICB3aGlsZSAodG9rZW4gPT09ICctPicgfHwgdG9rZW4gPT09ICctLScpIHtcbiAgICB2YXIgdG87XG4gICAgdmFyIHR5cGUgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG4gICAgaWYgKHN1YmdyYXBoKSB7XG4gICAgICB0byA9IHN1YmdyYXBoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJZGVudGlmaWVyIG9yIHN1YmdyYXBoIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICB0byA9IHRva2VuO1xuICAgICAgYWRkTm9kZShncmFwaCwge1xuICAgICAgICBpZDogdG9cbiAgICAgIH0pO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBlZGdlIGF0dHJpYnV0ZXNcbiAgICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuXG4gICAgLy8gY3JlYXRlIGVkZ2VcbiAgICB2YXIgZWRnZSA9IGNyZWF0ZUVkZ2UoZ3JhcGgsIGZyb20sIHRvLCB0eXBlLCBhdHRyKTtcbiAgICBhZGRFZGdlKGdyYXBoLCBlZGdlKTtcblxuICAgIGZyb20gPSB0bztcbiAgfVxufVxuXG4vKipcbiAqIEFzIGV4cGxhaW5lZCBpbiBbMV0sIGdyYXBodml6IGhhcyBsaW1pdGF0aW9ucyBmb3IgY29tYmluYXRpb24gb2ZcbiAqIGFycm93W2hlYWR8dGFpbF0gYW5kIGRpci4gSWYgYXR0cmlidXRlIGxpc3QgaW5jbHVkZXMgJ2RpcicsXG4gKiBmb2xsb3dpbmcgY2FzZXMganVzdCBiZSBzdXBwb3J0ZWQuXG4gKiAgIDEuIGJvdGggb3Igbm9uZSArIGFycm93aGVhZCwgYXJyb3d0YWlsXG4gKiAgIDIuIGZvcndhcmQgKyBhcnJvd2hlYWQgKGFycm93dGFpbCBpcyBub3QgYWZmZWR0ZWQpXG4gKiAgIDMuIGJhY2sgKyBhcnJvd3RhaWwgKGFycm93aGVhZCBpcyBub3QgYWZmZWN0ZWQpXG4gKiBbMV0gaHR0cHM6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2F0dHJzLmh0bWwjaDp1bmRpcl9ub3RlXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbSBwYXJzZUF0dHJpYnV0ZUxpc3QoKSB0byBwYXJzZSAnZGlyJ1xuICogYXR0cmlidXRlIHdpdGggZ2l2ZW4gJ2F0dHJfbmFtZXMnIGFuZCAnYXR0cl9saXN0Jy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyX25hbWVzICBBcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyX2xpc3QgIEFycmF5IG9mIG9iamVjdHMgb2YgYXR0cmlidXRlIHNldFxuICogQHJldHVybiB7T2JqZWN0fSBhdHRyX2xpc3QgIFVwZGF0ZWQgYXR0cl9saXN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGlyQXR0cmlidXRlKGF0dHJfbmFtZXMsIGF0dHJfbGlzdCkge1xuICB2YXIgaTtcbiAgaWYgKGF0dHJfbmFtZXMuaW5jbHVkZXMoJ2RpcicpKSB7XG4gICAgdmFyIGlkeCA9IHt9OyAvLyBnZXQgaW5kZXggb2YgJ2Fycm93cycgYW5kICdkaXInXG4gICAgaWR4LmFycm93cyA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyX2xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gJ2Fycm93cycpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS52YWx1ZS50byAhPSBudWxsKSB7XG4gICAgICAgICAgaWR4LmFycm93cy50byA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLnZhbHVlLmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgYXJyb3dzJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09ICdkaXInKSB7XG4gICAgICAgIGlkeC5kaXIgPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpcnN0LCBhZGQgZGVmYXVsdCBhcnJvdyBzaGFwZSBpZiBpdCBpcyBub3QgYXNzaWduZWQgdG8gYXZvaWQgZXJyb3JcbiAgICB2YXIgZGlyX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmRpcl0udmFsdWU7XG4gICAgaWYgKCFhdHRyX25hbWVzLmluY2x1ZGVzKCdhcnJvd3MnKSkge1xuICAgICAgaWYgKGRpcl90eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6ICdhcnJvd3MnLFxuICAgICAgICAgIHZhbHVlOiB7IHRvOiB7IGVuYWJsZWQ6IHRydWUgfSB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiAnYXJyb3dzJyxcbiAgICAgICAgICB2YWx1ZTogeyBmcm9tOiB7IGVuYWJsZWQ6IHRydWUgfSB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09ICdmb3J3YXJkJykge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogJ2Fycm93cycsXG4gICAgICAgICAgdmFsdWU6IHsgdG86IHsgZW5hYmxlZDogdHJ1ZSB9IH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09ICdiYWNrJykge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogJ2Fycm93cycsXG4gICAgICAgICAgdmFsdWU6IHsgZnJvbTogeyBlbmFibGVkOiB0cnVlIH0gfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6ICdhcnJvd3MnLFxuICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbV90eXBlO1xuICAgIHZhciB0b190eXBlO1xuICAgIC8vIHVwZGF0ZSAnYXJyb3dzJyBhdHRyaWJ1dGUgZnJvbSAnZGlyJy5cbiAgICBpZiAoZGlyX3R5cGUgPT09ICdib3RoJykge1xuICAgICAgLy8gYm90aCBvZiBzaGFwZXMgb2YgJ2Zyb20nIGFuZCAndG8nIGFyZSBnaXZlblxuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IHRvX3R5cGUgfSxcbiAgICAgICAgICAgIGZyb206IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogZnJvbV90eXBlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGF0dHJfbGlzdC5zcGxpY2UoaWR4LmFycm93cy5mcm9tLCAxKTtcblxuICAgICAgICAvLyBzaGFwZSBvZiAndG8nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCB0byAnZnJvbSdcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9ICdhcnJvdyc7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogdG9fdHlwZSB9LFxuICAgICAgICAgICAgZnJvbTogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiBmcm9tX3R5cGUgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG9ubHkgc2hhcGUgb2YgJ2Zyb20nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCBmb3IgJ3RvJ1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9ICdhcnJvdyc7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09ICdiYWNrJykge1xuICAgICAgLy8gZ2l2ZW4gYm90aCBvZiBzaGFwZXMsIGJ1dCB1c2Ugb25seSAnZnJvbSdcbiAgICAgIGlmIChpZHguYXJyb3dzLnRvICYmIGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gJyc7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZ2l2ZW4gc2hhcGUgb2YgJ3RvJywgYnV0IGRvZXMgbm90IHVzZSBpdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSAnJztcbiAgICAgICAgZnJvbV90eXBlID0gJ2Fycm93JztcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gaWR4LmFycm93cy50bztcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYXNzaWduIGdpdmVuICdmcm9tJyBzaGFwZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9ICcnO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IHRvX3R5cGUgfSxcbiAgICAgICAgICAgIGZyb206IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogZnJvbV90eXBlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICB2YXIgaWR4X2Fycm93O1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgaWR4X2Fycm93ID0gaWR4LmFycm93cy50bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeF9hcnJvdyA9IGlkeC5hcnJvd3MuZnJvbTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeF9hcnJvd10gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLm5hbWUsXG4gICAgICAgIHZhbHVlOiAnJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSAnZm9yd2FyZCcpIHtcbiAgICAgIC8vIGdpdmVuIGJvdGggb2Ygc2hhcGVzLCBidXQgdXNlIG9ubHkgJ3RvJ1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gJyc7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogdG9fdHlwZSB9LFxuICAgICAgICAgICAgZnJvbTogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiBmcm9tX3R5cGUgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFzc2lnbiBnaXZlbiAndG8nIHNoYXBlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSAnJztcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZ2l2ZW4gc2hhcGUgb2YgJ2Zyb20nLCBidXQgZG9lcyBub3QgdXNlIGl0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gJ2Fycm93JztcbiAgICAgICAgZnJvbV90eXBlID0gJyc7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBpZHguYXJyb3dzLmZyb207XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogdG9fdHlwZSB9LFxuICAgICAgICAgICAgZnJvbTogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiBmcm9tX3R5cGUgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgJ2RpcicgYXR0cmlidXRlIG5vIG5lZWQgYW55bW9yZVxuICAgIGF0dHJfbGlzdC5zcGxpY2UoaWR4LmRpciwgMSk7XG4gIH1cbiAgcmV0dXJuIGF0dHJfbGlzdDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHNldCB3aXRoIGF0dHJpYnV0ZXMsXG4gKiBmb3IgZXhhbXBsZSBbbGFiZWw9XCIxLjAwMFwiLCBzaGFwZT1zb2xpZF1cbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGF0dHJcbiAqL1xuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVMaXN0KCkge1xuICB2YXIgaTtcbiAgdmFyIGF0dHIgPSBudWxsO1xuXG4gIC8vIGVkZ2Ugc3R5bGVzIG9mIGRvdCBhbmQgdmlzXG4gIHZhciBlZGdlU3R5bGVzID0ge1xuICAgIGRhc2hlZDogdHJ1ZSxcbiAgICBzb2xpZDogZmFsc2UsXG4gICAgZG90dGVkOiBbMSwgNV1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhcnJvdyB0eXBlcy5cbiAgICAgKiB2aXMgY3VycmVudGx5IHN1cHBvcnRzIHR5cGVzIGRlZmluZWQgaW4gJ2Fycm93VHlwZXMnLlxuICAgICAqIERldGFpbHMgb2YgYXJyb3cgc2hhcGVzIGFyZSBkZXNjcmliZWQgaW5cbiAgICAgKiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2Fycm93LXNoYXBlc1xuICAgICAqL1xuICB9O3ZhciBhcnJvd1R5cGVzID0ge1xuICAgIGRvdDogJ2NpcmNsZScsXG4gICAgYm94OiAnYm94JyxcbiAgICBjcm93OiAnY3JvdycsXG4gICAgY3VydmU6ICdjdXJ2ZScsXG4gICAgaWN1cnZlOiAnaW52X2N1cnZlJyxcbiAgICBub3JtYWw6ICd0cmlhbmdsZScsXG4gICAgaW52OiAnaW52X3RyaWFuZ2xlJyxcbiAgICBkaWFtb25kOiAnZGlhbW9uZCcsXG4gICAgdGVlOiAnYmFyJyxcbiAgICB2ZWU6ICd2ZWUnXG5cbiAgICAvKipcbiAgICAgKiAnYXR0cl9saXN0JyBjb250YWlucyBhdHRyaWJ1dGVzIGZvciBjaGVja2luZyBpZiBzb21lIG9mIHRoZW0gYXJlIGFmZmVjdGVkXG4gICAgICogbGF0ZXIuIEZvciBpbnN0YW5jZSwgYm90aCBvZiAnYXJyb3doZWFkJyBhbmQgJ2RpcicgKGVkZ2Ugc3R5bGUgZGVmaW5lZFxuICAgICAqIGluIERPVCkgbWFrZSBjaGFuZ2VzIHRvICdhcnJvd3MnIGF0dHJpYnV0ZSBpbiB2aXMuXG4gICAgICovXG4gIH07dmFyIGF0dHJfbGlzdCA9IG5ldyBBcnJheSgpO1xuICB2YXIgYXR0cl9uYW1lcyA9IG5ldyBBcnJheSgpOyAvLyB1c2VkIGZvciBjaGVja2luZyB0aGUgY2FzZS5cblxuICAvLyBwYXJzZSBhdHRyaWJ1dGVzXG4gIHdoaWxlICh0b2tlbiA9PT0gJ1snKSB7XG4gICAgZ2V0VG9rZW4oKTtcbiAgICBhdHRyID0ge307XG4gICAgd2hpbGUgKHRva2VuICE9PSAnJyAmJiB0b2tlbiAhPSAnXScpIHtcbiAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0F0dHJpYnV0ZSBuYW1lIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICB2YXIgbmFtZSA9IHRva2VuO1xuXG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuICE9ICc9Jykge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignRXF1YWwgc2lnbiA9IGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHRva2VuO1xuXG4gICAgICAvLyBjb252ZXJ0IGZyb20gZG90IHN0eWxlIHRvIHZpc1xuICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgdmFsdWUgPSBlZGdlU3R5bGVzW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycm93VHlwZTtcbiAgICAgIGlmIChuYW1lID09PSAnYXJyb3doZWFkJykge1xuICAgICAgICBhcnJvd1R5cGUgPSBhcnJvd1R5cGVzW3ZhbHVlXTtcbiAgICAgICAgbmFtZSA9ICdhcnJvd3MnO1xuICAgICAgICB2YWx1ZSA9IHsgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogYXJyb3dUeXBlIH0gfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdhcnJvd3RhaWwnKSB7XG4gICAgICAgIGFycm93VHlwZSA9IGFycm93VHlwZXNbdmFsdWVdO1xuICAgICAgICBuYW1lID0gJ2Fycm93cyc7XG4gICAgICAgIHZhbHVlID0geyBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGFycm93VHlwZSB9IH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdC5wdXNoKHsgYXR0cjogYXR0ciwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgYXR0cl9uYW1lcy5wdXNoKG5hbWUpO1xuXG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuID09ICcsJykge1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdCcmFja2V0IF0gZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuXG4gIGF0dHJfbGlzdCA9IHBhcnNlRGlyQXR0cmlidXRlKGF0dHJfbmFtZXMsIGF0dHJfbGlzdCk7XG5cbiAgLy8gcGFyc2UgJ3BlbndpZHRoJ1xuICB2YXIgbm9mX2F0dHJfbGlzdDtcbiAgaWYgKGF0dHJfbmFtZXMuaW5jbHVkZXMoJ3BlbndpZHRoJykpIHtcbiAgICB2YXIgdG1wX2F0dHJfbGlzdCA9IFtdO1xuXG4gICAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZl9hdHRyX2xpc3Q7IGkrKykge1xuICAgICAgLy8gZXhjbHVkZSAnd2lkdGgnIGZyb20gYXR0cl9saXN0IGlmICdwZW53aWR0aCcgZXhpc3RzXG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgIT09ICd3aWR0aCcpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS5uYW1lID09PSAncGVud2lkdGgnKSB7XG4gICAgICAgICAgYXR0cl9saXN0W2ldLm5hbWUgPSAnd2lkdGgnO1xuICAgICAgICB9XG4gICAgICAgIHRtcF9hdHRyX2xpc3QucHVzaChhdHRyX2xpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBhdHRyX2xpc3QgPSB0bXBfYXR0cl9saXN0O1xuICB9XG5cbiAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBub2ZfYXR0cl9saXN0OyBpKyspIHtcbiAgICBzZXRWYWx1ZShhdHRyX2xpc3RbaV0uYXR0ciwgYXR0cl9saXN0W2ldLm5hbWUsIGF0dHJfbGlzdFtpXS52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gYXR0cjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzeW50YXggZXJyb3Igd2l0aCBleHRyYSBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IHRva2VuIGFuZCBpbmRleC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7U3ludGF4RXJyb3J9IGVyclxuICovXG5mdW5jdGlvbiBuZXdTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcsIGdvdCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCIgKGNoYXIgJyArIGluZGV4ICsgJyknKTtcbn1cblxuLyoqXG4gKiBDaG9wIG9mZiB0ZXh0IGFmdGVyIGEgbWF4aW11bSBsZW5ndGhcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBjaG9wKHRleHQsIG1heExlbmd0aCkge1xuICByZXR1cm4gdGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoID8gdGV4dCA6IHRleHQuc3Vic3RyKDAsIDI3KSArICcuLi4nO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBmbiBmb3IgZWFjaCBwYWlyIG9mIGVsZW1lbnRzIGluIHR3byBhcnJheXNcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTFcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gyKGFycmF5MSwgYXJyYXkyLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTEpKSB7XG4gICAgYXJyYXkxLmZvckVhY2goZnVuY3Rpb24gKGVsZW0xKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTIpKSB7XG4gICAgICAgIGFycmF5Mi5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICAgIGZuKGVsZW0xLCBlbGVtMik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oZWxlbTEsIGFycmF5Mik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgYXJyYXkyLmZvckVhY2goZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgIGZuKGFycmF5MSwgZWxlbTIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKGFycmF5MSwgYXJyYXkyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBuZXN0ZWQgcHJvcGVydHkgb24gYW4gb2JqZWN0XG4gKiBXaGVuIG5lc3RlZCBvYmplY3RzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEZvciBleGFtcGxlIHNldFByb3Aoe30sICdmb250LmNvbG9yJywgJ3JlZCcpIHdpbGwgcmV0dXJuIHtmb250OiB7Y29sb3I6ICdyZWQnfX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICAgQSBkb3Qgc2VwYXJhdGVkIHN0cmluZyBsaWtlICdmb250LmNvbG9yJ1xuICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICBWYWx1ZSBmb3IgdGhlIHByb3BlcnR5XG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdCwgYWxsb3dzIGZvciBjaGFpbmluZy5cbiAqL1xuZnVuY3Rpb24gc2V0UHJvcChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIHByb3AgPSBuYW1lcy5wb3AoKTtcblxuICAvLyB0cmF2ZXJzZSBvdmVyIHRoZSBuZXN0ZWQgb2JqZWN0c1xuICB2YXIgb2JqID0gb2JqZWN0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgIG9ialtuYW1lXSA9IHt9O1xuICAgIH1cbiAgICBvYmogPSBvYmpbbmFtZV07XG4gIH1cblxuICAvLyBzZXQgdGhlIHByb3BlcnR5IHZhbHVlXG4gIG9ialtwcm9wXSA9IHZhbHVlO1xuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3Qgd2l0aCBET1QgYXR0cmlidXRlcyB0byB0aGVpciB2aXMuanMgZXF1aXZhbGVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0ciAgICAgT2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB2aXMuanMgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBjb252ZXJ0QXR0cihhdHRyLCBtYXBwaW5nKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIGF0dHIpIHtcbiAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIHZpc1Byb3AgPSBtYXBwaW5nW3Byb3BdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmlzUHJvcCkpIHtcbiAgICAgICAgdmlzUHJvcC5mb3JFYWNoKGZ1bmN0aW9uICh2aXNQcm9wSSkge1xuICAgICAgICAgIHNldFByb3AoY29udmVydGVkLCB2aXNQcm9wSSwgYXR0cltwcm9wXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmlzUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHByb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9UIGxhbmd1YWdlIGludG8gYSBtYXAgY29udGFpbmluZ1xuICogd2l0aCBub2RlcyBhbmQgZWRnZXMgaW4gdGhlIGZvcm1hdCBvZiBncmFwaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICAgICAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdyYXBoRGF0YVxuICovXG5mdW5jdGlvbiBET1RUb0dyYXBoKGRhdGEpIHtcbiAgLy8gcGFyc2UgdGhlIERPVCBmaWxlXG4gIHZhciBkb3REYXRhID0gcGFyc2VET1QoZGF0YSk7XG4gIHZhciBncmFwaERhdGEgPSB7XG4gICAgbm9kZXM6IFtdLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBvcHRpb25zOiB7fVxuXG4gICAgLy8gY29weSB0aGUgbm9kZXNcbiAgfTtpZiAoZG90RGF0YS5ub2Rlcykge1xuICAgIGRvdERhdGEubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZG90Tm9kZSkge1xuICAgICAgdmFyIGdyYXBoTm9kZSA9IHtcbiAgICAgICAgaWQ6IGRvdE5vZGUuaWQsXG4gICAgICAgIGxhYmVsOiBTdHJpbmcoZG90Tm9kZS5sYWJlbCB8fCBkb3ROb2RlLmlkKVxuICAgICAgfTtcbiAgICAgIG1lcmdlKGdyYXBoTm9kZSwgY29udmVydEF0dHIoZG90Tm9kZS5hdHRyLCBOT0RFX0FUVFJfTUFQUElORykpO1xuICAgICAgaWYgKGdyYXBoTm9kZS5pbWFnZSkge1xuICAgICAgICBncmFwaE5vZGUuc2hhcGUgPSAnaW1hZ2UnO1xuICAgICAgfVxuICAgICAgZ3JhcGhEYXRhLm5vZGVzLnB1c2goZ3JhcGhOb2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvcHkgdGhlIGVkZ2VzXG4gIGlmIChkb3REYXRhLmVkZ2VzKSB7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiBlZGdlIGluIERPVCBmb3JtYXQgdG8gYW4gZWRnZSB3aXRoIFZpc0dyYXBoIGZvcm1hdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkb3RFZGdlXG4gICAgICogQHJldHVybnMge09iamVjdH0gZ3JhcGhFZGdlXG4gICAgICovXG4gICAgdmFyIGNvbnZlcnRFZGdlID0gZnVuY3Rpb24gY29udmVydEVkZ2UoZG90RWRnZSkge1xuICAgICAgdmFyIGdyYXBoRWRnZSA9IHtcbiAgICAgICAgZnJvbTogZG90RWRnZS5mcm9tLFxuICAgICAgICB0bzogZG90RWRnZS50b1xuICAgICAgfTtcbiAgICAgIG1lcmdlKGdyYXBoRWRnZSwgY29udmVydEF0dHIoZG90RWRnZS5hdHRyLCBFREdFX0FUVFJfTUFQUElORykpO1xuXG4gICAgICAvLyBBZGQgYXJyb3dzIGF0dHJpYnV0ZSB0byBkZWZhdWx0IHN0eWxlZCBhcnJvdy5cbiAgICAgIC8vIFRoZSByZWFzb24gd2h5IGRlZmF1bHQgc3R5bGUgaXMgbm90IGFkZGVkIGluIHBhcnNlQXR0cmlidXRlTGlzdCgpIGlzXG4gICAgICAvLyBiZWNhdXNlIG9ubHkgZGVmYXVsdCBpcyBjbGVhcmVkIGJlZm9yZSBoZXJlLlxuICAgICAgaWYgKGdyYXBoRWRnZS5hcnJvd3MgPT0gbnVsbCAmJiBkb3RFZGdlLnR5cGUgPT09ICctPicpIHtcbiAgICAgICAgZ3JhcGhFZGdlLmFycm93cyA9ICd0byc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFwaEVkZ2U7XG4gICAgfTtcblxuICAgIGRvdERhdGEuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZG90RWRnZSkge1xuICAgICAgdmFyIGZyb20sIHRvO1xuICAgICAgaWYgKGRvdEVkZ2UuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBmcm9tID0gZG90RWRnZS5mcm9tLm5vZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHtcbiAgICAgICAgICBpZDogZG90RWRnZS5mcm9tXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3RFZGdlLnRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHRvID0gZG90RWRnZS50by5ub2RlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvID0ge1xuICAgICAgICAgIGlkOiBkb3RFZGdlLnRvXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS5mcm9tLmVkZ2VzKSB7XG4gICAgICAgIGRvdEVkZ2UuZnJvbS5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJFZGdlKSB7XG4gICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3JFYWNoMihmcm9tLCB0bywgZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBzdWJFZGdlID0gY3JlYXRlRWRnZShncmFwaERhdGEsIGZyb20uaWQsIHRvLmlkLCBkb3RFZGdlLnR5cGUsIGRvdEVkZ2UuYXR0cik7XG4gICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLnRvLmVkZ2VzKSB7XG4gICAgICAgIGRvdEVkZ2UudG8uZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvcHkgdGhlIG9wdGlvbnNcbiAgaWYgKGRvdERhdGEuYXR0cikge1xuICAgIGdyYXBoRGF0YS5vcHRpb25zID0gZG90RGF0YS5hdHRyO1xuICB9XG5cbiAgcmV0dXJuIGdyYXBoRGF0YTtcbn1cblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5wYXJzZURPVCA9IHBhcnNlRE9UO1xuZXhwb3J0cy5ET1RUb0dyYXBoID0gRE9UVG9HcmFwaDtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2pzb259IGdlcGhpSlNPTlxuICogQHBhcmFtIHtvYmp9IG9wdGlvbnNPYmpcbiAqIEByZXR1cm5zIHt7bm9kZXM6IEFycmF5LCBlZGdlczogQXJyYXl9fVxuICovXG5mdW5jdGlvbiBwYXJzZUdlcGhpKGdlcGhpSlNPTiwgb3B0aW9uc09iaikge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBvcHRpb25zID0ge1xuICAgIGVkZ2VzOiB7XG4gICAgICBpbmhlcml0Q29sb3I6IGZhbHNlXG4gICAgfSxcbiAgICBub2Rlczoge1xuICAgICAgZml4ZWQ6IGZhbHNlLFxuICAgICAgcGFyc2VDb2xvcjogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdGlvbnNPYmogIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zT2JqLmZpeGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMuZml4ZWQgPSBvcHRpb25zT2JqLmZpeGVkO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc09iai5wYXJzZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9IG9wdGlvbnNPYmoucGFyc2VDb2xvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNPYmouaW5oZXJpdENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID0gb3B0aW9uc09iai5pbmhlcml0Q29sb3I7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdFZGdlcyA9IGdlcGhpSlNPTi5lZGdlcztcbiAgdmFyIGdOb2RlcyA9IGdlcGhpSlNPTi5ub2RlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IHt9O1xuICAgIHZhciBnRWRnZSA9IGdFZGdlc1tpXTtcbiAgICBlZGdlWydpZCddID0gZ0VkZ2UuaWQ7XG4gICAgZWRnZVsnZnJvbSddID0gZ0VkZ2Uuc291cmNlO1xuICAgIGVkZ2VbJ3RvJ10gPSBnRWRnZS50YXJnZXQ7XG4gICAgZWRnZVsnYXR0cmlidXRlcyddID0gZ0VkZ2UuYXR0cmlidXRlcztcbiAgICBlZGdlWydsYWJlbCddID0gZ0VkZ2UubGFiZWw7XG4gICAgZWRnZVsndGl0bGUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdFZGdlLmF0dHJpYnV0ZXMudGl0bGUgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGdFZGdlWyd0eXBlJ10gPT09ICdEaXJlY3RlZCcpIHtcbiAgICAgIGVkZ2VbJ2Fycm93cyddID0gJ3RvJztcbiAgICB9XG4gICAgLy8gICAgZWRnZVsndmFsdWUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdFZGdlLmF0dHJpYnV0ZXMuV2VpZ2h0IDogdW5kZWZpbmVkO1xuICAgIC8vICAgIGVkZ2VbJ3dpZHRoJ10gPSBlZGdlWyd2YWx1ZSddICE9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBlZGdlZ0VkZ2Uuc2l6ZTtcbiAgICBpZiAoZ0VkZ2UuY29sb3IgJiYgb3B0aW9ucy5pbmhlcml0Q29sb3IgPT09IGZhbHNlKSB7XG4gICAgICBlZGdlWydjb2xvciddID0gZ0VkZ2UuY29sb3I7XG4gICAgfVxuICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IGdOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBub2RlID0ge307XG4gICAgdmFyIGdOb2RlID0gZ05vZGVzW2pdO1xuICAgIG5vZGVbJ2lkJ10gPSBnTm9kZS5pZDtcbiAgICBub2RlWydhdHRyaWJ1dGVzJ10gPSBnTm9kZS5hdHRyaWJ1dGVzO1xuICAgIG5vZGVbJ3gnXSA9IGdOb2RlLng7XG4gICAgbm9kZVsneSddID0gZ05vZGUueTtcbiAgICBub2RlWydsYWJlbCddID0gZ05vZGUubGFiZWw7XG4gICAgbm9kZVsndGl0bGUnXSA9IGdOb2RlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdOb2RlLmF0dHJpYnV0ZXMudGl0bGUgOiBnTm9kZS50aXRsZTtcbiAgICBpZiAob3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID09PSB0cnVlKSB7XG4gICAgICBub2RlWydjb2xvciddID0gZ05vZGUuY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVbJ2NvbG9yJ10gPSBnTm9kZS5jb2xvciAhPT0gdW5kZWZpbmVkID8ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgYm9yZGVyOiBnTm9kZS5jb2xvcixcbiAgICAgICAgaGlnaGxpZ2h0OiB7IGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLCBib3JkZXI6IGdOb2RlLmNvbG9yIH0sXG4gICAgICAgIGhvdmVyOiB7IGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLCBib3JkZXI6IGdOb2RlLmNvbG9yIH1cbiAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG5vZGVbJ3NpemUnXSA9IGdOb2RlLnNpemU7XG4gICAgbm9kZVsnZml4ZWQnXSA9IG9wdGlvbnMubm9kZXMuZml4ZWQgJiYgZ05vZGUueCAhPT0gdW5kZWZpbmVkICYmIGdOb2RlLnkgIT09IHVuZGVmaW5lZDtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMgfTtcbn1cblxuZXhwb3J0cy5wYXJzZUdlcGhpID0gcGFyc2VHZXBoaTtcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfQ2FjaGVkSW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyk7XG5cbnZhciBfQ2FjaGVkSW1hZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FjaGVkSW1hZ2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhpcyBjYWxsYmFjayBpcyBhIGNhbGxiYWNrIHRoYXQgYWNjZXB0cyBhbiBJbWFnZS5cbiAqIEBjYWxsYmFjayBJbWFnZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyBsb2FkcyBpbWFnZXMgYW5kIGtlZXBzIHRoZW0gc3RvcmVkLlxuICpcbiAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xudmFyIEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlcyhjYWxsYmFjaykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEltYWdlcyk7XG5cbiAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgIHRoaXMuaW1hZ2VCcm9rZW4gPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICAgICAgICAgICAgICBUaGUgb3JpZ2luYWwgVXJsIHRoYXQgZmFpbGVkIHRvIGxvYWQsIGlmIHRoZSBicm9rZW4gaW1hZ2UgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjYWNoZSB1c2luZyB0aGlzIFVybCBhcyB0aGUga2V5IHNvIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBmb3IgdGhpcyBVcmwgd2lsbCByZXR1cm4gdGhlIGJyb2tlbiBpbWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnJva2VuVXJsICAgICAgICAgICAgICAgIFVybCB0aGUgYnJva2VuIGltYWdlIHRvIHRyeSBhbmQgbG9hZFxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVRvTG9hZEJyb2tlblVybE9uICAgVGhlIGltYWdlIG9iamVjdFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEltYWdlcywgW3tcbiAgICBrZXk6ICdfdHJ5bG9hZEJyb2tlblVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWFnZVRvTG9hZEJyb2tlblVybE9uKSB7XG4gICAgICAvL0lmIHRoZXNlIHBhcmFtZXRlcnMgYXJlbid0IHNwZWNpZmllZCB0aGVuIGV4aXQgdGhlIGZ1bmN0aW9uIGJlY2F1c2Ugbm90aGluZyBjb25zdHJ1Y3RpdmUgY2FuIGJlIGRvbmVcbiAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCBpbWFnZVRvTG9hZEJyb2tlblVybE9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIGlmIChicm9rZW5VcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIGJyb2tlbiB1cmwgaW1hZ2UgZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vQ2xlYXIgdGhlIG9sZCBzdWJzY3JpcHRpb24gdG8gdGhlIGVycm9yIGV2ZW50IGFuZCBwdXQgYSBuZXcgaW4gcGxhY2UgdGhhdCBvbmx5IGhhbmRsZSBlcnJvcnMgaW4gbG9hZGluZyB0aGUgYnJva2VuSW1hZ2VVcmxcbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGxvYWQgYnJva2VuSW1hZ2U6JywgYnJva2VuVXJsKTtcbiAgICAgICAgLy8gY2FjaGUgaXRlbSB3aWxsIGNvbnRhaW4gZW1wdHkgaW1hZ2UsIHRoaXMgc2hvdWxkIGJlIE9LIGZvciBkZWZhdWx0XG4gICAgICB9O1xuXG4gICAgICAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgYnJva2VuVXJsLCB0aGlzIGlzIGFjdHVhbGx5IHdoYXQga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBicm9rZW4gaW1hZ2VcbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24uaW1hZ2Uuc3JjID0gYnJva2VuVXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9SZWRyYXdXaXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlZHJhd1dpdGhJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXdXaXRoSW1hZ2UoaW1hZ2VUb1JlZHJhd1dpdGgpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soaW1hZ2VUb1JlZHJhd1dpdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgVXJsIG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgVXJsIG9mIGFuIGltYWdlIHRvIHVzZSBpZiB0aGUgdXJsIGltYWdlIGlzIG5vdCBmb3VuZFxuICAgICAqIEByZXR1cm4ge0ltYWdlfSBpbWcgICAgICAgICAgVGhlIGltYWdlIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGJyb2tlblVybCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy9UcnkgYW5kIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgY2FjaGUsIGlmIHN1Y2Nlc3NmdWwgdGhlbiByZXR1cm4gdGhlIGNhY2hlZCBpbWFnZVxuICAgICAgdmFyIGNhY2hlZEltYWdlID0gdGhpcy5pbWFnZXNbdXJsXTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSkgcmV0dXJuIGNhY2hlZEltYWdlO1xuXG4gICAgICAvL0NyZWF0ZSBhIG5ldyBpbWFnZVxuICAgICAgdmFyIGltZyA9IG5ldyBfQ2FjaGVkSW1hZ2UyWydkZWZhdWx0J10oKTtcblxuICAgICAgLy8gTmVlZCB0byBhZGQgdG8gY2FjaGUgaGVyZSwgb3RoZXJ3aXNlIGZpbmFsIHJldHVybiB3aWxsIHNwYXduIGRpZmZlcmVudCBjb3BpZXMgb2YgdGhlIHNhbWUgaW1hZ2UsXG4gICAgICAvLyBBbHNvLCB0aGVyZSB3aWxsIGJlIG11bHRpcGxlIGxvYWRzIG9mIHRoZSBzYW1lIGltYWdlLlxuICAgICAgdGhpcy5pbWFnZXNbdXJsXSA9IGltZztcblxuICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBsb2FkcyBzdWNjZXNzZnVsbHlcbiAgICAgIGltZy5pbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByb3Blcmx5IGluaXQgdGhlIGNhY2hlZCBpdGVtIGFuZCB0aGVuIHJlcXVlc3QgYSByZWRyYXdcbiAgICAgICAgX3RoaXMuX2ZpeEltYWdlQ29vcmRpbmF0ZXMoaW1nLmltYWdlKTtcbiAgICAgICAgaW1nLmluaXQoKTtcbiAgICAgICAgX3RoaXMuX3JlZHJhd1dpdGhJbWFnZShpbWcpO1xuICAgICAgfTtcblxuICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBmYWlscyB0byBsb2FkXG4gICAgICBpbWcuaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGxvYWQgaW1hZ2U6JywgdXJsKTtcbiAgICAgICAgLy9UcnkgYW5kIGxvYWQgdGhlIGltYWdlIHNwZWNpZmllZCBieSB0aGUgYnJva2VuVXJsIHVzaW5nXG4gICAgICAgIF90aGlzLl90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWcpO1xuICAgICAgfTtcblxuICAgICAgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIHVybCwgdGhpcyBpcyB3aGF0IGFjdHVhbGx5IGtpY2tzIG9mZiB0aGUgbG9hZGluZyBvZiB0aGUgaW1hZ2VcbiAgICAgIGltZy5pbWFnZS5zcmMgPSB1cmw7XG5cbiAgICAgIC8vUmV0dXJuIHRoZSBuZXcgaW1hZ2VcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSUUxMSBmaXggLS0gdGhhbmtzIGRwb25jaCFcbiAgICAgKlxuICAgICAqIExvY2FsIGhlbHBlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7dmlzLkltYWdlfSBpbWFnZVRvQ2FjaGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZml4SW1hZ2VDb29yZGluYXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXhJbWFnZUNvb3JkaW5hdGVzKGltYWdlVG9DYWNoZSkge1xuICAgICAgaWYgKGltYWdlVG9DYWNoZS53aWR0aCA9PT0gMCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICAgIGltYWdlVG9DYWNoZS53aWR0aCA9IGltYWdlVG9DYWNoZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaW1hZ2VUb0NhY2hlLmhlaWdodCA9IGltYWdlVG9DYWNoZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1hZ2VUb0NhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEltYWdlcztcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW1hZ2VzO1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9zbGljZWRUb0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlZFRvQXJyYXkyKTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29tcG9uZW50VXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpWydkZWZhdWx0J107XG52YXIgTGFiZWxTcGxpdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTM5KVsnZGVmYXVsdCddO1xuXG4vKipcbiAqIExpc3Qgb2Ygc3BlY2lhbCBzdHlsZXMgZm9yIG11bHRpLWZvbnRzXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbXVsdGlGb250U3R5bGUgPSBbJ2JvbGQnLCAnaXRhbCcsICdib2xkaXRhbCcsICdtb25vJ107XG5cbi8qKlxuICogQSBMYWJlbCB0byBiZSB1c2VkIGZvciBOb2RlcyBvciBFZGdlcy5cbiAqL1xuXG52YXIgTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlZGdlbGFiZWw9ZmFsc2VdXG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbChib2R5LCBvcHRpb25zKSB7XG4gICAgdmFyIGVkZ2VsYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgTGFiZWwpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvbnRPcHRpb25zID0ge307IC8vIGluc3RhbmNlIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlICppbnN0YW5jZS1sb2NhbCogZm9udCBvcHRpb25zXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2l6ZSA9IHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCB5TGluZTogMCB9O1xuICAgIHRoaXMuaXNFZGdlTGFiZWwgPSBlZGdlbGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIHBhcmVudCBOb2RlLWluc3RhbmNlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTGFiZWwsIFt7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5lbGVtZW50T3B0aW9ucyA9IG9wdGlvbnM7IC8vIFJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcGFyZW50IE5vZGUtaW5zdGFuY2VcblxuICAgICAgdGhpcy5pbml0Rm9udE9wdGlvbnMob3B0aW9ucy5mb250KTtcblxuICAgICAgaWYgKENvbXBvbmVudFV0aWwuaXNWYWxpZExhYmVsKG9wdGlvbnMubGFiZWwpKSB7XG4gICAgICAgIHRoaXMubGFiZWxEaXJ0eSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCYWQgbGFiZWwhIENoYW5nZSB0aGUgb3B0aW9uIHZhbHVlIHRvIHByZXZlbnQgYmFkIHN0dWZmIGhhcHBlbmluZ1xuICAgICAgICBvcHRpb25zLmxhYmVsID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gZm9udCBvcHRpb25zIGNhbiBiZSBkZWxldGVkIGF0IHZhcmlvdXMgbGV2ZWxzXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKG9wdGlvbnMuZm9udCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLmZvbnQuc2l6ZTtcblxuICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIGZvbnQgT3B0aW9ucyBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBNZW1iZXIgZm9udE9wdGlvbnMgc2VydmVzIGFzIGFuIGFjY3VtdWxhdG9yIGZvciB0aGUgY3VycmVudCBmb250IG9wdGlvbnMuXG4gICAgICogQXMgc3VjaCwgaXQgbmVlZHMgdG8gYmUgY29tcGxldGVseSBzZXBhcmF0ZWQgZnJvbSB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0ZvbnRPcHRpb25zIHRoZSBuZXcgZm9udCBvcHRpb25zIHRvIHByb2Nlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0Rm9udE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Rm9udE9wdGlvbnMobmV3Rm9udE9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIG11bHRpLWZvbnQgb3B0aW9uIG9iamVjdHMuXG4gICAgICAvLyBUaGVzZSB3aWxsIGJlIGZpbGxlZCBpbiBwcm9wYWdhdGVGb250cygpLCBpZiByZXF1aXJlZFxuICAgICAgdXRpbC5mb3JFYWNoKG11bHRpRm9udFN0eWxlLCBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgX3RoaXMuZm9udE9wdGlvbnNbc3R5bGVdID0ge307XG4gICAgICB9KTtcblxuICAgICAgLy8gSGFuZGxlIHNob3J0aGFuZCBvcHRpb24sIGlmIHByZXNlbnRcbiAgICAgIGlmIChMYWJlbC5wYXJzZUZvbnRTdHJpbmcodGhpcy5mb250T3B0aW9ucywgbmV3Rm9udE9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMudmFkanVzdCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSBvdmVyIHRoZSBub24tbXVsdGlmb250IG9wdGlvbnMsIGlmIHNwZWNpZmllZFxuICAgICAgdXRpbC5mb3JFYWNoKG5ld0ZvbnRPcHRpb25zLCBmdW5jdGlvbiAocHJvcCwgbikge1xuICAgICAgICBpZiAocHJvcCAhPT0gdW5kZWZpbmVkICYmIHByb3AgIT09IG51bGwgJiYgKHR5cGVvZiBwcm9wID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKHByb3ApKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBfdGhpcy5mb250T3B0aW9uc1tuXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGluLXZhcmlhYmxlIGlzIGEgc3RyaW5nLCBwYXJzZSBpdCBhcyBhIGZvbnQgc3BlY2lmaWVyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGZvbGxvd2luZyBpcyBub3QgZG9uZSBoZXJlIGFuZCBoYXZlIHRvIGJlIGRvbmUgYWZ0ZXIgdGhlIGNhbGw6XG4gICAgICogLSBObyBudW1iZXIgY29udmVyc2lvbiAoc2l6ZSlcbiAgICAgKiAtIE5vdCBhbGwgZm9udCBvcHRpb25zIGFyZSBzZXQgKHZhZGp1c3QsIG1vZClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRPcHRpb25zICBvdXQtcGFyYW1ldGVyLCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHBhcnNlIHJlc3VsdHMgKGlmIGFueSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5PcHRpb25zICBmb250IG9wdGlvbnMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGZvbnQgcGFyc2VkIGFzIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW4nLFxuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY29uc3RyYWludHMgYmFzZWQgb24gJ25lYXJlc3QnIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwaWxlIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGFjdHVhbCBjb25zdHJhaW50IHZhbHVlcyB0byB1c2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW4ocGlsZSkge1xuICAgICAgLy8gTk9URTogY29uc3RyYWluV2lkdGggYW5kICBjb25zdHJhaW5IZWlnaHQgbmV2ZXIgc2V0IVxuICAgICAgLy8gTk9URTogZm9yIGVkZ2UgbGFiZWxzLCBvbmx5ICdtYXhXZHQnIHNldFxuICAgICAgLy8gTm9kZSBsYWJlbHMgY2FuIHNldCBhbGwgdGhlIGZpZWxkc1xuICAgICAgdmFyIGZvbnRPcHRpb25zID0ge1xuICAgICAgICBjb25zdHJhaW5XaWR0aDogZmFsc2UsXG4gICAgICAgIG1heFdkdDogLTEsXG4gICAgICAgIG1pbldkdDogLTEsXG4gICAgICAgIGNvbnN0cmFpbkhlaWdodDogZmFsc2UsXG4gICAgICAgIG1pbkhndDogLTEsXG4gICAgICAgIHZhbGlnbjogJ21pZGRsZSdcbiAgICAgIH07XG5cbiAgICAgIHZhciB3aWR0aENvbnN0cmFpbnQgPSB1dGlsLnRvcE1vc3QocGlsZSwgJ3dpZHRoQ29uc3RyYWludCcpO1xuICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1heFdkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnQpO1xuICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB3aWR0aENvbnN0cmFpbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkod2lkdGhDb25zdHJhaW50KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciB3aWR0aENvbnN0cmFpbnRNYXhpbXVtID0gdXRpbC50b3BNb3N0KHBpbGUsIFsnd2lkdGhDb25zdHJhaW50JywgJ21heGltdW0nXSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50TWF4aW11bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5tYXhXZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50TWF4aW11bSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoQ29uc3RyYWludE1pbmltdW0gPSB1dGlsLnRvcE1vc3QocGlsZSwgWyd3aWR0aENvbnN0cmFpbnQnLCAnbWluaW11bSddKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnRNaW5pbXVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGZvbnRPcHRpb25zLm1pbldkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnRNaW5pbXVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludCA9IHV0aWwudG9wTW9zdChwaWxlLCAnaGVpZ2h0Q29uc3RyYWludCcpO1xuICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb250T3B0aW9ucy5taW5IZ3QgPSBOdW1iZXIoaGVpZ2h0Q29uc3RyYWludCk7XG4gICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShoZWlnaHRDb25zdHJhaW50KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9IHV0aWwudG9wTW9zdChwaWxlLCBbJ2hlaWdodENvbnN0cmFpbnQnLCAnbWluaW11bSddKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5taW5IZ3QgPSBOdW1iZXIoaGVpZ2h0Q29uc3RyYWludE1pbmltdW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50VmFsaWduID0gdXRpbC50b3BNb3N0KHBpbGUsIFsnaGVpZ2h0Q29uc3RyYWludCcsICd2YWxpZ24nXSk7XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gJ3RvcCcgfHwgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLnZhbGlnbiA9IGhlaWdodENvbnN0cmFpbnRWYWxpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb250T3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb3B0aW9ucyBhbmQgdXBkYXRlIGludGVybmFsIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgb3B0aW9ucyB0byBzZXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgcGlsZSAgICAgYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgdG8gY29uc2lkZXIgZm9yIG9wdGlvbiAnY2hvc2VuJ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUob3B0aW9ucywgcGlsZSkge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMsIHRydWUpO1xuICAgICAgdGhpcy5wcm9wYWdhdGVGb250cyhwaWxlKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZCh0aGlzLmZvbnRPcHRpb25zLCB0aGlzLmNvbnN0cmFpbihwaWxlKSk7XG4gICAgICB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIgPSBDb21wb25lbnRVdGlsLmNob29zaWZ5KCdsYWJlbCcsIHBpbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gbWFyZ2lucyBhcmUgc2V0IGluIGFuIGVsZW1lbnQsIGFkanVzdCBzaXplcyBpcyBjYWxsZWQgdG8gcmVtb3ZlIHRoZW1cbiAgICAgKiBmcm9tIHRoZSB3aWR0aC9oZWlnaHQgY29uc3RyYWludHMuIFRoaXMgbXVzdCBiZSBkb25lIHByaW9yIHRvIGxhYmVsIHNpemluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfX0gbWFyZ2luc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGp1c3RTaXplcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdFNpemVzKG1hcmdpbnMpIHtcbiAgICAgIHZhciB3aWR0aEJpYXMgPSBtYXJnaW5zID8gbWFyZ2lucy5yaWdodCArIG1hcmdpbnMubGVmdCA6IDA7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5jb25zdHJhaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCAtPSB3aWR0aEJpYXM7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluV2R0IC09IHdpZHRoQmlhcztcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRCaWFzID0gbWFyZ2lucyA/IG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b20gOiAwO1xuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuY29uc3RyYWluSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluSGd0IC09IGhlaWdodEJpYXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWV0aG9kcyBmb3IgaGFuZGxpbmcgb3B0aW9ucyBwaWxlc1xuICAgIC8vIEV2ZW50dWFsbHksIHRoZXNlIHdpbGwgYmUgbW92ZWQgdG8gYSBzZXBhcmF0ZSBjbGFzc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBmb250IG1lbWJlcnMgb2YgdGhlIHBhc3NlZCBsaXN0IG9mIG9wdGlvbiBvYmplY3RzIHRvIHRoZSBwaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBkc3RQaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIGFkZCB0b1xuICAgICAqIEBwYXJhbSB7UGlsZX0gc3JjUGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB0YWtlIGZvbnQgb3B0aW9ucyBmcm9tXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkRm9udE9wdGlvbnNUb1BpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250T3B0aW9uc1RvUGlsZShkc3RQaWxlLCBzcmNQaWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY1BpbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5hZGRGb250VG9QaWxlKGRzdFBpbGUsIHNyY1BpbGVbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBnaXZlbiBmb250IG9wdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyAodGhlICdwaWxlJykgdG8gY29uc2lkZXIgZm9yIGRldGVybWluaW5nXG4gICAgICogbXVsdGktZm9udCBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBpbnN0YW5jZSB0byBhZGQgdG8gcGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZEZvbnRUb1BpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250VG9QaWxlKHBpbGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIGlmIChvcHRpb25zLmZvbnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmZvbnQgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgdmFyIGl0ZW0gPSBvcHRpb25zLmZvbnQ7XG4gICAgICBwaWxlLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdCBhbGwgb3duLXByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBmb250IHBpbGUgdGhhdCBhcmVuJ3QgbXVsdGktZm9udCBvcHRpb24gb2JqZWN0c3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHJldHVybnMge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGN1cnJlbnQgb3duIGJhc2ljIGZvbnQgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEJhc2ljT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2ljT3B0aW9ucyhwaWxlKSB7XG4gICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgIC8vIFNjYW5zIHRoZSB3aG9sZSBwaWxlIHRvIGdldCBhbGwgb3B0aW9ucyBwcmVzZW50XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHBpbGUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgdmFyIGZvbnRPcHRpb25zID0gcGlsZVtuXTtcblxuICAgICAgICAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHRtcFNob3J0aGFuZCA9IHt9O1xuICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgZm9udE9wdGlvbnMpKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMgPSB0bXBTaG9ydGhhbmQ7XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmZvckVhY2goZm9udE9wdGlvbnMsIGZ1bmN0aW9uIChvcHQsIG5hbWUpIHtcbiAgICAgICAgICBpZiAob3B0ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gbXVsdGktZm9udCBvcHRpb24gbmVlZCBub3QgYmUgcHJlc2VudFxuICAgICAgICAgIGlmIChyZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHJldHVybjsgLy8gS2VlcCBmaXJzdCB2YWx1ZSB3ZSBlbmNvdW50ZXJcblxuICAgICAgICAgIGlmIChtdWx0aUZvbnRTdHlsZS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU2tpcCBtdWx0aS1mb250IHByb3BlcnRpZXMgYnV0IHdlIGRvIG5lZWQgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgcmV0W25hbWVdID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldFtuYW1lXSA9IG9wdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgZm9yIGdpdmVuIG9wdGlvbiBmb3IgdGhlIGdpdmVuIG11bHRpLWZvbnQuXG4gICAgICpcbiAgICAgKiBBbGwgYXZhaWxhYmxlIG9wdGlvbiBvYmplY3RzIGFyZSB0cmF3bGVkIGluIHRoZSBzZXQgb3JkZXIgdG8gY29uc3RydWN0IHRoZSBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIyMgVHJhdmVyc2FsIG9mIHBpbGUgZm9yIG11bHRpLWZvbnRzXG4gICAgICpcbiAgICAgKiBUaGUgZGV0ZXJtaW5hdGlvbiBvZiBtdWx0aS1mb250IG9wdGlvbiB2YWx1ZXMgaXMgYSBzcGVjaWFsIGNhc2UsIGJlY2F1c2UgYW55IHZhbHVlcyBub3RcbiAgICAgKiBwcmVzZW50IGluIHRoZSBtdWx0aS1mb250IG9wdGlvbnMgc2hvdWxkIGJ5IGRlZmluaXRpb24gYmUgdGFrZW4gZnJvbSB0aGUgbWFpbiBmb250IG9wdGlvbnMsXG4gICAgICogaS5lLiBmcm9tIHRoZSBjdXJyZW50ICdwYXJlbnQnIG9iamVjdCBvZiB0aGUgbXVsdGktZm9udCBvcHRpb24uXG4gICAgICpcbiAgICAgKiAjIyMgU2VhcmNoIG9yZGVyIGZvciBtdWx0aS1mb250c1xuICAgICAqXG4gICAgICogJ2JvbGQnIHVzZWQgYXMgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgLSBzZWFyY2ggaW4gb3B0aW9uIGdyb3VwICdib2xkJyBpbiBsb2NhbCBwcm9wZXJ0aWVzXG4gICAgICogICAtIHNlYXJjaCBpbiBtYWluIGZvbnQgb3B0aW9uIGdyb3VwIGluIGxvY2FsIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7TXVsdGlGb250U3R5bGV9IG11bHRpTmFtZSBzdWIgcGF0aCBmb3IgdGhlIG11bHRpLWZvbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uICB0aGUgb3B0aW9uIHRvIHNlYXJjaCBmb3IsIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGb250T3B0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbihwaWxlLCBtdWx0aU5hbWUsIG9wdGlvbikge1xuICAgICAgdmFyIG11bHRpRm9udCA9IHZvaWQgMDtcblxuICAgICAgLy8gU2VhcmNoIG11bHRpIGZvbnQgaW4gbG9jYWwgcHJvcGVydGllc1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBwaWxlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIHZhciBmb250T3B0aW9ucyA9IHBpbGVbbl07XG5cbiAgICAgICAgaWYgKGZvbnRPcHRpb25zLmhhc093blByb3BlcnR5KG11bHRpTmFtZSkpIHtcbiAgICAgICAgICBtdWx0aUZvbnQgPSBmb250T3B0aW9uc1ttdWx0aU5hbWVdO1xuICAgICAgICAgIGlmIChtdWx0aUZvbnQgPT09IHVuZGVmaW5lZCB8fCBtdWx0aUZvbnQgPT09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBzaG9ydGhhbmQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgLy8gVE9ETzogaW5lZmZpY2llbnQgdG8gZG8gdGhpcyBjb252ZXJzaW9uIGV2ZXJ5IHRpbWU7IGZpbmQgYSBiZXR0ZXIgd2F5LlxuICAgICAgICAgIHZhciB0bXBTaG9ydGhhbmQgPSB7fTtcbiAgICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgbXVsdGlGb250KSkge1xuICAgICAgICAgICAgbXVsdGlGb250ID0gdG1wU2hvcnRoYW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtdWx0aUZvbnQuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpRm9udFtvcHRpb25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPcHRpb24gaXMgbm90IG1lbnRpb25lZCBpbiB0aGUgbXVsdGkgZm9udCBvcHRpb25zOyB0YWtlIGl0IGZyb20gdGhlIHBhcmVudCBmb250IG9wdGlvbnMuXG4gICAgICAvLyBUaGVzZSBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgd2l0aCBnZXRCYXNpY09wdGlvbnMoKSwgc28gdXNlIHRoZSBjb252ZXJ0ZWQgdmFsdWVzLlxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICAvLyBBIHZhbHVlICoqbXVzdCoqIGJlIGZvdW5kOyB5b3Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIHZhbHVlIGZvciBtdWx0aS1mb250IGZvciBwcm9wZXJ0eTogJ1wiICsgb3B0aW9uICsgXCInXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgb3B0aW9ucyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250LlxuICAgICAqXG4gICAgICogQWxsIGF2YWlsYWJsZSBvcHRpb24gb2JqZWN0cyBhcmUgdHJhd2xlZCBpbiB0aGUgc2V0IG9yZGVyIHRvIGNvbnN0cnVjdCB0aGUgb3B0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge011bHRpRm9udFN0eWxlfSBtdWx0aU5hbWUgc3ViIHBhdGggZm9yIHRoZSBtb2QtZm9udFxuICAgICAqIEByZXR1cm5zIHtNdWx0aUZvbnRPcHRpb25zfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZvbnRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbnMocGlsZSwgbXVsdGlOYW1lKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgb3B0aW9uTmFtZXMgPSBbJ2NvbG9yJywgJ3NpemUnLCAnZmFjZScsICdtb2QnLCAndmFkanVzdCddOyAvLyBMaXN0IG9mIGFsbG93ZWQgb3B0aW9ucyBwZXIgbXVsdGktZm9udFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbk5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtb2QgPSBvcHRpb25OYW1lc1tpXTtcbiAgICAgICAgcmVzdWx0W21vZF0gPSB0aGlzLmdldEZvbnRPcHRpb24ocGlsZSwgbXVsdGlOYW1lLCBtb2QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEVuZCBtZXRob2RzIGZvciBoYW5kbGluZyBvcHRpb25zIHBpbGVzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSB0aGUgZm9udCBvcHRpb25zIGZvciB0aGUgbXVsdGktZm9udCB0byBzaW5nbGUgb2JqZWN0cywgZnJvbVxuICAgICAqIHRoZSBjaGFpbiBvZiBvcHRpb24gb2JqZWN0cyBwYXNzZWQgKHRoZSAncGlsZScpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBzZXF1ZW5jZSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIEZpcnN0IGl0ZW0gaW4gbGlzdCBhc3N1bWVkIHRvIGJlIHRoZSBuZXdseSBzZXQgb3B0aW9ucy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvcGFnYXRlRm9udHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wYWdhdGVGb250cyhwaWxlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvbnRQaWxlID0gW107IC8vIHNlcXVlbmNlIG9mIGZvbnQgb2JqZWN0cyB0byBjb25zaWRlciwgb3JkZXIgaW1wb3J0YW50XG5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzLmVsZW1lbnRPcHRpb25zIGlzIG5vdCB1c2VkIGhlcmUuXG4gICAgICB0aGlzLmFkZEZvbnRPcHRpb25zVG9QaWxlKGZvbnRQaWxlLCBwaWxlKTtcbiAgICAgIHRoaXMuZm9udE9wdGlvbnMgPSB0aGlzLmdldEJhc2ljT3B0aW9ucyhmb250UGlsZSk7XG5cbiAgICAgIC8vIFdlIHNldCBtdWx0aWZvbnQgdmFsdWVzIGV2ZW4gaWYgbXVsdGkgPT09IGZhbHNlLCBmb3IgY29uc2lzdGVuY3kgKHRoaW5ncyBicmVhayBvdGhlcndpc2UpXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIG1vZCA9IG11bHRpRm9udFN0eWxlW2ldO1xuICAgICAgICB2YXIgbW9kT3B0aW9ucyA9IF90aGlzMi5mb250T3B0aW9uc1ttb2RdO1xuICAgICAgICB2YXIgdG1wTXVsdGlGb250T3B0aW9ucyA9IF90aGlzMi5nZXRGb250T3B0aW9ucyhmb250UGlsZSwgbW9kKTtcblxuICAgICAgICAvLyBDb3B5IG92ZXIgZm91bmQgdmFsdWVzXG4gICAgICAgIHV0aWwuZm9yRWFjaCh0bXBNdWx0aUZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uLCBuKSB7XG4gICAgICAgICAgbW9kT3B0aW9uc1tuXSA9IG9wdGlvbjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kT3B0aW9ucy5zaXplID0gTnVtYmVyKG1vZE9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIG1vZE9wdGlvbnMudmFkanVzdCA9IE51bWJlcihtb2RPcHRpb25zLnZhZGp1c3QpO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aUZvbnRTdHlsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uLiBUaGlzIGlzIGNhbGxlZCBmcm9tIGFueXRoaW5nIHRoYXQgd2FudHMgdG8gZHJhdyBhIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAnbWlkZGxlJztcblxuICAgICAgLy8gaWYgbm8gbGFiZWwsIHJldHVyblxuICAgICAgaWYgKHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHRvIHJlbmRlciB0aGUgbGFiZWxcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsICYmIHZpZXdGb250U2l6ZSA8IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gMSkgcmV0dXJuO1xuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGVyZSB3aWxsIG5vdCBiZSBIVUdFIGxldHRlcnMgb24gc2NyZWVuXG4gICAgICAvLyBieSBzZXR0aW5nIGFuIHVwcGVyIGxpbWl0IG9uIHRoZSB2aXNpYmxlIHRleHQgc2l6ZSAocmVnYXJkbGVzcyBvZiB6b29tTGV2ZWwpXG4gICAgICBpZiAodmlld0ZvbnRTaXplID49IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKSB7XG4gICAgICAgIHZpZXdGb250U2l6ZSA9IE51bWJlcih0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBzaXplIGNhY2hlIGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgeCwgeSwgYmFzZWxpbmUpO1xuICAgICAgdGhpcy5fZHJhd0JhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMuX2RyYXdUZXh0KGN0eCwgeCwgdGhpcy5zaXplLnlMaW5lLCBiYXNlbGluZSwgdmlld0ZvbnRTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhd0JhY2tncm91bmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JhY2tncm91bmQoY3R4KSB7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSAnbm9uZScpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZDtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHNpemUubGVmdCwgc2l6ZS50b3AsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld0ZvbnRTaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2RyYXdUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdUZXh0KGN0eCwgeCwgeSkge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnbWlkZGxlJztcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSBhcmd1bWVudHNbNF07XG5cbiAgICAgIDtcbiAgICAgIHZhciBfc2V0QWxpZ25tZW50MiA9IHRoaXMuX3NldEFsaWdubWVudChjdHgsIHgsIHksIGJhc2VsaW5lKTtcblxuICAgICAgdmFyIF9zZXRBbGlnbm1lbnQzID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfc2V0QWxpZ25tZW50MiwgMik7XG5cbiAgICAgIHggPSBfc2V0QWxpZ25tZW50M1swXTtcbiAgICAgIHkgPSBfc2V0QWxpZ25tZW50M1sxXTtcblxuXG4gICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgeCA9IHggLSB0aGlzLnNpemUud2lkdGggLyAyOyAvLyBTaGlmdCBsYWJlbCAxLzItZGlzdGFuY2UgdG8gdGhlIGxlZnRcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiAmJiB0aGlzLnNpemUuaGVpZ2h0ID4gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB5IC09ICh0aGlzLnNpemUuaGVpZ2h0IC0gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMudmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHkgKz0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IHRoZSB0ZXh0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSAmJiBsaW5lLmJsb2Nrcykge1xuICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwgfHwgdGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHdpZHRoICs9ICh0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoKSAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB3aWR0aCArPSB0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tqXTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYmxvY2suZm9udDtcblxuICAgICAgICAgICAgdmFyIF9nZXRDb2xvcjIgPSB0aGlzLl9nZXRDb2xvcihibG9jay5jb2xvciwgdmlld0ZvbnRTaXplLCBibG9jay5zdHJva2VDb2xvciksXG4gICAgICAgICAgICAgICAgX2dldENvbG9yMyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENvbG9yMiwgMiksXG4gICAgICAgICAgICAgICAgZm9udENvbG9yID0gX2dldENvbG9yM1swXSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvciA9IF9nZXRDb2xvcjNbMV07XG5cbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJsb2NrLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7XG5cbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB3aWR0aCArPSBibG9jay53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgeSArPSBsaW5lLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZWxpbmVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldEFsaWdubWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBbGlnbm1lbnQoY3R4LCB4LCB5LCBiYXNlbGluZSkge1xuICAgICAgLy8gY2hlY2sgZm9yIGxhYmVsIGFsaWdubWVudCAoZm9yIGVkZ2VzKVxuICAgICAgLy8gVE9ETzogbWFrZSBhbGlnbm1lbnQgZm9yIG5vZGVzXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCAmJiB0aGlzLmZvbnRPcHRpb25zLmFsaWduICE9PSAnaG9yaXpvbnRhbCcgJiYgdGhpcy5wb2ludFRvU2VsZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgeCA9IDA7XG4gICAgICAgIHkgPSAwO1xuXG4gICAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICB5IC09IDIgKiBsaW5lTWFyZ2luOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGFscGhhYmV0aWMuIEFscGhhYmV0aWMgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2hhbmdpbmcnO1xuICAgICAgICAgIHkgKz0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmFkZSBpbiB3aGVuIHJlbGF0aXZlIHNjYWxlIGlzIGJldHdlZW4gdGhyZXNob2xkIGFuZCB0aHJlc2hvbGQgLSAxLlxuICAgICAqIElmIHRoZSByZWxhdGl2ZSBzY2FsZSB3b3VsZCBiZSBzbWFsbGVyIHRoYW4gdGhyZXNob2xkIC0xIHRoZSBkcmF3IGZ1bmN0aW9uIHdvdWxkIGhhdmUgcmV0dXJuZWQgYmVmb3JlIGNvbWluZyBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yICBUaGUgZm9udCBjb2xvciB0byB1c2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld0ZvbnRTaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWxTdHJva2VDb2xvclxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm9udCBjb2xvciBhbmQgc3Ryb2tlIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbG9yKGNvbG9yLCB2aWV3Rm9udFNpemUsIGluaXRpYWxTdHJva2VDb2xvcikge1xuICAgICAgdmFyIGZvbnRDb2xvciA9IGNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IGluaXRpYWxTdHJva2VDb2xvciB8fCAnI2ZmZmZmZic7XG4gICAgICBpZiAodmlld0ZvbnRTaXplIDw9IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgMSAtICh0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIHZpZXdGb250U2l6ZSkpKTtcbiAgICAgICAgZm9udENvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkoZm9udENvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgc3Ryb2tlQ29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eShzdHJva2VDb2xvciwgb3BhY2l0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2ZvbnRDb2xvciwgc3Ryb2tlQ29sb3JdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFRleHRTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdGhpcy5fcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodCxcbiAgICAgICAgbGluZUNvdW50OiB0aGlzLmxpbmVDb3VudFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgZGltZW5zaW9ucyBvZiB0aGUgbGFiZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3JlY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaXplKCkge1xuICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuICAgICAgdmFyIHggPSB0aGlzLnNpemUubGVmdDsgLy8gZGVmYXVsdCB2YWx1ZXMgd2hpY2ggbWlnaHQgYmUgb3ZlcnJpZGRlbiBiZWxvd1xuICAgICAgdmFyIHkgPSB0aGlzLnNpemUudG9wIC0gMC41ICogbGluZU1hcmdpbjsgLy8gaWRlbVxuXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCkge1xuICAgICAgICB2YXIgeDIgPSAtdGhpcy5zaXplLndpZHRoICogMC41O1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5mb250T3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gLXRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeCA9IHgyO1xuICAgICAgICAgICAgeSA9IC0odGhpcy5zaXplLmhlaWdodCArIGxpbmVNYXJnaW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSBsaW5lTWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICB3aWR0aDogdGhpcy5zaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0geydtaWRkbGUnfCdoYW5naW5nJ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVMYWJlbFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6ICdtaWRkbGUnO1xuXG4gICAgICB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5zaXplLmxlZnQgPSB4IC0gdGhpcy5zaXplLndpZHRoICogMC41O1xuICAgICAgdGhpcy5zaXplLnRvcCA9IHkgLSB0aGlzLnNpemUuaGVpZ2h0ICogMC41O1xuICAgICAgdGhpcy5zaXplLnlMaW5lID0geSArICgxIC0gdGhpcy5saW5lQ291bnQpICogMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgaWYgKGJhc2VsaW5lID09PSAnaGFuZ2luZycpIHtcbiAgICAgICAgdGhpcy5zaXplLnRvcCArPSAwLjUgKiB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuc2l6ZS50b3AgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBoYW5naW5nLiBIYW5naW5nIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICB0aGlzLnNpemUueUxpbmUgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kXG4gICAgICogQHJldHVybnMge3tjb2xvciwgc2l6ZSwgZmFjZSwgbW9kLCB2YWRqdXN0LCBzdHJva2VXaWR0aDogKiwgc3Ryb2tlQ29sb3I6ICgqfHN0cmluZ3xhbGxPcHRpb25zLmVkZ2VzLmZvbnQuc3Ryb2tlQ29sb3J8e3N0cmluZ318YWxsT3B0aW9ucy5ub2Rlcy5mb250LnN0cm9rZUNvbG9yfEFycmF5KX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZvcm1hdHRpbmdWYWx1ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBtb2QpIHtcbiAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGZvbnRPcHRpb25zLCBtb2QsIG9wdGlvbikge1xuICAgICAgICBpZiAobW9kID09PSAnbm9ybWFsJykge1xuICAgICAgICAgIGlmIChvcHRpb24gPT09ICdtb2QnKSByZXR1cm4gJyc7XG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9udE9wdGlvbnNbbW9kXVtvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBHcnVtYmwgbGVhdmluZyBvdXQgdGVzdCBvbiB1bmRlZmluZWQgZXF1YWxzIGZhbHNlIGZvciBcIlwiXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW21vZF1bb3B0aW9uXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUYWtlIGZyb20gcGFyZW50IGZvbnQgb3B0aW9uXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIGNvbG9yOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsICdjb2xvcicpLFxuICAgICAgICBzaXplOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsICdzaXplJyksXG4gICAgICAgIGZhY2U6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgJ2ZhY2UnKSxcbiAgICAgICAgbW9kOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsICdtb2QnKSxcbiAgICAgICAgdmFkanVzdDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCAndmFkanVzdCcpLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5mb250T3B0aW9ucy5zdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlQ29sb3JcbiAgICAgIH07XG4gICAgICBpZiAoc2VsZWN0ZWQgfHwgaG92ZXIpIHtcbiAgICAgICAgaWYgKG1vZCA9PT0gJ25vcm1hbCcgJiYgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSB0cnVlICYmIHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWxIaWdobGlnaHRCb2xkKSB7XG4gICAgICAgICAgdmFsdWVzLm1vZCA9ICdib2xkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyKHZhbHVlcywgdGhpcy5lbGVtZW50T3B0aW9ucy5pZCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZvbnRTdHJpbmcgPSAnJztcbiAgICAgIGlmICh2YWx1ZXMubW9kICE9PSB1bmRlZmluZWQgJiYgdmFsdWVzLm1vZCAhPT0gJycpIHtcbiAgICAgICAgLy8gc2FmZWd1YXJkIGZvciB1bmRlZmluZWQgLSB0aGlzIGhhcHBlbmVkXG4gICAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLm1vZCArICcgJztcbiAgICAgIH1cbiAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLnNpemUgKyAncHggJyArIHZhbHVlcy5mYWNlO1xuXG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgdmFsdWVzLmZvbnQgPSBjdHguZm9udDtcbiAgICAgIHZhbHVlcy5oZWlnaHQgPSB2YWx1ZXMuc2l6ZTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaWZmZXJlbnRTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpZmZlcmVudFN0YXRlKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkICE9PSB0aGlzLnNlbGVjdGVkU3RhdGUgfHwgaG92ZXIgIT09IHRoaXMuaG92ZXJTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV4cGxvZGVzIHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzIGFuZCBkZXRlcm1pbmVzIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBudW1iZXIgb2YgbGluZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UZXh0ICB0aGUgdGV4dCB0byBleHBsb2RlXG4gICAgICogQHJldHVybnMge3t3aWR0aCwgaGVpZ2h0LCBsaW5lc318Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcHJvY2Vzc0xhYmVsVGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzTGFiZWxUZXh0KGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBpblRleHQpIHtcbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBMYWJlbFNwbGl0dGVyKGN0eCwgdGhpcywgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHJldHVybiBzcGxpdHRlci5wcm9jZXNzKGluVGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBleHBsb2RlcyB0aGUgbGFiZWwgc3RyaW5nIGludG8gbGluZXMgYW5kIHNldHMgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIG51bWJlciBvZiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcHJvY2Vzc0xhYmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubGFiZWxEaXJ0eSA9PT0gZmFsc2UgJiYgIXRoaXMuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLl9wcm9jZXNzTGFiZWxUZXh0KGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsKTtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMubWluV2R0ID4gMCAmJiBzdGF0ZS53aWR0aCA8IHRoaXMuZm9udE9wdGlvbnMubWluV2R0KSB7XG4gICAgICAgIHN0YXRlLndpZHRoID0gdGhpcy5mb250T3B0aW9ucy5taW5XZHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLm1pbkhndCA+IDAgJiYgc3RhdGUuaGVpZ2h0IDwgdGhpcy5mb250T3B0aW9ucy5taW5IZ3QpIHtcbiAgICAgICAgc3RhdGUuaGVpZ2h0ID0gdGhpcy5mb250T3B0aW9ucy5taW5IZ3Q7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGluZXMgPSBzdGF0ZS5saW5lcztcbiAgICAgIHRoaXMubGluZUNvdW50ID0gc3RhdGUubGluZXMubGVuZ3RoO1xuICAgICAgdGhpcy5zaXplLndpZHRoID0gc3RhdGUud2lkdGg7XG4gICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgICAgdGhpcy5zZWxlY3RlZFN0YXRlID0gc2VsZWN0ZWQ7XG4gICAgICB0aGlzLmhvdmVyU3RhdGUgPSBob3ZlcjtcblxuICAgICAgdGhpcy5sYWJlbERpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBsYWJlbCBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoaXMgbGFiZWwgd2lsbCBiZSBzaG93LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmlzaWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpc2libGUoKSB7XG4gICAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSAwIHx8IHRoaXMuc2l6ZS5oZWlnaHQgPT09IDAgfHwgdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90aGluZyB0byBkaXNwbGF5XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPCB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUb28gc21hbGwgb3IgdG9vIGZhciBhd2F5IHRvIHNob3dcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwYXJzZUZvbnRTdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUZvbnRTdHJpbmcob3V0T3B0aW9ucywgaW5PcHRpb25zKSB7XG4gICAgICBpZiAoIWluT3B0aW9ucyB8fCB0eXBlb2YgaW5PcHRpb25zICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgbmV3T3B0aW9uc0FycmF5ID0gaW5PcHRpb25zLnNwbGl0KCcgJyk7XG5cbiAgICAgIG91dE9wdGlvbnMuc2l6ZSA9IG5ld09wdGlvbnNBcnJheVswXS5yZXBsYWNlKCdweCcsICcnKTtcbiAgICAgIG91dE9wdGlvbnMuZmFjZSA9IG5ld09wdGlvbnNBcnJheVsxXTtcbiAgICAgIG91dE9wdGlvbnMuY29sb3IgPSBuZXdPcHRpb25zQXJyYXlbMl07XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGFiZWw7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IExhYmVsO1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxNDEpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2xpY2VkVG9BcnJheTIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEVuZFBvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODApWydkZWZhdWx0J107XG5cbi8qKlxuICogVGhlIEJhc2UgQ2xhc3MgZm9yIGFsbCBlZGdlcy5cbiAqXG4gKi9cblxudmFyIEVkZ2VCYXNlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRWRnZUJhc2UpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5jb2xvciA9IHt9O1xuICAgIHRoaXMuc2VsZWN0aW9uV2lkdGggPSAyO1xuICAgIHRoaXMuaG92ZXJXaWR0aCA9IDEuNTtcbiAgICB0aGlzLmZyb21Qb2ludCA9IHRoaXMuZnJvbTtcbiAgICB0aGlzLnRvUG9pbnQgPSB0aGlzLnRvO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIGEgbm9kZSB0byBpdHNlbGZcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShFZGdlQmFzZSwgW3tcbiAgICBrZXk6ICdjb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYWx3YXlzIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFudXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhIGVkZ2UgYXMgYSBsaW5lXG4gICAgICogRHJhdyB0aGlzIGVkZ2UgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3TGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIsIHZpYU5vZGUpIHtcbiAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHZhbHVlcywgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIGlmICh2YWx1ZXMuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFtmcm9tUG9pbnRdXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBbdG9Qb2ludF1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhd0xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhMiA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhMyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENpcmNsZURhdGEyLCAzKSxcbiAgICAgICAgICAgIHggPSBfZ2V0Q2lyY2xlRGF0YTNbMF0sXG4gICAgICAgICAgICB5ID0gX2dldENpcmNsZURhdGEzWzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX2dldENpcmNsZURhdGEzWzJdO1xuXG4gICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFtmcm9tUG9pbnRdICBUT0RPOiBSZW1vdmUgaW4gbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBbdG9Qb2ludF0gICAgVE9ETzogUmVtb3ZlIGluIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3RGFzaGVkTGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgICB2YXIgcGF0dGVybiA9IFs1LCA1XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcy5kYXNoZXMpID09PSB0cnVlKSB7XG4gICAgICAgIHBhdHRlcm4gPSB2YWx1ZXMuZGFzaGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGZpcmVmb3ggYW5kIGNocm9tZSBzdXBwb3J0IHRoaXMgbWV0aG9kLCBlbHNlIHdlIHVzZSB0aGUgbGVnYWN5IG9uZS5cbiAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgIC8vIHNldCBkYXNoIHNldHRpbmdzIGZvciBjaHJvbWUgb3IgZmlyZWZveFxuICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgbGluZVxuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE0ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTUgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhNCwgMyksXG4gICAgICAgICAgICAgIHggPSBfZ2V0Q2lyY2xlRGF0YTVbMF0sXG4gICAgICAgICAgICAgIHkgPSBfZ2V0Q2lyY2xlRGF0YTVbMV0sXG4gICAgICAgICAgICAgIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhNVsyXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIGRhc2ggc2V0dGluZ3MuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5zdXBwb3J0aW5nIHNtb290aCBsaW5lc1xuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICBjdHguZGFzaGVkTGluZSh0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55LCBwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE2ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTcgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhNiwgMyksXG4gICAgICAgICAgICAgIF94ID0gX2dldENpcmNsZURhdGE3WzBdLFxuICAgICAgICAgICAgICBfeSA9IF9nZXRDaXJjbGVEYXRhN1sxXSxcbiAgICAgICAgICAgICAgX3JhZGl1cyA9IF9nZXRDaXJjbGVEYXRhN1syXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgX3gsIF95LCBfcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcblxuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShuZWFyTm9kZSwgY3R4LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7e2Zyb206ICh7eDogbnVtYmVyLCB5OiBudW1iZXIsIHQ6IG51bWJlcn18KiksIHRvOiAoe3g6IG51bWJlciwgeTogbnVtYmVyLCB0OiBudW1iZXJ9fCopfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZEJvcmRlclBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KSB7XG4gICAgICB2YXIgZnJvbSA9IHt9O1xuICAgICAgdmFyIHRvID0ge307XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgZnJvbSA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCk7XG4gICAgICAgIHRvID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMudG8sIGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2dldENpcmNsZURhdGEkc2xpY2UgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCkuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YSRzbGljZTIgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhJHNsaWNlLCAyKSxcbiAgICAgICAgICAgIHggPSBfZ2V0Q2lyY2xlRGF0YSRzbGljZTJbMF0sXG4gICAgICAgICAgICB5ID0gX2dldENpcmNsZURhdGEkc2xpY2UyWzFdO1xuXG4gICAgICAgIGZyb20gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgbG93OiAwLjI1LFxuICAgICAgICAgIGhpZ2g6IDAuNixcbiAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgIH0pO1xuICAgICAgICB0byA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBsb3c6IDAuNixcbiAgICAgICAgICBoaWdoOiAwLjgsXG4gICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IHRvIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSB4LCB5LCByYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Q2lyY2xlRGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDaXJjbGVEYXRhKGN0eCkge1xuICAgICAgdmFyIHggPSB2b2lkIDAsXG4gICAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy5mcm9tO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlU2l6ZTtcblxuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChub2RlLnNoYXBlLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLnNoYXBlLnJlc2l6ZShjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBjaXJjbGUgY29vcmRpbmF0ZXNcbiAgICAgIGlmIChub2RlLnNoYXBlLndpZHRoID4gbm9kZS5zaGFwZS5oZWlnaHQpIHtcbiAgICAgICAgeCA9IG5vZGUueCArIG5vZGUuc2hhcGUud2lkdGggKiAwLjU7XG4gICAgICAgIHkgPSBub2RlLnkgLSByYWRpdXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gbm9kZS54ICsgcmFkaXVzO1xuICAgICAgICB5ID0gbm9kZS55IC0gbm9kZS5zaGFwZS5oZWlnaHQgKiAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3gsIHksIHJhZGl1c107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcG9pbnQgb24gYSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50YWdlIC0gVmFsdWUgYmV0d2VlbiAwIChsaW5lIHN0YXJ0KSBhbmQgMSAobGluZSBlbmQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wb2ludE9uQ2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwZXJjZW50YWdlKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwZXJjZW50YWdlICogMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBiaW5hcnkgc2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBwb2ludCB3aGVyZSB0aGUgY2lyY2xlIGNyb3NzZXMgdGhlIGJvcmRlciBvZiB0aGUgbm9kZS5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShub2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB4ID0gb3B0aW9ucy54O1xuICAgICAgdmFyIHkgPSBvcHRpb25zLnk7XG4gICAgICB2YXIgbG93ID0gb3B0aW9ucy5sb3c7XG4gICAgICB2YXIgaGlnaCA9IG9wdGlvbnMuaGlnaDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbjtcblxuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlU2l6ZTtcbiAgICAgIHZhciBwb3MgPSB2b2lkIDAsXG4gICAgICAgICAgYW5nbGUgPSB2b2lkIDAsXG4gICAgICAgICAgZGlzdGFuY2VUb0JvcmRlciA9IHZvaWQgMCxcbiAgICAgICAgICBkaXN0YW5jZVRvUG9pbnQgPSB2b2lkIDAsXG4gICAgICAgICAgZGlmZmVyZW5jZSA9IHZvaWQgMDtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjA1O1xuICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcblxuICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuXG4gICAgICAgIHBvcyA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBtaWRkbGUpO1xuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgZGlzdGFuY2VUb0JvcmRlciA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRpb24rKztcbiAgICAgIH1cbiAgICAgIHBvcy50ID0gbWlkZGxlO1xuXG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGluZSB3aWR0aCBvZiB0aGUgZWRnZS4gRGVwZW5kcyBvbiB3aWR0aCBhbmQgd2hldGhlciBvbmUgb2YgdGhlXG4gICAgICogY29ubmVjdGVkIG5vZGVzIGlzIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMaW5lV2lkdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lV2lkdGgoc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2VsZWN0aW9uV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmhvdmVyV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5vcHRpb25zLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCAtIFVudXNlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXIgLSBVbnVzZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb2xvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbG9yKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gd2hlbiB0aGlzIGlzIGEgbG9vcCBlZGdlLCBqdXN0IHVzZSB0aGUgJ2Zyb20nIG1ldGhvZFxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09ICdib3RoJyAmJiB0aGlzLmZyb20uaWQgIT09IHRoaXMudG8uaWQpIHtcbiAgICAgICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnkpO1xuICAgICAgICAgIHZhciBmcm9tQ29sb3IgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIHRvQ29sb3IgPSB2b2lkIDA7XG4gICAgICAgICAgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG5cbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgICB0b0NvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSB0cnVlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsIGZyb21Db2xvcik7XG4gICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgxLCB0b0NvbG9yKTtcblxuICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIHRoaXMgcmV0dXJucyAtLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAgIHJldHVybiBncmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09ICd0bycpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFwiZnJvbVwiXG4gICAgICAgICAgcmV0dXJuIHV0aWwub3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdXRpbC5vdmVycmlkZU9wYWNpdHkodmFsdWVzLmNvbG9yLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIGxpbmUgZnJvbSBhIG5vZGUgdG8gaXRzZWxmLCBhIGNpcmNsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NpcmNsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaXJjbGUoY3R4LCB2YWx1ZXMsIHgsIHksIHJhZGl1cykge1xuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuXG4gICAgICAvLyBkcmF3IGEgY2lyY2xlXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEseTEpIHRvICh4Mix5MikuXG4gICAgICogKHgzLHkzKSBpcyB0aGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXREaXN0YW5jZVRvRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYSwgdmFsdWVzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSAwO1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTggPSB0aGlzLl9nZXRDaXJjbGVEYXRhKHVuZGVmaW5lZCksXG4gICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTkgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhOCwgMyksXG4gICAgICAgICAgICB4ID0gX2dldENpcmNsZURhdGE5WzBdLFxuICAgICAgICAgICAgeSA9IF9nZXRDaXJjbGVEYXRhOVsxXSxcbiAgICAgICAgICAgIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhOVsyXTtcblxuICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5MztcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBNYXRoLmFicyhNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC0gcmFkaXVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHB4ID0geDIgLSB4MTtcbiAgICAgIHZhciBweSA9IHkyIC0geTE7XG4gICAgICB2YXIgc29tZXRoaW5nID0gcHggKiBweCArIHB5ICogcHk7XG4gICAgICB2YXIgdSA9ICgoeDMgLSB4MSkgKiBweCArICh5MyAtIHkxKSAqIHB5KSAvIHNvbWV0aGluZztcblxuICAgICAgaWYgKHUgPiAxKSB7XG4gICAgICAgIHUgPSAxO1xuICAgICAgfSBlbHNlIGlmICh1IDwgMCkge1xuICAgICAgICB1ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSB4MSArIHUgKiBweDtcbiAgICAgIHZhciB5ID0geTEgKyB1ICogcHk7XG4gICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICB2YXIgZHkgPSB5IC0geTM7XG5cbiAgICAgIC8vIyBOb3RlOiBJZiB0aGUgYWN0dWFsIGRpc3RhbmNlIGRvZXMgbm90IG1hdHRlcixcbiAgICAgIC8vIyBpZiB5b3Ugb25seSB3YW50IHRvIGNvbXBhcmUgd2hhdCB0aGlzIGZ1bmN0aW9uXG4gICAgICAvLyMgcmV0dXJucyB0byBvdGhlciByZXN1bHRzIG9mIHRoaXMgZnVuY3Rpb24sIHlvdVxuICAgICAgLy8jIGNhbiBqdXN0IHJldHVybiB0aGUgc3F1YXJlZCBkaXN0YW5jZSBpbnN0ZWFkXG4gICAgICAvLyMgKGkuZS4gcmVtb3ZlIHRoZSBzcXJ0KSB0byBnYWluIGEgbGl0dGxlIHBlcmZvcm1hbmNlXG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHt7cG9pbnQ6ICosIGNvcmU6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sIGFuZ2xlOiAqLCBsZW5ndGg6IG51bWJlciwgdHlwZTogKn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEFycm93RGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFycm93RGF0YShjdHgsIHBvc2l0aW9uLCB2aWFOb2RlLCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgLy8gc2V0IGxldHNcbiAgICAgIHZhciBhbmdsZSA9IHZvaWQgMDtcbiAgICAgIHZhciBhcnJvd1BvaW50ID0gdm9pZCAwO1xuICAgICAgdmFyIG5vZGUxID0gdm9pZCAwO1xuICAgICAgdmFyIG5vZGUyID0gdm9pZCAwO1xuICAgICAgdmFyIGd1aWRlT2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgdmFyIHNjYWxlRmFjdG9yID0gdm9pZCAwO1xuICAgICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuXG4gICAgICBpZiAocG9zaXRpb24gPT09ICdmcm9tJykge1xuICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICBndWlkZU9mZnNldCA9IDAuMTtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSB2YWx1ZXMuZnJvbUFycm93U2NhbGU7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMuZnJvbUFycm93VHlwZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0bycpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgZ3VpZGVPZmZzZXQgPSAtMC4xO1xuICAgICAgICBzY2FsZUZhY3RvciA9IHZhbHVlcy50b0Fycm93U2NhbGU7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMudG9BcnJvd1R5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICBzY2FsZUZhY3RvciA9IHZhbHVlcy5taWRkbGVBcnJvd1NjYWxlO1xuICAgICAgICB0eXBlID0gdmFsdWVzLm1pZGRsZUFycm93VHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgbm90IGNvbm5lY3RlZCB0byBpdHNlbGZcbiAgICAgIGlmIChub2RlMSAhPSBub2RlMikge1xuICAgICAgICBpZiAocG9zaXRpb24gIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgLy8gZHJhdyBhcnJvdyBoZWFkXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgsIHsgdmlhOiB2aWFOb2RlIH0pO1xuICAgICAgICAgICAgdmFyIGd1aWRlUG9zID0gdGhpcy5nZXRQb2ludChNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgYXJyb3dQb2ludC50ICsgZ3VpZGVPZmZzZXQpKSwgdmlhTm9kZSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoYXJyb3dQb2ludC55IC0gZ3VpZGVQb3MueSwgYXJyb3dQb2ludC54IC0gZ3VpZGVQb3MueCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZTEueSAtIG5vZGUyLnksIG5vZGUxLnggLSBub2RlMi54KTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5nZXRQb2ludCgwLjUsIHZpYU5vZGUpOyAvLyB0aGlzIGlzIDAuNiB0byBhY2NvdW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgYXJyb3cuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyYXcgY2lyY2xlXG4gICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTEwID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX2dldENpcmNsZURhdGExMSA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENpcmNsZURhdGExMCwgMyksXG4gICAgICAgICAgICB4ID0gX2dldENpcmNsZURhdGExMVswXSxcbiAgICAgICAgICAgIHkgPSBfZ2V0Q2lyY2xlRGF0YTExWzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX2dldENpcmNsZURhdGExMVsyXTtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdmcm9tJykge1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuMjUsXG4gICAgICAgICAgICBoaWdoOiAwLjYsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5nbGUgPSBhcnJvd1BvaW50LnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvJykge1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuNixcbiAgICAgICAgICAgIGhpZ2g6IDEuMCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFuZ2xlID0gYXJyb3dQb2ludC50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSAtIDEuMSAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCAwLjE3NSk7XG4gICAgICAgICAgYW5nbGUgPSAzLjkyNjk5MDgxNjk4NzI0MTQ7IC8vID09PSAwLjE3NSAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ21pZGRsZScgJiYgc2NhbGVGYWN0b3IgPCAwKSBsaW5lV2lkdGggKj0gLTE7IC8vIHJldmVyc2VkIG1pZGRsZSBhcnJvd1xuICAgICAgdmFyIGxlbmd0aCA9IDE1ICogc2NhbGVGYWN0b3IgKyAzICogbGluZVdpZHRoOyAvLyAzKiBsaW5lV2lkdGggaXMgdGhlIHdpZHRoIG9mIHRoZSBlZGdlLlxuXG4gICAgICB2YXIgeGkgPSBhcnJvd1BvaW50LnggLSBsZW5ndGggKiAwLjkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeWkgPSBhcnJvd1BvaW50LnkgLSBsZW5ndGggKiAwLjkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgYXJyb3dDb3JlID0geyB4OiB4aSwgeTogeWkgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IGFycm93UG9pbnQsXG4gICAgICAgIGNvcmU6IGFycm93Q29yZSxcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyb3dEYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXdBcnJvd0hlYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIsIGFycm93RGF0YSkge1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIEVuZFBvaW50cy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlU2hhZG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB2YWx1ZXMuc2hhZG93Q29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdmFsdWVzLnNoYWRvd1NpemU7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdmFsdWVzLnNoYWRvd1g7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdmFsdWVzLnNoYWRvd1k7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlU2hhZG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IHRydWUpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7e3RvQXJyb3c6IGJvb2xlYW4sIHRvQXJyb3dTY2FsZTogKGFsbE9wdGlvbnMuZWRnZXMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yfHtudW1iZXJ9fGFsbE9wdGlvbnMuZWRnZXMuYXJyb3dzLm1pZGRsZS5zY2FsZUZhY3RvcnxhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yfEFycmF5fG51bWJlciksIHRvQXJyb3dUeXBlOiAqLCBtaWRkbGVBcnJvdzogYm9vbGVhbiwgbWlkZGxlQXJyb3dTY2FsZTogKG51bWJlcnxhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3J8e251bWJlcn18QXJyYXkpLCBtaWRkbGVBcnJvd1R5cGU6IChhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5taWRkbGUudHlwZXx7c3RyaW5nfXxzdHJpbmd8KiksIGZyb21BcnJvdzogYm9vbGVhbiwgZnJvbUFycm93U2NhbGU6IChhbGxPcHRpb25zLmVkZ2VzLmFycm93cy50by5zY2FsZUZhY3Rvcnx7bnVtYmVyfXxhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3J8YWxsT3B0aW9ucy5lZGdlcy5hcnJvd3MuZnJvbS5zY2FsZUZhY3RvcnxBcnJheXxudW1iZXIpLCBmcm9tQXJyb3dUeXBlOiAqLCBhcnJvd1N0cmlrZXRocm91Z2g6ICgqfGJvb2xlYW58YWxsT3B0aW9ucy5lZGdlcy5hcnJvd1N0cmlrZXRocm91Z2h8e2Jvb2xlYW59KSwgY29sb3I6IHVuZGVmaW5lZCwgaW5oZXJpdHNDb2xvcjogKHN0cmluZ3xzdHJpbmd8c3RyaW5nfGFsbE9wdGlvbnMuZWRnZXMuY29sb3IuaW5oZXJpdHx7c3RyaW5nLCBib29sZWFufXxBcnJheXwqKSwgb3BhY2l0eTogKiwgaGlkZGVuOiAqLCBsZW5ndGg6ICosIHNoYWRvdzogKiwgc2hhZG93Q29sb3I6ICosIHNoYWRvd1NpemU6ICosIHNoYWRvd1g6ICosIHNoYWRvd1k6ICosIGRhc2hlczogKCp8Ym9vbGVhbnxBcnJheXxhbGxPcHRpb25zLmVkZ2VzLmRhc2hlc3x7Ym9vbGVhbiwgYXJyYXl9KSwgd2lkdGg6ICp9fSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZHJhd0JhY2tncm91bmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5iYWNrZ3JvdW5kICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgYXR0cnMgPSBbJ3N0cm9rZVN0eWxlJywgJ2xpbmVXaWR0aCcsICdkYXNoZXMnXTtcbiAgICAgICAgdmFyIG9yaWdDdHhBdHRyID0ge307XG4gICAgICAgIC8vIHNhdmUgb3JpZ2luYWwgbGluZSBhdHRyc1xuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRybmFtZSkge1xuICAgICAgICAgIG9yaWdDdHhBdHRyW2F0dHJuYW1lXSA9IGN0eFthdHRybmFtZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMuYmFja2dyb3VuZFNpemU7XG4gICAgICAgIHRoaXMuc2V0U3Ryb2tlRGFzaGVkKGN0eCwgdmFsdWVzLmJhY2tncm91bmREYXNoZXMpO1xuXG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGxpbmUgYXR0cnNcbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cm5hbWUpIHtcbiAgICAgICAgICBjdHhbYXR0cm5hbWVdID0gb3JpZ0N0eEF0dHJbYXR0cm5hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdHJva2VEYXNoZWQoY3R4LCB2YWx1ZXMuZGFzaGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58QXJyYXl9IGRhc2hlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTdHJva2VEYXNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHJva2VEYXNoZWQoY3R4LCBkYXNoZXMpIHtcbiAgICAgIGlmIChkYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gWzUsIDVdO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhc2hlcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBkYXNoZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIHN0cm9rZSBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIHN0cm9rZSBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZUJhc2U7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEVkZ2VCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2F0aW9uIG9mIGFsbCB0aGUgZW5kcG9pbnQgZHJhd2luZyByb3V0aW5lcy5cbiAqXG4gKiBFdmVyeSBlbmRwb2ludCBoYXMgaXRzIG93biBkcmF3aW5nIHJvdXRpbmUsIHdoaWNoIGNvbnRhaW5zIGFuIGVuZHBvaW50IGRlZmluaXRpb24uXG4gKlxuICogVGhlIGVuZHBvaW50IGRlZmluaXRpb25zIG11c3QgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcmllczpcbiAqXG4gKiAtICgwLDApIGlzIHRoZSBjb25uZWN0aW9uIHBvaW50IHRvIHRoZSBub2RlIGl0IGF0dGFjaGVzIHRvXG4gKiAtIFRoZSBlbmRwb2ludHMgYXJlIG9yaWVudGF0ZWQgdG8gdGhlIHBvc2l0aXZlIHgtZGlyZWN0aW9uXG4gKiAtIFRoZSBsZW5ndGggb2YgdGhlIGVuZHBvaW50IGlzIGF0IG1vc3QgMVxuICpcbiAqIEFzIGxvbmcgYXMgdGhlIGVuZHBvaW50IGNsYXNzZXMgcmVtYWluIHNpbXBsZSBhbmQgbm90IHRvbyBudW1lcm91cywgdGhleSB3aWxsXG4gKiBiZSBjb250YWluZWQgd2l0aGluIHRoaXMgbW9kdWxlLlxuICogQWxsIGNsYXNzZXMgaGVyZSBleGNlcHQgYEVuZFBvaW50c2Agc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgcHJpdmF0ZSB0byB0aGlzIG1vZHVsZS5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIyMjIEZ1cnRoZXIgQWN0aW9uc1xuICpcbiAqIEFmdGVyIGFkZGluZyBhIG5ldyBlbmRwb2ludCBoZXJlLCB5b3UgYWxzbyBuZWVkIHRvIGRvIHRoZSBmb2xsb3dpbmcgdGhpbmdzOlxuICpcbiAqIC0gQWRkIHRoZSBuZXcgZW5kcG9pbnQgbmFtZSB0byBgbmV0d29yay9vcHRpb25zLmpzYCBpbiBhcnJheSBgZW5kUG9pbnRzYC5cbiAqIC0gQWRkIHRoZSBuZXcgZW5kcG9pbnQgbmFtZSB0byB0aGUgZG9jdW1lbnRhdGlvbi5cbiAqICAgU2NhbiBmb3IgJ2Fycm93cy50by50eXBlYCBhbmQgYWRkIGl0IHRvIHRoZSBkZXNjcmlwdGlvbi5cbiAqIC0gQWRkIHRoZSBlbmRwb2ludCB0byB0aGUgZXhhbXBsZXMuIEF0IHRoZSB2ZXJ5IGxlYXN0LCBhZGQgaXQgdG8gZXhhbXBsZVxuICogICBgZWRnZVN0eWxlcy9hcnJvd1R5cGVzYC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogQ29tbW9uIG1ldGhvZHMgZm9yIGVuZHBvaW50c1xuICpcbiAqIEBjbGFzc1xuICovXG52YXIgRW5kUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEVuZFBvaW50KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVuZFBvaW50LCBudWxsLCBbe1xuICAgIGtleTogJ3RyYW5zZm9ybScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm1hdGlvbiBvbiBwb2ludHMgZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGRvbmU6XG4gICAgICogLSByb3RhdGUgYnkgdGhlIHNwZWNpZmllZCBhbmdsZVxuICAgICAqIC0gbXVsdGlwbHkgdGhlIChub3JtYWxpemVkKSBjb29yZGluYXRlcyBieSB0aGUgcGFzc2VkIGxlbmd0aFxuICAgICAqIC0gb2Zmc2V0IGJ5IHRoZSB0YXJnZXQgY29vcmRpbmF0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBwb2ludHNcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpIHtcbiAgICAgIGlmICghKHBvaW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBwb2ludHMgPSBbcG9pbnRzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBhcnJvd0RhdGEucG9pbnQueDtcbiAgICAgIHZhciB5ID0gYXJyb3dEYXRhLnBvaW50Lnk7XG4gICAgICB2YXIgYW5nbGUgPSBhcnJvd0RhdGEuYW5nbGU7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyb3dEYXRhLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciB4dCA9IHAueCAqIE1hdGguY29zKGFuZ2xlKSAtIHAueSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIHl0ID0gcC54ICogTWF0aC5zaW4oYW5nbGUpICsgcC55ICogTWF0aC5jb3MoYW5nbGUpO1xuXG4gICAgICAgIHAueCA9IHggKyBsZW5ndGggKiB4dDtcbiAgICAgICAgcC55ID0geSArIGxlbmd0aCAqIHl0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBjbG9zZWQgcGF0aCB1c2luZyB0aGUgZ2l2ZW4gcmVhbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxQb2ludD59IHBvaW50c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZHJhd1BhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGF0aChjdHgsIHBvaW50cykge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRW5kUG9pbnQ7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYXJyb3cgZW5kcG9pbnQuXG4gKiBAZXh0ZW5kcyBFbmRQb2ludFxuICovXG5cblxudmFyIEFycm93ID0gZnVuY3Rpb24gKF9FbmRQb2ludCkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShBcnJvdywgX0VuZFBvaW50KTtcblxuICBmdW5jdGlvbiBBcnJvdygpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBBcnJvdyk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEFycm93Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShBcnJvdykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQXJyb3csIG51bGwsIFt7XG4gICAga2V5OiAnZHJhdycsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd0RhdGF9IGFycm93RGF0YVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAtMSwgeTogMC4zIH0sIHsgeDogLTAuOSwgeTogMCB9LCB7IHg6IC0xLCB5OiAtMC4zIH1dO1xuXG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXJyb3c7XG59KEVuZFBvaW50KTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjcm93IGVuZHBvaW50LlxuICogQGV4dGVuZHMgRW5kUG9pbnRcbiAqL1xuXG5cbnZhciBDcm93ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDcm93KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENyb3cpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ3JvdywgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogLTEsIHk6IDAgfSwgeyB4OiAwLCB5OiAwLjMgfSwgeyB4OiAtMC40LCB5OiAwIH0sIHsgeDogMCwgeTogLTAuMyB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENyb3c7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgY3VydmUgZW5kcG9pbnQuXG4gKiBAZXh0ZW5kcyBFbmRQb2ludFxuICovXG5cblxudmFyIEN1cnZlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDdXJ2ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBDdXJ2ZSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDdXJ2ZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnQgPSB7IHg6IC0wLjQsIHk6IDAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTtcblxuICAgICAgLy8gVXBkYXRlIGVuZHBvaW50IHN0eWxlIGZvciBkcmF3aW5nIHRyYW5zcGFyZW50IGFyYy5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMCknO1xuXG4gICAgICAvLyBEZWZpbmUgY3VydmUgZW5kcG9pbnQgYXMgc2VtaWNpcmNsZS5cbiAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICB2YXIgc3RhcnRfYW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgLSBwaSAvIDI7XG4gICAgICB2YXIgZW5kX2FuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40LCBzdGFydF9hbmdsZSwgZW5kX2FuZ2xlLCBmYWxzZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdXJ2ZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBpbnZlcnRlZCBjdXJ2ZSBlbmRwb2ludC5cbiAqIEBleHRlbmRzIEVuZFBvaW50XG4gKi9cblxuXG52YXIgSW52ZXJ0ZWRDdXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW52ZXJ0ZWRDdXJ2ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBJbnZlcnRlZEN1cnZlKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEludmVydGVkQ3VydmUsIG51bGwsIFt7XG4gICAga2V5OiAnZHJhdycsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd0RhdGF9IGFycm93RGF0YVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50ID0geyB4OiAtMC4zLCB5OiAwIH07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnQsIGFycm93RGF0YSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBlbmRwb2ludCBzdHlsZSBmb3IgZHJhd2luZyB0cmFuc3BhcmVudCBhcmMuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDApJztcblxuICAgICAgLy8gRGVmaW5lIGludmVydGVkIGN1cnZlIGVuZHBvaW50IGFzIHNlbWljaXJjbGUuXG4gICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgICAgdmFyIHN0YXJ0X2FuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgdmFyIGVuZF9hbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIDMgKiBwaSAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQsIHN0YXJ0X2FuZ2xlLCBlbmRfYW5nbGUsIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludmVydGVkQ3VydmU7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdHJpbmFnbGUgZW5kcG9pbnQuXG4gKiBAZXh0ZW5kcyBFbmRQb2ludFxuICovXG5cblxudmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmlhbmdsZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBUcmlhbmdsZSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShUcmlhbmdsZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMC4wMiwgeTogMCB9LCB7IHg6IC0xLCB5OiAwLjMgfSwgeyB4OiAtMSwgeTogLTAuMyB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyaWFuZ2xlO1xufSgpO1xuXG4vKipcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGludmVydGVkIHRyaW5hZ2xlIGVuZHBvaW50LlxuICogQGV4dGVuZHMgRW5kUG9pbnRcbiAqL1xuXG5cbnZhciBJbnZlcnRlZFRyaWFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnZlcnRlZFRyaWFuZ2xlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEludmVydGVkVHJpYW5nbGUpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSW52ZXJ0ZWRUcmlhbmdsZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMC4zIH0sIHsgeDogMCwgeTogLTAuMyB9LCB7IHg6IC0xLCB5OiAwIH1dO1xuXG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjaXJjbGUgZW5kcG9pbnQuXG4gKi9cblxuXG52YXIgQ2lyY2xlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2lyY2xlKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKENpcmNsZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnQgPSB7IHg6IC0wLjQsIHk6IDAgfTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpO1xuICAgICAgY3R4LmNpcmNsZShwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmNsZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBiYXIgZW5kcG9pbnQuXG4gKi9cblxuXG52YXIgQmFyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQmFyKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJhciwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvKlxuICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAge3g6MCwgeTowLjV9LFxuICAgICAgICB7eDowLCB5Oi0wLjV9XG4gICAgICBdO1xuICAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgICBjdHgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAqL1xuXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMC41IH0sIHsgeDogMCwgeTogLTAuNSB9LCB7IHg6IC0wLjE1LCB5OiAtMC41IH0sIHsgeDogLTAuMTUsIHk6IDAuNSB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJhcjtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBib3ggZW5kcG9pbnQuXG4gKi9cblxuXG52YXIgQm94ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCb3goKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQm94KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJveCwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMC4zIH0sIHsgeDogMCwgeTogLTAuMyB9LCB7IHg6IC0wLjYsIHk6IC0wLjMgfSwgeyB4OiAtMC42LCB5OiAwLjMgfV07XG5cbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgZGlhbW9uZCBlbmRwb2ludC5cbiAqL1xuXG5cbnZhciBEaWFtb25kID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaWFtb25kKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIERpYW1vbmQpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRGlhbW9uZCwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMCB9LCB7IHg6IC0wLjUsIHk6IC0wLjMgfSwgeyB4OiAtMSwgeTogMCB9LCB7IHg6IC0wLjUsIHk6IDAuMyB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERpYW1vbmQ7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdmVlIGVuZHBvaW50LlxuICogQGV4dGVuZHMgRW5kUG9pbnRcbiAqL1xuXG5cbnZhciBWZWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBWZWUpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmVlLCBudWxsLCBbe1xuICAgIGtleTogJ2RyYXcnLFxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dEYXRhfSBhcnJvd0RhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbeyB4OiAtMSwgeTogMC4zIH0sIHsgeDogLTAuNSwgeTogMCB9LCB7IHg6IC0xLCB5OiAtMC4zIH0sIHsgeDogMCwgeTogMCB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZlZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBlbmRwb2ludHMuXG4gKi9cblxuXG52YXIgRW5kUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbmRQb2ludHMoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRW5kUG9pbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVuZFBvaW50cywgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgYW4gZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIGlmIChhcnJvd0RhdGEudHlwZSkge1xuICAgICAgICB0eXBlID0gYXJyb3dEYXRhLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgQ2lyY2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3gnOlxuICAgICAgICAgIEJveC5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY3Jvdyc6XG4gICAgICAgICAgQ3Jvdy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY3VydmUnOlxuICAgICAgICAgIEN1cnZlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgICBEaWFtb25kLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnZfY3VydmUnOlxuICAgICAgICAgIEludmVydGVkQ3VydmUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgICBUcmlhbmdsZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW52X3RyaWFuZ2xlJzpcbiAgICAgICAgICBJbnZlcnRlZFRyaWFuZ2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICAgIEJhci5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVlJzpcbiAgICAgICAgICBWZWUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Fycm93JzogLy8gZmFsbC10aHJvdWdoXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgQXJyb3cuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFbmRQb2ludHM7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEVuZFBvaW50cztcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBCYXJuZXMgSHV0IFNvbHZlclxuICovXG52YXIgQmFybmVzSHV0U29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQmFybmVzSHV0U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQmFybmVzSHV0U29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuYmFybmVzSHV0VHJlZTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5yYW5kb21TZWVkID0gNTtcblxuICAgIC8vIGRlYnVnOiBzaG93IGdyaWRcbiAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZGVidWcoY3R4LCcjZmYwMDAwJyl9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQmFybmVzSHV0U29sdmVyLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLnRoZXRhSW52ZXJzZWQgPSAxIC8gdGhpcy5vcHRpb25zLnRoZXRhO1xuXG4gICAgICAvLyBpZiAxIHRoZW4gbWluIGRpc3RhbmNlID0gMC41LCBpZiAwLjUgdGhlbiBtaW4gZGlzdGFuY2UgPSAwLjUgKyAwLjUqbm9kZS5zaGFwZS5yYWRpdXNcbiAgICAgIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA9IDEgLSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLm9wdGlvbnMuYXZvaWRPdmVybGFwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByYW5kb20gaW50ZWdlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWVkZWRSYW5kb20nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVkZWRSYW5kb20oKSB7XG4gICAgICB2YXIgeCA9IE1hdGguc2luKHRoaXMucmFuZG9tU2VlZCsrKSAqIDEwMDAwO1xuICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgZ3Jhdml0YXRpb25hbCBtb2RlbC5cbiAgICAgKiBUaGUgQmFybmVzIEh1dCBtZXRob2QgaXMgdXNlZCB0byBzcGVlZCB1cCB0aGlzIE4tYm9keSBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc29sdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICE9PSAwICYmIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB0cmVlXG4gICAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0gdGhpcy5fZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKTtcblxuICAgICAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHRoaXMuYmFybmVzSHV0VHJlZSA9IGJhcm5lc0h1dFRyZWU7XG5cbiAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCByb290IGlzIGlycmVsZXZhbnQsIGl0IG5ldmVyIHBhc3NlcyB0aGUgQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRGb3JjZUNvbnRyaWJ1dGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb25zKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLCBub2RlKTtcbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5ORSwgbm9kZSk7XG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uU1csIG5vZGUpO1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNFLCBub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgYmFybmVzSHV0VHJlZS4gSXQgY2hlY2tzIHdoZW4gaXQgY2FuIGFwcHJveGltYXRlIGRpc3RhbnQgbm9kZXMgd2l0aCB0aGVpciBjZW50ZXIgb2YgbWFzcy5cbiAgICAgKiBJZiBhIHJlZ2lvbiBjb250YWlucyBhIHNpbmdsZSBub2RlLCB3ZSBjaGVjayBpZiBpdCBpcyBub3QgaXRzZWxmLCB0aGVuIHdlIGFwcGx5IHRoZSBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Rm9yY2VDb250cmlidXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLCBub2RlKSB7XG4gICAgICAvLyB3ZSBnZXQgbm8gZm9yY2UgY29udHJpYnV0aW9uIGZyb20gYW4gZW1wdHkgcmVnaW9uXG4gICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPiAwKSB7XG4gICAgICAgIHZhciBkeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGR5ID0gdm9pZCAwLFxuICAgICAgICAgICAgZGlzdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgbm9kZS5cbiAgICAgICAgZHggPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggLSBub2RlLng7XG4gICAgICAgIGR5ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55IC0gbm9kZS55O1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgLy8gQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAvLyBvcmlnaW5hbCBjb25kaXRpb24gOiBzL2QgPCB0aGV0YSA9IHBhc3NlZCAgPT09ICBkL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgIC8vIGNhbGNTaXplID0gMS9zIC0tPiBkICogMS9zID4gMS90aGV0YSA9IHBhc3NlZFxuICAgICAgICBpZiAoZGlzdGFuY2UgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUgPiB0aGlzLnRoZXRhSW52ZXJzZWQpIHtcbiAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEaWQgbm90IHBhc3MgdGhlIGNvbmRpdGlvbiwgZ28gaW50byBjaGlsZHJlbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9ucyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXJlbnRCcmFuY2ggbXVzdCBoYXZlIG9ubHkgb25lIG5vZGUsIGlmIGl0IHdhcyBlbXB0eSB3ZSB3b3VsZG50IGJlIGhlcmVcbiAgICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YS5pZCAhPSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIG5vdCBzZWxmXG4gICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2FsY3VsYXRlRm9yY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICBkaXN0YW5jZSA9IDAuMTtcbiAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEgJiYgbm9kZS5zaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzIC8gTWF0aC5wb3coZGlzdGFuY2UsIDMpO1xuICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcblxuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIHRoZSBiYXJuZXNIdXQgdHJlZSByZWN1cnNpdmVseS4gSXQgY3JlYXRlcyB0aGUgcm9vdCwgc3BsaXRzIGl0IGFuZCBzdGFydHMgcGxhY2luZyB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBub2RlSW5kaWNlc1xuICAgICAqIEByZXR1cm5zIHt7cm9vdDoge2NlbnRlck9mTWFzczoge3g6IG51bWJlciwgeTogbnVtYmVyfSwgbWFzczogbnVtYmVyLCByYW5nZToge21pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcn0sIHNpemU6IG51bWJlciwgY2FsY1NpemU6IG51bWJlciwgY2hpbGRyZW46IHtkYXRhOiBudWxsfSwgbWF4V2lkdGg6IG51bWJlciwgbGV2ZWw6IG51bWJlciwgY2hpbGRyZW5Db3VudDogbnVtYmVyfX19IEJhcm5lc0h1dFRyZWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZm9ybUJhcm5lc0h1dFRyZWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKSB7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgIHZhciBtaW5YID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLng7XG4gICAgICB2YXIgbWluWSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuICAgICAgdmFyIG1heFggPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueDtcbiAgICAgIHZhciBtYXhZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7XG5cbiAgICAgIC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5vZGVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgdmFyIHggPSBfbm9kZS54O1xuICAgICAgICB2YXIgeSA9IF9ub2RlLnk7XG4gICAgICAgIGlmIChfbm9kZS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgaWYgKHggPCBtaW5YKSB7XG4gICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgICBtYXhYID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG1ha2UgdGhlIHJhbmdlIGEgc3F1YXJlXG4gICAgICB2YXIgc2l6ZURpZmYgPSBNYXRoLmFicyhtYXhYIC0gbWluWCkgLSBNYXRoLmFicyhtYXhZIC0gbWluWSk7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBYIGFuZCBZXG4gICAgICBpZiAoc2l6ZURpZmYgPiAwKSB7XG4gICAgICAgIG1pblkgLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgIG1heFkgKz0gMC41ICogc2l6ZURpZmY7XG4gICAgICB9IC8vIHhTaXplID4geVNpemVcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIG1pblggKz0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgICAgbWF4WCAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgfSAvLyB4U2l6ZSA8IHlTaXplXG5cbiAgICAgIHZhciBtaW5pbXVtVHJlZVNpemUgPSAxZS01O1xuICAgICAgdmFyIHJvb3RTaXplID0gTWF0aC5tYXgobWluaW11bVRyZWVTaXplLCBNYXRoLmFicyhtYXhYIC0gbWluWCkpO1xuICAgICAgdmFyIGhhbGZSb290U2l6ZSA9IDAuNSAqIHJvb3RTaXplO1xuICAgICAgdmFyIGNlbnRlclggPSAwLjUgKiAobWluWCArIG1heFgpLFxuICAgICAgICAgIGNlbnRlclkgPSAwLjUgKiAobWluWSArIG1heFkpO1xuXG4gICAgICAvLyBjb25zdHJ1Y3QgdGhlIGJhcm5lc0h1dFRyZWVcbiAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgY2VudGVyT2ZNYXNzOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICBtaW5YOiBjZW50ZXJYIC0gaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWF4WDogY2VudGVyWCArIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1pblk6IGNlbnRlclkgLSBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtYXhZOiBjZW50ZXJZICsgaGFsZlJvb3RTaXplXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaXplOiByb290U2l6ZSxcbiAgICAgICAgICBjYWxjU2l6ZTogMSAvIHJvb3RTaXplLFxuICAgICAgICAgIGNoaWxkcmVuOiB7IGRhdGE6IG51bGwgfSxcbiAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICBjaGlsZHJlbkNvdW50OiA0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLl9zcGxpdEJyYW5jaChiYXJuZXNIdXRUcmVlLnJvb3QpO1xuXG4gICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVDb3VudDsgX2krKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbX2ldXTtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBnbG9iYWxcbiAgICAgIHJldHVybiBiYXJuZXNIdXRUcmVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgdXBkYXRlcyB0aGUgbWFzcyBvZiBhIGJyYW5jaC4gdGhpcyBpcyBpbmNyZWFzZWQgYnkgYWRkaW5nIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlQnJhbmNoTWFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdmFyIGNlbnRlck9mTWFzcyA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3M7XG4gICAgICB2YXIgdG90YWxNYXNzID0gcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIHZhciB0b3RhbE1hc3NJbnYgPSAxIC8gdG90YWxNYXNzO1xuXG4gICAgICBjZW50ZXJPZk1hc3MueCA9IGNlbnRlck9mTWFzcy54ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnggKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy54ICo9IHRvdGFsTWFzc0ludjtcblxuICAgICAgY2VudGVyT2ZNYXNzLnkgPSBjZW50ZXJPZk1hc3MueSAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS55ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueSAqPSB0b3RhbE1hc3NJbnY7XG5cbiAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gdG90YWxNYXNzO1xuICAgICAgdmFyIGJpZ2dlc3RTaXplID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5oZWlnaHQsIG5vZGUucmFkaXVzKSwgbm9kZS53aWR0aCk7XG4gICAgICBwYXJlbnRCcmFuY2gubWF4V2lkdGggPSBwYXJlbnRCcmFuY2gubWF4V2lkdGggPCBiaWdnZXN0U2l6ZSA/IGJpZ2dlc3RTaXplIDogcGFyZW50QnJhbmNoLm1heFdpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpbiB3aGljaCBicmFuY2ggdGhlIG5vZGUgd2lsbCBiZSBwbGFjZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwTWFzc1VwZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wbGFjZUluVHJlZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2gsIG5vZGUsIHNraXBNYXNzVXBkYXRlKSB7XG4gICAgICBpZiAoc2tpcE1hc3NVcGRhdGUgIT0gdHJ1ZSB8fCBza2lwTWFzc1VwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbWFzcyBvZiB0aGUgYnJhbmNoLlxuICAgICAgICB0aGlzLl91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVy5yYW5nZTtcbiAgICAgIHZhciByZWdpb24gPSB2b2lkIDA7XG4gICAgICBpZiAocmFuZ2UubWF4WCA+IG5vZGUueCkge1xuICAgICAgICAvLyBpbiBOVyBvciBTV1xuICAgICAgICBpZiAocmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgIHJlZ2lvbiA9ICdOVyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaW9uID0gJ1NXJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gTkUgb3IgU0VcbiAgICAgICAgaWYgKHJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICByZWdpb24gPSAnTkUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ2lvbiA9ICdTRSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIHJlZ2lvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWN0dWFsbHkgcGxhY2UgdGhlIG5vZGUgaW4gYSByZWdpb24gKG9yIGJyYW5jaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geydOVyd8ICdORScgfCAnU1cnIHwgJ1NFJ30gcmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BsYWNlSW5SZWdpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIHJlZ2lvbikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl07XG5cbiAgICAgIHN3aXRjaCAoY2hpbGRyZW4uY2hpbGRyZW5Db3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgLy8gcGxhY2Ugbm9kZSBoZXJlXG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW4uZGF0YSA9IG5vZGU7XG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW5Db3VudCA9IDE7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhjaGlsZHJlbiwgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyBjb252ZXJ0IGludG8gY2hpbGRyZW5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIG5vZGVzIGV4YWN0bHkgb3ZlcmxhcHBpbmcgKG9uIGluaXQsIG9uIG9wZW5pbmcgb2YgY2x1c3RlciBldGMuKVxuICAgICAgICAgIC8vIHdlIG1vdmUgb25lIG5vZGUgYSBsaXR0bGUgYml0IGFuZCB3ZSBkbyBub3QgcHV0IGl0IGluIHRoZSB0cmVlLlxuICAgICAgICAgIGlmIChjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnggPT09IG5vZGUueCAmJiBjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnkgPT09IG5vZGUueSkge1xuICAgICAgICAgICAgbm9kZS54ICs9IHRoaXMuc2VlZGVkUmFuZG9tKCk7XG4gICAgICAgICAgICBub2RlLnkgKz0gdGhpcy5zZWVkZWRSYW5kb20oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3BsaXRCcmFuY2goY2hpbGRyZW4pO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoY2hpbGRyZW4sIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIC8vIHBsYWNlIGluIGJyYW5jaFxuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGNoaWxkcmVuLCBub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHNwbGl0cyBhIGJyYW5jaCBpbnRvIDQgc3ViIGJyYW5jaGVzLiBJZiB0aGUgYnJhbmNoIGNvbnRhaW5lZCBhIG5vZGUsIHdlIHBsYWNlIGl0IGluIHRoZSBzdWJicmFuY2hcbiAgICAgKiBhZnRlciB0aGUgc3BsaXQgaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NwbGl0QnJhbmNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0QnJhbmNoKHBhcmVudEJyYW5jaCkge1xuICAgICAgLy8gaWYgdGhlIGJyYW5jaCBpcyBzaGFkZWQgd2l0aCBhIG5vZGUsIHJlcGxhY2UgdGhlIG5vZGUgaW4gdGhlIG5ldyBzdWJzZXQuXG4gICAgICB2YXIgY29udGFpbmVkTm9kZSA9IG51bGw7XG4gICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDEpIHtcbiAgICAgICAgY29udGFpbmVkTm9kZSA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhO1xuICAgICAgICBwYXJlbnRCcmFuY2gubWFzcyA9IDA7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCA9IDA7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueSA9IDA7XG4gICAgICB9XG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9IDQ7XG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YSA9IG51bGw7XG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCAnTlcnKTtcbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsICdORScpO1xuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgJ1NXJyk7XG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCAnU0UnKTtcblxuICAgICAgaWYgKGNvbnRhaW5lZE5vZGUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2gsIGNvbnRhaW5lZE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3ViZGl2aWRlcyB0aGUgcmVnaW9uIGludG8gZm91ciBuZXcgc2VnbWVudHMuXG4gICAgICogU3BlY2lmaWNhbGx5LCB0aGlzIGluc2VydHMgYSBzaW5nbGUgbmV3IHNlZ21lbnQuXG4gICAgICogSXQgZmlsbHMgdGhlIGNoaWxkcmVuIHNlY3Rpb24gb2YgdGhlIHBhcmVudEJyYW5jaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7J05XJ3wgJ05FJyB8ICdTVycgfCAnU0UnfSByZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaW5zZXJ0UmVnaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIHJlZ2lvbikge1xuICAgICAgdmFyIG1pblggPSB2b2lkIDAsXG4gICAgICAgICAgbWF4WCA9IHZvaWQgMCxcbiAgICAgICAgICBtaW5ZID0gdm9pZCAwLFxuICAgICAgICAgIG1heFkgPSB2b2lkIDA7XG4gICAgICB2YXIgY2hpbGRTaXplID0gMC41ICogcGFyZW50QnJhbmNoLnNpemU7XG4gICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICBjYXNlICdOVyc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORSc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTVyc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTRSc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSA9IHtcbiAgICAgICAgY2VudGVyT2ZNYXNzOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgbWFzczogMCxcbiAgICAgICAgcmFuZ2U6IHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9LFxuICAgICAgICBzaXplOiAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZSxcbiAgICAgICAgY2FsY1NpemU6IDIgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUsXG4gICAgICAgIGNoaWxkcmVuOiB7IGRhdGE6IG51bGwgfSxcbiAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgIGxldmVsOiBwYXJlbnRCcmFuY2gubGV2ZWwgKyAxLFxuICAgICAgICBjaGlsZHJlbkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZWQsIGl0IGRyYXdzIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kZWJ1ZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWJ1ZyhjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAodGhpcy5iYXJuZXNIdXRUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaCh0aGlzLmJhcm5lc0h1dFRyZWUucm9vdCwgY3R4LCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBJdCBkcmF3cyB0aGUgYnJhbmNoZXMgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYnJhbmNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3QnJhbmNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdCcmFuY2goYnJhbmNoLCBjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2xvciA9ICcjRkYwMDAwJztcbiAgICAgIH1cblxuICAgICAgaWYgKGJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSA0KSB7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLk5XLCBjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5ORSwgY3R4KTtcbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU0UsIGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLlNXLCBjdHgpO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIC8qXG4gICAgICAgaWYgKGJyYW5jaC5tYXNzID4gMCkge1xuICAgICAgIGN0eC5jaXJjbGUoYnJhbmNoLmNlbnRlck9mTWFzcy54LCBicmFuY2guY2VudGVyT2ZNYXNzLnksIDMqYnJhbmNoLm1hc3MpO1xuICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICB9XG4gICAgICAgKi9cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJhcm5lc0h1dFNvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQmFybmVzSHV0U29sdmVyO1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQ2VudHJhbCBHcmF2aXR5IFNvbHZlclxuICovXG52YXIgQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szW1wiZGVmYXVsdFwiXSkodGhpcywgQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShDZW50cmFsR3Jhdml0eVNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBmb3JjZXMgZm9yIGVhY2ggbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZHggPSB2b2lkIDAsXG4gICAgICAgICAgZHkgPSB2b2lkIDAsXG4gICAgICAgICAgZGlzdGFuY2UgPSB2b2lkIDAsXG4gICAgICAgICAgbm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgIGR4ID0gLW5vZGUueDtcbiAgICAgICAgZHkgPSAtbm9kZS55O1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAqIEBwYXJhbSB7T2JqZWN0PE5vZGUuaWQsIHZpcy5Ob2RlPn0gZm9yY2VzXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpIHtcbiAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAgOiB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgLyBkaXN0YW5jZTtcbiAgICAgIGZvcmNlc1tub2RlLmlkXS54ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICBmb3JjZXNbbm9kZS5pZF0ueSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4OCk7XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICogb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlxuICpcbiAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICogX190eXBlX18gaXMgYSByZXF1aXJlZCBmaWVsZCBmb3IgYWxsIG9iamVjdHMgYW5kIGNvbnRhaW5zIHRoZSBhbGxvd2VkIHR5cGVzIG9mIGFsbCBvYmplY3RzXG4gKi9cbnZhciBzdHJpbmcgPSAnc3RyaW5nJztcbnZhciBib29sID0gJ2Jvb2xlYW4nO1xudmFyIG51bWJlciA9ICdudW1iZXInO1xudmFyIGFycmF5ID0gJ2FycmF5JztcbnZhciBvYmplY3QgPSAnb2JqZWN0JzsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxudmFyIGRvbSA9ICdkb20nO1xudmFyIGFueSA9ICdhbnknO1xuXG4vLyBMaXN0IG9mIGVuZHBvaW50c1xudmFyIGVuZFBvaW50cyA9IFsnYXJyb3cnLCAnY2lyY2xlJywgJ2JhciddO1xuXG52YXIgYWxsT3B0aW9ucyA9IHtcbiAgY29uZmlndXJlOiB7XG4gICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgZmlsdGVyOiB7IGJvb2xlYW46IGJvb2wsIHN0cmluZzogc3RyaW5nLCBhcnJheTogYXJyYXksICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBjb250YWluZXI6IHsgZG9tOiBkb20gfSxcbiAgICBzaG93QnV0dG9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCwgc3RyaW5nOiBzdHJpbmcsIGFycmF5OiBhcnJheSwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgdHlwZTogeyBzdHJpbmc6IGVuZFBvaW50cyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgICB9LFxuICAgICAgbWlkZGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgICBzY2FsZUZhY3RvcjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB0eXBlOiB7IHN0cmluZzogZW5kUG9pbnRzIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICAgIH0sXG4gICAgICBmcm9tOiB7XG4gICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgICBzY2FsZUZhY3RvcjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB0eXBlOiB7IHN0cmluZzogZW5kUG9pbnRzIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBzdHJpbmc6IFsnZnJvbScsICd0bycsICdtaWRkbGUnXSwgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBkYXNoZXM6IHsgYm9vbGVhbjogYm9vbCwgYXJyYXk6IGFycmF5IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBjaG9zZW46IHtcbiAgICAgIGxhYmVsOiB7IGJvb2xlYW46IGJvb2wsICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGVkZ2U6IHsgYm9vbGVhbjogYm9vbCwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBoaWdobGlnaHQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGhvdmVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBpbmhlcml0OiB7IHN0cmluZzogWydmcm9tJywgJ3RvJywgJ2JvdGgnXSwgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgb3BhY2l0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICB9LFxuICAgIGRhc2hlczogeyBib29sZWFuOiBib29sLCBhcnJheTogYXJyYXkgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgc3Ryb2tlV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgIHN0cm9rZUNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBhbGlnbjogeyBzdHJpbmc6IFsnaG9yaXpvbnRhbCcsICd0b3AnLCAnbWlkZGxlJywgJ2JvdHRvbSddIH0sXG4gICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBtdWx0aTogeyBib29sZWFuOiBib29sLCBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgbW9kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHZhZGp1c3Q6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBib2xkaXRhbDoge1xuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgbW9kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHZhZGp1c3Q6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBtb2Q6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgdmFkanVzdDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIG1vbm86IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIG1vZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICB9LFxuICAgIGhpZGRlbjogeyBib29sZWFuOiBib29sIH0sXG4gICAgaG92ZXJXaWR0aDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIGxhYmVsOiB7IHN0cmluZzogc3RyaW5nLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBsZW5ndGg6IHsgbnVtYmVyOiBudW1iZXIsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICBwaHlzaWNzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgbWF4VmlzaWJsZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBkcmF3VGhyZXNob2xkOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICAgIH0sXG4gICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBzZWxmUmVmZXJlbmNlU2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgeTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgc3RyaW5nOiBbJ2R5bmFtaWMnLCAnY29udGludW91cycsICdkaXNjcmV0ZScsICdkaWFnb25hbENyb3NzJywgJ3N0cmFpZ2h0Q3Jvc3MnLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdjdXJ2ZWRDVycsICdjdXJ2ZWRDQ1cnLCAnY3ViaWNCZXppZXInXVxuICAgICAgfSxcbiAgICAgIHJvdW5kbmVzczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgZm9yY2VEaXJlY3Rpb246IHtcbiAgICAgICAgc3RyaW5nOiBbJ2hvcml6b250YWwnLCAndmVydGljYWwnLCAnbm9uZSddLFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgdGl0bGU6IHsgc3RyaW5nOiBzdHJpbmcsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICB3aWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHdpZHRoQ29uc3RyYWludDoge1xuICAgICAgbWF4aW11bTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wsIG51bWJlcjogbnVtYmVyIH1cbiAgICB9LFxuICAgIHZhbHVlOiB7IG51bWJlcjogbnVtYmVyLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9LFxuICBncm91cHM6IHtcbiAgICB1c2VEZWZhdWx0R3JvdXBzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBfX2FueV9fOiAnZ2V0IGZyb20gbm9kZXMsIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYmVsb3cnLFxuICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGRyYWdWaWV3OiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBoaWRlRWRnZXNPbkRyYWc6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGhpZGVFZGdlc09uWm9vbTogeyBib29sZWFuOiBib29sIH0sXG4gICAgaGlkZU5vZGVzT25EcmFnOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBob3ZlcjogeyBib29sZWFuOiBib29sIH0sXG4gICAga2V5Ym9hcmQ6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgc3BlZWQ6IHtcbiAgICAgICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHpvb206IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIGJpbmRUb1dpbmRvdzogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDogeyBib29sZWFuOiBib29sIH0sXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIHNlbGVjdGFibGU6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICB0b29sdGlwRGVsYXk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tVmlldzogeyBib29sZWFuOiBib29sIH0sXG4gICAgem9vbVNwZWVkOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICByYW5kb21TZWVkOiB7IHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgaW1wcm92ZWRMYXlvdXQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBsZXZlbFNlcGFyYXRpb246IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG5vZGVTcGFjaW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICB0cmVlU3BhY2luZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYmxvY2tTaGlmdGluZzogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBlZGdlTWluaW1pemF0aW9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIGRpcmVjdGlvbjogeyBzdHJpbmc6IFsnVUQnLCAnRFUnLCAnTFInLCAnUkwnXSB9LCAvLyBVRCwgRFUsIExSLCBSTFxuICAgICAgc29ydE1ldGhvZDogeyBzdHJpbmc6IFsnaHVic2l6ZScsICdkaXJlY3RlZCddIH0sIC8vIGh1YnNpemUsIGRpcmVjdGVkXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH0sXG4gIG1hbmlwdWxhdGlvbjoge1xuICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGluaXRpYWxseUFjdGl2ZTogeyBib29sZWFuOiBib29sIH0sXG4gICAgYWRkTm9kZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgYWRkRWRnZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZWRpdE5vZGU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIGVkaXRFZGdlOiB7XG4gICAgICBlZGl0V2l0aG91dERyYWc6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wsICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfVxuICAgIH0sXG4gICAgZGVsZXRlTm9kZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZGVsZXRlRWRnZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgY29udHJvbE5vZGVTdHlsZTogJ2dldCBmcm9tIG5vZGVzLCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlbG93JyxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gIH0sXG4gIG5vZGVzOiB7XG4gICAgYm9yZGVyV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiB7IG51bWJlcjogbnVtYmVyLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgYnJva2VuSW1hZ2U6IHsgc3RyaW5nOiBzdHJpbmcsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICBjaG9zZW46IHtcbiAgICAgIGxhYmVsOiB7IGJvb2xlYW46IGJvb2wsICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIG5vZGU6IHsgYm9vbGVhbjogYm9vbCwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGJvcmRlcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgIH0sXG4gICAgZml4ZWQ6IHtcbiAgICAgIHg6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgeTogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBhbGlnbjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGJhY2tncm91bmQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIHN0cm9rZVdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICBzdHJva2VDb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgdmFkanVzdDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbXVsdGk6IHsgYm9vbGVhbjogYm9vbCwgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGJvbGQ6IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIG1vZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIG1vZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgaXRhbDoge1xuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgbW9kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHZhZGp1c3Q6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBtb25vOiB7XG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBtb2Q6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgdmFkanVzdDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgfSxcbiAgICBncm91cDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICBoZWlnaHRDb25zdHJhaW50OiB7XG4gICAgICBtaW5pbXVtOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICB2YWxpZ246IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sLCBudW1iZXI6IG51bWJlciB9XG4gICAgfSxcbiAgICBoaWRkZW46IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGljb246IHtcbiAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGNvZGU6IHsgc3RyaW5nOiBzdHJpbmcgfSwgLy8nXFx1ZjAwNycsXG4gICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vNTAsXG4gICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgaWQ6IHsgc3RyaW5nOiBzdHJpbmcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgaW1hZ2U6IHtcbiAgICAgIHNlbGVjdGVkOiB7IHN0cmluZzogc3RyaW5nLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sIC8vIC0tPiBVUkxcbiAgICAgIHVuc2VsZWN0ZWQ6IHsgc3RyaW5nOiBzdHJpbmcsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSwgLy8gLS0+IFVSTFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICB9LFxuICAgIGxhYmVsOiB7IHN0cmluZzogc3RyaW5nLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBsZXZlbDogeyBudW1iZXI6IG51bWJlciwgdW5kZWZpbmVkOiAndW5kZWZpbmVkJyB9LFxuICAgIG1hcmdpbjoge1xuICAgICAgdG9wOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICByaWdodDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYm90dG9tOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBsZWZ0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgbnVtYmVyOiBudW1iZXIgfVxuICAgIH0sXG4gICAgbWFzczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHBoeXNpY3M6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbWF4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgICAgbWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBtYXhWaXNpYmxlOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICB9LFxuICAgIHNoYXBlOiB7XG4gICAgICBzdHJpbmc6IFsnZWxsaXBzZScsICdjaXJjbGUnLCAnZGF0YWJhc2UnLCAnYm94JywgJ3RleHQnLCAnaW1hZ2UnLCAnY2lyY3VsYXJJbWFnZScsICdkaWFtb25kJywgJ2RvdCcsICdzdGFyJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlRG93bicsICdzcXVhcmUnLCAnaWNvbicsICdoZXhhZ29uJ11cbiAgICB9LFxuICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgYm9yZGVyRGFzaGVzOiB7IGJvb2xlYW46IGJvb2wsIGFycmF5OiBhcnJheSB9LFxuICAgICAgYm9yZGVyUmFkaXVzOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIHVzZUltYWdlU2l6ZTogeyBib29sZWFuOiBib29sIH0sXG4gICAgICB1c2VCb3JkZXJXaXRoSW1hZ2U6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHRpdGxlOiB7IHN0cmluZzogc3RyaW5nLCBkb206IGRvbSwgdW5kZWZpbmVkOiAndW5kZWZpbmVkJyB9LFxuICAgIHZhbHVlOiB7IG51bWJlcjogbnVtYmVyLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgd2lkdGhDb25zdHJhaW50OiB7XG4gICAgICBtaW5pbXVtOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBtYXhpbXVtOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCwgbnVtYmVyOiBudW1iZXIgfVxuICAgIH0sXG4gICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH0sXG4gIHBoeXNpY3M6IHtcbiAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgY2VudHJhbEdyYXZpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGRhbXBpbmc6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICByZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBub2RlRGlzdGFuY2U6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGRhbXBpbmc6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG5vZGVEaXN0YW5jZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbWF4VmVsb2NpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBtaW5WZWxvY2l0eTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweC9zXG4gICAgc29sdmVyOiB7XG4gICAgICBzdHJpbmc6IFsnYmFybmVzSHV0JywgJ3JlcHVsc2lvbicsICdoaWVyYXJjaGljYWxSZXB1bHNpb24nLCAnZm9yY2VBdGxhczJCYXNlZCddXG4gICAgfSxcbiAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIGl0ZXJhdGlvbnM6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHRvIHN0YWJpbGl6ZVxuICAgICAgdXBkYXRlSW50ZXJ2YWw6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG9ubHlEeW5hbWljRWRnZXM6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgZml0OiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICB9LFxuICAgIHRpbWVzdGVwOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgYWRhcHRpdmVUaW1lc3RlcDogeyBib29sZWFuOiBib29sIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICB9LFxuXG4gIC8vZ2xvYmFscyA6XG4gIGF1dG9SZXNpemU6IHsgYm9vbGVhbjogYm9vbCB9LFxuICBjbGlja1RvVXNlOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgbG9jYWxlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gIGxvY2FsZXM6IHtcbiAgICBfX2FueV9fOiB7IGFueTogYW55IH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9LFxuICBoZWlnaHQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgd2lkdGg6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxufTtcblxuYWxsT3B0aW9ucy5ncm91cHMuX19hbnlfXyA9IGFsbE9wdGlvbnMubm9kZXM7XG5hbGxPcHRpb25zLm1hbmlwdWxhdGlvbi5jb250cm9sTm9kZVN0eWxlID0gYWxsT3B0aW9ucy5ub2RlcztcblxudmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gIG5vZGVzOiB7XG4gICAgYm9yZGVyV2lkdGg6IFsxLCAwLCAxMCwgMV0sXG4gICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogWzIsIDAsIDEwLCAxXSxcbiAgICBjb2xvcjoge1xuICAgICAgYm9yZGVyOiBbJ2NvbG9yJywgJyMyQjdDRTknXSxcbiAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnIzk3QzJGQyddLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogWydjb2xvcicsICcjMkI3Q0U5J10sXG4gICAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnI0QyRTVGRiddXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBbJ2NvbG9yJywgJyMyQjdDRTknXSxcbiAgICAgICAgYmFja2dyb3VuZDogWydjb2xvcicsICcjRDJFNUZGJ11cbiAgICAgIH1cbiAgICB9LFxuICAgIGZpeGVkOiB7XG4gICAgICB4OiBmYWxzZSxcbiAgICAgIHk6IGZhbHNlXG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogWydjb2xvcicsICcjMzQzNDM0J10sXG4gICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sIC8vIHB4XG4gICAgICBmYWNlOiBbJ2FyaWFsJywgJ3ZlcmRhbmEnLCAndGFob21hJ10sXG4gICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJ25vbmUnXSxcbiAgICAgIHN0cm9rZVdpZHRoOiBbMCwgMCwgNTAsIDFdLCAvLyBweFxuICAgICAgc3Ryb2tlQ29sb3I6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gICAgfSxcbiAgICAvL2dyb3VwOiAnc3RyaW5nJyxcbiAgICBoaWRkZW46IGZhbHNlLFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAvL2ljb246IHtcbiAgICAvLyAgZmFjZTogJ3N0cmluZycsICAvLydGb250QXdlc29tZScsXG4gICAgLy8gIGNvZGU6ICdzdHJpbmcnLCAgLy8nXFx1ZjAwNycsXG4gICAgLy8gIHNpemU6IFs1MCwgMCwgMjAwLCAxXSwgIC8vNTAsXG4gICAgLy8gIGNvbG9yOiBbJ2NvbG9yJywnIzJCN0NFOSddICAgLy8nI2FhMDBmZidcbiAgICAvL30sXG4gICAgLy9pbWFnZTogJ3N0cmluZycsIC8vIC0tPiBVUkxcbiAgICBwaHlzaWNzOiB0cnVlLFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogWzEwLCAwLCAyMDAsIDFdLFxuICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbWluOiBbMTQsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IFs1LCAwLCAyMCwgMV1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICBzaXplOiBbMTAsIDAsIDIwLCAxXSxcbiAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgIH0sXG4gICAgc2hhcGU6IFsnZWxsaXBzZScsICdib3gnLCAnY2lyY2xlJywgJ2RhdGFiYXNlJywgJ2RpYW1vbmQnLCAnZG90JywgJ3NxdWFyZScsICdzdGFyJywgJ3RleHQnLCAndHJpYW5nbGUnLCAndHJpYW5nbGVEb3duJywgJ2hleGFnb24nXSxcbiAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsXG4gICAgICBib3JkZXJSYWRpdXM6IFs2LCAwLCAyMCwgMV0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZVxuICAgIH0sXG4gICAgc2l6ZTogWzI1LCAwLCAyMDAsIDFdXG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSwgdHlwZTogJ2Fycm93JyB9LFxuICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLCB0eXBlOiAnYXJyb3cnIH0sXG4gICAgICBmcm9tOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLCB0eXBlOiAnYXJyb3cnIH1cbiAgICB9LFxuICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IFsnY29sb3InLCAnIzg0ODQ4NCddLFxuICAgICAgaGlnaGxpZ2h0OiBbJ2NvbG9yJywgJyM4NDg0ODQnXSxcbiAgICAgIGhvdmVyOiBbJ2NvbG9yJywgJyM4NDg0ODQnXSxcbiAgICAgIGluaGVyaXQ6IFsnZnJvbScsICd0bycsICdib3RoJywgdHJ1ZSwgZmFsc2VdLFxuICAgICAgb3BhY2l0eTogWzEsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICBkYXNoZXM6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIGNvbG9yOiBbJ2NvbG9yJywgJyMzNDM0MzQnXSxcbiAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSwgLy8gcHhcbiAgICAgIGZhY2U6IFsnYXJpYWwnLCAndmVyZGFuYScsICd0YWhvbWEnXSxcbiAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnbm9uZSddLFxuICAgICAgc3Ryb2tlV2lkdGg6IFsyLCAwLCA1MCwgMV0sIC8vIHB4XG4gICAgICBzdHJva2VDb2xvcjogWydjb2xvcicsICcjZmZmZmZmJ10sXG4gICAgICBhbGlnbjogWydob3Jpem9udGFsJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ11cbiAgICB9LFxuICAgIGhpZGRlbjogZmFsc2UsXG4gICAgaG92ZXJXaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgcGh5c2ljczogdHJ1ZSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IFsxLCAwLCAxMDAsIDFdLFxuICAgICAgbWF4OiBbMTUsIDAsIDEwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgc2VsZlJlZmVyZW5jZVNpemU6IFsyMCwgMCwgMjAwLCAxXSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6ICdyZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICB5OiBbNSwgLTMwLCAzMCwgMV1cbiAgICB9LFxuICAgIHNtb290aDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHR5cGU6IFsnZHluYW1pYycsICdjb250aW51b3VzJywgJ2Rpc2NyZXRlJywgJ2RpYWdvbmFsQ3Jvc3MnLCAnc3RyYWlnaHRDcm9zcycsICdob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ2N1cnZlZENXJywgJ2N1cnZlZENDVycsICdjdWJpY0JlemllciddLFxuICAgICAgZm9yY2VEaXJlY3Rpb246IFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdub25lJ10sXG4gICAgICByb3VuZG5lc3M6IFswLjUsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICB3aWR0aDogWzEsIDAsIDMwLCAxXVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICAvL3JhbmRvbVNlZWQ6IFswLCAwLCA1MDAsIDFdLFxuICAgIC8vaW1wcm92ZWRMYXlvdXQ6IHRydWUsXG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGxldmVsU2VwYXJhdGlvbjogWzE1MCwgMjAsIDUwMCwgNV0sXG4gICAgICBub2RlU3BhY2luZzogWzEwMCwgMjAsIDUwMCwgNV0sXG4gICAgICB0cmVlU3BhY2luZzogWzIwMCwgMjAsIDUwMCwgNV0sXG4gICAgICBibG9ja1NoaWZ0aW5nOiB0cnVlLFxuICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiBbJ1VEJywgJ0RVJywgJ0xSJywgJ1JMJ10sIC8vIFVELCBEVSwgTFIsIFJMXG4gICAgICBzb3J0TWV0aG9kOiBbJ2h1YnNpemUnLCAnZGlyZWN0ZWQnXSAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgIH1cbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgZHJhZ1ZpZXc6IHRydWUsXG4gICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICBoaWRlRWRnZXNPblpvb206IGZhbHNlLFxuICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2UsXG4gICAgaG92ZXI6IGZhbHNlLFxuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHNwZWVkOiB7XG4gICAgICAgIHg6IFsxMCwgMCwgNDAsIDFdLFxuICAgICAgICB5OiBbMTAsIDAsIDQwLCAxXSxcbiAgICAgICAgem9vbTogWzAuMDIsIDAsIDAuMSwgMC4wMDVdXG4gICAgICB9LFxuICAgICAgYmluZFRvV2luZG93OiB0cnVlXG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICB0b29sdGlwRGVsYXk6IFszMDAsIDAsIDEwMDAsIDI1XSxcbiAgICB6b29tVmlldzogdHJ1ZSxcbiAgICB6b29tU3BlZWQ6IDFcbiAgfSxcbiAgbWFuaXB1bGF0aW9uOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZVxuICB9LFxuICBwaHlzaWNzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstMjAwMCwgLTMwMDAwLCAwLCA1MF0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMywgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDQsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstNTAsIC01MDAsIDAsIDFdLFxuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjAxLCAwLCAxLCAwLjAwNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFs5NSwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wOCwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBkYW1waW5nOiBbMC40LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICByZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFsyMDAsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDUsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgbm9kZURpc3RhbmNlOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFsxMDAsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDEsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgbm9kZURpc3RhbmNlOiBbMTIwLCAwLCA1MDAsIDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBtYXhWZWxvY2l0eTogWzUwLCAwLCAxNTAsIDFdLFxuICAgIG1pblZlbG9jaXR5OiBbMC4xLCAwLjAxLCAwLjUsIDAuMDFdLFxuICAgIHNvbHZlcjogWydiYXJuZXNIdXQnLCAnZm9yY2VBdGxhczJCYXNlZCcsICdyZXB1bHNpb24nLCAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJ10sXG4gICAgdGltZXN0ZXA6IFswLjUsIDAuMDEsIDEsIDAuMDFdXG4gICAgLy9hZGFwdGl2ZVRpbWVzdGVwOiB0cnVlXG4gIH1cbn07XG5cbmV4cG9ydHMuYWxsT3B0aW9ucyA9IGFsbE9wdGlvbnM7XG5leHBvcnRzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gTmV0d29ya1xudXRpbC5leHRlbmQoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpKTtcblxuLyoqKi8gfSksXG4vKiA4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbl9fd2VicGFja19yZXF1aXJlX18oNDcpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcblxuXG4vKioqLyB9KSxcbi8qIDg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xudmFyIHN0ZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cblxuLyoqKi8gfSksXG4vKiA4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDkxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG52YXIgZGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbl9fd2VicGFja19yZXF1aXJlX18oMTkpKEl0ZXJhdG9yUHJvdG90eXBlLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xudmFyIGdldCA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG52YXIgJE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNikuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IF9fd2VicGFja19yZXF1aXJlX18oNDEpIH0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PYmplY3Qua2V5cztcblxuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNjgpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCkuZignaXRlcmF0b3InKTtcblxuXG4vKioqLyB9KSxcbi8qIDEwNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTA3KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExNSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuU3ltYm9sO1xuXG5cbi8qKiovIH0pLFxuLyogMTA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcbnZhciBNRVRBID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpLktFWTtcbnZhciAkZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xudmFyIHdrcyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgd2tzRXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgd2tzRGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgZW51bUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG52YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xudmFyIGdPUE5FeHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMik7XG52YXIgJEdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcbnZhciAkRFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIF9fd2VicGFja19yZXF1aXJlX18oNjkpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzMikuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg1MCkuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTkpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNRVRBID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSkoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIHNldERlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbi8qKiovIH0pLFxuLyogMTE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNDkpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0OSkoJ29ic2VydmFibGUnKTtcblxuXG4vKioqLyB9KSxcbi8qIDExNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7dmFyIHJlcXVpcmU7Ly8hIG1vbWVudC5qc1xuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuXG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgICEoZnVuY3Rpb24gd2VicGFja01pc3NpbmdNb2R1bGUoKSB7IHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlIFxcXCIuL2xvY2FsZVxcXCJcIik7IGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJzsgdGhyb3cgZTsgfSgpKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XG4gICAgICAgIFVUOiAwLFxuICAgICAgICBHTVQ6IDAsXG4gICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgUFNUOiAtOCAqIDYwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWZhdWx0OiBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWU7XG4gICAgICAgIHZhciBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICAgICAgdmFyIHpvbmUgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgICAgICB6b25lID0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB2YXIgeWVhciA9ICgwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkpID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgICAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgdW5pdHMgPSAnZGF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xuICAgIHByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBwcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXG4gICAgICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xuICAgIHByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgdG9JU09TdHJpbmckMSk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4yMi4yJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcbiAgICBob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIGhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICBob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdZWVlZLVtXXVdXJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNykobW9kdWxlKSkpXG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IDExODtcblxuLyoqKi8gfSksXG4vKiAxMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MgKi9cblxudmFyIF9ybmc7XG5cbnZhciBnbG9iYWxWYXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogbnVsbDtcblxuaWYgKGdsb2JhbFZhciAmJiBnbG9iYWxWYXIuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgIHJldHVybiBfcm5kczg7XG4gIH07XG59XG5cbmlmICghX3JuZykge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gIF9ybmcgPSBmdW5jdGlvbiBfcm5nKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JuZHM7XG4gIH07XG59XG5cbi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4vLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcblxuLy92YXIgX3JuZyA9IHJlcXVpcmUoJy4vcm5nJyk7XG5cbi8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG52YXIgX2J5dGVUb0hleCA9IFtdO1xudmFyIF9oZXhUb0J5dGUgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xufVxuXG4vLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbmZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwLFxuICAgICAgaWkgPSAwO1xuXG4gIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uIChvY3QpIHtcbiAgICBpZiAoaWkgPCAxNikge1xuICAgICAgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICBidWZbaSArIGlpKytdID0gX2hleFRvQnl0ZVtvY3RdO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gWmVybyBvdXQgcmVtYWluaW5nIGJ5dGVzIGlmIHN0cmluZyB3YXMgc2hvcnRcbiAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICBidWZbaSArIGlpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbi8vICoqYHVucGFyc2UoKWAgLSBDb252ZXJ0IFVVSUQgYnl0ZSBhcnJheSAoYWxhIHBhcnNlKCkpIGludG8gYSBzdHJpbmcqKlxuZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwLFxuICAgICAgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbnZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4vLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbnZhciBfbm9kZUlkID0gW19zZWVkQnl0ZXNbMF0gfCAweDAxLCBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXTtcblxuLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbnZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwLFxuICAgIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbn1cblxuLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbn1cblxuLy8gRXhwb3J0IHB1YmxpYyBBUElcbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG51dWlkLnBhcnNlID0gcGFyc2U7XG51dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxMjApKSlcblxuLyoqKi8gfSksXG4vKiAxMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMTIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIHV0aWxzXG5leHBvcnRzLnV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuZXhwb3J0cy5ET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjIpO1xuXG4vLyBkYXRhXG5leHBvcnRzLkRhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbmV4cG9ydHMuRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbmV4cG9ydHMuUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuLy8gTmV0d29ya1xuZXhwb3J0cy5OZXR3b3JrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpO1xuZXhwb3J0cy5uZXR3b3JrID0ge1xuICBJbWFnZXM6IF9fd2VicGFja19yZXF1aXJlX18oNzYpLFxuICBkb3RwYXJzZXI6IF9fd2VicGFja19yZXF1aXJlX18oNzQpLFxuICBnZXBoaVBhcnNlcjogX193ZWJwYWNrX3JlcXVpcmVfXyg3NSksXG4gIGFsbE9wdGlvbnM6IF9fd2VicGFja19yZXF1aXJlX18oODQpXG59O1xuZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnREb3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgcmV0dXJuIGV4cG9ydHMubmV0d29yay5kb3RwYXJzZXIuRE9UVG9HcmFwaChpbnB1dCk7XG59O1xuZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnRHZXBoaSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gZXhwb3J0cy5uZXR3b3JrLmdlcGhpUGFyc2VyLnBhcnNlR2VwaGkoaW5wdXQsIG9wdGlvbnMpO1xufTtcblxuLy8gYnVuZGxlZCBleHRlcm5hbCBsaWJyYXJpZXNcbmV4cG9ydHMubW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5leHBvcnRzLkhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuZXhwb3J0cy5rZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyBET00gdXRpbGl0eSBtZXRob2RzXG5cbi8qKlxuICogdGhpcyBwcmVwYXJlcyB0aGUgSlNPTiBjb250YWluZXIgZm9yIGFsbG9jYXRpbmcgU1ZHIGVsZW1lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5wcmVwYXJlRWxlbWVudHMgPSBmdW5jdGlvbiAoSlNPTmNvbnRhaW5lcikge1xuICAvLyBjbGVhbnVwIHRoZSByZWR1bmRhbnQgc3ZnRWxlbWVudHM7XG4gIGZvciAodmFyIGVsZW1lbnRUeXBlIGluIEpTT05jb250YWluZXIpIHtcbiAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudCA9IEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQ7XG4gICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkID0gW107XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIHRoaXMgY2xlYW5zIHVwIGFsbCB0aGUgdW51c2VkIFNWRyBlbGVtZW50cy4gQnkgYXNraW5nIGZvciB0aGUgcGFyZW50Tm9kZSwgd2Ugb25seSBuZWVkIHRvIHN1cHBseSB0aGUgSlNPTiBjb250YWluZXIgZnJvbVxuICogd2hpY2ggdG8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IEpTT05jb250YWluZXJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xlYW51cEVsZW1lbnRzID0gZnVuY3Rpb24gKEpTT05jb250YWluZXIpIHtcbiAgLy8gY2xlYW51cCB0aGUgcmVkdW5kYW50IHN2Z0VsZW1lbnRzO1xuICBmb3IgKHZhciBlbGVtZW50VHlwZSBpbiBKU09OY29udGFpbmVyKSB7XG4gICAgaWYgKEpTT05jb250YWluZXIuaGFzT3duUHJvcGVydHkoZWxlbWVudFR5cGUpKSB7XG4gICAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50W2ldKTtcbiAgICAgICAgfVxuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IGFsbCBlbGVtZW50cyBhcmUgcmVtb3ZlZCBmaXJzdCB1cCBzbyB0aGV5IGNhbiBiZSByZWNyZWF0ZWQgY2xlYW5seVxuICogQHBhcmFtIHtPYmplY3R9IEpTT05jb250YWluZXJcbiAqL1xuZXhwb3J0cy5yZXNldEVsZW1lbnRzID0gZnVuY3Rpb24gKEpTT05jb250YWluZXIpIHtcbiAgZXhwb3J0cy5wcmVwYXJlRWxlbWVudHMoSlNPTmNvbnRhaW5lcik7XG4gIGV4cG9ydHMuY2xlYW51cEVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICBleHBvcnRzLnByZXBhcmVFbGVtZW50cyhKU09OY29udGFpbmVyKTtcbn07XG5cbi8qKlxuICogQWxsb2NhdGUgb3IgZ2VuZXJhdGUgYW4gU1ZHIGVsZW1lbnQgaWYgbmVlZGVkLiBTdG9yZSBhIHJlZmVyZW5jZSB0byBpdCBpbiB0aGUgSlNPTiBjb250YWluZXIgYW5kIGRyYXcgaXQgaW4gdGhlIHN2Z0NvbnRhaW5lclxuICogdGhlIEpTT04gY29udGFpbmVyIGFuZCB0aGUgU1ZHIGNvbnRhaW5lciBoYXZlIHRvIGJlIHN1cHBsaWVkIHNvIG90aGVyIHN2ZyBjb250YWluZXJzIChsaWtlIHRoZSBsZWdlbmQpIGNhbiB1c2UgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBKU09OY29udGFpbmVyXG4gKiBAcGFyYW0ge09iamVjdH0gc3ZnQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7RWxlbWVudH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZ2V0U1ZHRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKSB7XG4gIHZhciBlbGVtZW50O1xuICAvLyBhbGxvY2F0ZSBTVkcgZWxlbWVudCwgaWYgaXQgZG9lc250IHlldCBleGlzdCwgY3JlYXRlIG9uZS5cbiAgaWYgKEpTT05jb250YWluZXIuaGFzT3duUHJvcGVydHkoZWxlbWVudFR5cGUpKSB7XG4gICAgLy8gdGhpcyBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQgYmVmb3JlXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gcmVkdW5kYW50IGVsZW1lbnRcbiAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGVsZW1lbnQgPSBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnRbMF07XG4gICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGVsZW1lbnRUeXBlKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHLCBhbHNvIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHN2Z0VsZW1lbnRzIHRvIGtlZXAgdHJhY2sgb2YgaXQuXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBlbGVtZW50VHlwZSk7XG4gICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0gPSB7IHVzZWQ6IFtdLCByZWR1bmRhbnQ6IFtdIH07XG4gICAgc3ZnQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG4gIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEFsbG9jYXRlIG9yIGdlbmVyYXRlIGFuIFNWRyBlbGVtZW50IGlmIG5lZWRlZC4gU3RvcmUgYSByZWZlcmVuY2UgdG8gaXQgaW4gdGhlIEpTT04gY29udGFpbmVyIGFuZCBkcmF3IGl0IGluIHRoZSBzdmdDb250YWluZXJcbiAqIHRoZSBKU09OIGNvbnRhaW5lciBhbmQgdGhlIFNWRyBjb250YWluZXIgaGF2ZSB0byBiZSBzdXBwbGllZCBzbyBvdGhlciBzdmcgY29udGFpbmVycyAobGlrZSB0aGUgbGVnZW5kKSBjYW4gdXNlIHRoaXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHBhcmFtIHtFbGVtZW50fSBET01Db250YWluZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gaW5zZXJ0QmVmb3JlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5nZXRET01FbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRUeXBlLCBKU09OY29udGFpbmVyLCBET01Db250YWluZXIsIGluc2VydEJlZm9yZSkge1xuICB2YXIgZWxlbWVudDtcbiAgLy8gYWxsb2NhdGUgRE9NIGVsZW1lbnQsIGlmIGl0IGRvZXNudCB5ZXQgZXhpc3QsIGNyZWF0ZSBvbmUuXG4gIGlmIChKU09OY29udGFpbmVyLmhhc093blByb3BlcnR5KGVsZW1lbnRUeXBlKSkge1xuICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIGJlZm9yZVxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFuIHJlZHVuZGFudCBlbGVtZW50XG4gICAgaWYgKEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudC5sZW5ndGggPiAwKSB7XG4gICAgICBlbGVtZW50ID0gSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50WzBdO1xuICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIFNWR1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgICAgaWYgKGluc2VydEJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIERPTUNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWxlbWVudCwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHLCBhbHNvIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHN2Z0VsZW1lbnRzIHRvIGtlZXAgdHJhY2sgb2YgaXQuXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdID0geyB1c2VkOiBbXSwgcmVkdW5kYW50OiBbXSB9O1xuICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgRE9NQ29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtZW50LCBpbnNlcnRCZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01Db250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIERyYXcgYSBwb2ludCBvYmplY3QuIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBiZWNhdXNlIGl0IGNhbiBhbHNvIGJlIGNhbGxlZCBieSB0aGUgbGVnZW5kLlxuICogVGhlIHJlYXNvbiB0aGUgSlNPTmNvbnRhaW5lciBhbmQgdGhlIHRhcmdldCBTVkcgc3ZnQ29udGFpbmVyIGhhdmUgdG8gYmUgc3VwcGxpZWQgaXMgc28gdGhlIGxlZ2VuZCBjYW4gdXNlIHRoZXNlIGZ1bmN0aW9uc1xuICogYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBncm91cFRlbXBsYXRlOiBBIHRlbXBsYXRlIGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBkcmF3IHRoZSBkYXRhcG9pbnQgZS5nLiwge3N0eWxlOiAnY2lyY2xlJywgc2l6ZTogNSwgY2xhc3NOYW1lOiAnY2xhc3NOYW1lJyB9XG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IHN2Z0NvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IGxhYmVsT2JqXG4gKiBAcmV0dXJucyB7dmlzLlBvaW50SXRlbX1cbiAqL1xuZXhwb3J0cy5kcmF3UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgZ3JvdXBUZW1wbGF0ZSwgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyLCBsYWJlbE9iaikge1xuICB2YXIgcG9pbnQ7XG4gIGlmIChncm91cFRlbXBsYXRlLnN0eWxlID09ICdjaXJjbGUnKSB7XG4gICAgcG9pbnQgPSBleHBvcnRzLmdldFNWR0VsZW1lbnQoJ2NpcmNsZScsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4JywgeCk7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5JywgeSk7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCAwLjUgKiBncm91cFRlbXBsYXRlLnNpemUpO1xuICB9IGVsc2Uge1xuICAgIHBvaW50ID0gZXhwb3J0cy5nZXRTVkdFbGVtZW50KCdyZWN0JywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHggLSAwLjUgKiBncm91cFRlbXBsYXRlLnNpemUpO1xuICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeSAtIDAuNSAqIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgfVxuXG4gIGlmIChncm91cFRlbXBsYXRlLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0eWxlJywgZ3JvdXBUZW1wbGF0ZS5zdHlsZXMpO1xuICB9XG4gIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIGdyb3VwVGVtcGxhdGUuY2xhc3NOYW1lICsgJyB2aXMtcG9pbnQnKTtcbiAgLy9oYW5kbGUgbGFiZWxcblxuICBpZiAobGFiZWxPYmopIHtcbiAgICB2YXIgbGFiZWwgPSBleHBvcnRzLmdldFNWR0VsZW1lbnQoJ3RleHQnLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIpO1xuICAgIGlmIChsYWJlbE9iai54T2Zmc2V0KSB7XG4gICAgICB4ID0geCArIGxhYmVsT2JqLnhPZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsT2JqLnlPZmZzZXQpIHtcbiAgICAgIHkgPSB5ICsgbGFiZWxPYmoueU9mZnNldDtcbiAgICB9XG4gICAgaWYgKGxhYmVsT2JqLmNvbnRlbnQpIHtcbiAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gbGFiZWxPYmouY29udGVudDtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxPYmouY2xhc3NOYW1lKSB7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBsYWJlbE9iai5jbGFzc05hbWUgKyAnIHZpcy1sYWJlbCcpO1xuICAgIH1cbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHgpO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnQ7XG59O1xuXG4vKipcbiAqIGRyYXcgYSBiYXIgU1ZHIGVsZW1lbnQgY2VudGVyZWQgb24gdGhlIFggY29vcmRpbmF0ZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IHN2Z0NvbnRhaW5lclxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKi9cbmV4cG9ydHMuZHJhd0JhciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjbGFzc05hbWUsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lciwgc3R5bGUpIHtcbiAgaWYgKGhlaWdodCAhPSAwKSB7XG4gICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgIGhlaWdodCAqPSAtMTtcbiAgICAgIHkgLT0gaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCgncmVjdCcsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHggLSAwLjUgKiB3aWR0aCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsIHkpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgd2lkdGgpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3R5bGUnLCBzdHlsZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gTG9hZCBjdXN0b20gc2hhcGVzIGludG8gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyNSk7XG5cbnZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgZG90cGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG52YXIgZ2VwaGlQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcbnZhciBBY3RpdmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNik7XG52YXIgbG9jYWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5KTtcblxudmFyIEltYWdlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpWydkZWZhdWx0J107XG52YXIgR3JvdXBzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzQpWydkZWZhdWx0J107XG52YXIgTm9kZXNIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpWydkZWZhdWx0J107XG52YXIgRWRnZXNIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjUpWydkZWZhdWx0J107XG52YXIgUGh5c2ljc0VuZ2luZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcxKVsnZGVmYXVsdCddO1xudmFyIENsdXN0ZXJFbmdpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OClbJ2RlZmF1bHQnXTtcbnZhciBDYW52YXNSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgwKVsnZGVmYXVsdCddO1xudmFyIENhbnZhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgxKVsnZGVmYXVsdCddO1xudmFyIFZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MilbJ2RlZmF1bHQnXTtcbnZhciBJbnRlcmFjdGlvbkhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MylbJ2RlZmF1bHQnXTtcbnZhciBTZWxlY3Rpb25IYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODYpWydkZWZhdWx0J107XG52YXIgTGF5b3V0RW5naW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODcpWydkZWZhdWx0J107XG52YXIgTWFuaXB1bGF0aW9uU3lzdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTApWydkZWZhdWx0J107XG52YXIgQ29uZmlndXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEpWydkZWZhdWx0J107XG52YXIgVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NClbJ2RlZmF1bHQnXTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksXG4gICAgcHJpbnRTdHlsZSA9IF9yZXF1aXJlLnByaW50U3R5bGU7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KSxcbiAgICBhbGxPcHRpb25zID0gX3JlcXVpcmUyLmFsbE9wdGlvbnMsXG4gICAgY29uZmlndXJlT3B0aW9ucyA9IF9yZXF1aXJlMi5jb25maWd1cmVPcHRpb25zO1xuXG52YXIgS2FtYWRhS2F3YWkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MylbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXR3b3JrIHZpc3VhbGl6YXRpb24sIGRpc3BsYXlpbmcgbm9kZXMgYW5kIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgVGhlIERPTSBlbGVtZW50IGluIHdoaWNoIHRoZSBOZXR3b3JrIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNyZWF0ZWQuIE5vcm1hbGx5IGEgZGl2IGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5fSBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IGVkZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgIE9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBOZXR3b3JrXG4gKi9cbmZ1bmN0aW9uIE5ldHdvcmsoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIC8vIHNldCBjb25zdGFudCB2YWx1ZXNcbiAgdGhpcy5vcHRpb25zID0ge307XG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbG9jYWxlOiAnZW4nLFxuICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgY2xpY2tUb1VzZTogZmFsc2VcbiAgfTtcbiAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvKipcbiAgICogQ29udGFpbmVycyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiAnZWRnZXMnIGFuZCAnbm9kZXMnIGNvbnRhaW4gdGhlIGZ1bGwgZGVmaW5pdGlvbnMgb2YgYWxsIHRoZSBuZXR3b3JrIGVsZW1lbnRzLlxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnIGNvbnRhaW4gdGhlIGlkJ3Mgb2YgdGhlIGFjdGl2ZSBlbGVtZW50cy5cbiAgICpcbiAgICogVGhlIGRpc3RpbmN0aW9uIGlzIGltcG9ydGFudCwgYmVjYXVzZSBhIGRlZmluZWQgbm9kZSBuZWVkIG5vdCBiZSBhY3RpdmUsIGkuZS5cbiAgICogdmlzaWJsZSBvbiB0aGUgY2FudmFzLiBUaGlzIGhhcHBlbnMgaW4gcGFydGljdWxhciB3aGVuIGNsdXN0ZXJzIGFyZSBkZWZpbmVkLCBpblxuICAgKiB0aGF0IGNhc2UgdGhlcmUgd2lsbCBiZSBub2RlcyBhbmQgZWRnZXMgbm90IGRpc3BsYXllZC5cbiAgICogVGhlIGJvdHRvbSBsaW5lIGlzIHRoYXQgYWxsIGNvZGUgd2l0aCBhY3Rpb25zIHJlbGF0ZWQgdG8gdmlzaWJpbGl0eSwgKm11c3QqIHVzZVxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnLCBub3QgJ25vZGVzJyBhbmQgJ2VkZ2VzJyBkaXJlY3RseS5cbiAgICovXG4gIHRoaXMuYm9keSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcblxuICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGZvciBmb2xsb3dpbmcgZmllbGRzXG4gICAgbm9kZXM6IHt9LFxuICAgIG5vZGVJbmRpY2VzOiBbXSxcbiAgICBlZGdlczoge30sXG4gICAgZWRnZUluZGljZXM6IFtdLFxuXG4gICAgZW1pdHRlcjoge1xuICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgIG9mZjogdGhpcy5vZmYuYmluZCh0aGlzKSxcbiAgICAgIGVtaXQ6IHRoaXMuZW1pdC5iaW5kKHRoaXMpLFxuICAgICAgb25jZTogdGhpcy5vbmNlLmJpbmQodGhpcylcbiAgICB9LFxuICAgIGV2ZW50TGlzdGVuZXJzOiB7XG4gICAgICBvblRhcDogZnVuY3Rpb24gb25UYXAoKSB7fSxcbiAgICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goKSB7fSxcbiAgICAgIG9uRG91YmxlVGFwOiBmdW5jdGlvbiBvbkRvdWJsZVRhcCgpIHt9LFxuICAgICAgb25Ib2xkOiBmdW5jdGlvbiBvbkhvbGQoKSB7fSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHt9LFxuICAgICAgb25EcmFnOiBmdW5jdGlvbiBvbkRyYWcoKSB7fSxcbiAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKCkge30sXG4gICAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbCgpIHt9LFxuICAgICAgb25QaW5jaDogZnVuY3Rpb24gb25QaW5jaCgpIHt9LFxuICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge30sXG4gICAgICBvblJlbGVhc2U6IGZ1bmN0aW9uIG9uUmVsZWFzZSgpIHt9LFxuICAgICAgb25Db250ZXh0OiBmdW5jdGlvbiBvbkNvbnRleHQoKSB7fVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgbm9kZXM6IG51bGwsIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuICAgICAgZWRnZXM6IG51bGwgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG4gICAgfSxcbiAgICBmdW5jdGlvbnM6IHtcbiAgICAgIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoKSB7fSxcbiAgICAgIGNyZWF0ZUVkZ2U6IGZ1bmN0aW9uIGNyZWF0ZUVkZ2UoKSB7fSxcbiAgICAgIGdldFBvaW50ZXI6IGZ1bmN0aW9uIGdldFBvaW50ZXIoKSB7fVxuICAgIH0sXG4gICAgbW9kdWxlczoge30sXG4gICAgdmlldzoge1xuICAgICAgc2NhbGU6IDEsXG4gICAgICB0cmFuc2xhdGlvbjogeyB4OiAwLCB5OiAwIH1cbiAgICB9XG5cbiAgICAvLyBiaW5kIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgfTt0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHNldHRpbmcgdXAgYWxsIG1vZHVsZXNcbiAgdGhpcy5pbWFnZXMgPSBuZXcgSW1hZ2VzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gIH0pOyAvLyBvYmplY3Qgd2l0aCBpbWFnZXNcbiAgdGhpcy5ncm91cHMgPSBuZXcgR3JvdXBzKCk7IC8vIG9iamVjdCB3aXRoIGdyb3Vwc1xuICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcy5ib2R5KTsgLy8gRE9NIGhhbmRsZXJcbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gbmV3IFNlbGVjdGlvbkhhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIFNlbGVjdGlvbiBoYW5kbGVyXG4gIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyID0gbmV3IEludGVyYWN0aW9uSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIpOyAvLyBJbnRlcmFjdGlvbiBoYW5kbGVyIGhhbmRsZXMgYWxsIHRoZSBoYW1tZXIgYmluZGluZ3MgKHRoYXQgYXJlIGJvdW5kIGJ5IGNhbnZhcyksIGtleVxuICB0aGlzLnZpZXcgPSBuZXcgVmlldyh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gY2FtZXJhIGhhbmRsZXIsIGRvZXMgYW5pbWF0aW9ucyBhbmQgem9vbXNcbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gcmVuZGVyZXIsIHN0YXJ0cyByZW5kZXJsb29wLCBoYXMgZXZlbnRzIHRoYXQgbW9kdWxlcyBjYW4gaG9vayBpbnRvXG4gIHRoaXMucGh5c2ljcyA9IG5ldyBQaHlzaWNzRW5naW5lKHRoaXMuYm9keSk7IC8vIHBoeXNpY3MgZW5naW5lLCBkb2VzIGFsbCB0aGUgc2ltdWxhdGlvbnNcbiAgdGhpcy5sYXlvdXRFbmdpbmUgPSBuZXcgTGF5b3V0RW5naW5lKHRoaXMuYm9keSk7IC8vIGxheW91dCBlbmdpbmUgZm9yIGluaXRhbCBsYXlvdXQgYW5kIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgdGhpcy5jbHVzdGVyaW5nID0gbmV3IENsdXN0ZXJFbmdpbmUodGhpcy5ib2R5KTsgLy8gY2x1c3RlcmluZyBhcGlcbiAgdGhpcy5tYW5pcHVsYXRpb24gPSBuZXcgTWFuaXB1bGF0aW9uU3lzdGVtKHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIGRhdGEgbWFuaXB1bGF0aW9uIHN5c3RlbVxuXG4gIHRoaXMubm9kZXNIYW5kbGVyID0gbmV3IE5vZGVzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5sYXlvdXRFbmdpbmUpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2Ygbm9kZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuICB0aGlzLmVkZ2VzSGFuZGxlciA9IG5ldyBFZGdlc0hhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2YgZWRnZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gIHRoaXMuYm9keS5tb2R1bGVzWydrYW1hZGFLYXdhaSddID0gbmV3IEthbWFkYUthd2FpKHRoaXMuYm9keSwgMTUwLCAwLjA1KTsgLy8gTGF5b3V0aW5nIGFsZ29yaXRobS5cbiAgdGhpcy5ib2R5Lm1vZHVsZXNbJ2NsdXN0ZXJpbmcnXSA9IHRoaXMuY2x1c3RlcmluZztcblxuICAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50c1xuICB0aGlzLmNhbnZhcy5fY3JlYXRlKCk7XG5cbiAgLy8gYXBwbHkgb3B0aW9uc1xuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gbG9hZCBkYXRhICh0aGUgZGlzYWJsZSBzdGFydCB2YXJpYWJsZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBlbmFibGVkIGNsdXN0ZXJpbmcpXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn1cblxuLy8gRXh0ZW5kIE5ldHdvcmsgd2l0aCBhbiBFbWl0dGVyIG1peGluXG5FbWl0dGVyKE5ldHdvcmsucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDsgLy8gVGhpcyBlbnN1cmVzIHRoYXQgb3B0aW9ucyBoYW5kbGluZyBkb2Vzbid0IGNyYXNoIGluIHRoZSBoYW5kbGluZ1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlcnJvckZvdW5kID0gVmFsaWRhdG9yLnZhbGlkYXRlKG9wdGlvbnMsIGFsbE9wdGlvbnMpO1xuICAgIGlmIChlcnJvckZvdW5kID09PSB0cnVlKSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNFcnJvcnMgaGF2ZSBiZWVuIGZvdW5kIGluIHRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdC4nLCBwcmludFN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IHRoZSBnbG9iYWwgZmllbGRzIG92ZXJcbiAgICB2YXIgZmllbGRzID0gWydsb2NhbGUnLCAnbG9jYWxlcycsICdjbGlja1RvVXNlJ107XG4gICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIHRoZSBoaWVyYXJjaGljYWwgc3lzdGVtIGNhbiBhZGFwdCB0aGUgZWRnZXMgYW5kIHRoZSBwaHlzaWNzIHRvIGl0J3Mgb3duIG9wdGlvbnMgYmVjYXVzZSBub3QgYWxsIGNvbWJpbmF0aW9ucyB3b3JrIHdpdGggdGhlIGhpZXJhcmljaGljYWwgc3lzdGVtLlxuICAgIG9wdGlvbnMgPSB0aGlzLmxheW91dEVuZ2luZS5zZXRPcHRpb25zKG9wdGlvbnMubGF5b3V0LCBvcHRpb25zKTtcblxuICAgIHRoaXMuY2FudmFzLnNldE9wdGlvbnMob3B0aW9ucyk7IC8vIG9wdGlvbnMgZm9yIGNhbnZhcyBhcmUgaW4gZ2xvYmFsc1xuXG4gICAgLy8gcGFzcyB0aGUgb3B0aW9ucyB0byB0aGUgbW9kdWxlc1xuICAgIHRoaXMuZ3JvdXBzLnNldE9wdGlvbnMob3B0aW9ucy5ncm91cHMpO1xuICAgIHRoaXMubm9kZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5ub2Rlcyk7XG4gICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmVkZ2VzKTtcbiAgICB0aGlzLnBoeXNpY3Muc2V0T3B0aW9ucyhvcHRpb25zLnBoeXNpY3MpO1xuICAgIHRoaXMubWFuaXB1bGF0aW9uLnNldE9wdGlvbnMob3B0aW9ucy5tYW5pcHVsYXRpb24sIG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7IC8vIG1hbmlwdWxhdGlvbiB1c2VzIHRoZSBsb2NhbGVzIGluIHRoZSBnbG9iYWxzXG5cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3IgcmVuZGVyaW5nIGFyZSBpbiBpbnRlcmFjdGlvblxuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pOyAvLyBvcHRpb25zIGZvciBzZWxlY3Rpb24gYXJlIGluIGludGVyYWN0aW9uXG5cbiAgICAvLyByZWxvYWQgdGhlIHNldHRpbmdzIG9mIHRoZSBub2RlcyB0byBhcHBseSBjaGFuZ2VzIGluIGdyb3VwcyB0aGF0IGFyZSBub3QgcmVmZXJlbmNlZCBieSBwb2ludGVyLlxuICAgIGlmIChvcHRpb25zLmdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZWZyZXNoTm9kZXMnKTtcbiAgICB9XG4gICAgLy8gdGhlc2UgdHdvIGRvIG5vdCBoYXZlIG9wdGlvbnMgYXQgdGhlIG1vbWVudCwgaGVyZSBmb3IgY29tcGxldGVuZXNzXG4gICAgLy90aGlzLnZpZXcuc2V0T3B0aW9ucyhvcHRpb25zLnZpZXcpO1xuICAgIC8vdGhpcy5jbHVzdGVyaW5nLnNldE9wdGlvbnMob3B0aW9ucy5jbHVzdGVyaW5nKTtcblxuICAgIGlmICgnY29uZmlndXJlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gbmV3IENvbmZpZ3VyYXRvcih0aGlzLCB0aGlzLmJvZHkuY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zLCB0aGlzLmNhbnZhcy5waXhlbFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0T3B0aW9ucyhvcHRpb25zLmNvbmZpZ3VyZSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtIGlzIGVuYWJsZWQsIGNvcHkgYWxsIG9wdGlvbnMgYW5kIHB1dCB0aGVtIGludG8gdGhlIGNvbmZpZyBzeXN0ZW1cbiAgICBpZiAodGhpcy5jb25maWd1cmF0b3IgJiYgdGhpcy5jb25maWd1cmF0b3Iub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB2YXIgbmV0d29ya09wdGlvbnMgPSB7XG4gICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgZWRnZXM6IHt9LFxuICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbjoge30sXG4gICAgICAgIG1hbmlwdWxhdGlvbjoge30sXG4gICAgICAgIHBoeXNpY3M6IHt9LFxuICAgICAgICBnbG9iYWw6IHt9XG4gICAgICB9O1xuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLm5vZGVzLCB0aGlzLm5vZGVzSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5lZGdlcywgdGhpcy5lZGdlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubGF5b3V0LCB0aGlzLmxheW91dEVuZ2luZS5vcHRpb25zKTtcbiAgICAgIC8vIGxvYWQgdGhlIHNlbGVjdGlvbkhhbmRsZXIgYW5kIHJlbmRlciBkZWZhdWx0IG9wdGlvbnMgaW4gdG8gdGhlIGludGVyYWN0aW9uIGdyb3VwXG4gICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5yZW5kZXJlci5vcHRpb25zKTtcblxuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5tYW5pcHVsYXRpb24sIHRoaXMubWFuaXB1bGF0aW9uLm9wdGlvbnMpO1xuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLnBoeXNpY3MsIHRoaXMucGh5c2ljcy5vcHRpb25zKTtcblxuICAgICAgLy8gbG9hZCBnbG9iYWxzIGludG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5nbG9iYWwsIHRoaXMuY2FudmFzLm9wdGlvbnMpO1xuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0TW9kdWxlT3B0aW9ucyhuZXR3b3JrT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIG5ldHdvcmsgZ2xvYmFsIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoJ2FjdGl2YXRlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjdGl2YXRvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdhY3RpdmF0ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdhY3RpdmF0ZScpO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzLnNldFNpemUoKTtcbiAgICAvLyBzdGFydCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLiBDYW4gYmUgc2FmZWx5IGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZpc2libGUgbm9kZXMgYW5kIGVkZ2VzIGxpc3Qgd2l0aCB0aGUgbW9zdCByZWNlbnQgbm9kZSBzdGF0ZS5cbiAqXG4gKiBWaXNpYmxlIG5vZGVzIGFyZSBzdG9yZWQgaW4gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLlxuICogVmlzaWJsZSBlZGdlcyBhcmUgc3RvcmVkIGluIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5cbiAqIEEgbm9kZSBvciBlZGdlcyBpcyB2aXNpYmxlIGlmIGl0IGlzIG5vdCBoaWRkZW4gb3IgY2x1c3RlcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gIHRoaXMuYm9keS5ub2RlSW5kaWNlcyA9IFtdO1xuICB0aGlzLmJvZHkuZWRnZUluZGljZXMgPSBbXTtcblxuICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgaWYgKCF0aGlzLmNsdXN0ZXJpbmcuX2lzQ2x1c3RlcmVkTm9kZShub2RlSWQpICYmIG5vZGVzW25vZGVJZF0ub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKG5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgIC8vIEl0IGNhbiBoYXBwZW4gdGhhdCB0aGlzIGlzIGV4ZWN1dGVkICphZnRlciogYSBub2RlIGVkZ2UgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgIC8vIGJ1dCAqYmVmb3JlKiB0aGUgZWRnZSBpdHNlbGYgaGFzIGJlZW4gcmVtb3ZlZC4gVGFraW5nIHRoaXMgaW50byBhY2NvdW50LlxuICAgICAgdmFyIGZyb21Ob2RlID0gbm9kZXNbZWRnZS5mcm9tSWRdO1xuICAgICAgdmFyIHRvTm9kZSA9IG5vZGVzW2VkZ2UudG9JZF07XG4gICAgICB2YXIgZWRnZU5vZGVzUHJlc2VudCA9IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgdG9Ob2RlICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc1Zpc2libGUgPSAhdGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZEVkZ2UoZWRnZUlkKSAmJiBlZGdlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiBlZGdlTm9kZXNQcmVzZW50ICYmIGZyb21Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiAvLyBBbHNvIGhpZGRlbiBpZiBhbnkgb2YgaXRzIGNvbm5lY3Rpbmcgbm9kZXMgYXJlIGhpZGRlblxuICAgICAgdG9Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZTsgLy8gaWRlbVxuXG4gICAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBCaW5kIGFsbCBldmVudHNcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuYmluZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAvLyBUaGlzIGV2ZW50IHdpbGwgdHJpZ2dlciBhIHJlYnVpbGRpbmcgb2YgdGhlIGNhY2hlIGV2ZXJ5dGhpbmcuXG4gIC8vIFVzZWQgd2hlbiBub2RlcyBvciBlZGdlcyBoYXZlIGJlZW4gYWRkZWQgb3IgcmVtb3ZlZC5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpczMuZWRnZXNIYW5kbGVyLl91cGRhdGVTdGF0ZSgpO1xuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFVcGRhdGVkJyk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gb3B0aW9ucyBvZiBFWElTVElORyBub2RlcyBvciBlZGdlcyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZGF0YVVwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gT3JkZXIgaW1wb3J0YW50IGluIGZvbGxvd2luZyBibG9ja1xuICAgIF90aGlzMy5jbHVzdGVyaW5nLl91cGRhdGVTdGF0ZSgpO1xuICAgIF90aGlzMy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcblxuICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5ub2Rlcyk7XG4gICAgX3RoaXMzLl91cGRhdGVWYWx1ZVJhbmdlKF90aGlzMy5ib2R5LmVkZ2VzKTtcbiAgICAvLyBzdGFydCBzaW11bGF0aW9uIChjYW4gYmUgY2FsbGVkIHNhZmVseSwgZXZlbiBpZiBhbHJlYWR5IHJ1bm5pbmcpXG4gICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTZXQgbm9kZXMgYW5kIGVkZ2VzLCBhbmQgb3B0aW9uYWxseSBvcHRpb25zIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbbm9kZXNdIEFycmF5IHdpdGggbm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IFtlZGdlc10gQXJyYXkgd2l0aCBlZGdlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtkb3RdIFN0cmluZyBjb250YWluaW5nIGRhdGEgaW4gRE9UIGZvcm1hdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtnZXBoaV0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBnZXBoaSBKU09OIGZvcm1hdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPcHRpb25zfSBbb3B0aW9uc10gT2JqZWN0IHdpdGggb3B0aW9uc1xuICovXG5OZXR3b3JrLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gcmVzZXQgdGhlIHBoeXNpY3MgZW5naW5lLlxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZXNldFBoeXNpY3MnKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3Jlc2V0RGF0YScpO1xuXG4gIC8vIHVuc2VsZWN0IGFsbCB0byBlbnN1cmUgbm8gc2VsZWN0aW9ucyBmcm9tIG9sZCBkYXRhIGFyZSBjYXJyaWVkIG92ZXIuXG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuZG90ICYmIChkYXRhLm5vZGVzIHx8IGRhdGEuZWRnZXMpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBlaXRoZXIgcGFyYW1ldGVyIFwiZG90XCIgb3IgJyArICcgcGFyYW1ldGVyIHBhaXIgXCJub2Rlc1wiIGFuZCBcImVkZ2VzXCIsIGJ1dCBub3QgYm90aC4nKTtcbiAgfVxuXG4gIC8vIHNldCBvcHRpb25zXG4gIHRoaXMuc2V0T3B0aW9ucyhkYXRhICYmIGRhdGEub3B0aW9ucyk7XG4gIC8vIHNldCBhbGwgZGF0YVxuICBpZiAoZGF0YSAmJiBkYXRhLmRvdCkge1xuICAgIGNvbnNvbGUubG9nKCdUaGUgZG90IHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0RG90IG1ldGhvZCB0byBjb252ZXJ0IERPVCBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnREb3QoZG90U3RyaW5nKTsnKTtcbiAgICAvLyBwYXJzZSBET1QgZmlsZVxuICAgIHZhciBkb3REYXRhID0gZG90cGFyc2VyLkRPVFRvR3JhcGgoZGF0YS5kb3QpO1xuICAgIHRoaXMuc2V0RGF0YShkb3REYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmdlcGhpKSB7XG4gICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICBjb25zb2xlLmxvZygnVGhlIGdlcGhpIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0R2VwaGkgbWV0aG9kIHRvIGNvbnZlcnQgZ2VwaGkgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0R2VwaGkoZ2VwaGlKc29uKTsnKTtcbiAgICB2YXIgZ2VwaGlEYXRhID0gZ2VwaGlQYXJzZXIucGFyc2VHZXBoaShkYXRhLmdlcGhpKTtcbiAgICB0aGlzLnNldERhdGEoZ2VwaGlEYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEubm9kZXMsIHRydWUpO1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldERhdGEoZGF0YSAmJiBkYXRhLmVkZ2VzLCB0cnVlKTtcbiAgfVxuXG4gIC8vIGVtaXQgY2hhbmdlIGluIGRhdGFcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG5cbiAgLy8gZW1pdCBkYXRhIGxvYWRlZFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUxvYWRlZCcpO1xuXG4gIC8vIGZpbmQgYSBzdGFibGUgcG9zaXRpb24gb3Igc3RhcnQgYW5pbWF0aW5nIHRvIGEgc3RhYmxlIHBvc2l0aW9uXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2luaXRQaHlzaWNzJyk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBhbGwgYmluZGluZ3Mgb2YgdGhlIG5ldHdvcmssIHJlbW92aW5nIGl0IGZ1bGx5IGZyb20gdGhlIG1lbW9yeSBJRiB0aGUgdmFyaWFibGUgaXMgc2V0IHRvIG51bGwgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICogdmFyIG5ldHdvcmsgPSBuZXcgdmlzLk5ldHdvcmsoLi4pO1xuICogbmV0d29yay5kZXN0cm95KCk7XG4gKiBuZXR3b3JrID0gbnVsbDtcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZGVzdHJveScpO1xuICAvLyBjbGVhciBldmVudHNcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gIHRoaXMub2ZmKCk7XG5cbiAgLy8gZGVsZXRlIG1vZHVsZXNcbiAgZGVsZXRlIHRoaXMuZ3JvdXBzO1xuICBkZWxldGUgdGhpcy5jYW52YXM7XG4gIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbkhhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMudmlldztcbiAgZGVsZXRlIHRoaXMucmVuZGVyZXI7XG4gIGRlbGV0ZSB0aGlzLnBoeXNpY3M7XG4gIGRlbGV0ZSB0aGlzLmxheW91dEVuZ2luZTtcbiAgZGVsZXRlIHRoaXMuY2x1c3RlcmluZztcbiAgZGVsZXRlIHRoaXMubWFuaXB1bGF0aW9uO1xuICBkZWxldGUgdGhpcy5ub2Rlc0hhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmVkZ2VzSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuY29uZmlndXJhdG9yO1xuICBkZWxldGUgdGhpcy5pbWFnZXM7XG5cbiAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgIGlmICghdGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgfVxuXG4gIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICBpZiAoIXRoaXMuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSBjb250aW51ZTtcbiAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF07XG4gIH1cblxuICAvLyByZW1vdmUgdGhlIGNvbnRhaW5lciBhbmQgZXZlcnl0aGluZyBpbnNpZGUgaXQgcmVjdXJzaXZlbHlcbiAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5ib2R5LmNvbnRhaW5lcik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIGFsbCBvYmplY3QgaW4gdGhlIGdpdmVuIGFycmF5IGFjY29yZGluZyB0byB0aGUgY3VycmVudFxuICogdmFsdWUgcmFuZ2Ugb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBFZGdlcyBvciBOb2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0cyBtdXN0IGhhdmUgYSBtZXRob2QgZ2V0VmFsdWUoKSBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVSYW5nZShtaW4sIG1heCkuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVSYW5nZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGlkO1xuXG4gIC8vIGRldGVybWluZSB0aGUgcmFuZ2Ugb2YgdGhlIG9iamVjdHNcbiAgdmFyIHZhbHVlTWluID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWVNYXggPSB1bmRlZmluZWQ7XG4gIHZhciB2YWx1ZVRvdGFsID0gMDtcbiAgZm9yIChpZCBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2lkXS5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVNaW4gPSB2YWx1ZU1pbiA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1pbih2YWx1ZSwgdmFsdWVNaW4pO1xuICAgICAgICB2YWx1ZU1heCA9IHZhbHVlTWF4ID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IE1hdGgubWF4KHZhbHVlLCB2YWx1ZU1heCk7XG4gICAgICAgIHZhbHVlVG90YWwgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRqdXN0IHRoZSByYW5nZSBvZiBhbGwgb2JqZWN0c1xuICBpZiAodmFsdWVNaW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIG9ialtpZF0uc2V0VmFsdWVSYW5nZSh2YWx1ZU1pbiwgdmFsdWVNYXgsIHZhbHVlVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgTmV0d29yayBpcyBhY3RpdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTmV0d29yay5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLnNldFNpemUuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2FudmFzVG9ET00gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTS5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5ET010b0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBOb2RlcyBjYW4gYmUgaW4gY2x1c3RlcnMuIENsdXN0ZXJzIGNhbiBhbHNvIGJlIGluIGNsdXN0ZXJzLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW5kIGFycmF5IG9mXG4gKiBub2RlSWRzIHNob3dpbmcgd2hlcmUgdGhlIG5vZGUgaXMuXG4gKlxuICogSWYgYW55IG5vZGVJZCBpbiB0aGUgY2hhaW4sIGVzcGVjaWFsbHkgdGhlIGZpcnN0IHBhc3NlZCBpbiBhcyBhIHBhcmFtZXRlciwgaXMgbm90IHByZXNlbnQgaW5cbiAqIHRoZSBjdXJyZW50IG5vZGVzIGxpc3QsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBjbHVzdGVyICdBJyBjb250YWlucyBjbHVzdGVyICdCJyxcbiAqIGNsdXN0ZXIgJ0InIGNvbnRhaW5zIGNsdXN0ZXIgJ0MnLFxuICogY2x1c3RlciAnQycgY29udGFpbnMgbm9kZSAnZnJlZCcuXG4gKiBganNuZXR3b3JrLmNsdXN0ZXJpbmcuZmluZE5vZGUoJ2ZyZWQnKWAgd2lsbCByZXR1cm4gYFsnQScsJ0InLCdDJywnZnJlZCddYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vZGVJZFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5maW5kTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5maW5kTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5pc0NsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuaXNDbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5vcGVuQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXROb2Rlc0luQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXROb2Rlc0luQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlckJ5Q29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlDb25uZWN0aW9uLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlIdWJzaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUh1YnNpemUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGNsdXN0ZXIgYWxsIG5vZGVzIHdpdGggMSBlZGdlIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25uZWN0ZWQgbm9kZS5cbiAqIFRoZSBvcHRpb25zIG9iamVjdCBpcyBleHBsYWluZWQgaW4gZnVsbCA8YSBkYXRhLXNjcm9sbD1cIlwiIGRhdGEtb3B0aW9ucz1cInsgJnF1b3Q7ZWFzaW5nJnF1b3Q7OiAmcXVvdDtlYXNlSW5DdWJpYyZxdW90OyB9XCIgaHJlZj1cIiNvcHRpb25zT2JqZWN0XCI+YmVsb3c8L2E+LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJPdXRsaWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFNlZWQuYXBwbHkodGhpcy5sYXlvdXRFbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZW5hYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lbmFibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5kaXNhYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5kaXNhYmxlRWRpdE1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuYWRkTm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5hZGROb2RlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS5sb2coJ0RlcHJlY2F0ZWQ6IFBsZWFzZSB1c2UgZWRpdE5vZGUgaW5zdGVhZCBvZiBlZGl0Tm9kZU1vZGUuJyk7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5hZGRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmVkaXRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXRFZGdlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5kZWxldGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRlbGV0ZVNlbGVjdGVkLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zdG9yZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLnN0b3JlUG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLm1vdmVOb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIubW92ZU5vZGUuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRCb3VuZGluZ0JveC5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDb25uZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChvYmplY3RJZCkge1xuICBpZiAodGhpcy5ib2R5Lm5vZGVzW29iamVjdElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLmVkZ2VzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfVxufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldENvbm5lY3RlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkRWRnZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc3RhcnRTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YXJ0U2ltdWxhdGlvbi5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RvcFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnN0YWJpbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdGFiaWxpemUuYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2Rlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXROb2RlQXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGUuaWQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0RWRnZUF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRFZGdlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlZGdlLmlkO1xuICB9XG4gIHJldHVybiBlZGdlO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnNlbGVjdE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zZWxlY3RFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUudW5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuTmV0d29yay5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZWRyYXcuYXBwbHkodGhpcy5yZW5kZXJlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5nZXRTY2FsZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0Vmlld1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmdldFZpZXdQb3NpdGlvbi5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmZpdC5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3Lm1vdmVUby5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZm9jdXMuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnJlbGVhc2VOb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LnJlbGVhc2VOb2RlLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRPcHRpb25zRnJvbUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgaWYgKHRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuY29uZmlndXJhdG9yLmdldE9wdGlvbnMuYXBwbHkodGhpcy5jb25maWd1cmF0b3IpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrO1xuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIENhbnZhcyBzaGFwZXMgdXNlZCBieSBOZXR3b3JrXG4gKi9cbmlmICh0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICE9PSAndW5kZWZpbmVkJykge1xuICAvKipcbiAgICogRHJhdyBhIGNpcmNsZSBzaGFwZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jaXJjbGUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5hcmMoeCwgeSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgc3F1YXJlIHNoYXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAgIHNpemUsIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNxdWFyZVxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5yZWN0KHggLSByLCB5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgdHJpYW5nbGUgc2hhcGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByICAgcmFkaXVzLCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS50cmlhbmdsZSA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgICByICo9IDEuMTU7XG4gICAgeSArPSAwLjI3NSAqIHI7XG5cbiAgICB2YXIgcyA9IHIgKiAyO1xuICAgIHZhciBzMiA9IHMgLyAyO1xuICAgIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG4gICAgdmFyIGggPSBNYXRoLnNxcnQocyAqIHMgLSBzMiAqIHMyKTsgLy8gaGVpZ2h0XG5cbiAgICB0aGlzLm1vdmVUbyh4LCB5IC0gKGggLSBpcikpO1xuICAgIHRoaXMubGluZVRvKHggKyBzMiwgeSArIGlyKTtcbiAgICB0aGlzLmxpbmVUbyh4IC0gczIsIHkgKyBpcik7XG4gICAgdGhpcy5saW5lVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgdHJpYW5nbGUgc2hhcGUgaW4gZG93bndhcmQgb3JpZW50YXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByIHJhZGl1c1xuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS50cmlhbmdsZURvd24gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG4gICAgciAqPSAxLjE1O1xuICAgIHkgLT0gMC4yNzUgKiByO1xuXG4gICAgdmFyIHMgPSByICogMjtcbiAgICB2YXIgczIgPSBzIC8gMjtcbiAgICB2YXIgaXIgPSBNYXRoLnNxcnQoMykgLyA2ICogczsgLy8gcmFkaXVzIG9mIGlubmVyIGNpcmNsZVxuICAgIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuXG4gICAgdGhpcy5tb3ZlVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgczIsIHkgLSBpcik7XG4gICAgdGhpcy5saW5lVG8oeCAtIHMyLCB5IC0gaXIpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIHN0YXIgc2hhcGUsIGEgc3RhciB3aXRoIDUgcG9pbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAgIHJhZGl1cywgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcyBvZiB0aGUgdHJpYW5nbGVcbiAgICovXG4gIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3RhciA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgLy8gaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgICByICo9IDAuODI7XG4gICAgeSArPSAwLjEgKiByO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCAxMDsgbisrKSB7XG4gICAgICB2YXIgcmFkaXVzID0gbiAlIDIgPT09IDAgPyByICogMS4zIDogciAqIDAuNTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByYWRpdXMgKiBNYXRoLnNpbihuICogMiAqIE1hdGguUEkgLyAxMCksIHkgLSByYWRpdXMgKiBNYXRoLmNvcyhuICogMiAqIE1hdGguUEkgLyAxMCkpO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgYSBEaWFtb25kIHNoYXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAgIHJhZGl1cywgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcyBvZiB0aGUgdHJpYW5nbGVcbiAgICovXG4gIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGlhbW9uZCA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgLy8gaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgdGhpcy5saW5lVG8oeCArIHIsIHkpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgLSByKTtcbiAgICB0aGlzLmxpbmVUbyh4IC0gciwgeSk7XG5cbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNTU1MTIvaG93LXRvLWRyYXctYS1yb3VuZGVkLXJlY3RhbmdsZS1vbi1odG1sLWNhbnZhc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcikge1xuICAgIHZhciByMmQgPSBNYXRoLlBJIC8gMTgwO1xuICAgIGlmICh3IC0gMiAqIHIgPCAwKSB7XG4gICAgICByID0gdyAvIDI7XG4gICAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB4XG4gICAgaWYgKGggLSAyICogciA8IDApIHtcbiAgICAgIHIgPSBoIC8gMjtcbiAgICB9IC8vZW5zdXJlIHRoYXQgdGhlIHJhZGl1cyBpc24ndCB0b28gbGFyZ2UgZm9yIHlcbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xuICAgIHRoaXMuYXJjKHggKyB3IC0gciwgeSArIHIsIHIsIHIyZCAqIDI3MCwgcjJkICogMzYwLCBmYWxzZSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgdGhpcy5hcmMoeCArIHcgLSByLCB5ICsgaCAtIHIsIHIsIDAsIHIyZCAqIDkwLCBmYWxzZSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICB0aGlzLmFyYyh4ICsgciwgeSArIGggLSByLCByLCByMmQgKiA5MCwgcjJkICogMTgwLCBmYWxzZSk7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIHIpO1xuICAgIHRoaXMuYXJjKHggKyByLCB5ICsgciwgciwgcjJkICogMTgwLCByMmQgKiAyNzAsIGZhbHNlKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcbiAgICpcbiAgICogUG9zdGZpeCAnX3ZpcycgYWRkZWQgdG8gZGlzY2VybiBpdCBmcm9tIHN0YW5kYXJkIG1ldGhvZCBlbGxpcHNlKCkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAqL1xuICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmVsbGlwc2VfdmlzID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgIG94ID0gdyAvIDIgKiBrYXBwYSxcbiAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgIG95ID0gaCAvIDIgKiBrYXBwYSxcbiAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICB4ZSA9IHggKyB3LFxuICAgICAgICAvLyB4LWVuZFxuICAgIHllID0geSArIGgsXG4gICAgICAgIC8vIHktZW5kXG4gICAgeG0gPSB4ICsgdyAvIDIsXG4gICAgICAgIC8vIHgtbWlkZGxlXG4gICAgeW0gPSB5ICsgaCAvIDI7IC8vIHktbWlkZGxlXG5cbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMubW92ZVRvKHgsIHltKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kYXRhYmFzZSA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgdmFyIGYgPSAxIC8gMztcbiAgICB2YXIgd0VsbGlwc2UgPSB3O1xuICAgIHZhciBoRWxsaXBzZSA9IGggKiBmO1xuXG4gICAgdmFyIGthcHBhID0gMC41NTIyODQ4LFxuICAgICAgICBveCA9IHdFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgb3kgPSBoRWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICB4ZSA9IHggKyB3RWxsaXBzZSxcbiAgICAgICAgLy8geC1lbmRcbiAgICB5ZSA9IHkgKyBoRWxsaXBzZSxcbiAgICAgICAgLy8geS1lbmRcbiAgICB4bSA9IHggKyB3RWxsaXBzZSAvIDIsXG4gICAgICAgIC8vIHgtbWlkZGxlXG4gICAgeW0gPSB5ICsgaEVsbGlwc2UgLyAyLFxuICAgICAgICAvLyB5LW1pZGRsZVxuICAgIHltYiA9IHkgKyAoaCAtIGhFbGxpcHNlIC8gMiksXG4gICAgICAgIC8vIHktbWlkbGxlLCBib3R0b20gZWxsaXBzZVxuICAgIHllYiA9IHkgKyBoOyAvLyB5LWVuZCwgYm90dG9tIGVsbGlwc2VcblxuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5tb3ZlVG8oeGUsIHltKTtcblxuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG5cbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcblxuICAgIHRoaXMubGluZVRvKHhlLCB5bWIpO1xuXG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bWIgKyBveSwgeG0gKyBveCwgeWViLCB4bSwgeWViKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeG0gLSBveCwgeWViLCB4LCB5bWIgKyBveSwgeCwgeW1iKTtcblxuICAgIHRoaXMubGluZVRvKHgsIHltKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgZGFzaGVkTGluZSBmdW5jdGlvbmFsaXR5IGZvciBkcmF3aW5nXG4gICAqIE9yaWdpbmFsIGNvZGUgY2FtZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1xuICAgKiBAYXV0aG9yIERhdmlkIEpvcmRhblxuICAgKiBAZGF0ZSAyMDEyLTA4LTA4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAgICovXG4gIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGFzaGVkTGluZSA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIHBhdHRlcm4pIHtcbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuXG4gICAgdmFyIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICB2YXIgZHggPSB4MiAtIHg7XG4gICAgdmFyIGR5ID0geTIgLSB5O1xuICAgIHZhciBzbG9wZSA9IGR5IC8gZHg7XG4gICAgdmFyIGRpc3RSZW1haW5pbmcgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHZhciBwYXR0ZXJuSW5kZXggPSAwO1xuICAgIHZhciBkcmF3ID0gdHJ1ZTtcbiAgICB2YXIgeFN0ZXAgPSAwO1xuICAgIHZhciBkYXNoTGVuZ3RoID0gcGF0dGVyblswXTtcblxuICAgIHdoaWxlIChkaXN0UmVtYWluaW5nID49IDAuMSkge1xuICAgICAgZGFzaExlbmd0aCA9IHBhdHRlcm5bcGF0dGVybkluZGV4KysgJSBwYXR0ZXJuTGVuZ3RoXTtcbiAgICAgIGlmIChkYXNoTGVuZ3RoID4gZGlzdFJlbWFpbmluZykge1xuICAgICAgICBkYXNoTGVuZ3RoID0gZGlzdFJlbWFpbmluZztcbiAgICAgIH1cblxuICAgICAgeFN0ZXAgPSBNYXRoLnNxcnQoZGFzaExlbmd0aCAqIGRhc2hMZW5ndGggLyAoMSArIHNsb3BlICogc2xvcGUpKTtcbiAgICAgIHhTdGVwID0gZHggPCAwID8gLXhTdGVwIDogeFN0ZXA7XG4gICAgICB4ICs9IHhTdGVwO1xuICAgICAgeSArPSBzbG9wZSAqIHhTdGVwO1xuXG4gICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxpbmVUbyh4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgfVxuXG4gICAgICBkaXN0UmVtYWluaW5nIC09IGRhc2hMZW5ndGg7XG4gICAgICBkcmF3ID0gIWRyYXc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgSGV4YWdvbiBzaGFwZSB3aXRoIDYgc2lkZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByICAgcmFkaXVzXG4gICAqL1xuICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmhleGFnb24gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdmFyIHNpZGVzID0gNjtcbiAgICB2YXIgYSA9IE1hdGguUEkgKiAyIC8gc2lkZXM7XG4gICAgdGhpcy5tb3ZlVG8oeCArIHIsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgdGhpcy5saW5lVG8oeCArIHIgKiBNYXRoLmNvcyhhICogaSksIHkgKyByICogTWF0aC5zaW4oYSAqIGkpKTtcbiAgICB9XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGtleWNoYXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xudmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vKipcbiAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAqIFdoZW4gbm90IGFjdGl2ZSwgdGhlIGVsZW1lbnQgaGFzIGEgdHJhbnNwYXJlbnQgb3ZlcmxheS4gV2hlbiB0aGUgb3ZlcmxheSBpc1xuICogY2xpY2tlZCwgdGhlIG1vZGUgaXMgY2hhbmdlZCB0byBhY3RpdmUuXG4gKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICogdGhlIGludGVyYWN0aXZlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSB1c2VkLiBXaGVuIGNsaWNrZWQgb3V0c2lkZVxuICogdGhlIGVsZW1lbnQsIHRoZSBlbGVtZW50cyBtb2RlIGlzIGNoYW5nZWQgdG8gaW5hY3RpdmUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICogQGNvbnN0cnVjdG9yIEFjdGl2YXRvclxuICovXG5mdW5jdGlvbiBBY3RpdmF0b3IoY29udGFpbmVyKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5kb20gPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfTtcblxuICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLm92ZXJsYXkuY2xhc3NOYW1lID0gJ3Zpcy1vdmVybGF5JztcblxuICB0aGlzLmRvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgdGhpcy5oYW1tZXIgPSBIYW1tZXIodGhpcy5kb20ub3ZlcmxheSk7XG4gIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCB0aGlzLl9vblRhcE92ZXJsYXkuYmluZCh0aGlzKSk7XG5cbiAgLy8gYmxvY2sgYWxsIHRvdWNoIGV2ZW50cyAoZXhjZXB0IHRhcClcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGV2ZW50cyA9IFsndGFwJywgJ2RvdWJsZXRhcCcsICdwcmVzcycsICdwaW5jaCcsICdwYW4nLCAncGFuc3RhcnQnLCAncGFubW92ZScsICdwYW5lbmQnXTtcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhdHRhY2ggYSBjbGljayBldmVudCB0byB0aGUgd2luZG93LCBpbiBvcmRlciB0byBkZWFjdGl2YXRlIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgdGltZWxpbmVcbiAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB0aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX2hhc1BhcmVudChldmVudC50YXJnZXQsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgbWUuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gIH1cblxuICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gIH1cbiAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKCk7XG5cbiAgLy8ga2V5Y2hhcm0gbGlzdGVuZXIgb25seSBib3VuZGVkIHdoZW4gYWN0aXZlKVxuICB0aGlzLmVzY0xpc3RlbmVyID0gdGhpcy5kZWFjdGl2YXRlLmJpbmQodGhpcyk7XG59XG5cbi8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG5FbWl0dGVyKEFjdGl2YXRvci5wcm90b3R5cGUpO1xuXG4vLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBhY3RpdmF0b3JcbkFjdGl2YXRvci5jdXJyZW50ID0gbnVsbDtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVhY3RpdmF0ZSgpO1xuXG4gIC8vIHJlbW92ZSBkb21cbiAgdGhpcy5kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gIC8vIHJlbW92ZSBnbG9iYWwgZXZlbnQgbGlzdGVuZXJcbiAgaWYgKHRoaXMub25DbGljaykge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICB9XG4gIC8vIHJlbW92ZSBrZXljaGFybVxuICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gIH1cbiAgdGhpcy5rZXljaGFybSA9IG51bGw7XG4gIC8vIGNsZWFudXAgaGFtbWVyIGluc3RhbmNlc1xuICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcbiAgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZCBmcm9tIG1lbW9yeSlcbn07XG5cbi8qKlxuICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHdlIGFsbG93IG9ubHkgb25lIGFjdGl2ZSBhY3RpdmF0b3IgYXQgYSB0aW1lXG4gIGlmIChBY3RpdmF0b3IuY3VycmVudCkge1xuICAgIEFjdGl2YXRvci5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgfVxuICBBY3RpdmF0b3IuY3VycmVudCA9IHRoaXM7XG5cbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcblxuICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICB0aGlzLmVtaXQoJ2FjdGl2YXRlJyk7XG5cbiAgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICB0aGlzLmtleWNoYXJtLmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBEZWFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uY29udGFpbmVyLCAndmlzLWFjdGl2ZScpO1xuICB0aGlzLmtleWNoYXJtLnVuYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG5cbiAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgdGhpcy5lbWl0KCdkZWFjdGl2YXRlJyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhIHRhcCBldmVudDogYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLl9vblRhcE92ZXJsYXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICB0aGlzLmFjdGl2YXRlKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgcGFyZW50IGVsZW1lbnQgc29tZXdoZXJlIGluXG4gKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2hhc1BhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aXZhdG9yO1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgaWYgKHRydWUpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgIC8vIGxpa2UgTm9kZS5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgIHdpbmRvdy5wcm9wYWdhdGluZyA9IGZhY3RvcnkoKTtcbiAgfVxufShmdW5jdGlvbiAoKSB7XG4gIHZhciBfZmlyc3RUYXJnZXQgPSBudWxsOyAvLyBzaW5nbGV0b24sIHdpbGwgY29udGFpbiB0aGUgdGFyZ2V0IGVsZW1lbnQgd2hlcmUgdGhlIHRvdWNoIGV2ZW50IHN0YXJ0ZWRcblxuICAvKipcbiAgICogRXh0ZW5kIGFuIEhhbW1lci5qcyBpbnN0YW5jZSB3aXRoIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKlxuICAgKiBGZWF0dXJlczpcbiAgICogLSBFdmVudHMgZW1pdHRlZCBieSBoYW1tZXIgd2lsbCBwcm9wYWdhdGUgaW4gb3JkZXIgZnJvbSBjaGlsZCB0byBwYXJlbnRcbiAgICogICBlbGVtZW50cy5cbiAgICogLSBFdmVudHMgYXJlIGV4dGVuZGVkIHdpdGggYSBmdW5jdGlvbiBgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClgIHRvIHN0b3BcbiAgICogICBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuXG4gICAqIC0gQW4gb3B0aW9uIGBwcmV2ZW50RGVmYXVsdGAgdG8gc3RvcCBhbGwgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yLlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogICB2YXIgaGFtbWVyID0gcHJvcGFnYXRpbmdIYW1tZXIobmV3IEhhbW1lcihlbGVtZW50KSk7XG4gICAqICAgdmFyIGhhbW1lciA9IHByb3BhZ2F0aW5nSGFtbWVyKG5ldyBIYW1tZXIoZWxlbWVudCksIHtwcmV2ZW50RGVmYXVsdDogdHJ1ZX0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0hhbW1lci5NYW5hZ2VyfSBoYW1tZXIgICBBbiBoYW1tZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB8IGZhbHNlIHwgJ21vdXNlJyB8ICd0b3VjaCcgfCAncGVuJ2AuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5mb3JjZSBwcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2Fubm90IGJlIHNldCB0byBgZmFsc2VgLlxuICAgKiBAcmV0dXJuIHtIYW1tZXIuTWFuYWdlcn0gUmV0dXJucyB0aGUgc2FtZSBoYW1tZXIgaW5zdGFuY2Ugd2l0aCBleHRlbmRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3BhZ2F0aW5nKGhhbW1lciwgb3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChoYW1tZXIuTWFuYWdlcikge1xuICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIHRoZSBIYW1tZXIgY29uc3RydWN0b3IuXG4gICAgICAvLyBPdmVybG9hZCB0aGUgY29uc3RydWN0b3JzIHdpdGggb3VyIG93bi5cbiAgICAgIHZhciBIYW1tZXIgPSBoYW1tZXI7XG5cbiAgICAgIHZhciBQcm9wYWdhdGluZ0hhbW1lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKF9vcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIEhhbW1lci5hc3NpZ24obywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGluZyhuZXcgSGFtbWVyKGVsZW1lbnQsIG8pLCBvKTtcbiAgICAgIH07XG4gICAgICBIYW1tZXIuYXNzaWduKFByb3BhZ2F0aW5nSGFtbWVyLCBIYW1tZXIpO1xuXG4gICAgICBQcm9wYWdhdGluZ0hhbW1lci5NYW5hZ2VyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKF9vcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIEhhbW1lci5hc3NpZ24obywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGluZyhuZXcgSGFtbWVyLk1hbmFnZXIoZWxlbWVudCwgbyksIG8pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFByb3BhZ2F0aW5nSGFtbWVyO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIGZ1bmN0aW9uc1xuICAgIC8vIGBvbmAsIGBvZmZgLCBgZGVzdHJveWAsIGFuZCBgZW1pdGAgb2YgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgIHZhciB3cmFwcGVyID0gT2JqZWN0LmNyZWF0ZShoYW1tZXIpO1xuXG4gICAgLy8gYXR0YWNoIHRvIERPTSBlbGVtZW50XG4gICAgdmFyIGVsZW1lbnQgPSBoYW1tZXIuZWxlbWVudDtcblxuICAgIGlmKCFlbGVtZW50LmhhbW1lcikgZWxlbWVudC5oYW1tZXIgPSBbXTtcbiAgICBlbGVtZW50LmhhbW1lci5wdXNoKHdyYXBwZXIpO1xuXG4gICAgLy8gcmVnaXN0ZXIgYW4gZXZlbnQgdG8gY2F0Y2ggdGhlIHN0YXJ0IG9mIGEgZ2VzdHVyZSBhbmQgc3RvcmUgdGhlXG4gICAgLy8gdGFyZ2V0IGluIGEgc2luZ2xldG9uXG4gICAgaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9PT0gdHJ1ZSB8fCAoX29wdGlvbnMucHJldmVudERlZmF1bHQgPT09IGV2ZW50LnBvaW50ZXJUeXBlKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgX2ZpcnN0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgQXJyYXkuPGZ1bmN0aW9uPj59ICovXG4gICAgd3JhcHBlci5faGFuZGxlcnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgaGFuZGxlciBmb3Igb25lIG9yIG11bHRpcGxlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHMgICAgQSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGggZXZlbnRzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBBIGNhbGxiYWNrIGZ1bmN0aW9uLCBjYWxsZWQgYXMgaGFuZGxlcihldmVudClcbiAgICAgKiBAcmV0dXJucyB7SGFtbWVyLk1hbmFnZXJ9IFJldHVybnMgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHdyYXBwZXIub24gPSBmdW5jdGlvbiAoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAvLyByZWdpc3RlciB0aGUgaGFuZGxlclxuICAgICAgc3BsaXQoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2hhbmRsZXJzID0gd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICBpZiAoIV9oYW5kbGVycykge1xuICAgICAgICAgIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XSA9IF9oYW5kbGVycyA9IFtdO1xuXG4gICAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIHN0YXRpYywgcHJvcGFnYXRlZCBoYW5kbGVyXG4gICAgICAgICAgaGFtbWVyLm9uKGV2ZW50LCBwcm9wYWdhdGVkSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBvbmUgb3IgbXVsdGlwbGUgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50cyAgICAgIEEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyB3aXRoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSBPcHRpb25hbC4gVGhlIHJlZ2lzdGVyZWQgaGFuZGxlci4gSWYgbm90XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkLCBhbGwgaGFuZGxlcnMgZm9yIGdpdmVuIGV2ZW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJucyB7SGFtbWVyLk1hbmFnZXJ9ICAgUmV0dXJucyB0aGUgaGFtbWVyIGluc3RhbmNlXG4gICAgICovXG4gICAgd3JhcHBlci5vZmYgPSBmdW5jdGlvbiAoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAvLyB1bnJlZ2lzdGVyIHRoZSBoYW5kbGVyXG4gICAgICBzcGxpdChldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfaGFuZGxlcnMgPSB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF07XG4gICAgICAgIGlmIChfaGFuZGxlcnMpIHtcbiAgICAgICAgICBfaGFuZGxlcnMgPSBoYW5kbGVyID8gX2hhbmRsZXJzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgcmV0dXJuIGggIT09IGhhbmRsZXI7XG4gICAgICAgICAgfSkgOiBbXTtcblxuICAgICAgICAgIGlmIChfaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdID0gX2hhbmRsZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdGF0aWMsIHByb3BhZ2F0ZWQgaGFuZGxlclxuICAgICAgICAgICAgaGFtbWVyLm9mZihldmVudCwgcHJvcGFnYXRlZEhhbmRsZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW1pdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgd3JhcHBlci5lbWl0ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBldmVudCkge1xuICAgICAgX2ZpcnN0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaGFtbWVyLmVtaXQoZXZlbnRUeXBlLCBldmVudCk7XG4gICAgfTtcblxuICAgIHdyYXBwZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERldGFjaCBmcm9tIERPTSBlbGVtZW50XG4gICAgICB2YXIgaGFtbWVycyA9IGhhbW1lci5lbGVtZW50LmhhbW1lcjtcbiAgICAgIHZhciBpZHggPSBoYW1tZXJzLmluZGV4T2Yod3JhcHBlcik7XG4gICAgICBpZihpZHggIT09IC0xKSBoYW1tZXJzLnNwbGljZShpZHgsMSk7XG4gICAgICBpZighaGFtbWVycy5sZW5ndGgpIGRlbGV0ZSBoYW1tZXIuZWxlbWVudC5oYW1tZXI7XG5cbiAgICAgIC8vIGNsZWFyIGFsbCBoYW5kbGVyc1xuICAgICAgd3JhcHBlci5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgLy8gY2FsbCBvcmlnaW5hbCBoYW1tZXIgZGVzdHJveVxuICAgICAgaGFtbWVyLmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBzcGFjZSBzZXBhcmF0ZWQgd29yZHNcbiAgICBmdW5jdGlvbiBzcGxpdChldmVudHMpIHtcbiAgICAgIHJldHVybiBldmVudHMubWF0Y2goL1teIF0rL2cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGV2ZW50IGhhbmRsZXIsIGFwcGx5aW5nIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAvLyBsZXQgb25seSBhIHNpbmdsZSBoYW1tZXIgaW5zdGFuY2UgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgIGlmIChldmVudC50eXBlICE9PSAnaGFtbWVyLmlucHV0Jykge1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBzYW1lIHNyY0V2ZW50IGlzIHVzZWQgd2l0aCBtdWx0aXBsZSBoYW1tZXIgZXZlbnRzLFxuICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9uIHdoaWNoIGV2ZW50cyBhcmUgaGFuZGxlZCBpbiBhbiBvYmplY3QgX2hhbmRsZWRcbiAgICAgICAgaWYgKCFldmVudC5zcmNFdmVudC5faGFuZGxlZCkge1xuICAgICAgICAgIGV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWRbZXZlbnQudHlwZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWRbZXZlbnQudHlwZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGF0dGFjaCBhIHN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB0byB0aGUgZXZlbnRcbiAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgLy93cmFwIHRoZSBzcmNFdmVudCdzIHN0b3BQcm9wYWdhdGlvbiB0byBhbHNvIHN0b3AgaGFtbWVyIHByb3BhZ2F0aW9uOlxuICAgICAgdmFyIHNyY1N0b3AgPSBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24uYmluZChldmVudC5zcmNFdmVudCk7XG4gICAgICBpZih0eXBlb2Ygc3JjU3RvcCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICBzcmNTdG9wKCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYXR0YWNoIGZpcnN0VGFyZ2V0IHByb3BlcnR5IHRvIHRoZSBldmVudFxuICAgICAgZXZlbnQuZmlyc3RUYXJnZXQgPSBfZmlyc3RUYXJnZXQ7XG5cbiAgICAgIC8vIHByb3BhZ2F0ZSBvdmVyIGFsbCBlbGVtZW50cyAodW50aWwgc3RvcHBlZClcbiAgICAgIHZhciBlbGVtID0gX2ZpcnN0VGFyZ2V0O1xuICAgICAgd2hpbGUgKGVsZW0gJiYgIXN0b3BwZWQpIHtcbiAgICAgICAgdmFyIGVsZW1IYW1tZXIgPSBlbGVtLmhhbW1lcjtcbiAgICAgICAgaWYoZWxlbUhhbW1lcil7XG4gICAgICAgICAgdmFyIF9oYW5kbGVycztcbiAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgZWxlbUhhbW1lci5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICBfaGFuZGxlcnMgPSBlbGVtSGFtbWVyW2tdLl9oYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgICAgIGlmKF9oYW5kbGVycykgZm9yICh2YXIgaSA9IDA7IGkgPCBfaGFuZGxlcnMubGVuZ3RoICYmICFzdG9wcGVkOyBpKyspIHtcbiAgICAgICAgICAgICAgX2hhbmRsZXJzW2ldKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfTtcbn0pKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG59IGVsc2Uge1xuICAgIHdpbmRvd1tleHBvcnROYW1lXSA9IEhhbW1lcjtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuXG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIEVuZ2xpc2hcbmV4cG9ydHNbJ2VuJ10gPSB7XG4gIGVkaXQ6ICdFZGl0JyxcbiAgZGVsOiAnRGVsZXRlIHNlbGVjdGVkJyxcbiAgYmFjazogJ0JhY2snLFxuICBhZGROb2RlOiAnQWRkIE5vZGUnLFxuICBhZGRFZGdlOiAnQWRkIEVkZ2UnLFxuICBlZGl0Tm9kZTogJ0VkaXQgTm9kZScsXG4gIGVkaXRFZGdlOiAnRWRpdCBFZGdlJyxcbiAgYWRkRGVzY3JpcHRpb246ICdDbGljayBpbiBhbiBlbXB0eSBzcGFjZSB0byBwbGFjZSBhIG5ldyBub2RlLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLicsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICdDbGljayBvbiB0aGUgY29udHJvbCBwb2ludHMgYW5kIGRyYWcgdGhlbSB0byBhIG5vZGUgdG8gY29ubmVjdCB0byBpdC4nLFxuICBjcmVhdGVFZGdlRXJyb3I6ICdDYW5ub3QgbGluayBlZGdlcyB0byBhIGNsdXN0ZXIuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgY2Fubm90IGJlIGRlbGV0ZWQuJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ0NsdXN0ZXJzIGNhbm5vdCBiZSBlZGl0ZWQuJ1xufTtcbmV4cG9ydHNbJ2VuX0VOJ10gPSBleHBvcnRzWydlbiddO1xuZXhwb3J0c1snZW5fVVMnXSA9IGV4cG9ydHNbJ2VuJ107XG5cbi8vIEdlcm1hblxuZXhwb3J0c1snZGUnXSA9IHtcbiAgZWRpdDogJ0VkaXRpZXJlbicsXG4gIGRlbDogJ0xcXHhGNnNjaGUgQXVzd2FobCcsXG4gIGJhY2s6ICdadXJcXHhGQ2NrJyxcbiAgYWRkTm9kZTogJ0tub3RlbiBoaW56dWZcXHhGQ2dlbicsXG4gIGFkZEVkZ2U6ICdLYW50ZSBoaW56dWZcXHhGQ2dlbicsXG4gIGVkaXROb2RlOiAnS25vdGVuIGVkaXRpZXJlbicsXG4gIGVkaXRFZGdlOiAnS2FudGUgZWRpdGllcmVuJyxcbiAgYWRkRGVzY3JpcHRpb246ICdLbGlja2UgYXVmIGVpbmUgZnJlaWUgU3RlbGxlLCB1bSBlaW5lbiBuZXVlbiBLbm90ZW4genUgcGxhemllcmVuLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0tsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi4nLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnS2xpY2tlIGF1ZiBkaWUgVmVyYmluZHVuZ3NwdW5rdGUgdW5kIHppZWhlIGRpZXNlIGF1ZiBlaW5lbiBLbm90ZW4sIHVtIHNpZSB6dSB2ZXJiaW5kZW4uJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAnRXMgaXN0IG5pY2h0IG1cXHhGNmdsaWNoLCBLYW50ZW4gbWl0IENsdXN0ZXJuIHp1IHZlcmJpbmRlbi4nLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZ2VsXFx4RjZzY2h0IHdlcmRlbi4nLFxuICBlZGl0Q2x1c3RlckVycm9yOiAnQ2x1c3RlciBrXFx4RjZubmVuIG5pY2h0IGVkaXRpZXJ0IHdlcmRlbi4nXG59O1xuZXhwb3J0c1snZGVfREUnXSA9IGV4cG9ydHNbJ2RlJ107XG5cbi8vIFNwYW5pc2hcbmV4cG9ydHNbJ2VzJ10gPSB7XG4gIGVkaXQ6ICdFZGl0YXInLFxuICBkZWw6ICdFbGltaW5hciBzZWxlY2NpXFx4RjNuJyxcbiAgYmFjazogJ1xceEMxdHJhcycsXG4gIGFkZE5vZGU6ICdBXFx4RjFhZGlyIG5vZG8nLFxuICBhZGRFZGdlOiAnQVxceEYxYWRpciBhcmlzdGEnLFxuICBlZGl0Tm9kZTogJ0VkaXRhciBub2RvJyxcbiAgZWRpdEVkZ2U6ICdFZGl0YXIgYXJpc3RhJyxcbiAgYWRkRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gbHVnYXIgdmFjXFx4RURvIHBhcmEgY29sb2NhciB1biBudWV2byBub2RvLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0hhZ2EgY2xpYyBlbiB1biBub2RvIHkgYXJyYXN0cmUgbGEgYXJpc3RhIGhhY2lhIG90cm8gbm9kbyBwYXJhIGNvbmVjdGFybG9zLicsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby4nLFxuICBjcmVhdGVFZGdlRXJyb3I6ICdObyBzZSBwdWVkZSBjb25lY3RhciB1bmEgYXJpc3RhIGEgdW4gZ3J1cG8uJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnTm8gZXMgcG9zaWJsZSBlbGltaW5hciBncnVwb3MuJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ05vIGVzIHBvc2libGUgZWRpdGFyIGdydXBvcy4nXG59O1xuZXhwb3J0c1snZXNfRVMnXSA9IGV4cG9ydHNbJ2VzJ107XG5cbi8vSXRhbGlhbm9cbmV4cG9ydHNbJ2l0J10gPSB7XG4gIGVkaXQ6ICdNb2RpZmljYScsXG4gIGRlbDogJ0NhbmNlbGxhIGxhIHNlbGV6aW9uZScsXG4gIGJhY2s6ICdJbmRpZXRybycsXG4gIGFkZE5vZGU6ICdBZ2dpdW5naSB1biBub2RvJyxcbiAgYWRkRWRnZTogJ0FnZ2l1bmdpIHVuIHZlcnRpY2UnLFxuICBlZGl0Tm9kZTogJ01vZGlmaWNhIGlsIG5vZG8nLFxuICBlZGl0RWRnZTogJ01vZGlmaWNhIGlsIHZlcnRpY2UnLFxuICBhZGREZXNjcmlwdGlvbjogJ0NsaWNjYSBwZXIgYWdnaXVuZ2VyZSB1biBudW92byBub2RvJyxcbiAgZWRnZURlc2NyaXB0aW9uOiAnQ2xpY2NhIHN1IHVuIG5vZG8gZSB0cmFzY2luYWxvIGFkIHVuIGFsdHJvIG5vZG8gcGVyIGNvbm5ldHRlcmxpLicsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICdDbGljY2Egc3VpIFB1bnRpIGRpIGNvbnRyb2xsbyBlIHRyYXNjaW5hbGkgYWQgdW4gbm9kbyBwZXIgY29ubmV0dGVybGkuJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAnTm9uIHNpIHBvc3Nvbm8gY29sbGVnYXJlIHZlcnRpY2kgYWQgdW4gY2x1c3RlcicsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogJ0kgY2x1c3RlciBub24gcG9zc29ubyBlc3NlcmUgY2FuY2VsbGF0aScsXG4gIGVkaXRDbHVzdGVyRXJyb3I6ICdJIGNsdXN0ZXJzIG5vbiBwb3Nzb25vIGVzc2VyZSBtb2RpZmljYXRpLidcbn07XG5leHBvcnRzWydpdF9JVCddID0gZXhwb3J0c1snaXQnXTtcblxuLy8gRHV0Y2hcbmV4cG9ydHNbJ25sJ10gPSB7XG4gIGVkaXQ6ICdXaWp6aWdlbicsXG4gIGRlbDogJ1NlbGVjdGllIHZlcndpamRlcmVuJyxcbiAgYmFjazogJ1RlcnVnJyxcbiAgYWRkTm9kZTogJ05vZGUgdG9ldm9lZ2VuJyxcbiAgYWRkRWRnZTogJ0xpbmsgdG9ldm9lZ2VuJyxcbiAgZWRpdE5vZGU6ICdOb2RlIHdpanppZ2VuJyxcbiAgZWRpdEVkZ2U6ICdMaW5rIHdpanppZ2VuJyxcbiAgYWRkRGVzY3JpcHRpb246ICdLbGlrIG9wIGVlbiBsZWVnIGdlYmllZCBvbSBlZW4gbmlldXdlIG5vZGUgdGUgbWFrZW4uJyxcbiAgZWRnZURlc2NyaXB0aW9uOiAnS2xpayBvcCBlZW4gbm9kZSBlbiBzbGVlcCBkZSBsaW5rIG5hYXIgZWVuIGFuZGVyZSBub2RlIG9tIHplIHRlIHZlcmJpbmRlbi4nLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnS2xpayBvcCBkZSB2ZXJiaW5kaW5nc3B1bnRlbiBlbiBzbGVlcCB6ZSBuYWFyIGVlbiBub2RlIG9tIGRhYXJtZWUgdGUgdmVyYmluZGVuLicsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogJ0thbiBnZWVuIGxpbmsgbWFrZW4gbmFhciBlZW4gY2x1c3Rlci4nLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gdmVyd2lqZGVyZC4nLFxuICBlZGl0Q2x1c3RlckVycm9yOiAnQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIGFhbmdlcGFzdC4nXG59O1xuZXhwb3J0c1snbmxfTkwnXSA9IGV4cG9ydHNbJ25sJ107XG5leHBvcnRzWydubF9CRSddID0gZXhwb3J0c1snbmwnXTtcblxuLy8gUG9ydHVndWVzZSBCcmF6aWxcbmV4cG9ydHNbJ3B0LWJyJ10gPSB7XG4gIGVkaXQ6ICdFZGl0YXInLFxuICBkZWw6ICdSZW1vdmVyIHNlbGVjaW9uYWRvJyxcbiAgYmFjazogJ1ZvbHRhcicsXG4gIGFkZE5vZGU6ICdBZGljaW9uYXIgbsOzJyxcbiAgYWRkRWRnZTogJ0FkaWNpb25hciBhcmVzdGEnLFxuICBlZGl0Tm9kZTogJ0VkaXRhciBuw7MnLFxuICBlZGl0RWRnZTogJ0VkaXRhciBhcmVzdGEnLFxuICBhZGREZXNjcmlwdGlvbjogJ0NsaXF1ZSBlbSB1bSBlc3Bhw6dvIGVtIGJyYW5jbyBwYXJhIGFkaWNpb25hciB1bSBub3ZvIG7DsycsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaXF1ZSBlbSB1bSBuw7MgZSBhcnJhc3RlIGEgYXJlc3RhIGF0w6kgb3V0cm8gbsOzIHBhcmEgY29uZWN0w6EtbG9zJyxcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ0NsaXF1ZSBub3MgcG9udG9zIGRlIGNvbnRyb2xlIGUgb3MgYXJyYXN0ZSBwYXJhIHVtIG7DsyBwYXJhIGNvbmVjdMOhLWxvcycsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogJ07Do28gZm9pIHBvc3PDrXZlbCBsaW5rYXIgYXJlc3RhcyBhIHVtIGNsdXN0ZXIuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciByZW1vdmlkb3MuJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ0NsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgZWRpdGFkb3MuJ1xufTtcbmV4cG9ydHNbJ3B0LUJSJ10gPSBleHBvcnRzWydwdC1iciddO1xuZXhwb3J0c1sncHRfQlInXSA9IGV4cG9ydHNbJ3B0LWJyJ107XG5leHBvcnRzWydwdF9iciddID0gZXhwb3J0c1sncHQtYnInXTtcblxuLy8gUnVzc2lhblxuZXhwb3J0c1sncnUnXSA9IHtcbiAgZWRpdDogJ9Cg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMJyxcbiAgZGVsOiAn0KPQtNCw0LvQuNGC0Ywg0LLRi9Cx0YDQsNC90L3QvtC1JyxcbiAgYmFjazogJ9Cd0LDQt9Cw0LQnLFxuICBhZGROb2RlOiAn0JTQvtCx0LDQstC40YLRjCDRg9C30LXQuycsXG4gIGFkZEVkZ2U6ICfQlNC+0LHQsNCy0LjRgtGMINGA0LXQsdGA0L4nLFxuICBlZGl0Tm9kZTogJ9Cg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGD0LfQtdC7JyxcbiAgZWRpdEVkZ2U6ICfQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjCDRgNC10LHRgNC+JyxcbiAgYWRkRGVzY3JpcHRpb246ICfQmtC70LjQutC90LjRgtC1INCyINGB0LLQvtCx0L7QtNC90L7QtSDQvNC10YHRgtC+LCDRh9GC0L7QsdGLINC00L7QsdCw0LLQuNGC0Ywg0L3QvtCy0YvQuSDRg9C30LXQuy4nLFxuICBlZGdlRGVzY3JpcHRpb246ICfQmtC70LjQutC90LjRgtC1INC90LAg0YPQt9C10Lsg0Lgg0L/RgNC+0YLRj9C90LjRgtC1INGA0LXQsdGA0L4g0Log0LTRgNGD0LPQvtC80YMg0YPQt9C70YMsINGH0YLQvtCx0Ysg0YHQvtC10LTQuNC90LjRgtGMINC40YUuJyxcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ9Ca0LvQuNC60L3QuNGC0LUg0L3QsCDQutC+0L3RgtGA0L7Qu9GM0L3Ri9C1INGC0L7Rh9C60Lgg0Lgg0L/QtdGA0LXRgtCw0YnQuNGC0LUg0LjRhSDQsiDRg9C30LXQuywg0YfRgtC+0LHRiyDQv9C+0LTQutC70Y7Rh9C40YLRjNGB0Y8g0Log0L3QtdC80YMuJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAn0J3QtdCy0L7Qt9C80L7QttC90L4g0YHQvtC10LTQuNC90LjRgtGMINGA0LXQsdGA0LAg0LIg0LrQu9Cw0YHRgtC10YAuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAn0JrQu9Cw0YHRgtC10YDRiyDQvdC1INC80L7Qs9GD0YIg0LHRi9GC0Ywg0YPQtNCw0LvQtdC90YsnLFxuICBlZGl0Q2x1c3RlckVycm9yOiAn0JrQu9Cw0YHRgtC10YDRiyDQvdC10LTQvtGB0YLRg9C/0L3RiyDQtNC70Y8g0YDQtdC00LDQutGC0LjRgNC+0LLQsNC90LjRjy4nXG59O1xuZXhwb3J0c1sncnVfUlUnXSA9IGV4cG9ydHNbJ3J1J107XG5cbi8vIENoaW5lc2VcbmV4cG9ydHNbJ2NuJ10gPSB7XG4gIGVkaXQ6ICfnvJbovpEnLFxuICBkZWw6ICfliKDpmaTpgInlrponLFxuICBiYWNrOiAn6L+U5ZueJyxcbiAgYWRkTm9kZTogJ+a3u+WKoOiKgueCuScsXG4gIGFkZEVkZ2U6ICfmt7vliqDov57mjqXnur8nLFxuICBlZGl0Tm9kZTogJ+e8lui+keiKgueCuScsXG4gIGVkaXRFZGdlOiAn57yW6L6R6L+e5o6l57q/JyxcbiAgYWRkRGVzY3JpcHRpb246ICfljZXlh7vnqbrnmb3lpITmlL7nva7mlrDoioLngrnjgIInLFxuICBlZGdlRGVzY3JpcHRpb246ICfljZXlh7vmn5DkuKroioLngrnlubblsIbor6Xov57mjqXnur/mi5bliqjliLDlj6bkuIDkuKroioLngrnku6Xov57mjqXlroPku6zjgIInLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAn5Y2V5Ye75o6n5Yi26IqC54K55bm25bCG5a6D5Lus5ouW5Yiw6IqC54K55LiK6L+e5o6l44CCJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAn5peg5rOV5bCG6L+e5o6l57q/6L+e5o6l5Yiw576k6ZuG44CCJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAn5peg5rOV5Yig6Zmk576k6ZuG44CCJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ+aXoOazlee8lui+kee+pOmbhuOAgidcbn07XG5leHBvcnRzWyd6aF9DTiddID0gZXhwb3J0c1snY24nXTtcblxuLy8gVWtyYWluaWFuXG5leHBvcnRzWyd1ayddID0ge1xuICBlZGl0OiAn0KDQtdC00LDQs9GD0LLQsNGC0LgnLFxuICBkZWw6ICfQktC40LTQsNC70LjRgtC4INC+0LHRgNCw0L3QtScsXG4gIGJhY2s6ICfQndCw0LfQsNC0JyxcbiAgYWRkTm9kZTogJ9CU0L7QtNCw0YLQuCDQstGD0LfQvtC7JyxcbiAgYWRkRWRnZTogJ9CU0L7QtNCw0YLQuCDQutGA0LDQuScsXG4gIGVkaXROb2RlOiAn0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LLRg9C30L7QuycsXG4gIGVkaXRFZGdlOiAn0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LrRgNCw0LknLFxuICBhZGREZXNjcmlwdGlvbjogJ0vQu9GW0LrQvdGW0YLRjCDQvdCwINCy0ZbQu9GM0L3QtSDQvNGW0YHRhtC1LCDRidC+0LEg0LTQvtC00LDRgtC4INC90L7QstC40Lkg0LLRg9C30L7Quy4nLFxuICBlZGdlRGVzY3JpcHRpb246IFwi0JrQu9GW0LrQvdGW0YLRjCDQvdCwINCy0YPQt9C+0Lsg0ZYg0L/QtdGA0LXRgtGP0LPQvdGW0YLRjCDQutGA0LDQuSDQtNC+INGW0L3RiNC+0LPQviDQstGD0LfQu9CwLCDRidC+0LEg0ZfRhSDQtyfRlNC00L3QsNGC0LguXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICfQmtC70ZbQutC90ZbRgtGMINC90LAg0LrQvtC90YLRgNC+0LvRjNC90ZYg0YLQvtGH0LrQuCDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINGX0YUg0YMg0LLRg9C30L7Quywg0YnQvtCxINC/0ZbQtNC60LvRjtGH0LjRgtC40YHRjyDQtNC+INC90YzQvtCz0L4uJyxcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LUg0LzQvtC20LvQuNCy0L4g0L7QsSfRlNC00L3QsNGC0Lgg0LrRgNCw0Zcg0LIg0LPRgNGD0L/Rgy5cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAn0JPRgNGD0L/QuCDQvdC1INC80L7QttGD0YLRjCDQsdGD0YLQuCDQstC40LTQsNC70LXQvdGWLicsXG4gIGVkaXRDbHVzdGVyRXJyb3I6ICfQk9GA0YPQv9C4INC90LXQtNC+0YHRgtGD0L/QvdGWINC00LvRjyDRgNC10LTQsNCz0YPQstCw0L3QvdGPLidcbn07XG5leHBvcnRzWyd1a19VQSddID0gZXhwb3J0c1sndWsnXTtcblxuLy8gRnJlbmNoXG5leHBvcnRzWydmciddID0ge1xuICBlZGl0OiAnRWRpdGVyJyxcbiAgZGVsOiAnRWZmYWNlciBsYSBzZWxlY3Rpb24nLFxuICBiYWNrOiAnUmV0b3VyJyxcbiAgYWRkTm9kZTogJ0Fqb3V0ZXIgdW4gbm9ldWQnLFxuICBhZGRFZGdlOiAnQWpvdXRlciB1biBsaWVuJyxcbiAgZWRpdE5vZGU6ICdFZGl0ZXIgbGUgbm9ldWQnLFxuICBlZGl0RWRnZTogJ0VkaXRlciBsZSBsaWVuJyxcbiAgYWRkRGVzY3JpcHRpb246ICdDbGlxdWV6IGRhbnMgdW4gZW5kcm9pdCB2aWRlIHBvdXIgcGxhY2VyIHVuIG5vZXVkLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaXF1ZXogc3VyIHVuIG5vZXVkIGV0IGdsaXNzZXogbGUgbGllbiB2ZXJzIHVuIGF1dHJlIG5vZXVkIHBvdXIgbGVzIGNvbm5lY3Rlci4nLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnQ2xpcXVleiBzdXIgbGVzIHBvaW50cyBkZSBjb250csO0bGUgZXQgZ2xpc3Nlei1sZXMgcG91ciBjb25uZWN0ZXIgdW4gbm9ldWQuJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAnSW1wb3NzaWJsZSBkZSBjcsOpZXIgdW4gbGllbiB2ZXJzIHVuIGNsdXN0ZXIuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZmZhY8Opcy4nLFxuICBlZGl0Q2x1c3RlckVycm9yOiAnTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZGl0ZXMuJ1xufTtcbmV4cG9ydHNbJ2ZyX0ZSJ10gPSBleHBvcnRzWydmciddO1xuXG4vKioqLyB9KSxcbi8qIDEzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTMxKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDEzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEzMik7XG52YXIgJE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNikuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIV9fd2VicGFja19yZXF1aXJlX18oMTMpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogX193ZWJwYWNrX3JlcXVpcmVfXygxMikuZiB9KTtcblxuXG4vKioqLyB9KSxcbi8qIDEzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGEgY2FudmFzIHRvIGEgZ2l2ZW4gaW1hZ2UsIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcmVuZGVyaW5nc1xuICogb2YgdGhlIGltYWdlIGF0IHZhcmlvdXMgc2l6ZXMuXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgaXMga25vd24gYXMgJ21pcG1hcHBpbmcnLlxuICpcbiAqIE5PVEU6IEltYWdlcyBjYW4gYWxzbyBiZSBvZiB0eXBlICdkYXRhOnN2Zyt4bWxgLiBUaGlzIGNvZGUgYWxzbyB3b3Jrc1xuICogICAgICAgZm9yIHN2ZywgYnV0IHRoZSBtaXBtYXBwaW5nIG1heSBub3QgYmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKi9cbnZhciBDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIENhY2hlZEltYWdlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENhY2hlZEltYWdlKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aGlzLk5VTV9JVEVSQVRJT05TID0gNDsgLy8gTnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjb29yZGluYXRlcyBhcnJheVxuXG4gICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGltYWdlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2FjaGVkSW1hZ2UsIFt7XG4gICAga2V5OiAnaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47XG5cbiAgICAgIHRoaXMuc3JjID0gdGhpcy5pbWFnZS5zcmM7IC8vIEZvciBzYW1lIGludGVyZmFjZSB3aXRoIEltYWdlXG4gICAgICB2YXIgdyA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgICB2YXIgaCA9IHRoaXMuaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAvLyBFYXNlIGV4dGVybmFsIGFjY2Vzc1xuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG5cbiAgICAgIHZhciBoMiA9IE1hdGguZmxvb3IoaCAvIDIpO1xuICAgICAgdmFyIGg0ID0gTWF0aC5mbG9vcihoIC8gNCk7XG4gICAgICB2YXIgaDggPSBNYXRoLmZsb29yKGggLyA4KTtcbiAgICAgIHZhciBoMTYgPSBNYXRoLmZsb29yKGggLyAxNik7XG5cbiAgICAgIHZhciB3MiA9IE1hdGguZmxvb3IodyAvIDIpO1xuICAgICAgdmFyIHc0ID0gTWF0aC5mbG9vcih3IC8gNCk7XG4gICAgICB2YXIgdzggPSBNYXRoLmZsb29yKHcgLyA4KTtcbiAgICAgIHZhciB3MTYgPSBNYXRoLmZsb29yKHcgLyAxNik7XG5cbiAgICAgIC8vIE1ha2UgY2FudmFzIGFzIHNtYWxsIGFzIHBvc3NpYmxlXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDMgKiB3NDtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGgyO1xuXG4gICAgICAvLyBDb29yZGluYXRlcyBhbmQgc2l6ZXMgb2YgaW1hZ2VzIGNvbnRhaW5lZCBpbiB0aGUgY2FudmFzXG4gICAgICAvLyBWYWx1ZXMgcGVyIHJvdzogIFt0b3AgeCwgbGVmdCB5LCB3aWR0aCwgaGVpZ2h0XVxuXG4gICAgICB0aGlzLmNvb3JkaW5hdGVzID0gW1swLCAwLCB3MiwgaDJdLCBbdzIsIDAsIHc0LCBoNF0sIFt3MiwgaDQsIHc4LCBoOF0sIFs1ICogdzgsIGg0LCB3MTYsIGgxNl1dO1xuXG4gICAgICB0aGlzLl9maWxsTWlwTWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpbml0KCkgaGFzIGJlZW4gY2FsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBtYWluIGltYWdlIGluIHZhcmlvdXMgc2l6ZXMgdG8gdGhlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBUaGUgcmF0aW9uYWxlIGJlaGluZCB0aGlzIGlzIHRvIHJlZHVjZSBhcnRlZmFjdHMgZHVlIHRvIGludGVycG9sYXRpb25cbiAgICAgKiBhdCBkaWZmZXJpbmcgem9vbSBsZXZlbHMuXG4gICAgICpcbiAgICAgKiBTb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4NzYxNDA0LzEyMjM1MzFcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kcyB0YWtlcyB0aGUgcmVzaXppbmcgb3V0IG9mIHRoZSBkcmF3aW5nIGxvb3AsIGluIG9yZGVyIHRvXG4gICAgICogcmVkdWNlIHBlcmZvcm1hbmNlIG92ZXJoZWFkLlxuICAgICAqXG4gICAgICogVE9ETzogVGhlIGNvZGUgYXNzdW1lcyB0aGF0IGEgMkQgY29udGV4dCBjYW4gYWx3YXlzIGJlIGdvdHRlbi4gVGhpcyBpc1xuICAgICAqICAgICAgIG5vdCBuZWNlc3NhcmlseSB0cnVlISBPVE9ILCBpZiBub3QgdHJ1ZSB0aGVuIHVzYWdlIG9mIHRoaXMgY2xhc3NcbiAgICAgKiAgICAgICBpcyBzZW5zZWxlc3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmlsbE1pcE1hcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maWxsTWlwTWFwKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIC8vIEZpcnN0IHpvb20tbGV2ZWwgY29tZXMgZnJvbSB0aGUgaW1hZ2VcbiAgICAgIHZhciB0byA9IHRoaXMuY29vcmRpbmF0ZXNbMF07XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIHRvWzBdLCB0b1sxXSwgdG9bMl0sIHRvWzNdKTtcblxuICAgICAgLy8gVGhlIHJlc3QgYXJlIGNvcHkgYWN0aW9ucyBpbnRlcm5hbCB0byB0aGUgY2FudmFzL2NvbnRleHRcbiAgICAgIGZvciAodmFyIGl0ZXJhdGlvbnMgPSAxOyBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUzsgaXRlcmF0aW9ucysrKSB7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zIC0gMV07XG4gICAgICAgIHZhciBfdG8gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnNdO1xuXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIF90b1swXSwgX3RvWzFdLCBfdG9bMl0sIF90b1szXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgaW1hZ2UsIHVzaW5nIHRoZSBtaXBtYXAgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogTWlwTWFwIGlzIG9ubHkgdXNlZCBpZiBwYXJhbSBmYWN0b3IgPiAyOyBvdGhlcndpc2UsIG9yaWdpbmFsIGJpdG1hcFxuICAgICAqIGlzIHJlc2l6ZWQuIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNraXAgbWlwbWFwIHVzYWdlLCBlLmcuIGJ5IHNldHRpbmcgZmFjdG9yID0gMVxuICAgICAqXG4gICAgICogQ3JlZGl0cyB0byAnQWxleCBkZSBNdWxkZXInIGZvciBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIGNvbnRleHQgb24gd2hpY2ggdG8gZHJhdyB6b29tZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBmYWN0b3Igc2NhbGUgZmFjdG9yIGF0IHdoaWNoIHRvIGRyYXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXdJbWFnZUF0UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgZmFjdG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47IC8vY2FuJ3QgZHJhdyBpbWFnZSB5ZXQgbm90IGludGlhbGl6ZWRcblxuICAgICAgaWYgKGZhY3RvciA+IDIpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHpvb21lZCBpbWFnZSB0byB1c2VcbiAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB3aGlsZSAoZmFjdG9yID4gMiAmJiBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPj0gdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLk5VTV9JVEVSQVRJT05TIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiaXRlcmF0aW9uczogXCIgKyBpdGVyYXRpb25zKTtcblxuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9uc107XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGltYWdlIGRpcmVjdGx5XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhY2hlZEltYWdlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDYWNoZWRJbWFnZTtcblxuLyoqKi8gfSksXG4vKiAxMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNhbiBzdG9yZSBncm91cHMgYW5kIG9wdGlvbnMgc3BlY2lmaWMgZm9yIGdyb3Vwcy5cbiAqL1xuXG52YXIgR3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gR3JvdXBzKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEdyb3Vwcyk7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5kZWZhdWx0SW5kZXggPSAwO1xuICAgIHRoaXMuZ3JvdXBzQXJyYXkgPSBbXTtcbiAgICB0aGlzLmdyb3VwSW5kZXggPSAwO1xuXG4gICAgdGhpcy5kZWZhdWx0R3JvdXBzID0gW3tcbiAgICAgIGJvcmRlcjogJyMyQjdDRTknLFxuICAgICAgYmFja2dyb3VuZDogJyM5N0MyRkMnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyMyQjdDRTknLCBiYWNrZ3JvdW5kOiAnI0QyRTVGRicgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyMyQjdDRTknLCBiYWNrZ3JvdW5kOiAnI0QyRTVGRicgfVxuICAgIH0sIC8vIDA6IGJsdWVcbiAgICB7XG4gICAgICBib3JkZXI6ICcjRkZBNTAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkZGRjAwJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRkZBNTAwJywgYmFja2dyb3VuZDogJyNGRkZGQTMnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRkZBNTAwJywgYmFja2dyb3VuZDogJyNGRkZGQTMnIH1cbiAgICB9LCAvLyAxOiB5ZWxsb3dcbiAgICB7XG4gICAgICBib3JkZXI6ICcjRkEwQTEwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkI3RTgxJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRkEwQTEwJywgYmFja2dyb3VuZDogJyNGRkFGQjEnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRkEwQTEwJywgYmFja2dyb3VuZDogJyNGRkFGQjEnIH1cbiAgICB9LCAvLyAyOiByZWRcbiAgICB7XG4gICAgICBib3JkZXI6ICcjNDFBOTA2JyxcbiAgICAgIGJhY2tncm91bmQ6ICcjN0JFMTQxJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjNDFBOTA2JywgYmFja2dyb3VuZDogJyNBMUVDNzYnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjNDFBOTA2JywgYmFja2dyb3VuZDogJyNBMUVDNzYnIH1cbiAgICB9LCAvLyAzOiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNFMTI5RjAnLFxuICAgICAgYmFja2dyb3VuZDogJyNFQjdERjQnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNFMTI5RjAnLCBiYWNrZ3JvdW5kOiAnI0YwQjNGNScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNFMTI5RjAnLCBiYWNrZ3JvdW5kOiAnI0YwQjNGNScgfVxuICAgIH0sIC8vIDQ6IG1hZ2VudGFcbiAgICB7XG4gICAgICBib3JkZXI6ICcjN0MyOUYwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjQUQ4NUU0JyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjN0MyOUYwJywgYmFja2dyb3VuZDogJyNEM0JERjAnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjN0MyOUYwJywgYmFja2dyb3VuZDogJyNEM0JERjAnIH1cbiAgICB9LCAvLyA1OiBwdXJwbGVcbiAgICB7XG4gICAgICBib3JkZXI6ICcjQzM3RjAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkZBODA3JyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjQzM3RjAwJywgYmFja2dyb3VuZDogJyNGRkNBNjYnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjQzM3RjAwJywgYmFja2dyb3VuZDogJyNGRkNBNjYnIH1cbiAgICB9LCAvLyA2OiBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6ICcjNDIyMEZCJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjNkU2RUZEJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjNDIyMEZCJywgYmFja2dyb3VuZDogJyM5QjlCRkQnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjNDIyMEZCJywgYmFja2dyb3VuZDogJyM5QjlCRkQnIH1cbiAgICB9LCAvLyA3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNGRDVBNzcnLFxuICAgICAgYmFja2dyb3VuZDogJyNGRkMwQ0InLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNGRDVBNzcnLCBiYWNrZ3JvdW5kOiAnI0ZGRDFEOScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNGRDVBNzcnLCBiYWNrZ3JvdW5kOiAnI0ZGRDFEOScgfVxuICAgIH0sIC8vIDg6IHBpbmtcbiAgICB7XG4gICAgICBib3JkZXI6ICcjNEFENjNBJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjQzJGQUJDJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjNEFENjNBJywgYmFja2dyb3VuZDogJyNFNkZGRTMnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjNEFENjNBJywgYmFja2dyb3VuZDogJyNFNkZGRTMnIH1cbiAgICB9LCAvLyA5OiBtaW50XG5cbiAgICB7XG4gICAgICBib3JkZXI6ICcjOTkwMDAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRUUwMDAwJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjQkIwMDAwJywgYmFja2dyb3VuZDogJyNGRjMzMzMnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjQkIwMDAwJywgYmFja2dyb3VuZDogJyNGRjMzMzMnIH1cbiAgICB9LCAvLyAxMDpicmlnaHQgcmVkXG5cbiAgICB7XG4gICAgICBib3JkZXI6ICcjRkY2MDAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkY2MDAwJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRkY2MDAwJywgYmFja2dyb3VuZDogJyNGRjYwMDAnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRkY2MDAwJywgYmFja2dyb3VuZDogJyNGRjYwMDAnIH1cbiAgICB9LCAvLyAxMjogcmVhbCBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6ICcjOTdDMkZDJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjMkI3Q0U5JyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRDJFNUZGJywgYmFja2dyb3VuZDogJyMyQjdDRTknIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRDJFNUZGJywgYmFja2dyb3VuZDogJyMyQjdDRTknIH1cbiAgICB9LCAvLyAxMzogYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyMzOTk2MDUnLFxuICAgICAgYmFja2dyb3VuZDogJyMyNTVDMDMnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyMzOTk2MDUnLCBiYWNrZ3JvdW5kOiAnIzI1NUMwMycgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyMzOTk2MDUnLCBiYWNrZ3JvdW5kOiAnIzI1NUMwMycgfVxuICAgIH0sIC8vIDE0OiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNCNzAwNTQnLFxuICAgICAgYmFja2dyb3VuZDogJyNGRjAwN0UnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNCNzAwNTQnLCBiYWNrZ3JvdW5kOiAnI0ZGMDA3RScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNCNzAwNTQnLCBiYWNrZ3JvdW5kOiAnI0ZGMDA3RScgfVxuICAgIH0sIC8vIDE1OiBtYWdlbnRhXG4gICAge1xuICAgICAgYm9yZGVyOiAnI0FEODVFNCcsXG4gICAgICBiYWNrZ3JvdW5kOiAnIzdDMjlGMCcsXG4gICAgICBoaWdobGlnaHQ6IHsgYm9yZGVyOiAnI0QzQkRGMCcsIGJhY2tncm91bmQ6ICcjN0MyOUYwJyB9LFxuICAgICAgaG92ZXI6IHsgYm9yZGVyOiAnI0QzQkRGMCcsIGJhY2tncm91bmQ6ICcjN0MyOUYwJyB9XG4gICAgfSwgLy8gMTY6IHB1cnBsZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyM0NTU3RkEnLFxuICAgICAgYmFja2dyb3VuZDogJyMwMDBFQTEnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyM2RTZFRkQnLCBiYWNrZ3JvdW5kOiAnIzAwMEVBMScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyM2RTZFRkQnLCBiYWNrZ3JvdW5kOiAnIzAwMEVBMScgfVxuICAgIH0sIC8vIDE3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNGRkMwQ0InLFxuICAgICAgYmFja2dyb3VuZDogJyNGRDVBNzcnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNGRkQxRDknLCBiYWNrZ3JvdW5kOiAnI0ZENUE3NycgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNGRkQxRDknLCBiYWNrZ3JvdW5kOiAnI0ZENUE3NycgfVxuICAgIH0sIC8vIDE4OiBwaW5rXG4gICAge1xuICAgICAgYm9yZGVyOiAnI0MyRkFCQycsXG4gICAgICBiYWNrZ3JvdW5kOiAnIzc0RDY2QScsXG4gICAgICBoaWdobGlnaHQ6IHsgYm9yZGVyOiAnI0U2RkZFMycsIGJhY2tncm91bmQ6ICcjNzRENjZBJyB9LFxuICAgICAgaG92ZXI6IHsgYm9yZGVyOiAnI0U2RkZFMycsIGJhY2tncm91bmQ6ICcjNzRENjZBJyB9XG4gICAgfSwgLy8gMTk6IG1pbnRcblxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNFRTAwMDAnLFxuICAgICAgYmFja2dyb3VuZDogJyM5OTAwMDAnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNGRjMzMzMnLCBiYWNrZ3JvdW5kOiAnI0JCMDAwMCcgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNGRjMzMzMnLCBiYWNrZ3JvdW5kOiAnI0JCMDAwMCcgfSAvLyAyMDpicmlnaHQgcmVkXG4gICAgfV07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdXNlRGVmYXVsdEdyb3VwczogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEdyb3VwcywgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9uRmllbGRzID0gWyd1c2VEZWZhdWx0R3JvdXBzJ107XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgZ3JvdXBOYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uRmllbGRzLmluZGV4T2YoZ3JvdXBOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgdmFyIGdyb3VwID0gb3B0aW9uc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgICB0aGlzLmFkZChncm91cE5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JvdXBzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgdGhpcy5ncm91cHNBcnJheSA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBncm91cCBvcHRpb25zIG9mIGEgZ3JvdXBuYW1lLlxuICAgICAqIElmIGdyb3VwbmFtZSBpcyBub3QgZm91bmQsIGEgbmV3IGdyb3VwIG1heSBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBncm91cG5hbWUgICAgIENhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBEYXRlLCBldGMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkQ3JlYXRlPXRydWVdIElmIHRydWUsIGNyZWF0ZSBhIG5ldyBncm91cFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZvdW5kIG9yIGNyZWF0ZWQgZ3JvdXBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGdyb3VwbmFtZSkge1xuICAgICAgdmFyIHNob3VsZENyZWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBuYW1lXTtcblxuICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgJiYgc2hvdWxkQ3JlYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlRGVmYXVsdEdyb3VwcyA9PT0gZmFsc2UgJiYgdGhpcy5ncm91cHNBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ3JvdXBJbmRleCAlIHRoaXMuZ3JvdXBzQXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ3JvdXBJbmRleCsrO1xuICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgZ3JvdXAuY29sb3IgPSB0aGlzLmdyb3Vwc1t0aGlzLmdyb3Vwc0FycmF5W2luZGV4XV07XG4gICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBuYW1lXSA9IGdyb3VwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZ3JvdXBcbiAgICAgICAgICB2YXIgX2luZGV4ID0gdGhpcy5kZWZhdWx0SW5kZXggJSB0aGlzLmRlZmF1bHRHcm91cHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZGVmYXVsdEluZGV4Kys7XG4gICAgICAgICAgZ3JvdXAgPSB7fTtcbiAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuZGVmYXVsdEdyb3Vwc1tfaW5kZXhdO1xuICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwbmFtZV0gPSBncm91cDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY3VzdG9tIGdyb3VwIHN0eWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBib3JkZXJDb2xvcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLCBldGMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBncm91cCAgICAgIFRoZSBjcmVhdGVkIGdyb3VwIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZ3JvdXBOYW1lLCBzdHlsZSkge1xuICAgICAgdGhpcy5ncm91cHNbZ3JvdXBOYW1lXSA9IHN0eWxlO1xuICAgICAgdGhpcy5ncm91cHNBcnJheS5wdXNoKGdyb3VwTmFtZSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBHcm91cHM7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEdyb3VwcztcblxuLyoqKi8gfSksXG4vKiAxMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNClbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBOb2Rlc1xuICovXG5cbnZhciBOb2Rlc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0ltYWdlc30gaW1hZ2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPEdyb3VwPn0gZ3JvdXBzXG4gICAqIEBwYXJhbSB7TGF5b3V0RW5naW5lfSBsYXlvdXRFbmdpbmVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVzSGFuZGxlcihib2R5LCBpbWFnZXMsIGdyb3VwcywgbGF5b3V0RW5naW5lKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE5vZGVzSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICAgIHRoaXMubGF5b3V0RW5naW5lID0gbGF5b3V0RW5naW5lO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBub2RlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5ub2Rlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zLCBwYXJhbXMuZGF0YSwgcGFyYW1zLm9sZERhdGEpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IDIsXG4gICAgICBicm9rZW5JbWFnZTogdW5kZWZpbmVkLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgYm9yZGVyOiAnIzJCN0NFOScsXG4gICAgICAgIGJhY2tncm91bmQ6ICcjOTdDMkZDJyxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiAnIzJCN0NFOScsXG4gICAgICAgICAgYmFja2dyb3VuZDogJyNEMkU1RkYnXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYm9yZGVyOiAnIzJCN0NFOScsXG4gICAgICAgICAgYmFja2dyb3VuZDogJyNEMkU1RkYnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaXhlZDoge1xuICAgICAgICB4OiBmYWxzZSxcbiAgICAgICAgeTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiAnIzM0MzQzNCcsXG4gICAgICAgIHNpemU6IDE0LCAvLyBweFxuICAgICAgICBmYWNlOiAnYXJpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLCAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIHZhZGp1c3Q6IDAsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogJ2JvbGQnXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiAnYm9sZCBpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIGl0YWw6IHtcbiAgICAgICAgICBtb2Q6ICdpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6ICcnLFxuICAgICAgICAgIHNpemU6IDE1LCAvLyBweFxuICAgICAgICAgIGZhY2U6ICdtb25vc3BhY2UnLFxuICAgICAgICAgIHZhZGp1c3Q6IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgaWNvbjoge1xuICAgICAgICBmYWNlOiAnRm9udEF3ZXNvbWUnLCAvLydGb250QXdlc29tZScsXG4gICAgICAgIGNvZGU6IHVuZGVmaW5lZCwgLy8nXFx1ZjAwNycsXG4gICAgICAgIHNpemU6IDUwLCAvLzUwLFxuICAgICAgICBjb2xvcjogJyMyQjdDRTknIC8vJyNhYTAwZmYnXG4gICAgICB9LFxuICAgICAgaW1hZ2U6IHVuZGVmaW5lZCwgLy8gLS0+IFVSTFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgIGxldmVsOiB1bmRlZmluZWQsXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgdG9wOiA1LFxuICAgICAgICByaWdodDogNSxcbiAgICAgICAgYm90dG9tOiA1LFxuICAgICAgICBsZWZ0OiA1XG4gICAgICB9LFxuICAgICAgbWFzczogMSxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMTAsXG4gICAgICAgIG1heDogMzAsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIG1heFZpc2libGU6IDMwLFxuICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiBmdW5jdGlvbiBjdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICB4OiA1LFxuICAgICAgICB5OiA1XG4gICAgICB9LFxuICAgICAgc2hhcGU6ICdlbGxpcHNlJyxcbiAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICBib3JkZXJEYXNoZXM6IGZhbHNlLCAvLyBvbmx5IGZvciBib3JkZXJzXG4gICAgICAgIGJvcmRlclJhZGl1czogNiwgLy8gb25seSBmb3IgYm94IHNoYXBlXG4gICAgICAgIGludGVycG9sYXRpb246IHRydWUsIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICB1c2VJbWFnZVNpemU6IGZhbHNlLCAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiBmYWxzZSAvLyBvbmx5IGZvciBpbWFnZSBzaGFwZVxuICAgICAgfSxcbiAgICAgIHNpemU6IDI1LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB4OiB1bmRlZmluZWQsXG4gICAgICB5OiB1bmRlZmluZWRcblxuICAgICAgLy8gUHJvdGVjdCBmcm9tIGlkaW9jeVxuICAgIH07aWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMubWFzcyA8PSAwKSB7XG4gICAgICB0aHJvdyAnSW50ZXJuYWwgZXJyb3I6IG1hc3MgaW4gZGVmYXVsdE9wdGlvbnMgb2YgTm9kZXNIYW5kbGVyIG1heSBub3QgYmUgemVybyBvciBuZWdhdGl2ZSc7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5icmlkZ2VPYmplY3QodGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKE5vZGVzSGFuZGxlciwgW3tcbiAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gcmVmcmVzaCB0aGUgbm9kZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaE5vZGVzJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMi5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLm5vZGVzKSBfdGhpczIuYm9keS5kYXRhLm5vZGVzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE5vZGUucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzaGFwZSBpbiBhbGwgbm9kZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hhcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS51cGRhdGVTaGFwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZm9udCBpbiBhbGwgbm9kZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHNoYXBlIHNpemUgaW4gYWxsIG5vZGVzXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBkYXRhIHNldCB3aXRoIG5vZGVzIGZvciB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IG5vZGVzICAgICAgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgbm9kZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldERhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKG5vZGVzKSB7XG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyIG9sZE5vZGVzRGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzO1xuXG4gICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IG5vZGVzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBub2RlcztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5hZGQobm9kZXMpO1xuICAgICAgfSBlbHNlIGlmICghbm9kZXMpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkTm9kZXNEYXRhKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBvbGROb2Rlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZHJhd24gbm9kZXNcbiAgICAgIHRoaXMuYm9keS5ub2RlcyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5ib2R5LmRhdGEubm9kZXMpIHtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgbWUuYm9keS5kYXRhLm5vZGVzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgaWQgPSB2b2lkIDA7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldChpZCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGUocHJvcGVydGllcyk7XG4gICAgICAgIG5ld05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tpZF0gPSBub2RlOyAvLyBub3RlOiB0aGlzIG1heSByZXBsYWNlIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXlvdXRFbmdpbmUucG9zaXRpb25Jbml0aWFsbHkobmV3Tm9kZXMpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3Rpbmcgbm9kZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzIGlkJ3Mgb2YgY2hhbmdlZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZWREYXRhIGFycmF5IHdpdGggY2hhbmdlZCBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR9IG9sZERhdGEgb3B0aW9uYWw7IGFycmF5IHdpdGggcHJldmlvdXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMsIGNoYW5nZWREYXRhLCBvbGREYXRhKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZF07XG4gICAgICAgIHZhciBkYXRhID0gY2hhbmdlZERhdGFbaV07XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgbm9kZVxuICAgICAgICAgIGlmIChub2RlLnNldE9wdGlvbnMoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIGNyZWF0ZSBub2RlXG4gICAgICAgICAgbm9kZSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgIG5vZGVzW2lkXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhQ2hhbmdlZCAmJiBvbGREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjaGFuZ2VzIHdoaWNoIHNob3VsZCB0cmlnZ2VyIGEgbGF5b3V0IHJlY2FsY3VsYXRpb25cbiAgICAgICAgLy8gRm9yIG5vdywgdGhpcyBpcyBqdXN0ICdsZXZlbCcgZm9yIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgLy8gQXNzdW1wdGlvbjogb2xkIGFuZCBuZXcgZGF0YSBhcnJhbmdlZCBpbiBzYW1lIG9yZGVyOyBhdCB0aW1lIG9mIHdyaXRpbmcsIHRoaXMgaG9sZHMuXG4gICAgICAgIGRhdGFDaGFuZ2VkID0gY2hhbmdlZERhdGEuc29tZShmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkRGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlICYmIG9sZFZhbHVlLmxldmVsICE9PSBuZXdWYWx1ZS5sZXZlbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhVXBkYXRlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBleGlzdGluZyBub2Rlcy4gSWYgbm9kZXMgZG8gbm90IGV4aXN0LCB0aGUgbWV0aG9kIHdpbGwganVzdCBpZ25vcmUgaXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgZGVsZXRlIG5vZGVzW2lkXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtjbGFzc30gW2NvbnN0cnVjdG9yQ2xhc3M9Tm9kZS5kZWZhdWx0XVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yQ2xhc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE5vZGU7XG5cbiAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3JDbGFzcyhwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsZWFyUG9zaXRpb25zPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xlYXJQb3NpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXMzLmJvZHkuZGF0YS5ub2Rlcy5nZXQobm9kZUlkKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjbGVhclBvc2l0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHsgeDogbnVsbCwgeTogbnVsbCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHsgZml4ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlLmlkPnxTdHJpbmd9IFtpZHNdICAtLT4gb3B0aW9uYWwsIGNhbiBiZSBhcnJheSBvZiBub2RlSWRzLCBjYW4gYmUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoaWRzKSB7XG4gICAgICB2YXIgZGF0YUFycmF5ID0ge307XG4gICAgICBpZiAoaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWRzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNbaV1dO1xuICAgICAgICAgICAgICBkYXRhQXJyYXlbaWRzW2ldXSA9IHsgeDogTWF0aC5yb3VuZChub2RlLngpLCB5OiBNYXRoLnJvdW5kKG5vZGUueSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZHNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNdO1xuICAgICAgICAgICAgZGF0YUFycmF5W2lkc10gPSB7IHg6IE1hdGgucm91bmQoX25vZGUueCksIHk6IE1hdGgucm91bmQoX25vZGUueSkgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlMiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbX2ldXTtcbiAgICAgICAgICBkYXRhQXJyYXlbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV0gPSB7XG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKF9ub2RlMi54KSxcbiAgICAgICAgICAgIHk6IE1hdGgucm91bmQoX25vZGUyLnkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBYWSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGludG8gdGhlIGRhdGFzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3JlUG9zaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcmVQb3NpdGlvbnMoKSB7XG4gICAgICAvLyB0b2RvOiBhZGQgc3VwcG9ydCBmb3IgY2x1c3RlcnMgYW5kIGhpZXJhcmNoaWNhbC5cbiAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gZGF0YXNldC5fZGF0YSkge1xuICAgICAgICBpZiAoZGF0YXNldC5fZGF0YS5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBpZiAoZGF0YXNldC5fZGF0YVtub2RlSWRdLnggIT0gTWF0aC5yb3VuZChub2RlLngpIHx8IGRhdGFzZXQuX2RhdGFbbm9kZUlkXS55ICE9IE1hdGgucm91bmQobm9kZS55KSkge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goe1xuICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChub2RlLngpLFxuICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG5vZGUueSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0YXNldC51cGRhdGUoZGF0YUFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhIG5vZGUuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7anwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNoYXBlLmJvdW5kaW5nQm94O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSWRzIG9mIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0geyd0byd8J2Zyb20nfHVuZGVmaW5lZH0gZGlyZWN0aW9uIHZhbHVlcyAnZnJvbScgYW5kICd0bycgc2VsZWN0IHJlc3BlY3RpdmVseSBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzIG9ubHkuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbnkgb3RoZXIgdmFsdWUgcmV0dXJucyBib3RoIHBhcmVudCBhbmQgY2hpbGQgbm9kZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb25uZWN0ZWROb2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKG5vZGVJZCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIHZhciBub2RlT2JqID0ge307IC8vIHVzZWQgdG8gcXVpY2tseSBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAndG8nICYmIGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG91YmxlIGVxdWFscyBzaW5jZSBpZHMgY2FuIGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLmZyb21JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLmZyb21JZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICE9PSAnZnJvbScgJiYgZWRnZS5mcm9tSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS50b0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLnRvSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkcyBvZiB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb25uZWN0ZWRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZEVkZ2VzKG5vZGVJZCkge1xuICAgICAgdmFyIGVkZ2VMaXN0ID0gW107XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlZGdlTGlzdC5wdXNoKG5vZGUuZWRnZXNbaV0uaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnTm9kZUlkIHByb3ZpZGVkIGZvciBnZXRDb25uZWN0ZWRFZGdlcyBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6ICcsIG5vZGVJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRnZUxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTm9kZShub2RlSWQsIHgsIHkpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS54ID0gTnVtYmVyKHgpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55ID0gTnVtYmVyKHkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOb2RlIGlkIHN1cHBsaWVkIHRvIG1vdmVOb2RlIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogJywgbm9kZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVzSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTm9kZXNIYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDEzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTM3KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDEzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbl9fd2VicGFja19yZXF1aXJlX18oNDcpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOCk7XG5cblxuLyoqKi8gfSksXG4vKiAxMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBPW0lURVJBVE9SXSAhPT0gdW5kZWZpbmVkXG4gICAgfHwgJ0BAaXRlcmF0b3InIGluIE9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGljZWRUb0FycmF5Mik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgTGFiZWxBY2N1bXVsYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKVsnZGVmYXVsdCddO1xudmFyIENvbXBvbmVudFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVsnZGVmYXVsdCddO1xuXG4vLyBIYXNoIG9mIHByZXBhcmVkIHJlZ2V4cCdzIGZvciB0YWdzXG52YXIgdGFnUGF0dGVybiA9IHtcbiAgLy8gSFRNTFxuICAnPGI+JzogLzxiPi8sXG4gICc8aT4nOiAvPGk+LyxcbiAgJzxjb2RlPic6IC88Y29kZT4vLFxuICAnPC9iPic6IC88XFwvYj4vLFxuICAnPC9pPic6IC88XFwvaT4vLFxuICAnPC9jb2RlPic6IC88XFwvY29kZT4vLFxuICAvLyBNYXJrZG93blxuICAnKic6IC9cXCovLCAvLyBib2xkXG4gIF86IC9cXF8vLCAvLyBpdGFsXG4gICdgJzogL2AvLCAvLyBtb25vXG4gIGFmdGVyQm9sZDogL1teXFwqXS8sXG4gIGFmdGVySXRhbDogL1teX10vLFxuICBhZnRlck1vbm86IC9bXmBdL1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgY2xhc3MgZm9yIHBhcnNpbmcgdGhlIG1hcmt1cCB0YWdzIGZvciBIVE1MIGFuZCBNYXJrZG93bi5cbiAgICpcbiAgICogTk9URTogU2VxdWVuY2VzIG9mIHRhYnMgYW5kIHNwYWNlcyBhcmUgcmVkdWNlZCB0byBzaW5nbGUgc3BhY2UuXG4gICAqICAgICAgIFNjYW4gdXNhZ2Ugb2YgYHRoaXMuc3BhY2luZ2Agd2l0aGluIG1ldGhvZFxuICAgKi9cbn07XG52YXIgTWFya3VwQWNjdW11bGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gcGFyc2UgZm9yIG1hcmt1cFxuICAgKi9cbiAgZnVuY3Rpb24gTWFya3VwQWNjdW11bGF0b3IodGV4dCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE1hcmt1cEFjY3VtdWxhdG9yKTtcblxuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5ib2xkID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsID0gZmFsc2U7XG4gICAgdGhpcy5tb25vID0gZmFsc2U7XG4gICAgdGhpcy5zcGFjaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB0aGlzLm1vZFN0YWNrID0gW107XG5cbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbW9kIGxhYmVsIGN1cnJlbnRseSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgbGFiZWwgb2YgdG9wbW9zdCBtb2RcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShNYXJrdXBBY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6ICdtb2QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RTdGFjay5sZW5ndGggPT09IDAgPyAnbm9ybWFsJyA6IHRoaXMubW9kU3RhY2tbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtb2QgbGFiZWwgY3VycmVudGx5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIGFjdGl2ZSBtb2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtb2ROYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kTmFtZSgpIHtcbiAgICAgIGlmICh0aGlzLm1vZFN0YWNrLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdub3JtYWwnO2Vsc2UgaWYgKHRoaXMubW9kU3RhY2tbMF0gPT09ICdtb25vJykgcmV0dXJuICdtb25vJztlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYm9sZCAmJiB0aGlzLml0YWwpIHtcbiAgICAgICAgICByZXR1cm4gJ2JvbGRpdGFsJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJvbGQpIHtcbiAgICAgICAgICByZXR1cm4gJ2JvbGQnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiAnaXRhbCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0QmxvY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0QmxvY2soKSB7XG4gICAgICBpZiAodGhpcy5zcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuYWRkKCcgJyk7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ibG9ja3MucHVzaCh7IHRleHQ6IHRoaXMuYnVmZmVyLCBtb2Q6IHRoaXMubW9kTmFtZSgpIH0pO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE91dHB1dCB0ZXh0IHRvIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gYWRkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gJyAnO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ICE9ICcgJykge1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwYXJzaW5nIG9mIHdoaXRlc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaCAgdGhlIGNoYXJhY3RlciB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgd2FzIHByb2Nlc3NlZCBhcyB3aGl0ZXNwYWNlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VXUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlV1MoY2gpIHtcbiAgICAgIGlmICgvWyBcXHRdLy50ZXN0KGNoKSkge1xuICAgICAgICBpZiAoIXRoaXMubW9ubykge1xuICAgICAgICAgIHRoaXMuc3BhY2luZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGQoY2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFRhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLm1vZFN0YWNrLnVuc2hpZnQodGFnTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHVuc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5zZXRUYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IGZhbHNlO1xuICAgICAgdGhpcy5tb2RTdGFjay5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIGxhYmVsIGZvciBibG9jayB0eXBlIHdlIGFyZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRhZyB3YXMgcHJvY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VTdGFydFRhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnTmFtZSwgdGFnKSB7XG4gICAgICAvLyBOb3RlOiBpZiAnbW9ubycgcGFzc2VkIGFzIHRhZ05hbWUsIHRoZXJlIGlzIGEgZG91YmxlIGNoZWNrIGhlcmUuIFRoaXMgaXMgT0tcbiAgICAgIGlmICghdGhpcy5tb25vICYmICF0aGlzW3RhZ05hbWVdICYmIHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICB0aGlzLnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWR2YW5jZT10cnVlXSBpZiBzZXQsIGFkdmFuY2UgY3VycmVudCBwb3NpdGlvbiBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbWF0Y2ggYXQgZ2l2ZW4gcG9zaXRpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21hdGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2godGFnKSB7XG4gICAgICB2YXIgYWR2YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIF9wcmVwYXJlUmVnRXhwID0gdGhpcy5wcmVwYXJlUmVnRXhwKHRhZyksXG4gICAgICAgICAgX3ByZXBhcmVSZWdFeHAyID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfcHJlcGFyZVJlZ0V4cCwgMiksXG4gICAgICAgICAgcmVnRXhwID0gX3ByZXBhcmVSZWdFeHAyWzBdLFxuICAgICAgICAgIGxlbmd0aCA9IF9wcmVwYXJlUmVnRXhwMlsxXTtcblxuICAgICAgdmFyIG1hdGNoZWQgPSByZWdFeHAudGVzdCh0aGlzLnRleHQuc3Vic3RyKHRoaXMucG9zaXRpb24sIGxlbmd0aCkpO1xuXG4gICAgICBpZiAobWF0Y2hlZCAmJiBhZHZhbmNlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgbGFiZWwgZm9yIGJsb2NrIHR5cGUgd2UgYXJlIGN1cnJlbnRseSBwcm9jZXNzaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW25leHRUYWddIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBmb3IgY2hhcmFjdGVycyAqZm9sbG93aW5nKiB0aGUgY3VycmVudCB0YWdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXJzZUVuZFRhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZ05hbWUsIHRhZywgbmV4dFRhZykge1xuICAgICAgdmFyIGNoZWNrVGFnID0gdGhpcy5tb2QoKSA9PT0gdGFnTmFtZTtcbiAgICAgIGlmICh0YWdOYW1lID09PSAnbW9ubycpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgJ21vbm8nXG4gICAgICAgIGNoZWNrVGFnID0gY2hlY2tUYWcgJiYgdGhpcy5tb25vO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tUYWcgPSBjaGVja1RhZyAmJiAhdGhpcy5tb25vO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tUYWcgJiYgdGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIGlmIChuZXh0VGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBQdXJwb3NlIG9mIHRoZSBmb2xsb3dpbmcgbWF0Y2ggaXMgdG8gcHJldmVudCBhIGRpcmVjdCB1bnNldC9zZXQgb2YgYSBnaXZlbiB0YWdcbiAgICAgICAgICAvLyBFLmcuICcqYm9sZCAqKnN0aWxsIGJvbGQqJyA9PiAnKmJvbGQgc3RpbGwgYm9sZConXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMudGV4dC5sZW5ndGggLSAxIHx8IHRoaXMubWF0Y2gobmV4dFRhZywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyAgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSAgc3RyaW5nIHRvIHJlcGxhY2UgdGFnIHdpdGgsIGlmIGZvdW5kIGF0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YWcsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIHRhZyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgYFtSZWdFeHAsIG51bWJlcl1gLCB3aXRoIGV4YWN0bHkgdHdvIHZhbHVlLCB3aGVyZTpcbiAgICAgKiAgLSBSZWdFeHAgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2VcbiAgICAgKiAgLSBudW1iZXIgaXMgdGhlIGxlbnRoIG9mIHRoZSBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnICBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgYW5kIGxlbmd0aCBvZiBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcmVwYXJlUmVnRXhwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVJlZ0V4cCh0YWcpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2b2lkIDA7XG4gICAgICB2YXIgcmVnRXhwID0gdm9pZCAwO1xuICAgICAgaWYgKHRhZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZWdFeHAgPSB0YWc7XG4gICAgICAgIGxlbmd0aCA9IDE7IC8vIEFTU1VNUFRJT046IHJlZ2V4cCBvbmx5IHRlc3RzIG9uZSBjaGFyYWN0ZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBwcmVwYXJlZCByZWdleHAgaWYgcHJlc2VudFxuICAgICAgICB2YXIgcHJlcGFyZWQgPSB0YWdQYXR0ZXJuW3RhZ107XG4gICAgICAgIGlmIChwcmVwYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVnRXhwID0gcHJlcGFyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cCh0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gdGFnLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyZWdFeHAsIGxlbmd0aF07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXJrdXBBY2N1bXVsYXRvcjtcbn0oKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIExhYmVsIHdoaWNoIGV4cGxvZGVzIHRoZSBsYWJlbCB0ZXh0IGludG8gbGluZXMgYW5kIGJsb2NrcyB3aXRoaW4gbGluZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIExhYmVsU3BsaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge0xhYmVsfSBwYXJlbnQgcmVmZXJlbmNlIHRvIHRoZSBMYWJlbCBpbnN0YW5jZSB1c2luZyBjdXJyZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxTcGxpdHRlcihjdHgsIHBhcmVudCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIExhYmVsU3BsaXR0ZXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCB3aWR0aDsgcGFzc2VkIHRvIExhYmVsQWNjdW11bGF0b3IgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCBzdHJpbmcgdG8gZGV0ZXJtaW5lIHdpZHRoIG9mXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBtb2QgIGZvbnQgdHlwZSB0byB1c2UgZm9yIHRoaXMgdGV4dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0geyB3aWR0aCwgdmFsdWVzfSB3aWR0aCBpbiBwaXhlbHMgYW5kIGZvbnQgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIHZhciB0ZXh0V2lkdGggPSBmdW5jdGlvbiB0ZXh0V2lkdGgodGV4dCwgbW9kKSB7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcblxuICAgICAgLy8gVE9ETzogVGhpcyBjYW4gYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5IHdpdGggY2FjaGluZ1xuICAgICAgdmFyIHZhbHVlcyA9IF90aGlzLnBhcmVudC5nZXRGb3JtYXR0aW5nVmFsdWVzKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBtb2QpO1xuXG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgaWYgKHRleHQgIT09ICcnKSB7XG4gICAgICAgIC8vIE5PVEU6IFRoZSBmb2xsb3dpbmcgbWF5IGFjdHVhbGx5IGJlICppbmNvcnJlY3QqIGZvciB0aGUgbW9kIGZvbnRzIVxuICAgICAgICAvLyAgICAgICBUaGlzIHJldHVybnMgdGhlIHNpemUgd2l0aCBhIHJlZ3VsYXIgZm9udCwgYm9sZCBldGMuIG1heVxuICAgICAgICAvLyAgICAgICBoYXZlIGRpZmZlcmVudCBzaXplcy5cbiAgICAgICAgdmFyIG1lYXN1cmUgPSBfdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIHdpZHRoID0gbWVhc3VyZS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCB2YWx1ZXM6IHZhbHVlcyB9O1xuICAgIH07XG5cbiAgICB0aGlzLmxpbmVzID0gbmV3IExhYmVsQWNjdW11bGF0b3IodGV4dFdpZHRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBwYXNzZWQgdGV4dCBvZiBhIGxhYmVsIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAgICpcbiAgICogIyBOT1RFXG4gICAqXG4gICAqIFRoZSBoYW5kbGluZyBvZiBzcGFjaW5nIGlzIG9wdGlvbiBkZXBlbmRlbnQ6XG4gICAqXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiBmYWxzZWAsIGFsbCBzcGFjZXMgYXJlIHJldGFpbmVkXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiB0cnVlYCwgZXZlcnkgc2VxdWVuY2Ugb2Ygc3BhY2VzIGlzIGNvbXByZXNzZWQgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICpcbiAgICogVGhpcyBtaWdodCBub3QgYmUgdGhlIGJlc3Qgd2F5IHRvIGRvIGl0LCBidXQgdGhpcyBpcyBhcyBpdCBoYXMgYmVlbiB3b3JraW5nIHRpbGwgbm93LlxuICAgKiBJbiBvcmRlciBub3QgdG8gYnJlYWsgZXhpc3RpbmcgZnVuY3Rpb25hbGl0eSwgZm9yIHRoZSB0aW1lIGJlaW5nIHRoaXMgYmVoYXZpb3VyIHdpbGxcbiAgICogYmUgcmV0YWluZWQgaW4gYW55IGNvZGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gc3BsaXRcbiAgICogQHJldHVybnMge0FycmF5PGxpbmU+fVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKExhYmVsU3BsaXR0ZXIsIFt7XG4gICAga2V5OiAncHJvY2VzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3ModGV4dCkge1xuICAgICAgaWYgKCFDb21wb25lbnRVdGlsLmlzVmFsaWRMYWJlbCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lcy5maW5hbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9udCA9IHRoaXMucGFyZW50LmZvbnRPcHRpb25zO1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGVuZC1vZi1saW5lJ3MgdG8gYSBzaW5nbGUgcmVwcmVzZW50YXRpb24gLSBvcmRlciBpbXBvcnRhbnRcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7IC8vIERvcyBFT0wnc1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csICdcXG4nKTsgLy8gTWFjIEVPTCdzXG5cbiAgICAgIC8vIE5vdGUgdGhhdCBhdCB0aGlzIHBvaW50LCB0aGVyZSBjYW4gYmUgbm8gXFxyJ3MgaW4gdGhlIHRleHQuXG4gICAgICAvLyBUaGlzIGlzIHVzZWQgbGF0ZXIgb24gc3BsaXRTdHJpbmdJbnRvTGluZXMoKSB0byBzcGxpdCBtdWx0aWZvbnQgdGV4dHMuXG5cbiAgICAgIHZhciBubExpbmVzID0gU3RyaW5nKHRleHQpLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBsaW5lQ291bnQgPSBubExpbmVzLmxlbmd0aDtcblxuICAgICAgaWYgKGZvbnQubXVsdGkpIHtcbiAgICAgICAgLy8gTXVsdGktZm9udCBjYXNlOiBzdHlsaW5nIHRhZ3MgYWN0aXZlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5zcGxpdEJsb2NrcyhubExpbmVzW2ldLCBmb250Lm11bHRpKTtcbiAgICAgICAgICAvLyBQb3N0OiBTZXF1ZW5jZXMgb2YgdGFicyBhbmQgc3BhY2VzIGFyZSByZWR1Y2VkIHRvIHNpbmdsZSBzcGFjZVxuXG4gICAgICAgICAgaWYgKGJsb2NrcyA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoJycpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gZGVmaW5lZFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbXVsdGksIG1heDogJyArIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBtb2QgPSBibG9ja3Nbal0ubW9kO1xuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBibG9ja3Nbal0udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhfdGV4dCwgbW9kLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gTk9UIGRlZmluZWRcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBibG9ja3MubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfbW9kID0gYmxvY2tzW19qXS5tb2Q7XG4gICAgICAgICAgICAgIHZhciBfdGV4dDIgPSBibG9ja3NbX2pdLnRleHQ7XG4gICAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKF90ZXh0MiwgX21vZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmdsZS1mb250IGNhc2VcbiAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIGRlZmluZWRcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbm9ybWFsLCBtYXg6ICcgKyB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxpbmVDb3VudDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhubExpbmVzW19pXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIE5PVCBkZWZpbmVkXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGluZUNvdW50OyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKG5sTGluZXNbX2kyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbm9ybWFsaXplIHRoZSBtYXJrdXAgc3lzdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58J21kJ3wnbWFya2Rvd24nfCdodG1sJ30gbWFya3VwU3lzdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVjb2RlTWFya3VwU3lzdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlTWFya3VwU3lzdGVtKG1hcmt1cFN5c3RlbSkge1xuICAgICAgdmFyIHN5c3RlbSA9ICdub25lJztcbiAgICAgIGlmIChtYXJrdXBTeXN0ZW0gPT09ICdtYXJrZG93bicgfHwgbWFya3VwU3lzdGVtID09PSAnbWQnKSB7XG4gICAgICAgIHN5c3RlbSA9ICdtYXJrZG93bic7XG4gICAgICB9IGVsc2UgaWYgKG1hcmt1cFN5c3RlbSA9PT0gdHJ1ZSB8fCBtYXJrdXBTeXN0ZW0gPT09ICdodG1sJykge1xuICAgICAgICBzeXN0ZW0gPSAnaHRtbCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3lzdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NwbGl0SHRtbEJsb2NrcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0SHRtbEJsb2Nrcyh0ZXh0KSB7XG4gICAgICB2YXIgcyA9IG5ldyBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KTtcblxuICAgICAgdmFyIHBhcnNlRW50aXRpZXMgPSBmdW5jdGlvbiBwYXJzZUVudGl0aWVzKGNoKSB7XG4gICAgICAgIGlmICgvJi8udGVzdChjaCkpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gcy5yZXBsYWNlKHMudGV4dCwgJyZsdDsnLCAnPCcpIHx8IHMucmVwbGFjZShzLnRleHQsICcmYW1wOycsICcmJyk7XG5cbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcy5hZGQoJyYnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChzLnBvc2l0aW9uIDwgcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2ggPSBzLnRleHQuY2hhckF0KHMucG9zaXRpb24pO1xuXG4gICAgICAgIHZhciBwYXJzZWQgPSBzLnBhcnNlV1MoY2gpIHx8IC88Ly50ZXN0KGNoKSAmJiAocy5wYXJzZVN0YXJ0VGFnKCdib2xkJywgJzxiPicpIHx8IHMucGFyc2VTdGFydFRhZygnaXRhbCcsICc8aT4nKSB8fCBzLnBhcnNlU3RhcnRUYWcoJ21vbm8nLCAnPGNvZGU+JykgfHwgcy5wYXJzZUVuZFRhZygnYm9sZCcsICc8L2I+JykgfHwgcy5wYXJzZUVuZFRhZygnaXRhbCcsICc8L2k+JykgfHwgcy5wYXJzZUVuZFRhZygnbW9ubycsICc8L2NvZGU+JykpIHx8IHBhcnNlRW50aXRpZXMoY2gpO1xuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICB9XG4gICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgIH1cbiAgICAgIHMuZW1pdEJsb2NrKCk7XG4gICAgICByZXR1cm4gcy5ibG9ja3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3BsaXRNYXJrZG93bkJsb2NrcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0TWFya2Rvd25CbG9ja3ModGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzID0gbmV3IE1hcmt1cEFjY3VtdWxhdG9yKHRleHQpO1xuICAgICAgdmFyIGJlZ2luYWJsZSA9IHRydWU7XG5cbiAgICAgIHZhciBwYXJzZU92ZXJyaWRlID0gZnVuY3Rpb24gcGFyc2VPdmVycmlkZShjaCkge1xuICAgICAgICBpZiAoL1xcXFwvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgaWYgKHMucG9zaXRpb24gPCBfdGhpczIudGV4dC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICAgICAgICBjaCA9IF90aGlzMi50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICgvIFxcdC8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocy5wb3NpdGlvbiA8IHMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gcy50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcblxuICAgICAgICB2YXIgcGFyc2VkID0gcy5wYXJzZVdTKGNoKSB8fCBwYXJzZU92ZXJyaWRlKGNoKSB8fCAoYmVnaW5hYmxlIHx8IHMuc3BhY2luZykgJiYgKHMucGFyc2VTdGFydFRhZygnYm9sZCcsICcqJykgfHwgcy5wYXJzZVN0YXJ0VGFnKCdpdGFsJywgJ18nKSB8fCBzLnBhcnNlU3RhcnRUYWcoJ21vbm8nLCAnYCcpKSB8fCBzLnBhcnNlRW5kVGFnKCdib2xkJywgJyonLCAnYWZ0ZXJCb2xkJykgfHwgcy5wYXJzZUVuZFRhZygnaXRhbCcsICdfJywgJ2FmdGVySXRhbCcpIHx8IHMucGFyc2VFbmRUYWcoJ21vbm8nLCAnYCcsICdhZnRlck1vbm8nKTtcblxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICBiZWdpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICB9XG4gICAgICBzLmVtaXRCbG9jaygpO1xuICAgICAgcmV0dXJuIHMuYmxvY2tzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGxvZGVzIGEgcGllY2Ugb2YgdGV4dCBpbnRvIHNpbmdsZS1mb250IGJsb2NrcyB1c2luZyBhIGdpdmVuIG1hcmt1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58J21kJ3wnbWFya2Rvd24nfCdodG1sJ30gbWFya3VwU3lzdGVtXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7dGV4dDogc3RyaW5nLCBtb2Q6IHN0cmluZ30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NwbGl0QmxvY2tzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRCbG9ja3ModGV4dCwgbWFya3VwU3lzdGVtKSB7XG4gICAgICB2YXIgc3lzdGVtID0gdGhpcy5kZWNvZGVNYXJrdXBTeXN0ZW0obWFya3VwU3lzdGVtKTtcbiAgICAgIGlmIChzeXN0ZW0gPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIG1vZDogJ25vcm1hbCdcbiAgICAgICAgfV07XG4gICAgICB9IGVsc2UgaWYgKHN5c3RlbSA9PT0gJ21hcmtkb3duJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdE1hcmtkb3duQmxvY2tzKHRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzeXN0ZW0gPT09ICdodG1sJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEh0bWxCbG9ja3ModGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0ZXh0IGxlbmd0aCBvdmVyIHRoZSBjdXJyZW50IG1heCB3aXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb3Zlck1heFdpZHRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Zlck1heFdpZHRoKHRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXMubGluZXMuY3VyV2lkdGgoKSArIHdpZHRoID4gdGhpcy5wYXJlbnQuZm9udE9wdGlvbnMubWF4V2R0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbG9uZ2VzdCBwYXJ0IG9mIHRoZSBzZW50ZW5jZSB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgIEFycmF5IG9mIHN0cmluZ3Mgc2lnbmlmeWluZyBhIHRleHQgbGluZXNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgaW5kZXggb2YgZmlyc3QgaXRlbSBpbiBzdHJpbmcgbWFraW5nIHN0cmluZyBnbyBvdmVyIG1heFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldExvbmdlc3RGaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb25nZXN0Rml0KHdvcmRzKSB7XG4gICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgdmFyIHcgPSAwO1xuXG4gICAgICB3aGlsZSAodyA8IHdvcmRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJlID0gdGV4dCA9PT0gJycgPyAnJyA6ICcgJztcbiAgICAgICAgdmFyIG5ld1RleHQgPSB0ZXh0ICsgcHJlICsgd29yZHNbd107XG5cbiAgICAgICAgaWYgKHRoaXMub3Zlck1heFdpZHRoKG5ld1RleHQpKSBicmVhaztcbiAgICAgICAgdGV4dCA9IG5ld1RleHQ7XG4gICAgICAgIHcrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBsb25nZXN0IHBhcnQgb2YgdGhlIHN0cmluZyB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgQXJyYXkgb2Ygc3RyaW5ncyBzaWduaWZ5aW5nIGEgdGV4dCBsaW5lc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW5kZXggb2YgZmlyc3QgaXRlbSBpbiBzdHJpbmcgbWFraW5nIHN0cmluZyBnbyBvdmVyIG1heFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMb25nZXN0Rml0V29yZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvbmdlc3RGaXRXb3JkKHdvcmRzKSB7XG4gICAgICB2YXIgdyA9IDA7XG5cbiAgICAgIHdoaWxlICh3IDwgd29yZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJNYXhXaWR0aCh3b3Jkcy5zbGljZSgwLCB3KSkpIGJyZWFrO1xuICAgICAgICB3Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzLCBhY2NvcmRpbmcgdG8gd2lkdGggY29uc3RyYWludCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSBzaW5nbGUgbGluZSwgaS5lLiB3aXRob3V0IGxpbmVzIGJyZWFrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0YWlucyBzcGFjZXMsIGlmIHN0aWxsIHByZXNlbnQgKGNhc2UgYGZvbnQubXVsdGk6IGZhbHNlYCkuXG4gICAgICogQSBzcGFjZSB3aGljaCBmYWxscyBvbiBhbiBpbnRlcm5hbCBsaW5lIGJyZWFrLCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgbmV3bGluZS5cbiAgICAgKiBUaGVyZSBpcyBubyBzcGVjaWFsIGhhbmRsaW5nIG9mIHRhYnM7IHRoZXNlIGdvIGFsb25nIHdpdGggdGhlIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2Q9J25vcm1hbCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXBwZW5kTGFzdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzcGxpdFN0cmluZ0ludG9MaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0U3RyaW5nSW50b0xpbmVzKHN0cikge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ25vcm1hbCc7XG4gICAgICB2YXIgYXBwZW5kTGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIC8vIFN0aWxsLXByZXNlbnQgc3BhY2VzIGFyZSByZWxldmFudCwgcmV0YWluIHRoZW1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKCArKS9nLCAnJDFcXHInKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oW15cXHJdW14gXSopKCArKS9nLCAnJDFcXHIkMlxccicpO1xuICAgICAgdmFyIHdvcmRzID0gc3RyLnNwbGl0KCdcXHInKTtcblxuICAgICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmdldExvbmdlc3RGaXQod29yZHMpO1xuXG4gICAgICAgIGlmICh3ID09PSAwKSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aGUgZmlyc3Qgd29yZCBpcyBhbHJlYWR5IGxhcmdlciB0aGFuIHRoZSBtYXggd2lkdGguXG4gICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1swXTtcblxuICAgICAgICAgIC8vIEJyZWFrIHRoZSB3b3JkIHRvIHRoZSBsYXJnZXN0IHBhcnQgdGhhdCBmaXRzIHRoZSBsaW5lXG4gICAgICAgICAgdmFyIHggPSB0aGlzLmdldExvbmdlc3RGaXRXb3JkKHdvcmQpO1xuICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZSh3b3JkLnNsaWNlKDAsIHgpLCBtb2QpO1xuXG4gICAgICAgICAgLy8gQWRqdXN0IHRoZSB3b3JkLCBzbyB0aGF0IHRoZSByZXN0IHdpbGwgYmUgZG9uZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgIHdvcmRzWzBdID0gd29yZC5zbGljZSh4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBza2lwIGFueSBzcGFjZSB0aGF0IGlzIHJlcGxhY2VkIGJ5IGEgbmV3bGluZVxuICAgICAgICAgIHZhciBuZXdXID0gdztcbiAgICAgICAgICBpZiAod29yZHNbdyAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgIHctLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdvcmRzW25ld1ddID09PSAnICcpIHtcbiAgICAgICAgICAgIG5ld1crKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dCA9IHdvcmRzLnNsaWNlKDAsIHcpLmpvaW4oJycpO1xuXG4gICAgICAgICAgaWYgKHcgPT0gd29yZHMubGVuZ3RoICYmIGFwcGVuZExhc3QpIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKHRleHQsIG1vZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZSh0ZXh0LCBtb2QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkanVzdCB0aGUgd29yZCwgc28gdGhhdCB0aGUgcmVzdCB3aWxsIGJlIGRvbmUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICB3b3JkcyA9IHdvcmRzLnNsaWNlKG5ld1cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMYWJlbFNwbGl0dGVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBMYWJlbFNwbGl0dGVyO1xuXG4vKioqLyB9KSxcbi8qIDE0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCBkaW1lbnNpb25zLCB1c2luZyB0aGUgcGFyZW50IGxhYmVsIHNldHRpbmdzLlxuICogQGNhbGxiYWNrIE1lYXN1cmVUZXh0XG4gKiBAcGFyYW0ge3RleHR9IHRleHRcbiAqIEBwYXJhbSB7dGV4dH0gbW9kXG4gKiBAcmV0dXJuIHtPYmplY3R9IHsgd2lkdGgsIHZhbHVlc30gd2lkdGggaW4gcGl4ZWxzIGFuZCBmb250IGF0dHJpYnV0ZXNcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgTGFiZWwgd2hpY2ggY29sbGVjdHMgcmVzdWx0cyBvZiBzcGxpdHRpbmcgbGFiZWxzIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGFiZWxBY2N1bXVsYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TWVhc3VyZVRleHR9IG1lYXN1cmVUZXh0XG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbEFjY3VtdWxhdG9yKG1lYXN1cmVUZXh0KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgTGFiZWxBY2N1bXVsYXRvcik7XG5cbiAgICB0aGlzLm1lYXN1cmVUZXh0ID0gbWVhc3VyZVRleHQ7XG4gICAgdGhpcy5jdXJyZW50ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBnaXZlbiB0ZXh0IHRvIHRoZSBnaXZlbiBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gIGwgICAgaW5kZXggb2YgbGluZSB0byBhZGQgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0ZXh0IHN0cmluZyB0byBhcHBlbmQgdG8gbGluZVxuICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTGFiZWxBY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6ICdfYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZChsLCB0ZXh0KSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbm9ybWFsJztcblxuICAgICAgaWYgKHRoaXMubGluZXNbbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxpbmVzW2xdID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICBibG9ja3M6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gc2V0IGEgYmxvY2sgZm9yIHVuZGVmaW5lZCBhbmQgZW1wdHkgdGV4dHMsIGhlbmNlIHJldHVybiBhdCB0aGlzIHBvaW50XG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIGRvbid0IGtub3cgYXQgdGhpcyBwb2ludCBpZiB3ZSdyZSBhdCB0aGVcbiAgICAgIC8vIHN0YXJ0IG9mIGFuIGVtcHR5IGxpbmUgb3Igbm90LlxuICAgICAgLy8gVG8gY29tcGVuc2F0ZSwgZW1wdHkgYmxvY2tzIGFyZSByZW1vdmVkIGluIGBmaW5hbGl6ZSgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBzdGlsbCBoYXZlIGEgaGVpZ2h0XG4gICAgICB2YXIgdG1wVGV4dCA9IHRleHQ7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09ICcnKSB0bXBUZXh0ID0gJyAnO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgd2lkdGggYW5kIGdldCB0aGUgZm9udCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5tZWFzdXJlVGV4dCh0bXBUZXh0LCBtb2QpO1xuICAgICAgdmFyIGJsb2NrID0gKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHt9LCByZXN1bHQudmFsdWVzKTtcbiAgICAgIGJsb2NrLnRleHQgPSB0ZXh0O1xuICAgICAgYmxvY2sud2lkdGggPSByZXN1bHQud2lkdGg7XG4gICAgICBibG9jay5tb2QgPSBtb2Q7XG5cbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gJycpIHtcbiAgICAgICAgYmxvY2sud2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpbmVzW2xdLmJsb2Nrcy5wdXNoKGJsb2NrKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBsaW5lIHdpZHRoLiBXZSBuZWVkIHRoaXMgZm9yIGRldGVybWluaW5nIGlmIGEgc3RyaW5nIGdvZXMgb3ZlciBtYXggd2lkdGhcbiAgICAgIHRoaXMubGluZXNbbF0ud2lkdGggKz0gYmxvY2sud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjdXJXaWR0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cldpZHRoKCkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW3RoaXMuY3VycmVudF07XG4gICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcblxuICAgICAgcmV0dXJuIGxpbmUud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRleHQgaW4gYmxvY2sgdG8gY3VycmVudCBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdub3JtYWwnO1xuXG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZSBhbmQgc3RhcnQgYSBuZXcgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ25ld0xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdMaW5lKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdub3JtYWwnO1xuXG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFuZCBzZXQgdGhlIGhlaWdodHMgb2YgYWxsIHRoZSBsaW5lcyBjdXJyZW50bHkgY29udGFpbmVkIGluIHRoaXMgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aWR0aCBoYXMgYWxyZWFkeSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RldGVybWluZUxpbmVIZWlnaHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lTGluZUhlaWdodHMoKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIC8vIExvb2tpbmcgZm9yIG1heCBoZWlnaHQgb2YgYmxvY2tzIGluIGxpbmVcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBDYW4gaGFwcGVuIGlmIHRleHQgY29udGFpbnMgZS5nLiAnXFxuICdcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tsXTtcblxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IGJsb2NrLmhlaWdodCkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSBibG9jay5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBmdWxsIHNpemUgb2YgdGhlIGxhYmVsIHRleHQsIGFzIGRldGVybWluZWQgYnkgY3VycmVudCBsaW5lcyBhbmQgYmxvY2tzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXRlcm1pbmVMYWJlbFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVMYWJlbFNpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIGlmIChsaW5lLndpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0ICs9IGxpbmUuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGVtcHR5IGJsb2NrcyBhbmQgZW1wdHkgbGluZXMgd2UgZG9uJ3QgbmVlZFxuICAgICAqXG4gICAgICogVGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIHdpZHRoL2hlaWdodCBkZXRlcm1pbmF0aW9uLFxuICAgICAqIHNvIHRoYXQgdGhlc2UgYXJlIHNldCBwcm9wZXJseSBmb3IgcHJvY2Vzc2luZyBoZXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5PExpbmU+fSBMaW5lcyB3aXRoIGVtcHR5IGJsb2NrcyAoYW5kIHNvbWUgZW1wdHkgbGluZXMpIHJlbW92ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVFbXB0eUJsb2NrcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5QmxvY2tzKCkge1xuICAgICAgdmFyIHRtcExpbmVzID0gW107XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIC8vIE5vdGU6IGFuIGVtcHR5IGxpbmUgaW4gYmV0d2VlbiB0ZXh0IGhhcyB3aWR0aCB6ZXJvIGJ1dCBpcyBzdGlsbCByZWxldmFudCB0byBsYXlvdXQuXG4gICAgICAgIC8vIFNvIHdlIGNhbid0IHVzZSB3aWR0aCBmb3IgdGVzdGluZyBlbXB0eSBsaW5lIGhlcmVcbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgLy8gRGlzY2FyZCBmaW5hbCBlbXB0eSBsaW5lIGFsd2F5c1xuICAgICAgICBpZiAoayA9PT0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKGxpbmUud2lkdGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcExpbmUgPSB7fTtcbiAgICAgICAgKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHRtcExpbmUsIGxpbmUpO1xuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IFtdO1xuXG4gICAgICAgIHZhciBmaXJzdEVtcHR5QmxvY2sgPSB2b2lkIDA7XG4gICAgICAgIHZhciB0bXBCbG9ja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2xdO1xuICAgICAgICAgIGlmIChibG9jay53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgdG1wQmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RFbXB0eUJsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlyc3RFbXB0eUJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgKnNvbWUqIHRleHQgcHJlc2VudFxuICAgICAgICBpZiAodG1wQmxvY2tzLmxlbmd0aCA9PT0gMCAmJiBmaXJzdEVtcHR5QmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRtcEJsb2Nrcy5wdXNoKGZpcnN0RW1wdHlCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IHRtcEJsb2NrcztcblxuICAgICAgICB0bXBMaW5lcy5wdXNoKHRtcExpbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG1wTGluZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplcyBmb3IgYWxsIGxpbmVzIGFuZCB0aGUgd2hvbGUgdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyfCopLCBoZWlnaHQ6IChudW1iZXJ8KiksIGxpbmVzOiBBcnJheX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRoaXMubGluZXMsIG51bGwsIDIpKTtcblxuICAgICAgdGhpcy5kZXRlcm1pbmVMaW5lSGVpZ2h0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVMYWJlbFNpemUoKTtcbiAgICAgIHZhciB0bXBMaW5lcyA9IHRoaXMucmVtb3ZlRW1wdHlCbG9ja3MoKTtcblxuICAgICAgLy8gUmV0dXJuIGEgc2ltcGxlIGhhc2ggb2JqZWN0IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgbGluZXM6IHRtcExpbmVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGFiZWxBY2N1bXVsYXRvcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTGFiZWxBY2N1bXVsYXRvcjtcblxuLyoqKi8gfSksXG4vKiAxNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxNDIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9iamVjdC5hc3NpZ247XG5cblxuLyoqKi8gfSksXG4vKiAxNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IF9fd2VicGFja19yZXF1aXJlX18oMTQzKSB9KTtcblxuXG4vKioqLyB9KSxcbi8qIDE0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbnZhciBnT1BTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG52YXIgcElFID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8qKiovIH0pLFxuLyogMTQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgQm94IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBOb2RlQmFzZVxuICovXG52YXIgQm94ID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShCb3gsIF9Ob2RlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBCb3gob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBCb3gpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQm94Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShCb3gpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJveCwgW3tcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5yb3VuZFJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHZhbHVlcy5ib3JkZXJSYWRpdXMpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdmFyIGJvcmRlclJhZGl1cyA9IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzOyAvLyBvbmx5IGVmZmVjdGl2ZSBmb3IgYm94XG4gICAgICB0aGlzLl9hZGRCb3VuZGluZ0JveE1hcmdpbihib3JkZXJSYWRpdXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJveDtcblxuLyoqKi8gfSksXG4vKiAxNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxNDYpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuXG4vKioqLyB9KSxcbi8qIDE0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDY4KSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxNDgpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogMTQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTQ5KTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKi8gfSksXG4vKiAxNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IF9fd2VicGFja19yZXF1aXJlX18oMTUwKS5zZXQgfSk7XG5cblxuLyoqKi8gfSksXG4vKiAxNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKShGdW5jdGlvbi5jYWxsLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0NpcmNsZUltYWdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxudmFyIF9DaXJjbGVJbWFnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlSW1hZ2VCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIENpcmNsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cbnZhciBDaXJjbGUgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDaXJjbGUsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2lyY2xlKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKENpcmNsZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2lyY2xlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDaXJjbGUsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgICAgdmFyIGRpYW1ldGVyID0gTWF0aC5tYXgoZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdCwgZGltZW5zaW9ucy5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b20pO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gZGlhbWV0ZXIgLyAyOyAvLyBOT1RFOiB0aGlzIHNpemUgZmllbGQgb25seSBzZXQgaGVyZSwgbm90IGluIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgIH1cblxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFVudXNlZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmNsZTtcbn0oX0NpcmNsZUltYWdlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENpcmNsZTtcblxuLyoqKi8gfSksXG4vKiAxNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9DaXJjbGVJbWFnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cbnZhciBfQ2lyY2xlSW1hZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZUltYWdlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQSBDaXJjdWxhckltYWdlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xudmFyIENpcmN1bGFySW1hZ2UgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDaXJjdWxhckltYWdlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIENpcmN1bGFySW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENpcmN1bGFySW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQ2lyY3VsYXJJbWFnZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2lyY3VsYXJJbWFnZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcblxuICAgIF90aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDaXJjdWxhckltYWdlLCBbe1xuICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcblxuICAgICAgdmFyIGltYWdlQWJzZW50ID0gdGhpcy5pbWFnZU9iai5zcmMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai5oZWlnaHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGltYWdlQWJzZW50KSB7XG4gICAgICAgIHZhciBkaWFtZXRlciA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgYW4gaW1hZ2UgaXMgcHJlc2VudCwgaS5lLiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkLlxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnN3aXRjaEltYWdlcyhzZWxlY3RlZCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kIGNpcmNsZS4gSU1QT1JUQU5UOiB0aGUgc3Ryb2tlIGluIHRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIGNsaXAgbWV0aG9kIGJlbG93LlxuICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcyk7XG5cbiAgICAgIC8vIG5vdyB3ZSBkcmF3IGluIHRoZSBjaXJjbGUsIHdlIHNhdmUgc28gd2UgY2FuIHJldmVydCB0aGUgY2xpcCBvcGVyYXRpb24gYWZ0ZXIgZHJhd2luZy5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBjbGlwIGlzIHVzZWQgdG8gdXNlIHRoZSBzdHJva2UgaW4gZHJhd1Jhd0NpcmNsZSBhcyBhbiBhcmVhIHRoYXQgd2UgY2FuIGRyYXcgaW4uXG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpO1xuICAgICAgLy8gcmVzdG9yZSBzbyB3ZSBjYW4gYWdhaW4gZHJhdyBvbiB0aGUgZnVsbCBjYW52YXNcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb21wYXJlIHdpdGggQ2lyY2xlLnVwZGF0ZUJvdW5kaW5nQm94KCksIGNvbnNvbGlkYXRlPyBNb3JlIHN0dWZmIGlzIGhhcHBlbmluZyBoZXJlXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuXG4gICAgICAvLyBUT0RPOiBjb21wYXJlIHdpdGggSW1hZ2UudXBkYXRlQm91bmRpbmdCb3goKSwgY29uc29saWRhdGU/XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFVudXNlZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmN1bGFySW1hZ2U7XG59KF9DaXJjbGVJbWFnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDaXJjdWxhckltYWdlO1xuXG4vKioqLyB9KSxcbi8qIDE1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIERhdGFiYXNlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBOb2RlQmFzZVxuICovXG52YXIgRGF0YWJhc2UgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKERhdGFiYXNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YWJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBEYXRhYmFzZSk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChEYXRhYmFzZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoRGF0YWJhc2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRGF0YWJhc2UsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBzaXplID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcblxuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LmRhdGFiYXNlKHggLSB0aGlzLndpZHRoIC8gMiwgeSAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRhYmFzZTtcbn0oX05vZGVCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRGF0YWJhc2U7XG5cbi8qKiovIH0pLFxuLyogMTU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgRGlhbW9uZCBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgU2hhcGVCYXNlXG4gKi9cbnZhciBEaWFtb25kID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoRGlhbW9uZCwgX1NoYXBlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEaWFtb25kKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRGlhbW9uZCk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKERpYW1vbmQuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKERpYW1vbmQpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShEaWFtb25kLCBbe1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICdkaWFtb25kJywgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGlhbW9uZDtcbn0oX1NoYXBlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERpYW1vbmQ7XG5cbi8qKiovIH0pLFxuLyogMTU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgRG90IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZUJhc2VcbiAqL1xudmFyIERvdCA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKERvdCwgX1NoYXBlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEb3Qob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBEb3QpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChEb3QuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKERvdCkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKERvdCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnY2lyY2xlJywgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEb3Q7XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBEb3Q7XG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEFtIEVsbGlwc2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIE5vZGVCYXNlXG4gKi9cbnZhciBFbGxpcHNlID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShFbGxpcHNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRWxsaXBzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEVsbGlwc2UpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChFbGxpcHNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShFbGxpcHNlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVsbGlwc2UsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICsgZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBjdHguZWxsaXBzZV92aXModGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgdmFyIGEgPSB0aGlzLndpZHRoICogMC41O1xuICAgICAgdmFyIGIgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgIHZhciB3ID0gTWF0aC5zaW4oYW5nbGUpICogYTtcbiAgICAgIHZhciBoID0gTWF0aC5jb3MoYW5nbGUpICogYjtcbiAgICAgIHJldHVybiBhICogYiAvIE1hdGguc3FydCh3ICogdyArIGggKiBoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVsbGlwc2U7XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEVsbGlwc2U7XG5cbi8qKiovIH0pLFxuLyogMTU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEFuIGljb24gcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIEljb24gPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKEljb24sIF9Ob2RlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBJY29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgSWNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChJY29uLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShJY29uKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSWNvbiwgW3tcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHRoaXMuaWNvblNpemUgPSB7XG4gICAgICAgICAgd2lkdGg6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKSxcbiAgICAgICAgICBoZWlnaHQ6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5pY29uU2l6ZS53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmljb25TaXplLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMub3B0aW9ucy5pY29uLnNpemUgPSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplIHx8IDUwO1xuXG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLl9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMuaWNvblNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgeSArIHRoaXMuaGVpZ2h0IC8gMiArIGljb25UZXh0U3BhY2luZywgc2VsZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHZhciBpY29uVGV4dFNwYWNpbmcgPSA1O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0ICsgaWNvblRleHRTcGFjaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyIC0gVW51c2VkXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaWNvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpY29uU2l6ZSA9IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCA/ICdib2xkICcgOiAnJykgKyBpY29uU2l6ZSArICdweCAnICsgdGhpcy5vcHRpb25zLmljb24uZmFjZTtcblxuICAgICAgICAvLyBkcmF3IGljb25cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uLmNvbG9yIHx8ICdibGFjayc7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSwgeCwgeSk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1doZW4gdXNpbmcgdGhlIGljb24gc2hhcGUsIHlvdSBuZWVkIHRvIGRlZmluZSB0aGUgY29kZSBpbiB0aGUgaWNvbiBvcHRpb25zIG9iamVjdC4gVGhpcyBjYW4gYmUgZG9uZSBwZXIgbm9kZSBvciBnbG9iYWxseS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEljb247XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEljb247XG5cbi8qKiovIH0pLFxuLyogMTU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQ2lyY2xlSW1hZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xuXG52YXIgX0NpcmNsZUltYWdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGVJbWFnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEFuIGltYWdlLWJhc2VkIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIENpcmNsZUltYWdlQmFzZVxuICovXG52YXIgSW1hZ2UgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqQWx0XG4gICAqL1xuICBmdW5jdGlvbiBJbWFnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgSW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoSW1hZ2UuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKEltYWdlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBVbnVzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShJbWFnZSwgW3tcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG5cbiAgICAgIHZhciBpbWFnZUFic2VudCA9IHRoaXMuaW1hZ2VPYmouc3JjID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpbWFnZUFic2VudCkge1xuICAgICAgICB2YXIgc2lkZSA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpZGU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2lkZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUJvcmRlcldpdGhJbWFnZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyBzZXR1cCB0aGUgbGluZSBwcm9wZXJ0aWVzLlxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcblxuICAgICAgICAvLyBzZXQgYSBmaWxsc3R5bGVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuXG4gICAgICAgIC8vIGRyYXcgYSByZWN0YW5nbGUgdG8gZm9ybSB0aGUgYm9yZGVyIGFyb3VuZC4gVGhpcyByZWN0YW5nbGUgaXMgZmlsbGVkIHNvIHRoZSBvcGFjaXR5IG9mIGEgcGljdHVyZSAoaW4gZnV0dXJlIHZpcyByZWxlYXNlcz8pIGNhbiBiZSB1c2VkIHRvIHRpbnQgdGhlIGltYWdlXG4gICAgICAgIGN0eC5yZWN0KHRoaXMubGVmdCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMudG9wIC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy53aWR0aCArIGN0eC5saW5lV2lkdGgsIHRoaXMuaGVpZ2h0ICsgY3R4LmxpbmVXaWR0aCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgdGhpcy5wZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpO1xuXG4gICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEltYWdlO1xufShfQ2lyY2xlSW1hZ2VCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW1hZ2U7XG5cbi8qKiovIH0pLFxuLyogMTU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgU3F1YXJlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZUJhc2VcbiAqL1xudmFyIFNxdWFyZSA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKFNxdWFyZSwgX1NoYXBlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBTcXVhcmUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBTcXVhcmUpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChTcXVhcmUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKFNxdWFyZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKFNxdWFyZSwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnc3F1YXJlJywgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3F1YXJlO1xufShfU2hhcGVCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3F1YXJlO1xuXG4vKioqLyB9KSxcbi8qIDE2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIEhleGFnb24gTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIFNoYXBlQmFzZVxuICovXG52YXIgSGV4YWdvbiA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKEhleGFnb24sIF9TaGFwZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gSGV4YWdvbihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEhleGFnb24pO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChIZXhhZ29uLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShIZXhhZ29uKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSGV4YWdvbiwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnaGV4YWdvbicsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhleGFnb247XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBIZXhhZ29uO1xuXG4vKioqLyB9KSxcbi8qIDE2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIFN0YXIgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIFNoYXBlQmFzZVxuICovXG52YXIgU3RhciA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKFN0YXIsIF9TaGFwZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3RhcihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIFN0YXIpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChTdGFyLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShTdGFyKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU3RhciwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnc3RhcicsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0YXI7XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdGFyO1xuXG4vKioqLyB9KSxcbi8qIDE2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIHRleHQtYmFzZWQgcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIFRleHQgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKFRleHQsIF9Ob2RlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgVGV4dCk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChUZXh0Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShUZXh0KSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKFRleHQsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHRoaXMudG9wICsgdGhpcy50ZXh0U2l6ZS5oZWlnaHQgLyAyICsgdGhpcy5tYXJnaW4udG9wLCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUZXh0O1xufShfTm9kZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDE2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIFRyaWFuZ2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZUJhc2VcbiAqL1xudmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoVHJpYW5nbGUsIF9TaGFwZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJpYW5nbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBUcmlhbmdsZSk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKFRyaWFuZ2xlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShUcmlhbmdsZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVHJpYW5nbGUsIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ3RyaWFuZ2xlJywgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJpYW5nbGU7XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUcmlhbmdsZTtcblxuLyoqKi8gfSksXG4vKiAxNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9TaGFwZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBfU2hhcGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYXBlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQSBkb3dud2FyZCBmYWNpbmcgVHJpYW5nbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIFNoYXBlQmFzZVxuICovXG52YXIgVHJpYW5nbGVEb3duID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoVHJpYW5nbGVEb3duLCBfU2hhcGVCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyaWFuZ2xlRG93bihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIFRyaWFuZ2xlRG93bik7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKFRyaWFuZ2xlRG93bi5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoVHJpYW5nbGVEb3duKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShUcmlhbmdsZURvd24sIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ3RyaWFuZ2xlRG93bicsIDMsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyaWFuZ2xlRG93bjtcbn0oX1NoYXBlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRyaWFuZ2xlRG93bjtcblxuLyoqKi8gfSksXG4vKiAxNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSlbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBFZGdlc1xuICovXG5cbnZhciBFZGdlc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxJbWFnZT59IGltYWdlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxHcm91cD59IGdyb3Vwc1xuICAgKi9cbiAgZnVuY3Rpb24gRWRnZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEVkZ2VzSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBlZGdlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5lZGdlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHRvOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSwgdHlwZTogJ2Fycm93JyB9LCAvLyBib29sZWFuIC8ge2Fycm93U2NhbGVGYWN0b3I6MX0gLyB7ZW5hYmxlZDogZmFsc2UsIGFycm93U2NhbGVGYWN0b3I6MX1cbiAgICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSwgdHlwZTogJ2Fycm93JyB9LFxuICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSwgdHlwZTogJ2Fycm93JyB9XG4gICAgICB9LFxuICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6ICcjODQ4NDg0JyxcbiAgICAgICAgaGlnaGxpZ2h0OiAnIzg0ODQ4NCcsXG4gICAgICAgIGhvdmVyOiAnIzg0ODQ4NCcsXG4gICAgICAgIGluaGVyaXQ6ICdmcm9tJyxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9LFxuICAgICAgZGFzaGVzOiBmYWxzZSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6ICcjMzQzNDM0JyxcbiAgICAgICAgc2l6ZTogMTQsIC8vIHB4XG4gICAgICAgIGZhY2U6ICdhcmlhbCcsXG4gICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgIGFsaWduOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgdmFkanVzdDogMCxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogJ2JvbGQnXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiAnYm9sZCBpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIGl0YWw6IHtcbiAgICAgICAgICBtb2Q6ICdpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6ICcnLFxuICAgICAgICAgIHNpemU6IDE1LCAvLyBweFxuICAgICAgICAgIGZhY2U6ICdjb3VyaWVyIG5ldycsXG4gICAgICAgICAgdmFkanVzdDogMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGhvdmVyV2lkdGg6IDEuNSxcbiAgICAgIGxhYmVsOiB1bmRlZmluZWQsXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMSxcbiAgICAgICAgbWF4OiAxNSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICBtYXhWaXNpYmxlOiAzMCxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogZnVuY3Rpb24gY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAodmFsdWUgLSBtaW4pICogc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGlvbldpZHRoOiAxLjUsXG4gICAgICBzZWxmUmVmZXJlbmNlU2l6ZTogMjAsXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHg6IDUsXG4gICAgICAgIHk6IDVcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMTExLDExMSwxMTEsMSknLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgZGFzaGVzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgIGZvcmNlRGlyZWN0aW9uOiAnbm9uZScsXG4gICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICB9LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICB1dGlsLmRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRWRnZXNIYW5kbGVyLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyB0aGlzIGFsbG93cyBleHRlcm5hbCBtb2R1bGVzIHRvIGZvcmNlIGFsbCBkeW5hbWljIGN1cnZlcyB0byB0dXJuIHN0YXRpYy5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlcycsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICB0eXBlID0gJ2NvbnRpbnVvdXMnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gX3RoaXMyLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczIuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgdmFyIGVkZ2VEYXRhID0gX3RoaXMyLmJvZHkuZGF0YS5lZGdlcy5fZGF0YVtlZGdlSWRdO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGZvcmNpYmx5IHJlbW92ZSB0aGUgc21vb3RoIGN1cnZlIGlmIHRoZSBkYXRhIGhhcyBiZWVuIHNldCBvZiB0aGUgZWRnZSBoYXMgdGhlIHNtb290aCBjdXJ2ZXMgZGVmaW5lZC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBhIGNoYW5nZSBpbiB0aGUgZ2xvYmFsIHdvdWxkIG5vdCBhZmZlY3QgdGhlc2UgY3VydmVzLlxuICAgICAgICAgICAgaWYgKGVkZ2VEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHNtb290aE9wdGlvbnMgPSBlZGdlRGF0YS5zbW9vdGg7XG4gICAgICAgICAgICAgIGlmIChzbW9vdGhPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoT3B0aW9ucy5lbmFibGVkID09PSB0cnVlICYmIHNtb290aE9wdGlvbnMudHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7IHNtb290aDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoeyBzbW9vdGg6IHsgdHlwZTogdHlwZSB9IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSAmJiBkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IE5vdCB0cnVlLCBjYWxsZWQgd2hlbiBvcHRpb25zIGhhdmUgTk9UIGNoYW5nZWQsIGZvciBib3RoIGV4aXN0aW5nIGFzIHdlbGwgYXMgbmV3IG5vZGVzLlxuICAgICAgLy8gICAgICAgU2VlIHVwZGF0ZSgpIGZvciBsb2dpYy5cbiAgICAgIC8vIFRPRE86IFZlcmlmeSBhbmQgZXhhbWluZSB0aGUgY29uc2VxdWVuY2VzIG9mIHRoaXMuIEl0IG1pZ2h0IHN0aWxsIHRyaWdnZXIgd2hlblxuICAgICAgLy8gICAgICAgbm9uLW9wdGlvbiBmaWVsZHMgaGF2ZSBjaGFuZ2VkLCBidXQgdGhlbiByZWNvbm5lY3RpbmcgZWRnZXMgaXMgc3RpbGwgdXNlbGVzcy5cbiAgICAgIC8vICAgICAgIEFsdGVybmF0aXZlbHksIGl0IG1pZ2h0IGFsc28gYmUgY2FsbGVkIHdoZW4gZWRnZXMgYXJlIHJlbW92ZWQuXG4gICAgICAvL1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhVXBkYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlY29ubmVjdEVkZ2VzKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVmcmVzaCB0aGUgZWRnZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaEVkZ2VzJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMi5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLmVkZ2VzKSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZSB0aGUgcGFyc2VyIGZyb20gdGhlIEVkZ2UgY2xhc3MgdG8gZmlsbCBpbiBhbGwgc2hvcnRoYW5kIG5vdGF0aW9uc1xuICAgICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZGVmYXVsdE9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzbW9vdGggc2V0dGluZ3MgaW4gYWxsIGVkZ2VzXG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5zbW9vdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLnVwZGF0ZUVkZ2VUeXBlKCkgfHwgZGF0YUNoYW5nZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGZvbnRzIGluIGFsbCBlZGdlc1xuICAgICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBfZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShfZWRnZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF0udXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGVkZ2VzIGJ5IHJlYWRpbmcgdGhlIGRhdGEgdGFibGVcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBlZGdlcyAgICBUaGUgZGF0YSBjb250YWluaW5nIHRoZSBlZGdlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0RGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZWRnZXMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyIG9sZEVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBpZiAoZWRnZXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGVkZ2VzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBlZGdlcztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlZGdlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5hZGQoZWRnZXMpO1xuICAgICAgfSBlbHNlIGlmICghZWRnZXMpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuICAgICAgaWYgKG9sZEVkZ2VzRGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgb2xkRWRnZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGRyYXduIGVkZ2VzXG4gICAgICB0aGlzLmJvZHkuZWRnZXMgPSB7fTtcblxuICAgICAgLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cbiAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5lZGdlcykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLmVkZ2VzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dCcpO1xuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGVkZ2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGlkcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuXG4gICAgICAgIHZhciBvbGRFZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICBpZiAob2xkRWRnZSkge1xuICAgICAgICAgIG9sZEVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSBlZGdlc0RhdGEuZ2V0KGlkLCB7IHNob3dJbnRlcm5hbElkczogdHJ1ZSB9KTtcbiAgICAgICAgZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dCcpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3RpbmcgZWRnZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkcykge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCk7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGVkZ2VcbiAgICAgICAgICBlZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKSB8fCBkYXRhQ2hhbmdlZDsgLy8gaWYgYSBzdXBwb3J0IG5vZGUgaXMgYWRkZWQsIGRhdGEgY2FuIGJlIGNoYW5nZWQuXG4gICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGVkZ2VcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXQnKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YVVwZGF0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXhpc3RpbmcgZWRnZXMuIE5vbiBleGlzdGluZyBpZHMgd2lsbCBiZSBpZ25vcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIGVhcmx5IG91dFxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB1dGlsLmZvckVhY2goaWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIEVkZ2UgSGFuZGxlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ib2R5LmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXM0LmJvZHkuZGF0YS5lZGdlcy5fZGF0YVtlZGdlSWRdO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge0VkZ2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IEVkZ2UocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY29ubmVjdCBhbGwgZWRnZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWNvbm5lY3RFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdEVkZ2VzKCkge1xuICAgICAgdmFyIGlkO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBub2Rlc1tpZF0uZWRnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBlZGdlLmZyb20gPSBudWxsO1xuICAgICAgICAgIGVkZ2UudG8gPSBudWxsO1xuICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q29ubmVjdGVkTm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2RlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UuZnJvbUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZS50b0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UudG9JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkaXJlY3QgcmVsYXRpb24gYmV0d2VlbiB0aGUgbm9kZXMgYW5kIHRoZSBlZGdlcyBEYXRhU2V0LFxuICAgICAqIHNvIHRoZSByaWdodCBwbGFjZSB0byBkbyBjYWxsIHRoaXMgaXMgaW4gdGhlIGhhbmRsZXIgZm9yIGV2ZW50IGBfZGF0YVVwZGF0ZWRgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICB0aGlzLl9hZGRNaXNzaW5nRWRnZXMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUludmFsaWRFZGdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYW4gZm9yIG1pc3Npbmcgbm9kZXMgYW5kIHJlbW92ZSBjb3JyZXNwb25kaW5nIGVkZ2VzLCBpZiBhbnkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlbW92ZUludmFsaWRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVJbnZhbGlkRWRnZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGVkZ2VzVG9EZWxldGUgPSBbXTtcblxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGlkKSB7XG4gICAgICAgIHZhciB0b05vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLnRvSWRdO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF07XG5cbiAgICAgICAgLy8gU2tpcCBjbHVzdGVyaW5nIGVkZ2VzIGhlcmUsIGxldCB0aGUgQ2x1c3RlcmluZyBtb2R1bGUgaGFuZGxlIHRob3NlXG4gICAgICAgIGlmICh0b05vZGUgIT09IHVuZGVmaW5lZCAmJiB0b05vZGUuaXNDbHVzdGVyID09PSB0cnVlIHx8IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgZnJvbU5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZyb21Ob2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlc1RvRGVsZXRlLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5yZW1vdmUoZWRnZXNUb0RlbGV0ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbGwgZWRnZXMgZnJvbSBkYXRhc2V0IHRoYXQgYXJlIG5vdCBpbiB0aGUgY2FjaGVkIHN0YXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FkZE1pc3NpbmdFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRNaXNzaW5nRWRnZXMoKSB7XG4gICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICBpZiAoZWRnZXNEYXRhID09PSB1bmRlZmluZWQgfHwgZWRnZXNEYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm8gZWRnZXMgRGF0YVNldCB5ZXQ7IGNhbiBoYXBwZW4gb24gc3RhcnR1cFxuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgYWRkSWRzID0gW107XG5cbiAgICAgIGVkZ2VzRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlRGF0YSwgZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZElkcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZChhZGRJZHMsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZXNIYW5kbGVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBFZGdlc0hhbmRsZXI7XG5cbi8qKiovIH0pLFxuLyogMTY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9zbGljZWRUb0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlZFRvQXJyYXkyKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9DdWJpY0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTY3KTtcblxudmFyIF9DdWJpY0JlemllckVkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1YmljQmV6aWVyRWRnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgQ3ViaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWxcbiAqIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIEN1YmljQmV6aWVyRWRnZUJhc2VcbiAqL1xudmFyIEN1YmljQmV6aWVyRWRnZSA9IGZ1bmN0aW9uIChfQ3ViaWNCZXppZXJFZGdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2UsIF9DdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEN1YmljQmV6aWVyRWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEN1YmljQmV6aWVyRWRnZSk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEN1YmljQmV6aWVyRWRnZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ3ViaWNCZXppZXJFZGdlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gdmlhTm9kZXNcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2UsIFt7XG4gICAga2V5OiAnX2xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZXMpIHtcbiAgICAgIC8vIGdldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHN1cHBvcnQgcG9pbnRzLlxuICAgICAgdmFyIHZpYTEgPSB2aWFOb2Rlc1swXTtcbiAgICAgIHZhciB2aWEyID0gdmlhTm9kZXNbMV07XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhMSwgdmlhMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHt4OiBudW1iZXIsIHk6IG51bWJlcn0+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRWaWFDb29yZGluYXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgdmFyIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG5cbiAgICAgIHZhciB4MSA9IHZvaWQgMCxcbiAgICAgICAgICB5MSA9IHZvaWQgMCxcbiAgICAgICAgICB4MiA9IHZvaWQgMCxcbiAgICAgICAgICB5MiA9IHZvaWQgMDtcbiAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzcztcblxuICAgICAgLy8gaG9yaXpvbnRhbCBpZiB4ID4geSBvciBpZiBkaXJlY3Rpb24gaXMgZm9yY2VkIG9yIGlmIGRpcmVjdGlvbiBpcyBob3Jpem9udGFsXG4gICAgICBpZiAoKE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykgJiYgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiAhPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICB5MSA9IHRoaXMuZnJvbS55O1xuICAgICAgICB5MiA9IHRoaXMudG8ueTtcbiAgICAgICAgeDEgPSB0aGlzLmZyb20ueCAtIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgICB4MiA9IHRoaXMudG8ueCArIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB0aGlzLmZyb20ueSAtIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB5MiA9IHRoaXMudG8ueSArIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB4MSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB4MiA9IHRoaXMudG8ueDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3g6IG51bWJlciwgeTogbnVtYmVyfT59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5lYXJOb2RlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXIsIHQ6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhMVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhMlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICAgIF9yZWYyID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfcmVmLCAyKSxcbiAgICAgICAgICB2aWExID0gX3JlZjJbMF0sXG4gICAgICAgICAgdmlhMiA9IF9yZWYyWzFdO1xuXG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWExLCB2aWEyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnRhZ2VcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFt2aWExPXRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKClbMF1dXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBbdmlhMj10aGlzLl9nZXRWaWFDb29yZGluYXRlcygpWzFdXVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICAgIF9yZWY0ID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfcmVmMywgMiksXG4gICAgICAgICAgdmlhMSA9IF9yZWY0WzBdLFxuICAgICAgICAgIHZpYTIgPSBfcmVmNFsxXTtcblxuICAgICAgdmFyIHQgPSBwZXJjZW50YWdlO1xuICAgICAgdmFyIHZlYyA9IFtdO1xuICAgICAgdmVjWzBdID0gTWF0aC5wb3coMSAtIHQsIDMpO1xuICAgICAgdmVjWzFdID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMik7XG4gICAgICB2ZWNbMl0gPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpO1xuICAgICAgdmVjWzNdID0gTWF0aC5wb3codCwgMyk7XG4gICAgICB2YXIgeCA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnggKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgIHZhciB5ID0gdmVjWzBdICogdGhpcy5mcm9tUG9pbnQueSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHRoaXMudG9Qb2ludC55O1xuXG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdWJpY0JlemllckVkZ2U7XG59KF9DdWJpY0JlemllckVkZ2VCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ3ViaWNCZXppZXJFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDE2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXG52YXIgX0JlemllckVkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JlemllckVkZ2VCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIEJhc2UgQ2xhc3MgZm9yIGFsbCBDdWJpYyBCZXppZXIgRWRnZXMuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWxcbiAqIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIEJlemllckVkZ2VCYXNlXG4gKi9cbnZhciBDdWJpY0JlemllckVkZ2VCYXNlID0gZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2VCYXNlLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChDdWJpY0JlemllckVkZ2VCYXNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2VCYXNlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb21cbiAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxuICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geDEgZnJvbSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHgyIHRvIHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkyIHRvIHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkzIHBvaW50IHRvIGNoZWNrIHlcbiAgICogQHBhcmFtIHtOb2RlfSB2aWExXG4gICAqIEBwYXJhbSB7Tm9kZX0gdmlhMlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEN1YmljQmV6aWVyRWRnZUJhc2UsIFt7XG4gICAga2V5OiAnX2dldERpc3RhbmNlVG9CZXppZXJFZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuICAgICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgICAgdCA9IHZvaWQgMCxcbiAgICAgICAgICB4ID0gdm9pZCAwLFxuICAgICAgICAgIHkgPSB2b2lkIDA7XG4gICAgICB2YXIgbGFzdFggPSB4MTtcbiAgICAgIHZhciBsYXN0WSA9IHkxO1xuICAgICAgdmFyIHZlYyA9IFswLCAwLCAwLCAwXTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICB2ZWNbMF0gPSBNYXRoLnBvdygxIC0gdCwgMyk7XG4gICAgICAgIHZlY1sxXSA9IDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpO1xuICAgICAgICB2ZWNbMl0gPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpO1xuICAgICAgICB2ZWNbM10gPSBNYXRoLnBvdyh0LCAzKTtcbiAgICAgICAgeCA9IHZlY1swXSAqIHgxICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogeDI7XG4gICAgICAgIHkgPSB2ZWNbMF0gKiB5MSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHkyO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdWJpY0JlemllckVkZ2VCYXNlO1xufShfQmV6aWVyRWRnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDdWJpY0JlemllckVkZ2VCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDE2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGljZWRUb0FycmF5Mik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmV6aWVyRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbnZhciBfQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgRHluYW1pYyBCZXppZXIgRWRnZS4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbFxuICogY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuIFRoZSBEeW5hbWljIHBpZWNlIHJlZmVycyB0byBob3cgdGhlIGN1cnZlXG4gKiByZWFjdHMgdG8gcGh5c2ljcyBjaGFuZ2VzLlxuICpcbiAqIEBleHRlbmRzIEJlemllckVkZ2VCYXNlXG4gKi9cbnZhciBCZXppZXJFZGdlRHluYW1pYyA9IGZ1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoQmV6aWVyRWRnZUR5bmFtaWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlRHluYW1pYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEJlemllckVkZ2VEeW5hbWljKTtcblxuICAgIC8vIC0tPiB0aGlzIGNhbGxzIHRoZSBzZXRPcHRpb25zIGJlbG93XG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQmV6aWVyRWRnZUR5bmFtaWMuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKEJlemllckVkZ2VEeW5hbWljKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIC8vdGhpcy52aWEgPSB1bmRlZmluZWQ7IC8vIEhlcmUgZm9yIGNvbXBsZXRlbmVzcyBidXQgbm90IGFsbG93ZWQgdG8gZGVmaW5lZCBiZWZvcmUgc3VwZXIoKSBpcyBpbnZva2VkLlxuXG5cbiAgICBfdGhpcy5fYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgIH07XG4gICAgX3RoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVwb3NpdGlvbkJlemllck5vZGVzJywgX3RoaXMuX2JvdW5kRnVuY3Rpb24pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJlemllckVkZ2VEeW5hbWljLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhcyBjaGFuZ2VkLlxuICAgICAgdmFyIHBoeXNpY3NDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzKSB7XG4gICAgICAgIHBoeXNpY3NDaGFuZ2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIG9wdGlvbnMgYW5kIHRoZSB0byBhbmQgZnJvbSBub2Rlc1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuXG4gICAgICAvLyBzZXR1cCB0aGUgc3VwcG9ydCBub2RlIGFuZCBjb25uZWN0XG4gICAgICB0aGlzLnNldHVwU3VwcG9ydE5vZGUoKTtcbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgICAvLyB3aGVuIHdlIGNoYW5nZSB0aGUgcGh5c2ljcyBzdGF0ZSBvZiB0aGUgZWRnZSwgd2UgcmVwb3NpdGlvbiB0aGUgc3VwcG9ydCBub2RlLlxuICAgICAgaWYgKHBoeXNpY3NDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IHRoaXMub3B0aW9ucy5waHlzaWNzIH0pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGFuIGVkZ2UgdG8gbm9kZShzKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICBpZiAodGhpcy5mcm9tID09PSB1bmRlZmluZWQgfHwgdGhpcy50byA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5waHlzaWNzID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaXggd2VpcmQgYmVoYXZpb3VyIHdoZXJlIGEgc2VsZiByZWZlcmVuY2luZyBub2RlIGhhcyBwaHlzaWNzIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5pZCA9PT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgc3VwcG9ydCBub2Rlc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhbnVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZignX3JlcG9zaXRpb25CZXppZXJOb2RlcycsIHRoaXMuX2JvdW5kRnVuY3Rpb24pO1xuICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnZpYS5pZF07XG4gICAgICAgIHRoaXMudmlhID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZXppZXIgY3VydmVzIHJlcXVpcmUgYW4gYW5jaG9yIHBvaW50IHRvIGNhbGN1bGF0ZSB0aGUgc21vb3RoIGZsb3cuIFRoZXNlIHBvaW50cyBhcmUgbm9kZXMuIFRoZXNlIG5vZGVzIGFyZSBpbnZpc2libGUgYnV0XG4gICAgICogYXJlIHVzZWQgZm9yIHRoZSBmb3JjZSBjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBjaGFuZ2VkIGRhdGEgaXMgbm90IGNhbGxlZCwgaWYgbmVlZGVkLCBpdCBpcyByZXR1cm5lZCBieSB0aGUgbWFpbiBlZGdlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldHVwU3VwcG9ydE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFN1cHBvcnROb2RlKCkge1xuICAgICAgaWYgKHRoaXMudmlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9ICdlZGdlSWQ6JyArIHRoaXMuaWQ7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKHtcbiAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICB0aGlzLnZpYSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlhLnBhcmVudEVkZ2VJZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIGJlemllciBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uQmV6aWVyTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uQmV6aWVyTm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpYS54ID0gMC41ICogKHRoaXMuZnJvbS54ICsgdGhpcy50by54KTtcbiAgICAgICAgdGhpcy52aWEueSA9IDAuNSAqICh0aGlzLmZyb20ueSArIHRoaXMudG8ueSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52aWEueCA9IDA7XG4gICAgICAgIHRoaXMudmlhLnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKSB7XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXx1bmRlZmluZWR8Knx7aW5kZXgsIGxpbmUsIGNvbHVtbn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVkIGZ1bmN0aW9uIG9mIHBvaW50T25MaW5lIGFuZCBwb2ludE9uQmV6aWVyLiBUaGlzIGdpdmVzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBsaW5lIGF0IGEgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB3YXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50YWdlXG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwZXJjZW50YWdlKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52aWE7XG5cbiAgICAgIHZhciB0ID0gcGVyY2VudGFnZTtcbiAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgIHkgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5mcm9tID09PSB0aGlzLnRvKSB7XG4gICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YSA9IHRoaXMuX2dldENpcmNsZURhdGEodGhpcy5mcm9tKSxcbiAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhMiA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENpcmNsZURhdGEsIDMpLFxuICAgICAgICAgICAgY3ggPSBfZ2V0Q2lyY2xlRGF0YTJbMF0sXG4gICAgICAgICAgICBjeSA9IF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICAgIGNyID0gX2dldENpcmNsZURhdGEyWzJdO1xuXG4gICAgICAgIHZhciBhID0gMiAqIE1hdGguUEkgKiAoMSAtIHQpO1xuICAgICAgICB4ID0gY3ggKyBjciAqIE1hdGguc2luKGEpO1xuICAgICAgICB5ID0gY3kgKyBjciAtIGNyICogKDEgLSBNYXRoLmNvcyhhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICAgIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC55ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS55ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBuZWFyTm9kZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIHRoaXMudmlhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRoaXMudmlhKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJlemllckVkZ2VEeW5hbWljO1xufShfQmV6aWVyRWRnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCZXppZXJFZGdlRHluYW1pYztcblxuLyoqKi8gfSksXG4vKiAxNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CZXppZXJFZGdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIF9CZXppZXJFZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CZXppZXJFZGdlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQSBTdGF0aWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWxcbiAqIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIEJlemllckVkZ2VCYXNlXG4gKi9cbnZhciBCZXppZXJFZGdlU3RhdGljID0gZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShCZXppZXJFZGdlU3RhdGljLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZVN0YXRpYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEJlemllckVkZ2VTdGF0aWMpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChCZXppZXJFZGdlU3RhdGljLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShCZXppZXJFZGdlU3RhdGljKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShCZXppZXJFZGdlU3RhdGljLCBbe1xuICAgIGtleTogJ19saW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpIHtcbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3g6IG51bWJlciwgeTogbnVtYmVyfT59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgZG8gbm90IHVzZSB0aGUgdG8gYW5kIGZyb21Qb2ludHMgaGVyZSB0byBtYWtlIHRoZSB2aWEgbm9kZXMgdGhlIHNhbWUgYXMgZWRnZXMgd2l0aG91dCBhcnJvd3MuXG4gICAgICogQHJldHVybnMge3t4OiB1bmRlZmluZWQsIHk6IHVuZGVmaW5lZH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFZpYUNvb3JkaW5hdGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgLy8gQXNzdW1wdGlvbjogeC95IGNvb3JkaW5hdGVzIGluIGZyb20vdG8gYWx3YXlzIGRlZmluZWRcbiAgICAgIHZhciB4VmlhID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHlWaWEgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZmFjdG9yID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMub3B0aW9ucy5zbW9vdGgudHlwZTtcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KTtcbiAgICAgIGlmICh0eXBlID09PSAnZGlzY3JldGUnIHx8IHR5cGUgPT09ICdkaWFnb25hbENyb3NzJykge1xuICAgICAgICB2YXIgc3RlcFggPSB2b2lkIDA7XG4gICAgICAgIHZhciBzdGVwWSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICBzdGVwWCA9IHN0ZXBZID0gZmFjdG9yICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcFggPSBzdGVwWSA9IGZhY3RvciAqIGR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSBzdGVwWCA9IC1zdGVwWDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkgc3RlcFkgPSAtc3RlcFk7XG5cbiAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgc3RlcFg7XG4gICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIHN0ZXBZO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnZGlzY3JldGUnKSB7XG4gICAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgICB4VmlhID0gZHggPCBmYWN0b3IgKiBkeSA/IHRoaXMuZnJvbS54IDogeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeVZpYSA9IGR5IDwgZmFjdG9yICogZHggPyB0aGlzLmZyb20ueSA6IHlWaWE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJhaWdodENyb3NzJykge1xuICAgICAgICB2YXIgX3N0ZXBYID0gKDEgLSBmYWN0b3IpICogZHg7XG4gICAgICAgIHZhciBfc3RlcFkgPSAoMSAtIGZhY3RvcikgKiBkeTtcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICAvLyB1cCAtIGRvd25cbiAgICAgICAgICBfc3RlcFggPSAwO1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkgX3N0ZXBZID0gLV9zdGVwWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsZWZ0IC0gcmlnaHRcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIF9zdGVwWCA9IC1fc3RlcFg7XG4gICAgICAgICAgX3N0ZXBZID0gMDtcbiAgICAgICAgfVxuICAgICAgICB4VmlhID0gdGhpcy50by54ICsgX3N0ZXBYO1xuICAgICAgICB5VmlhID0gdGhpcy50by55ICsgX3N0ZXBZO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdmFyIF9zdGVwWDIgPSAoMSAtIGZhY3RvcikgKiBkeDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSBfc3RlcFgyID0gLV9zdGVwWDI7XG4gICAgICAgIHhWaWEgPSB0aGlzLnRvLnggKyBfc3RlcFgyO1xuICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgdmFyIF9zdGVwWTIgPSAoMSAtIGZhY3RvcikgKiBkeTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSBfc3RlcFkyID0gLV9zdGVwWTI7XG4gICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueDtcbiAgICAgICAgeVZpYSA9IHRoaXMudG8ueSArIF9zdGVwWTI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjdXJ2ZWRDVycpIHtcbiAgICAgICAgZHggPSB0aGlzLnRvLnggLSB0aGlzLmZyb20ueDtcbiAgICAgICAgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciBwaSA9IE1hdGguUEk7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIHZhciBteUFuZ2xlID0gKG9yaWdpbmFsQW5nbGUgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHBpKSAlICgyICogcGkpO1xuXG4gICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5zaW4obXlBbmdsZSk7XG4gICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5jb3MobXlBbmdsZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjdXJ2ZWRDQ1cnKSB7XG4gICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIF9waSA9IE1hdGguUEk7XG5cbiAgICAgICAgdmFyIF9vcmlnaW5hbEFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICB2YXIgX215QW5nbGUgPSAoX29yaWdpbmFsQW5nbGUgKyAoLWZhY3RvciAqIDAuNSArIDAuNSkgKiBfcGkpICUgKDIgKiBfcGkpO1xuXG4gICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguc2luKF9teUFuZ2xlKTtcbiAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5jb3MoX215QW5nbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udGludW91c1xuICAgICAgICB2YXIgX3N0ZXBYMyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIF9zdGVwWTMgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IF9zdGVwWTMgPSBmYWN0b3IgKiBkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3RlcFgzID0gX3N0ZXBZMyA9IGZhY3RvciAqIGR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSBfc3RlcFgzID0gLV9zdGVwWDM7XG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIF9zdGVwWTMgPSAtX3N0ZXBZMztcblxuICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBfc3RlcFgzO1xuICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBfc3RlcFkzO1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggPCB4VmlhID8gdGhpcy50by54IDogeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCA+IHhWaWEgPyB0aGlzLnRvLnggOiB4VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICB5VmlhID0gdGhpcy50by55ID4geVZpYSA/IHRoaXMudG8ueSA6IHlWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgPCB5VmlhID8gdGhpcy50by55IDogeVZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHg6IHhWaWEsIHk6IHlWaWEgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgb3B0aW9ucy52aWEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0VkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG5cbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYU5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVkIGZ1bmN0aW9uIG9mIHBvaW50T25MaW5lIGFuZCBwb2ludE9uQmV6aWVyLiBUaGlzIGdpdmVzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBsaW5lIGF0IGEgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB3YXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudGFnZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhTm9kZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG5cbiAgICAgIHZhciB0ID0gcGVyY2VudGFnZTtcbiAgICAgIHZhciB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICB2YXIgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC55O1xuXG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCZXppZXJFZGdlU3RhdGljO1xufShfQmV6aWVyRWRnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCZXppZXJFZGdlU3RhdGljO1xuXG4vKioqLyB9KSxcbi8qIDE3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0VkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xuXG52YXIgX0VkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VkZ2VCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIFN0cmFpZ2h0IEVkZ2UuXG4gKlxuICogQGV4dGVuZHMgRWRnZUJhc2VcbiAqL1xudmFyIFN0cmFpZ2h0RWRnZSA9IGZ1bmN0aW9uIChfRWRnZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoU3RyYWlnaHRFZGdlLCBfRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3RyYWlnaHRFZGdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgU3RyYWlnaHRFZGdlKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoU3RyYWlnaHRFZGdlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShTdHJhaWdodEVkZ2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gIH1cblxuICAvKipcbiAgICogRHJhdyBhIGxpbmUgYmV0d2VlbiB0d28gbm9kZXNcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU3RyYWlnaHRFZGdlLCBbe1xuICAgIGtleTogJ19saW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudGFnZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgLSBwZXJjZW50YWdlKSAqIHRoaXMuZnJvbVBvaW50LnggKyBwZXJjZW50YWdlICogdGhpcy50b1BvaW50LngsXG4gICAgICAgIHk6ICgxIC0gcGVyY2VudGFnZSkgKiB0aGlzLmZyb21Qb2ludC55ICsgcGVyY2VudGFnZSAqIHRoaXMudG9Qb2ludC55XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBuZWFyTm9kZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIG5vZGUyID0gdGhpcy50bztcbiAgICAgIH1cblxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgdmFyIGR4ID0gbm9kZTEueCAtIG5vZGUyLng7XG4gICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgIHZhciBlZGdlU2VnbWVudExlbmd0aCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB2YXIgdG9Cb3JkZXJEaXN0ID0gbmVhck5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIHZhciB0b0JvcmRlclBvaW50ID0gKGVkZ2VTZWdtZW50TGVuZ3RoIC0gdG9Cb3JkZXJEaXN0KSAvIGVkZ2VTZWdtZW50TGVuZ3RoO1xuXG4gICAgICB2YXIgYm9yZGVyUG9zID0ge307XG4gICAgICBib3JkZXJQb3MueCA9ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi54ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLng7XG4gICAgICBib3JkZXJQb3MueSA9ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi55ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLnk7XG5cbiAgICAgIHJldHVybiBib3JkZXJQb3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXREaXN0YW5jZVRvRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmFpZ2h0RWRnZTtcbn0oX0VkZ2VCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3RyYWlnaHRFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDE3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgQmFybmVzSHV0U29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSlbJ2RlZmF1bHQnXTtcbnZhciBSZXB1bHNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MilbJ2RlZmF1bHQnXTtcbnZhciBIaWVyYXJjaGljYWxSZXB1bHNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MylbJ2RlZmF1bHQnXTtcbnZhciBTcHJpbmdTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NClbJ2RlZmF1bHQnXTtcbnZhciBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NSlbJ2RlZmF1bHQnXTtcbnZhciBDZW50cmFsR3Jhdml0eVNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oODIpWydkZWZhdWx0J107XG52YXIgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2KVsnZGVmYXVsdCddO1xudmFyIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTc3KVsnZGVmYXVsdCddO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEVuZFBvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODApWydkZWZhdWx0J107IC8vIGZvciBkZWJ1Z2dpbmcgd2l0aCBfZHJhd0ZvcmNlcygpXG5cbi8qKlxuICogVGhlIHBoeXNpY3MgZW5naW5lXG4gKi9cblxudmFyIFBoeXNpY3NFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gUGh5c2ljc0VuZ2luZShib2R5KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgUGh5c2ljc0VuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSB7XG4gICAgICBwaHlzaWNzTm9kZUluZGljZXM6IFtdLFxuICAgICAgcGh5c2ljc0VkZ2VJbmRpY2VzOiBbXSxcbiAgICAgIGZvcmNlczoge30sXG4gICAgICB2ZWxvY2l0aWVzOiB7fVxuICAgIH07XG5cbiAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCA9IDEwMDAgLyA2MDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5wcmV2aW91c1N0YXRlcyA9IHt9O1xuICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcbiAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHBhcmFtZXRlcnMgZm9yIHRoZSBhZGFwdGl2ZSB0aW1lc3RlcFxuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IDA7XG4gICAgdGhpcy5hZGFwdGl2ZUludGVydmFsID0gMztcblxuICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7IC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhlIHN0YWJpbGl6ZVxuXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBiYXJuZXNIdXQ6IHtcbiAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtMjAwMCxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMyxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiA5NSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDQsXG4gICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtNTAsXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjAxLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wOCxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDAuNCxcbiAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICB9LFxuICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjIsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMjAwLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDEsXG4gICAgICAgIG5vZGVEaXN0YW5jZTogMTIwLFxuICAgICAgICBkYW1waW5nOiAwLjA5XG4gICAgICB9LFxuICAgICAgbWF4VmVsb2NpdHk6IDUwLFxuICAgICAgbWluVmVsb2NpdHk6IDAuNzUsIC8vIHB4L3NcbiAgICAgIHNvbHZlcjogJ2Jhcm5lc0h1dCcsXG4gICAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAsIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiB0byBzdGFiaWxpemVcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IDUwLFxuICAgICAgICBvbmx5RHluYW1pY0VkZ2VzOiBmYWxzZSxcbiAgICAgICAgZml0OiB0cnVlXG4gICAgICB9LFxuICAgICAgdGltZXN0ZXA6IDAuNSxcbiAgICAgIGFkYXB0aXZlVGltZXN0ZXA6IHRydWVcbiAgICB9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy50aW1lc3RlcCA9IDAuNTtcbiAgICB0aGlzLmxheW91dEZhaWxlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShQaHlzaWNzRW5naW5lLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuaW5pdFBoeXNpY3MoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19sYXlvdXRGYWlsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmxheW91dEZhaWxlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyZXNldFBoeXNpY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIF90aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkaXNhYmxlUGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3Jlc3RvcmVQaHlzaWNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zZXRPcHRpb25zKF90aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignc3RhcnRTaW11bGF0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignc3RvcFNpbXVsYXRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbihmYWxzZSk7XG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm9kZXMgYW5kL29yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLCB1cGRhdGUgc2hvcnRjdXQgbGlzdHMuXG4gICAgICAgIF90aGlzLnVwZGF0ZVBoeXNpY3NEYXRhKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZGVidWc6IHNob3cgZm9yY2VzXG4gICAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZHJhd0ZvcmNlcyhjdHgpO30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgcGh5c2ljcyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlTm90RGVlcEV4dGVuZChbJ3N0YWJpbGl6YXRpb24nXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdzdGFiaWxpemF0aW9uJyk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2V0IHRoZSB0aW1lc3RlcFxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbmZpZ3VyZSB0aGUgZW5naW5lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09ICdmb3JjZUF0bGFzMkJhc2VkJykge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmZvcmNlQXRsYXMyQmFzZWQ7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09ICdyZXB1bHNpb24nKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmVwdWxzaW9uO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IFJlcHVsc2lvbih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbicpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWxSZXB1bHNpb247XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsUmVwdWxzaW9uKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYmFybmVzSHV0XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYmFybmVzSHV0O1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEJhcm5lc0h1dFNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RlbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgdGhlIGVuZ2luZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0UGh5c2ljcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQaHlzaWNzKCkge1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnN0YWJpbGl6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2ZpdCcsIHt9LCB0aGlzLmxheW91dEZhaWxlZCk7IC8vIGlmIHRoZSBsYXlvdXQgZmFpbGVkLCB3ZSB1c2UgdGhlIGFwcHJveGltYXRpb24gZm9yIHRoZSB6b29tXG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2ZpdCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBzaW11bGF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0U2ltdWxhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2ltdWxhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHdoZW4gdmlzaWJsZSwgYWRhcHRpdml0eSBpcyBkaXNhYmxlZC5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXNpemVOb2RlcycpO1xuICAgICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5zaW11bGF0aW9uU3RlcC5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UmVkcmF3JywgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdGFydFJlbmRlcmluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgc2ltdWxhdGlvbiwgZm9yY2Ugc3RhYmlsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3BTaW11bGF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFNpbXVsYXRpb24oKSB7XG4gICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgdGhpcy5zdGFiaWxpemVkID0gdHJ1ZTtcbiAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoJ2luaXRSZWRyYXcnLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdG9wUmVuZGVyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmlld0Z1bmN0aW9uIGluc2VydHMgdGhpcyBzdGVwIGludG8gZWFjaCByZW5kZXIgbG9vcC4gSXQgY2FsbHMgdGhlIHBoeXNpY3MgdGljayBhbmQgaGFuZGxlcyB0aGUgY2xlYW51cCBhdCBzdGFiaWxpemVkLlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NpbXVsYXRpb25TdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2ltdWxhdGlvblN0ZXAoKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgcGh5c2ljcyBoYXZlIHNldHRsZWRcbiAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgdmFyIHBoeXNpY3NUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gcnVuIGRvdWJsZSBzcGVlZCBpZiBpdCBpcyBhIGxpdHRsZSBncmFwaFxuICAgICAgaWYgKChwaHlzaWNzVGltZSA8IDAuNCAqIHRoaXMuc2ltdWxhdGlvbkludGVydmFsIHx8IHRoaXMucnVuRG91YmxlU3BlZWQgPT09IHRydWUpICYmIHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgc3VyZSB0aGVyZSBpcyBubyBqaXR0ZXIuIFRoZSBkZWNpc2lvbiBpcyB0YWtlbiBvbmNlIHRvIHJ1biBpdCBhdCBkb3VibGUgc3BlZWQuXG4gICAgICAgIHRoaXMucnVuRG91YmxlU3BlZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmlnZ2VyIHRoZSBzdGFiaWxpemVkIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRPZkl0ZXJhdGlvbnM9dGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9uc11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZW1pdFN0YWJpbGl6ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN0YWJpbGl6ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGFtb3VudE9mSXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucztcblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPiAxIHx8IHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemVkJywgeyBpdGVyYXRpb25zOiBhbW91bnRPZkl0ZXJhdGlvbnMgfSk7XG4gICAgICAgICAgX3RoaXMyLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgZm9yIG9uZSBwaHlzaWNzIGl0ZXJhdGlvbiBhbmQgbW92ZSB0aGUgbm9kZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGh5c2ljc1N0ZXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzU3RlcCgpIHtcbiAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5ub2Rlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGR5bmFtaWMgYWRqdXN0bWVudHMgdG8gdGhlIHRpbWVzdGVwLCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBwaHlzaWNzVGljaygpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkanVzdFRpbWVTdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0VGltZVN0ZXAoKSB7XG4gICAgICB2YXIgZmFjdG9yID0gMS4yOyAvLyBGYWN0b3IgZm9yIGluY3JlYXNpbmcgdGhlIHRpbWVzdGVwIG9uIHN1Y2Nlc3MuXG5cbiAgICAgIC8vIHdlIGNvbXBhcmUgdGhlIHR3byBzdGVwcy4gaWYgaXQgaXMgYWNjZXB0YWJsZSB3ZSBkb3VibGUgdGhlIHN0ZXAuXG4gICAgICBpZiAodGhpcy5fZXZhbHVhdGVTdGVwUXVhbGl0eSgpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudGltZXN0ZXAgPSBmYWN0b3IgKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm90LCB3ZSBkZWNyZWFzZSB0aGUgc3RlcCB0byBhIG1pbmltdW0gb2YgdGhlIG9wdGlvbnMgdGltZXN0ZXAuXG4gICAgICAgIC8vIGlmIHRoZSBkZWNyZWFzZWQgdGltZXN0ZXAgaXMgc21hbGxlciB0aGFuIHRoZSBvcHRpb25zIHN0ZXAsIHdlIGRvIG5vdCByZXNldCB0aGUgY291bnRlclxuICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCB0aGUgb3B0aW9ucyB0aW1lc3RlcCBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAgICBpZiAodGhpcy50aW1lc3RlcCAvIGZhY3RvciA8IHRoaXMub3B0aW9ucy50aW1lc3RlcCkge1xuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHRpbWVzdGVwIHdhcyBsYXJnZXIgdGhhbiAyIHRpbWVzIHRoZSBvcHRpb24gb25lIHdlIGNoZWNrIHRoZSBhZGFwdGl2aXR5IGFnYWluIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgbGFyZ2UgaW5zdGFiaWxpdGllcyBkbyBub3QgZm9ybS5cbiAgICAgICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IC0xOyAvLyBjaGVjayBhZ2FpbiBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSBNYXRoLm1heCh0aGlzLm9wdGlvbnMudGltZXN0ZXAsIHRoaXMudGltZXN0ZXAgLyBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW5nbGUgc2ltdWxhdGlvbiBzdGVwIChvciAndGljaycpIGluIHRoZSBwaHlzaWNzIHNpbXVsYXRpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BoeXNpY3NUaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGh5c2ljc1RpY2soKSB7XG4gICAgICB0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCk7IC8vIHRoaXMgZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vIHN0YXJ0IGV2ZW50IHdoZW4gdGhlIG5ldHdvcmsgaXMgYWxyZWFkeSBzdGFibGUuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSByZXR1cm47XG5cbiAgICAgIC8vIGFkYXB0aXZpdHkgbWVhbnMgdGhlIHRpbWVzdGVwIGFkYXB0cyB0byB0aGUgc2l0dWF0aW9uLCBvbmx5IGFwcGxpY2FibGUgZm9yIHN0YWJpbGl6YXRpb25cbiAgICAgIGlmICh0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPT09IHRydWUgJiYgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB0aW1lc3RlcCByZW1haW5zIHN0YWJsZSBmb3IgXCJpbnRlcnZhbFwiIGl0ZXJhdGlvbnMuXG4gICAgICAgIHZhciBkb0FkYXB0aXZlID0gdGhpcy5hZGFwdGl2ZUNvdW50ZXIgJSB0aGlzLmFkYXB0aXZlSW50ZXJ2YWwgPT09IDA7XG5cbiAgICAgICAgaWYgKGRvQWRhcHRpdmUpIHtcbiAgICAgICAgICAvLyBmaXJzdCB0aGUgYmlnIHN0ZXAgYW5kIHJldmVydC5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMiAqIHRoaXMudGltZXN0ZXA7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMucmV2ZXJ0KCk7IC8vIHNhdmVzIHRoZSByZWZlcmVuY2Ugc3RhdGVcblxuICAgICAgICAgIC8vIG5vdyB0aGUgbm9ybWFsIHN0ZXAuIFNpbmNlIHRoaXMgaXMgdGhlIGxhc3Qgc3RlcCwgaXQgaXMgdGhlIG1vcmUgc3RhYmxlIG9uZSBhbmQgd2Ugd2lsbCB0YWtlIHRoaXMuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IDAuNSAqIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgICAgICAvLyBzaW5jZSBpdCdzIGhhbGYgdGhlIHN0ZXAsIHdlIGRvIGl0IHR3aWNlLlxuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG5cbiAgICAgICAgICB0aGlzLmFkanVzdFRpbWVTdGVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpOyAvLyBub3JtYWwgc3RlcCwga2VlcGluZyB0aW1lc3RlcCBjb25zdGFudFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgZm9yIHRoZSBzdGF0aWMgdGltZXN0ZXAsIHdlIHJlc2V0IGl0IHRvIHRoZSBvbmUgaW4gb3B0aW9ucyBhbmQgdGFrZSBhIG5vcm1hbCBzdGVwLlxuICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHRoaXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zKys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9kZXMgYW5kIGVkZ2VzIGNhbiBoYXZlIHRoZSBwaHlzaWNzIHRvZ2dsZXMgb24gb3Igb2ZmLiBBIGNvbGxlY3Rpb24gb2YgaW5kaWNlcyBpcyBjcmVhdGVkIGhlcmUgc28gd2UgY2FuIHNraXAgdGhlIGNoZWNrIGFsbCB0aGUgdGltZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVBoeXNpY3NEYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGh5c2ljc0RhdGEoKSB7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcyA9IHt9O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMgPSBbXTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIC8vIGdldCBub2RlIGluZGljZXMgZm9yIHBoeXNpY3NcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGVkZ2UgaW5kaWNlcyBmb3IgcGh5c2ljc1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIHZlbG9jaXR5IGFuZCB0aGUgZm9yY2VzIHZlY3RvclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tfbm9kZUlkXSA9IHsgeDogMCwgeTogMFxuXG4gICAgICAgICAgLy8gZm9yY2VzIGNhbiBiZSByZXNldCBiZWNhdXNlIHRoZXkgYXJlIHJlY2FsY3VsYXRlZC4gVmVsb2NpdGllcyBoYXZlIHRvIHBlcnNpc3QuXG4gICAgICAgIH07aWYgKHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2xlYW4gZGVsZXRlZCBub2RlcyBmcm9tIHRoZSB2ZWxvY2l0eSB2ZWN0b3JcbiAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcykge1xuICAgICAgICBpZiAobm9kZXNbX25vZGVJZDJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWQyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aGUgc2ltdWxhdGlvbiBvbmUgc3RlcC4gVGhpcyBpcyBkb25lIHNvIGFmdGVyIHN0YWJpbGl6YXRpb24sIGV2ZXJ5IG5ldyBzdGFydCBvZiB0aGUgc2ltdWxhdGlvbiB3aWxsIGFsc28gc2F5IHN0YWJpbGl6ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JldmVydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydCgpIHtcbiAgICAgIHZhciBub2RlSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKSh0aGlzLnByZXZpb3VzU3RhdGVzKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciB2ZWxvY2l0aWVzID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzO1xuICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJZHNbaV07XG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGVbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zOiB7IHg6IG5vZGVzW25vZGVJZF0ueCwgeTogbm9kZXNbbm9kZUlkXS55IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueCA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eDtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS55ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ5O1xuICAgICAgICAgICAgbm9kZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLng7XG4gICAgICAgICAgICBub2Rlc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0ueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY29tcGFyZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2V2YWx1YXRlU3RlcFF1YWxpdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbHVhdGVTdGVwUXVhbGl0eSgpIHtcbiAgICAgIHZhciBkeCA9IHZvaWQgMCxcbiAgICAgICAgICBkeSA9IHZvaWQgMCxcbiAgICAgICAgICBkcG9zID0gdm9pZCAwO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlU3RhdGU7XG4gICAgICB2YXIgcG9zVGhyZXNob2xkID0gMC4zO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5yZWZlcmVuY2VTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VTdGF0ZS5oYXNPd25Qcm9wZXJ0eShub2RlSWQpICYmIG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGR4ID0gbm9kZXNbbm9kZUlkXS54IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLng7XG4gICAgICAgICAgZHkgPSBub2Rlc1tub2RlSWRdLnkgLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueTtcblxuICAgICAgICAgIGRwb3MgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcblxuICAgICAgICAgIGlmIChkcG9zID4gcG9zVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlcyBvbmUgdGltZXN0ZXAgYW5kIGNoZWNrIGlmIHRoZXkgYXJlIHN0YWJpbGl6ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZU5vZGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgbWF4Tm9kZVZlbG9jaXR5ID0gMDtcbiAgICAgIHZhciBhdmVyYWdlTm9kZVZlbG9jaXR5ID0gMDtcblxuICAgICAgLy8gdGhlIHZlbG9jaXR5IHRocmVzaG9sZCAoZW5lcmd5IGluIHRoZSBzeXN0ZW0pIGZvciB0aGUgYWRhcHRpdml0eSB0b2dnbGVcbiAgICAgIHZhciB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkID0gNTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIHZhciBub2RlVmVsb2NpdHkgPSB0aGlzLl9wZXJmb3JtU3RlcChub2RlSWQpO1xuICAgICAgICAvLyBzdGFiaWxpemVkIGlzIHRydWUgaWYgc3RhYmlsaXplZCBpcyB0cnVlIGFuZCB2ZWxvY2l0eSBpcyBzbWFsbGVyIHRoYW4gdm1pbiAtLT4gYWxsIG5vZGVzIG11c3QgYmUgc3RhYmlsaXplZFxuICAgICAgICBtYXhOb2RlVmVsb2NpdHkgPSBNYXRoLm1heChtYXhOb2RlVmVsb2NpdHksIG5vZGVWZWxvY2l0eSk7XG4gICAgICAgIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgKz0gbm9kZVZlbG9jaXR5O1xuICAgICAgfVxuXG4gICAgICAvLyBldmFsdWF0aW5nIHRoZSBzdGFiaWxpemVkIGFuZCBhZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCBjb25kaXRpb25zXG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gYXZlcmFnZU5vZGVWZWxvY2l0eSAvIG5vZGVJbmRpY2VzLmxlbmd0aCA8IHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQ7XG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBtYXhOb2RlVmVsb2NpdHkgPCB0aGlzLm9wdGlvbnMubWluVmVsb2NpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG5ldyB2ZWxvY2l0eSBmb3IgYSBjb29yZGluYXRlIGRpcmVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYgIHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiAgcmVndWxhciBmb3JjZSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG0gIG1hc3Mgb2YgY3VycmVudCBub2RlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbmV3IHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHYsIGYsIG0pIHtcbiAgICAgIHZhciBkZiA9IHRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcgKiB2OyAvLyBkYW1waW5nIGZvcmNlXG4gICAgICB2YXIgYSA9IChmIC0gZGYpIC8gbTsgLy8gYWNjZWxlcmF0aW9uXG5cbiAgICAgIHYgKz0gYSAqIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgIC8vIFB1dCBhIGxpbWl0IG9uIHRoZSB2ZWxvY2l0aWVzIGlmIGl0IGlzIHJlYWxseSBoaWdoXG4gICAgICB2YXIgbWF4ViA9IHRoaXMub3B0aW9ucy5tYXhWZWxvY2l0eSB8fCAxZTk7XG4gICAgICBpZiAoTWF0aC5hYnModikgPiBtYXhWKSB7XG4gICAgICAgIHYgPSB2ID4gMCA/IG1heFYgOiAtbWF4VjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB0aGUgYWN0dWFsIHN0ZXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIG5ldyB2ZWxvY2l0eSBvZiBnaXZlbiBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BlcmZvcm1TdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1TdGVwKG5vZGVJZCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGVJZF07XG4gICAgICB2YXIgdmVsb2NpdHkgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbbm9kZUlkXTtcblxuICAgICAgLy8gc3RvcmUgdGhlIHN0YXRlIHNvIHdlIGNhbiByZXZlcnRcbiAgICAgIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXSA9IHtcbiAgICAgICAgeDogbm9kZS54LFxuICAgICAgICB5OiBub2RlLnksXG4gICAgICAgIHZ4OiB2ZWxvY2l0eS54LFxuICAgICAgICB2eTogdmVsb2NpdHkueVxuICAgICAgfTtcblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS54ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS54LCBmb3JjZS54LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueCArPSB2ZWxvY2l0eS54ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnggPSAwO1xuICAgICAgICB2ZWxvY2l0eS54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS55ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS55LCBmb3JjZS55LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueSArPSB2ZWxvY2l0eS55ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnkgPSAwO1xuICAgICAgICB2ZWxvY2l0eS55ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVmVsb2NpdHkgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHkueCwgMikgKyBNYXRoLnBvdyh2ZWxvY2l0eS55LCAyKSk7XG4gICAgICByZXR1cm4gdG90YWxWZWxvY2l0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGluaXRpYWxpemluZyBhbmQgc3RhYmlsaXppbmcsIHdlIGNhbiBmcmVlemUgbm9kZXMgd2l0aCBhIHByZWRlZmluZWQgcG9zaXRpb24uXG4gICAgICogVGhpcyBncmVhdGx5IHNwZWVkcyB1cCBzdGFiaWxpemF0aW9uIGJlY2F1c2Ugb25seSB0aGUgc3VwcG9ydG5vZGVzIGZvciB0aGUgc21vb3RoQ3VydmVzIGhhdmUgdG8gc2V0dGxlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZyZWV6ZU5vZGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZyZWV6ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tpZF0ueCAmJiBub2Rlc1tpZF0ueSkge1xuICAgICAgICAgICAgdmFyIGZpeGVkID0gbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlW2lkXSA9IHsgeDogZml4ZWQueCwgeTogZml4ZWQueSB9O1xuICAgICAgICAgICAgZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICBmaXhlZC55ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmZyZWV6ZXMgdGhlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGZyb3plbiBieSBfZnJlZXplRGVmaW5lZE5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3Jlc3RvcmVGcm96ZW5Ob2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRnJvemVuTm9kZXMoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJlZXplQ2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnggPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS54O1xuICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHN0YWJsZSBwb3NpdGlvbiBmb3IgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZXJhdGlvbnM9dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9uc11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RhYmlsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhYmlsaXplKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zO1xuICAgICAgICBjb25zb2xlLmxvZygnVGhlIHN0YWJpbGl6ZSBtZXRob2QgbmVlZHMgYSBudW1lcmljIGFtb3VudCBvZiBpdGVyYXRpb25zLiBTd2l0Y2hpbmcgdG8gZGVmYXVsdDogJywgaXRlcmF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZW5hYmxlIGFkYXB0aXZlIHRpbWVzdGVwc1xuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuYWRhcHRpdmVUaW1lc3RlcDtcblxuICAgICAgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVzaXplTm9kZXMnKTtcblxuICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpOyAvLyBzdG9wIHRoZSByZW5kZXIgbG9vcFxuICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG5cbiAgICAgIC8vIGJsb2NrIHJlZHJhdyByZXF1ZXN0c1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2Jsb2NrUmVkcmF3Jyk7XG4gICAgICB0aGlzLnRhcmdldEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuXG4gICAgICAvLyBzdGFydCB0aGUgc3RhYmlsaXphdGlvblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZnJlZXplTm9kZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc3RhYmlsaXphdGlvbkJhdGNoKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBub3QgYWxyZWFkeSBzdGFiaWxpemluZywgc3RhcnQgaXQgYW5kIGVtaXQgYSBzdGFydCBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHN0YWJpbGl6YXRpb24gc3RhcnRlZCB3aXRoIHRoaXMgY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zdGFydFN0YWJpbGl6aW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U3RhYmlsaXppbmcoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFN0YWJpbGl6aW5nJyk7XG4gICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uZSBiYXRjaCBvZiBzdGFiaWxpemF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3N0YWJpbGl6YXRpb25CYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFiaWxpemF0aW9uQmF0Y2goKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHJ1bm5pbmcgPSBmdW5jdGlvbiBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnN0YWJpbGl6ZWQgPT09IGZhbHNlICYmIF90aGlzNC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA8IF90aGlzNC50YXJnZXRJdGVyYXRpb25zO1xuICAgICAgfTtcblxuICAgICAgdmFyIHNlbmRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNlbmRQcm9ncmVzcygpIHtcbiAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemF0aW9uUHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgaXRlcmF0aW9uczogX3RoaXM0LnN0YWJpbGl6YXRpb25JdGVyYXRpb25zLFxuICAgICAgICAgIHRvdGFsOiBfdGhpczQudGFyZ2V0SXRlcmF0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCkpIHtcbiAgICAgICAgc2VuZFByb2dyZXNzKCk7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzdGFydCBldmVudC5cbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHdoaWxlIChydW5uaW5nKCkgJiYgY291bnQgPCB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi51cGRhdGVJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG5cbiAgICAgIHNlbmRQcm9ncmVzcygpO1xuXG4gICAgICBpZiAocnVubmluZygpKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fc3RhYmlsaXphdGlvbkJhdGNoLmJpbmQodGhpcyksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVTdGFiaWxpemF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcCB1cCB0aGUgc3RhYmlsaXphdGlvbiwgZml0IGFuZCBlbWl0IHRoZSBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmFsaXplU3RhYmlsaXphdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5hbGl6ZVN0YWJpbGl6YXRpb24oKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfYWxsb3dSZWRyYXcnKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5maXQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZml0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVGcm96ZW5Ob2RlcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmUnKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdFN0YWJpbGl6ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBEZWJ1ZyBmdW5jdGlvbiB0aGF0IGRpc3BsYXkgYXJyb3dzIGZvciB0aGUgZm9yY2VzIGN1cnJlbnRseSBhY3RpdmUgaW4gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB3aGVuIGRlYnVnZ2luZyBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3Rm9yY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdGb3JjZXMoY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpbmRleF07XG4gICAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIGZhY3RvciA9IDIwO1xuICAgICAgICB2YXIgY29sb3JGYWN0b3IgPSAwLjAzO1xuICAgICAgICB2YXIgZm9yY2VTaXplID0gTWF0aC5zcXJ0KE1hdGgucG93KGZvcmNlLngsIDIpICsgTWF0aC5wb3coZm9yY2UueCwgMikpO1xuXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oTWF0aC5tYXgoNSwgZm9yY2VTaXplKSwgMTUpO1xuICAgICAgICB2YXIgYXJyb3dTaXplID0gMyAqIHNpemU7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gdXRpbC5IU1ZUb0hleCgoMTgwIC0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgY29sb3JGYWN0b3IgKiBmb3JjZVNpemUpKSAqIDE4MCkgLyAzNjAsIDEsIDEpO1xuXG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICB4OiBub2RlLnggKyBmYWN0b3IgKiBmb3JjZS54LFxuICAgICAgICAgIHk6IG5vZGUueSArIGZhY3RvciAqIGZvcmNlLnlcbiAgICAgICAgfTtcblxuICAgICAgICBjdHgubGluZVdpZHRoID0gc2l6ZTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhub2RlLngsIG5vZGUueSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGZvcmNlLnksIGZvcmNlLngpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIEVuZFBvaW50cy5kcmF3KGN0eCwge1xuICAgICAgICAgIHR5cGU6ICdhcnJvdycsXG4gICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICBsZW5ndGg6IGFycm93U2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBoeXNpY3NFbmdpbmU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBoeXNpY3NFbmdpbmU7XG5cbi8qKiovIH0pLFxuLyogMTcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogUmVwdWxzaW9uIFNvbHZlclxuICovXG52YXIgUmVwdWxzaW9uU29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIGZ4LCBmeSwgcmVwdWxzaW5nRm9yY2UsIG5vZGUxLCBub2RlMjtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgIC8vIHJlcHVsc2luZyBmb3JjZXMgYmV0d2VlbiBub2Rlc1xuICAgICAgdmFyIG5vZGVEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5ub2RlRGlzdGFuY2U7XG5cbiAgICAgIC8vIGFwcHJveGltYXRpb24gY29uc3RhbnRzXG4gICAgICB2YXIgYSA9IC0yIC8gMyAvIG5vZGVEaXN0YW5jZTtcbiAgICAgIHZhciBiID0gNCAvIDM7XG5cbiAgICAgIC8vIHdlIGxvb3AgZnJvbSBpIG92ZXIgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyZWUgaW4gdGhlIGFycmF5XG4gICAgICAvLyBqIGxvb3BzIGZyb20gaSsxIHRvIHRoZSBsYXN0LiBUaGlzIHdheSB3ZSBkbyBub3QgZG91YmxlIGNvdW50IGFueSBvZiB0aGUgaW5kaWNlcywgbm9yIGkgPT09IGpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG5vZGUyID0gbm9kZXNbbm9kZUluZGljZXNbal1dO1xuXG4gICAgICAgICAgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgIC8vIHNhbWUgY29uZGl0aW9uIGFzIEJhcm5lc0h1dFNvbHZlciwgbWFraW5nIHN1cmUgbm9kZXMgYXJlIG5ldmVyIDEwMCUgb3ZlcmxhcHBpbmcuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDIgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDAuNSAqIG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IDEuMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gYSAqIGRpc3RhbmNlICsgYjsgLy8gbGluZWFyIGFwcHJveCBvZiAgMSAvICgxICsgTWF0aC5leHAoKGRpc3RhbmNlIC8gbm9kZURpc3RhbmNlIC0gMSkgKiBzdGVlcG5lc3MpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG5cbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSZXB1bHNpb25Tb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogMTczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFJlcHVsc2lvbiBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szW1wiZGVmYXVsdFwiXSkodGhpcywgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzW1wiZGVmYXVsdFwiXSkoSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBmeCwgZnksIHJlcHVsc2luZ0ZvcmNlLCBub2RlMSwgbm9kZTIsIGksIGo7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlO1xuXG4gICAgICAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbm9kZTIgPSBub2Rlc1tub2RlSW5kaWNlc1tqXV07XG5cbiAgICAgICAgICAvLyBub2RlcyBvbmx5IGFmZmVjdCBub2RlcyBvbiB0aGVpciBsZXZlbFxuICAgICAgICAgIGlmIChub2RlMS5sZXZlbCA9PT0gbm9kZTIubGV2ZWwpIHtcbiAgICAgICAgICAgIGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICB2YXIgc3RlZXBuZXNzID0gMC4wNTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IC1NYXRoLnBvdyhzdGVlcG5lc3MgKiBkaXN0YW5jZSwgMikgKyBNYXRoLnBvdyhzdGVlcG5lc3MgKiBub2RlRGlzdGFuY2UsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGZvcmNlIHdpdGhcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IDAuMDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IHJlcHVsc2luZ0ZvcmNlIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG5cbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogMTc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogU3ByaW5nIFNvbHZlclxuICovXG52YXIgU3ByaW5nU29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU3ByaW5nU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbXCJkZWZhdWx0XCJdKSh0aGlzLCBTcHJpbmdTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShTcHJpbmdTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IHZvaWQgMCxcbiAgICAgICAgICBlZGdlID0gdm9pZCAwO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgbm9kZTEgPSB2b2lkIDAsXG4gICAgICAgICAgbm9kZTIgPSB2b2lkIDAsXG4gICAgICAgICAgbm9kZTMgPSB2b2lkIDA7XG5cbiAgICAgIC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgZm9yY2VzIGlmIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBzZWN0b3JcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmVkZ2VUeXBlLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoIDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgbm9kZTEgPSBlZGdlLnRvO1xuICAgICAgICAgICAgICBub2RlMiA9IGVkZ2UuZWRnZVR5cGUudmlhO1xuICAgICAgICAgICAgICBub2RlMyA9IGVkZ2UuZnJvbTtcblxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMiwgbm9kZTMsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhlICogMS41IGlzIGhlcmUgc28gdGhlIGVkZ2UgbG9va3MgYXMgbGFyZ2UgYXMgYSBzbW9vdGggZWRnZS4gSXQgZG9lcyBub3QgaW5pdGlhbGx5IGJlY2F1c2UgdGhlIHNtb290aCBlZGdlcyB1c2VcbiAgICAgICAgICAgICAgLy8gdGhlIHN1cHBvcnQgbm9kZXMgd2hpY2ggZXhlcnQgYSByZXB1bHNpdmUgZm9yY2Ugb24gdGhlIHRvIGFuZCBmcm9tIG5vZGVzLCBtYWtpbmcgdGhlIGVkZ2UgYXBwZWFyIGxhcmdlci5cbiAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggKiAxLjUgOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShlZGdlLmZyb20sIGVkZ2UudG8sIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvZGUgYWN0dWFsbHkgcGVyZm9ybWluZyB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBhYm92ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIGVkZ2VMZW5ndGgpIHtcbiAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgdmFyIGR5ID0gbm9kZTEueSAtIG5vZGUyLnk7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLCAwLjAxKTtcblxuICAgICAgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuICAgICAgdmFyIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcblxuICAgICAgdmFyIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvbmUgbm9kZSBpcyBub3QgcGFydCBvZiB0aGUgcGh5c2Npc1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS54ICs9IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0ueSArPSBmeTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS54IC09IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueSAtPSBmeTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNwcmluZ1NvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTcHJpbmdTb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogMTc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFNwcmluZyBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szW1wiZGVmYXVsdFwiXSkodGhpcywgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzW1wiZGVmYXVsdFwiXSkoSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNwcmluZ2ZvcmNlcyBvbiB0aGUgbm9kZXMsIGFjY291bnRpbmcgZm9yIHRoZSBzdXBwb3J0IG5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGVkZ2VMZW5ndGgsIGVkZ2U7XG4gICAgICB2YXIgZHgsIGR5LCBmeCwgZnksIHNwcmluZ0ZvcmNlLCBkaXN0YW5jZTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBmYWN0b3IgPSAwLjU7XG5cbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNwcmluZyBmb3JjZSBjb3VudGVyc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z4ID0gMDtcbiAgICAgICAgZm9yY2VzW25vZGVJZF0uc3ByaW5nRnkgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgZHggPSBlZGdlLmZyb20ueCAtIGVkZ2UudG8ueDtcbiAgICAgICAgICBkeSA9IGVkZ2UuZnJvbS55IC0gZWRnZS50by55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09PSAwID8gMC4wMSA6IGRpc3RhbmNlO1xuXG4gICAgICAgICAgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuICAgICAgICAgIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcblxuICAgICAgICAgIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgICAgICBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgICAgICBpZiAoZWRnZS50by5sZXZlbCAhPSBlZGdlLmZyb20ubGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z4IC09IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeSAtPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeCArPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeSArPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueCAtPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueSAtPSBmYWN0b3IgKiBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS54ICs9IGZhY3RvciAqIGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnkgKz0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBzcHJpbmcgZm9yY2VzXG4gICAgICBzcHJpbmdGb3JjZSA9IDE7XG4gICAgICB2YXIgc3ByaW5nRngsIHNwcmluZ0Z5O1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IG5vZGVJbmRpY2VzW19pMl07XG4gICAgICAgIHNwcmluZ0Z4ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z4KSk7XG4gICAgICAgIHNwcmluZ0Z5ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z5KSk7XG5cbiAgICAgICAgZm9yY2VzW19ub2RlSWRdLnggKz0gc3ByaW5nRng7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkXS55ICs9IHNwcmluZ0Z5O1xuICAgICAgfVxuXG4gICAgICAvLyByZXRhaW4gZW5lcmd5IGJhbGFuY2VcbiAgICAgIHZhciB0b3RhbEZ4ID0gMDtcbiAgICAgIHZhciB0b3RhbEZ5ID0gMDtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdmFyIF9ub2RlSWQyID0gbm9kZUluZGljZXNbX2kzXTtcbiAgICAgICAgdG90YWxGeCArPSBmb3JjZXNbX25vZGVJZDJdLng7XG4gICAgICAgIHRvdGFsRnkgKz0gZm9yY2VzW19ub2RlSWQyXS55O1xuICAgICAgfVxuICAgICAgdmFyIGNvcnJlY3Rpb25GeCA9IHRvdGFsRnggLyBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICB2YXIgY29ycmVjdGlvbkZ5ID0gdG90YWxGeSAvIG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgX25vZGVJZDMgPSBub2RlSW5kaWNlc1tfaTRdO1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnggLT0gY29ycmVjdGlvbkZ4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnkgLT0gY29ycmVjdGlvbkZ5O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcjtcblxuLyoqKi8gfSksXG4vKiAxNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXJuZXNIdXRTb2x2ZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG5cbnZhciBfQmFybmVzSHV0U29sdmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhcm5lc0h1dFNvbHZlcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQGV4dGVuZHMgQmFybmVzSHV0U29sdmVyXG4gKi9cbnZhciBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyID0gZnVuY3Rpb24gKF9CYXJuZXNIdXRTb2x2ZXIpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgX0Jhcm5lc0h1dFNvbHZlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcikpLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50QnJhbmNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6ICdfY2FsY3VsYXRlRm9yY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPCAxICYmIG5vZGUuc2hhcGUucmFkaXVzKSB7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMC4xICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogbm9kZS5zaGFwZS5yYWRpdXMsIGRpc3RhbmNlIC0gbm9kZS5zaGFwZS5yYWRpdXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVncmVlID0gbm9kZS5lZGdlcy5sZW5ndGggKyAxO1xuICAgICAgLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG4gICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgKiBkZWdyZWUgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMik7XG4gICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuXG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS54ICs9IGZ4O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueSArPSBmeTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXI7XG59KF9CYXJuZXNIdXRTb2x2ZXIzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyO1xuXG4vKioqLyB9KSxcbi8qIDE3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyMiA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG52YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NlbnRyYWxHcmF2aXR5U29sdmVyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBAZXh0ZW5kcyBDZW50cmFsR3Jhdml0eVNvbHZlclxuICovXG52YXIgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyID0gZnVuY3Rpb24gKF9DZW50cmFsR3Jhdml0eVNvbHZlcikge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIF9DZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKSkuY2FsbCh0aGlzLCBib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICogQHBhcmFtIHtPYmplY3Q8Tm9kZS5pZCwgTm9kZT59IGZvcmNlc1xuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIFt7XG4gICAga2V5OiAnX2NhbGN1bGF0ZUZvcmNlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgKiBkZWdyZWUgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjtcbn0oX0NlbnRyYWxHcmF2aXR5U29sdmVyM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyO1xuXG4vKioqLyB9KSxcbi8qIDE3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiMgVE9ET1xuXG4tIGBlZGdlUmVwbGFjZWRCeUlkYCBub3QgY2xlYW5lZCB1cCB5ZXQgb24gY2x1c3RlciBlZGdlIHJlbW92YWxcbi0gYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciBjb3VsZCBiZSBhIGdsb2JhbCBvcHRpb24gYXMgd2VsbDsgY3VycmVudGx5IG5lZWRzIHRvIGFsd2F5c1xuICBiZSBwYXNzZWQgdG8gY2x1c3RlcmluZyBtZXRob2RzXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuIyBTdGF0ZSBNb2RlbCBmb3IgQ2x1c3RlcmluZ1xuXG5UaGUgdG90YWwgc3RhdGUgZm9yIGNsdXN0ZXJpbmcgaXMgbm9uLXRyaXZpYWwuIEl0IGlzIHVzZWZ1bCB0byBoYXZlIGEgbW9kZWxcbmF2YWlsYWJsZSBhcyB0byBob3cgaXQgd29ya3MuIFRoZSBmb2xsb3dpbmcgZG9jdW1lbnRzIHRoZSByZWxldmFudCBzdGF0ZSBpdGVtcy5cblxuXG4jIyBOZXR3b3JrIFN0YXRlXG5cblRoZSBmb2xsb3dpbmcgYG5ldHdvcmtgLW1lbWJlcnMgYXJlIHJlbGV2YW50IHRvIGNsdXN0ZXJpbmc6XG5cbi0gYGJvZHkubm9kZXNgICAgICAgIC0gYWxsIG5vZGVzIGFjdGl2ZWx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIG5ldHdvcmtcbi0gYGJvZHkuZWRnZXNgICAgICAgIC0gc2FtZSBmb3IgZWRnZXNcbi0gYGJvZHkubm9kZUluZGljZXNgIC0gaWQncyBvZiBub2RlcyB0aGF0IGFyZSB2aXNpYmxlIGF0IGEgZ2l2ZW4gbW9tZW50XG4tIGBib2R5LmVkZ2VJbmRpY2VzYCAtIHNhbWUgZm9yIGVkZ2VzXG5cblRoaXMgaW5jbHVkZXM6XG5cbi0gaGVscGVyIG5vZGVzIGZvciBkcmFnZ2luZyBpbiBgbWFuaXB1bGF0aW9uYFxuLSBoZWxwZXIgbm9kZXMgZm9yIGVkZ2UgdHlwZSBgZHluYW1pY2Bcbi0gY2x1c3RlciBub2RlcyBhbmQgZWRnZXNcbi0gdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiB0aGlzLlxuXG5BIG5vZGUvZWRnZSBtYXkgYmUgbWlzc2luZyBpbiB0aGUgYEluZGljZXNgIG1lbWJlciBpZjpcblxuLSBpdCBpcyBhIGhlbHBlciBub2RlXG4tIHRoZSBub2RlIG9yIGVkZ2Ugc3RhdGUgaGFzIG9wdGlvbiBgaGlkZGVuYCBzZXRcbi0gSXQgaXMgbm90IHZpc2libGUgZHVlIHRvIGNsdXN0ZXJpbmdcblxuXG4jIyBDbHVzdGVyaW5nIFN0YXRlXG5cbkZvciB0aGUgaGFzaGVzLCB0aGUgaWQncyBvZiB0aGUgbm9kZXMvZWRnZXMgYXJlIHVzZWQgYXMga2V5LlxuXG5NZW1iZXIgYG5ldHdvcmsuY2x1c3RlcmluZ2AgY29udGFpbnMgdGhlIGZvbGxvd2luZyBpdGVtczpcblxuLSBgY2x1c3RlcmVkTm9kZXNgIC0gaGFzaCB3aXRoIHZhbHVlczogeyBjbHVzdGVySWQ6IDxpZCBvZiBjbHVzdGVyPiwgbm9kZTogPG5vZGUgaW5zdGFuY2U+fVxuLSBgY2x1c3RlcmVkRWRnZXNgIC0gaGFzaCB3aXRoIHZhbHVlczogcmVzdG9yZSBpbmZvcm1hdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuXG5cbkR1ZSB0byBuZXN0aW5nIG9mIGNsdXN0ZXJzLCB0aGVzZSBtZW1iZXJzIGNhbiBjb250YWluIGNsdXN0ZXIgbm9kZXMgYW5kIGVkZ2VzIGFzIHdlbGwuXG5cblRoZSBpbXBvcnRhbnQgdGhpbmcgdG8gbm90ZSBoZXJlLCBpcyB0aGF0IHRoZSBjbHVzdGVyZWQgbm9kZXMgYW5kIGVkZ2VzIGFsc29cbmFwcGVhciBpbiB0aGUgbWVtYmVycyBvZiB0aGUgY2x1c3RlciBub2Rlcy4gRm9yIGRhdGEgdXBkYXRlLCBpdCBpcyB0aGVyZWZvcmUgXG5pbXBvcnRhbnQgdG8gc2NhbiB0aGVzZSBsaXN0cyBhcyB3ZWxsIGFzIHRoZSBjbHVzdGVyIG5vZGVzLlxuXG5cbiMjIyBDbHVzdGVyIE5vZGVcblxuQSBjbHVzdGVyIG5vZGUgaGFzIHRoZSBmb2xsb3dpbmcgZXh0cmEgZmllbGRzOlxuXG4tIGBpc0NsdXN0ZXIgOiB0cnVlYCAtIGluZGljYXRpb24gdGhhdCB0aGlzIGlzIGEgY2x1c3RlciBub2RlXG4tIGBjb250YWluZWROb2Rlc2AgICAtIGhhc2ggb2Ygbm9kZXMgY29udGFpbmVkIGluIHRoaXMgY2x1c3RlclxuLSBgY29udGFpbmVkRWRnZXNgICAgLSBzYW1lIGZvciBlZGdlc1xuLSBgZWRnZXNgICAgICAgICAgICAgLSBhcnJheSBvZiBjbHVzdGVyIGVkZ2VzIGZvciB0aGlzIG5vZGUgXG5cblxuKipOT1RFOioqXG5cbi0gYGNvbnRhaW5lZEVkZ2VzYCBjYW4gYWxzbyBjb250YWluIGVkZ2VzIHdoaWNoIGFyZSBub3QgY2x1c3RlcmVkOyBlLmcuIGFuIGVkZ2VcbiAgIGNvbm5lY3RpbmcgdHdvIG5vZGVzIGluIHRoZSBzYW1lIGNsdXN0ZXIuXG5cblxuIyMjIENsdXN0ZXIgRWRnZVxuXG5UaGVzZSBhcmUgdGhlIGl0ZW1zIGluIHRoZSBgZWRnZXNgIG1lbWJlciBvZiBhIGNsdXN0ZXJlZCBub2RlLiBUaGV5IGhhdmUgdGhlXG5mb2xsb3dpbmcgcmVsZXZhbnQgbWVtYmVyczpcblxuLSAnY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNgIC0gYXJyYXkgb2YgaWQncyBvZiBlZGdlcyByZXBsYWNlZCBieSB0aGlzIGVkZ2VcblxuTm90ZSB0aGF0IGl0J3MgcG9zc2libGUgdG8gbmVzdCBjbHVzdGVycywgc28gdGhhdCBgY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNgXG5jYW4gY29udGFpbiBlZGdlIGlkJ3Mgb2Ygb3RoZXIgY2x1c3RlcnMuXG5cblxuIyMjIENsdXN0ZXJlZCBFZGdlXG5cblRoaXMgaXMgYW55IGVkZ2UgY29udGFpbmVkIGJ5IGEgY2x1c3RlciBlZGdlLiBJdCBnZXRzIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbFxubWVtYmVyOlxuXG4tIGBlZGdlUmVwbGFjZWRCeUlkYCAtIGlkIG9mIHRoZSBjbHVzdGVyIGVkZ2UgaW4gd2hpY2ggY3VycmVudCBlZGdlIGlzIGNsdXN0ZXJlZFxuXG5cbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIE5ldHdvcmtVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NylbJ2RlZmF1bHQnXTtcbnZhciBDbHVzdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzkpWydkZWZhdWx0J107XG52YXIgRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpWydkZWZhdWx0J107IC8vIE9ubHkgbmVlZGVkIGZvciBjaGVjayBvbiB0eXBlIVxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KVsnZGVmYXVsdCddOyAvLyBPbmx5IG5lZWRlZCBmb3IgY2hlY2sgb24gdHlwZSFcblxuLyoqXG4gKiBUaGUgY2x1c3RlcmluZyBlbmdpbmVcbiAqL1xuXG52YXIgQ2x1c3RlckVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyRW5naW5lKGJvZHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2x1c3RlckVuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2x1c3RlcmVkTm9kZXMgPSB7fTsgLy8ga2V5OiBub2RlIGlkLCB2YWx1ZTogeyBjbHVzdGVySWQ6IDxpZCBvZiBjbHVzdGVyPiwgbm9kZTogPG5vZGUgaW5zdGFuY2U+fVxuICAgIHRoaXMuY2x1c3RlcmVkRWRnZXMgPSB7fTsgLy8ga2V5OiBlZGdlIGlkLCB2YWx1ZTogcmVzdG9yZSBpbmZvcm1hdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3Jlc2V0RGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307XG4gICAgICBfdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBodWJzaXplXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2x1c3RlckVuZ2luZSwgW3tcbiAgICBrZXk6ICdjbHVzdGVyQnlIdWJzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5SHVic2l6ZShodWJzaXplLCBvcHRpb25zKSB7XG4gICAgICBpZiAoaHVic2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaHVic2l6ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShodWJzaXplKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMoaHVic2l6ZSk7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2Rlc1RvQ2x1c3RlciA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgaWYgKG5vZGUuZWRnZXMubGVuZ3RoID49IGh1YnNpemUpIHtcbiAgICAgICAgICBub2Rlc1RvQ2x1c3Rlci5wdXNoKG5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlc1RvQ2x1c3Rlci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVzVG9DbHVzdGVyW19pXSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvb3Agb3ZlciBhbGwgbm9kZXMsIGNoZWNrIGlmIHRoZXkgYWRoZXJlIHRvIHRoZSBjb25kaXRpb24gYW5kIGNsdXN0ZXIgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2x1c3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBjbHVzdGVyQnlOb2RlRGF0YSB3aXRob3V0IGEgam9pbkNvbmRpdGlvbiBmdW5jdGlvbiBpbiB0aGUgb3B0aW9ucy4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIG9wdGlvbnMgb2JqZWN0IGlzIGZpbmUsIGFwcGVuZCBpZiBuZWVkZWRcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuXG4gICAgICAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucyAmJiBvcHRpb25zLmpvaW5Db25kaXRpb24obm9kZS5vcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IG5vZGU7XG5cbiAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBlZGdlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgICB1dGlsLmZvckVhY2gobm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IFggZWRnZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZUNvdW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbHVzdGVyQnlFZGdlQ291bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlFZGdlQ291bnQoZWRnZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgICB2YXIgdXNlZE5vZGVzID0ge307XG4gICAgICB2YXIgZWRnZSA9IHZvaWQgMCxcbiAgICAgICAgICBlZGdlcyA9IHZvaWQgMCxcbiAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCA9IHZvaWQgMDtcbiAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG4gICAgICAgIHZhciBub2RlSWQgPSBfdGhpczMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgbm9kZSBpcyBhbHJlYWR5IHVzZWQgaW4gYW5vdGhlciBjbHVzdGVyIHRoaXMgc2Vzc2lvbiwgd2UgZG8gbm90IGhhdmUgdG8gcmUtZXZhbHVhdGUgaXQuXG4gICAgICAgIGlmICh1c2VkTm9kZXNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQgPSAwO1xuICAgICAgICAgIGVkZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBlZGdlID0gbm9kZS5lZGdlc1tqXTtcbiAgICAgICAgICAgIGlmIChfdGhpczMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0aGlzIG5vZGUgcXVhbGlmaWVzLCB3ZSBjb2xsZWN0IGl0cyBuZWlnaGJvdXJzIHRvIHN0YXJ0IHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG4gICAgICAgICAgaWYgKHJlbGV2YW50RWRnZUNvdW50ID09PSBlZGdlQ291bnQpIHtcbiAgICAgICAgICAgIGNoZWNrSm9pbkNvbmRpdGlvbiA9IGZ1bmN0aW9uIGNoZWNrSm9pbkNvbmRpdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGVkZ2VzLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICBlZGdlID0gZWRnZXNbX2pdO1xuICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSBfdGhpczMuX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCk7XG4gICAgICAgICAgICAgIC8vIGFkZCB0aGUgbm9kZXMgdG8gdGhlIGxpc3QgYnkgdGhlIGpvaW4gY29uZGl0aW9uLlxuICAgICAgICAgICAgICBpZiAoY2hlY2tKb2luQ29uZGl0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtub2RlSWRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IF90aGlzMy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICB1c2VkTm9kZXNbbm9kZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBub2RlIGRvZXMgbm90IHF1YWxpZnkgYWZ0ZXIgYWxsLlxuICAgICAgICAgICAgICAgIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgdG8gdGhlIGNsdXN0ZXIgcXVldWVcbiAgICAgICAgICAgIGlmICgoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA+IDAgJiYgKDAsIF9rZXlzMlsnZGVmYXVsdCddKShjaGlsZEVkZ2VzT2JqKS5sZW5ndGggPiAwICYmIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNlYXJjaCBmb3IgY2x1c3RlciBkYXRhIHRoYXQgY29udGFpbnMgYW55IG9mIHRoZSBub2RlIGlkJ3NcbiAgICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgbm8gam9pbkNvbmRpdGlvbiwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBvZiBqb2luQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBmaW5kQ2x1c3RlckRhdGEgPSBmdW5jdGlvbiBmaW5kQ2x1c3RlckRhdGEoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbHVzdGVycy5sZW5ndGg7ICsrbikge1xuICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNsdXN0ZXIgY29udGFpbmluZyBhbnkgb2YgdGhlIG5vZGUgaWQnc1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyc1tuXS5ub2Rlc1ttXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsdXN0ZXJzW25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGZvdW5kIG5vZGVzIGlzIHBhcnQgb2YgYSBjbHVzdGVyIGZvdW5kIGluIHRoaXMgbWV0aG9kLFxuICAgICAgICAgICAgICAvLyBhZGQgdGhlIGN1cnJlbnQgdmFsdWVzIHRvIHRoYXQgY2x1c3RlclxuXG5cbiAgICAgICAgICAgICAgZm91bmRDbHVzdGVyID0gZmluZENsdXN0ZXJEYXRhKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIHRvIGZvdW5kIGNsdXN0ZXIgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIubm9kZXNbbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENsdXN0ZXIubm9kZXNbbV0gPSBjaGlsZE5vZGVzT2JqW21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBlZGdlcyB0byBmb3VuZCBjbHVzdGVyLCBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9tIGluIGNoaWxkRWRnZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIuZWRnZXNbX21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDbHVzdGVyLmVkZ2VzW19tXSA9IGNoaWxkRWRnZXNPYmpbX21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2x1c3RlciBncm91cFxuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goeyBub2RlczogY2hpbGROb2Rlc09iaiwgZWRnZXM6IGNoaWxkRWRnZXNPYmogfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja0pvaW5Db25kaXRpb247XG4gICAgICAgIHZhciBmaW5kQ2x1c3RlckRhdGE7XG4gICAgICAgIHZhciBmb3VuZENsdXN0ZXI7XG5cbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY2x1c3RlcihjbHVzdGVyc1tpXS5ub2RlcywgY2x1c3RlcnNbaV0uZWRnZXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDEgZWRnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2x1c3Rlck91dGxpZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3Rlck91dGxpZXJzKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMSwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDIgZWRnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2x1c3RlckJyaWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnJpZGdlcyhvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDIsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdWNrIGFsbCBjb25uZWN0ZWQgbm9kZXMgb2YgYSBub2RlIGludG8gdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsdXN0ZXJCeUNvbm5lY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGVJZCBzdXBwbGllZCB0byBjbHVzdGVyQnlDb25uZWN0aW9uIScpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbm9kZUlkIGdpdmVuIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24gZG9lcyBub3QgZXhpc3QhJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMsIG5vZGUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gbm9kZS54O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gbm9kZS55O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueCA9IG5vZGUub3B0aW9ucy5maXhlZC54O1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC55ID0gbm9kZS5vcHRpb25zLmZpeGVkLnk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgdmFyIHBhcmVudE5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICB2YXIgcGFyZW50Q2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgIGNoaWxkTm9kZXNPYmpbcGFyZW50Tm9kZUlkXSA9IG5vZGU7XG5cbiAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIHBhcmVudE5vZGVJZCk7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgY2hpbGQgbm9kZSBpcyBub3QgaW4gYSBjbHVzdGVyXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVJZCAhPT0gcGFyZW50Tm9kZUlkKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgb3B0aW9ucyBhbmQgaW5zZXJ0IHNvbWUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgY291bGQgYmUgaW50ZXJlc3RpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyh0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKHBhcmVudENsb25lZE9wdGlvbnMsIGNoaWxkQ2xvbmVkT3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3dhbGxvdyB0aGUgZWRnZSBpZiBpdCBpcyBzZWxmLXJlZmVyZW5jaW5nLlxuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZE5vZGVJRHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopLm1hcChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZV0uaWQ7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChjaGlsZE5vZGUgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICBpZiAoIWNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkoY2hpbGROb2RlKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlXTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICB2YXIgY2hpbGRFZGdlID0gY2hpbGROb2RlLmVkZ2VzW3ldO1xuICAgICAgICAgIGlmIChjaGlsZE5vZGVJRHMuaW5kZXhPZih0aGlzLl9nZXRDb25uZWN0ZWRJZChjaGlsZEVkZ2UsIGNoaWxkTm9kZS5pZCkpID4gLTEpIHtcbiAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbY2hpbGRFZGdlLmlkXSA9IGNoaWxkRWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyB0aGUgZWRnZXMgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBjbHVzdGVyXG4gICAgICogSXQgbG9va3MgZm9yIGVkZ2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgbm9kZXMgZnJvbSB0aGUgXCJvdXRzaWRlJyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e05vZGUuaWQ6IHZpcy5Ob2RlfX0gY2hpbGROb2Rlc09ialxuICAgICAqIEBwYXJhbSB7e3Zpcy5FZGdlLmlkOiB2aXMuRWRnZX19IGNoaWxkRWRnZXNPYmpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsdXN0ZXJFZGdlUHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVDbHVzdGVyRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgZWRnZSA9IHZvaWQgMCxcbiAgICAgICAgICBjaGlsZE5vZGVJZCA9IHZvaWQgMCxcbiAgICAgICAgICBjaGlsZE5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgdG9JZCA9IHZvaWQgMCxcbiAgICAgICAgICBmcm9tSWQgPSB2b2lkIDAsXG4gICAgICAgICAgb3RoZXJOb2RlSWQgPSB2b2lkIDA7XG5cbiAgICAgIC8vIGxvb3Agb3ZlciBhbGwgY2hpbGQgbm9kZXMgYW5kIHRoZWlyIGVkZ2VzIHRvIGZpbmQgZWRnZXMgZ29pbmcgb3V0IG9mIHRoZSBjbHVzdGVyXG4gICAgICAvLyB0aGVzZSBlZGdlcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IGNsdXN0ZXJFZGdlcy5cbiAgICAgIHZhciBjaGlsZEtleXMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopO1xuICAgICAgdmFyIGNyZWF0ZUVkZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVJZCA9IGNoaWxkS2V5c1tpXTtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF07XG5cbiAgICAgICAgLy8gY29uc3RydWN0IG5ldyBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIHRvIG90aGVyc1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkTm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbal07XG4gICAgICAgICAgLy8gd2Ugb25seSBoYW5kbGUgZWRnZXMgdGhhdCBhcmUgdmlzaWJsZSB0byB0aGUgc3lzdGVtLCBub3QgdGhlIGRpc2FibGVkIG9uZXMgZnJvbSB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgXCJoaWRkZW5cIiBsaXN0XG4gICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBmcm9tIGFuZCB0by5cbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBjaGlsZE5vZGVJZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkb3VibGUgZXF1YWxzIGJlY2F1c2UgaW50cyBhbmQgc3RyaW5ncyBjYW4gYmUgaW50ZXJjaGFuZ2VkIGhlcmUuXG4gICAgICAgICAgICAgICAgdG9JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBmcm9tSWQgPSBlZGdlLmZyb21JZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IGZyb21JZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0lkID0gZWRnZS50b0lkO1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IHRvSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIG91dHdhcmRzIGFyZSBiZWluZyByZXBsYWNlZC5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqW290aGVyTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNyZWF0ZUVkZ2VzLnB1c2goeyBlZGdlOiBlZGdlLCBmcm9tSWQ6IGZyb21JZCwgdG9JZDogdG9JZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEhlcmUgd2UgYWN0dWFsbHkgY3JlYXRlIHRoZSByZXBsYWNlbWVudCBlZGdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBjb3VsZCBub3QgZG8gdGhpcyBpbiB0aGUgbG9vcCBhYm92ZSBhcyB0aGUgY3JlYXRpb24gcHJvY2Vzc1xuICAgICAgLy8gd291bGQgYWRkIGFuIGVkZ2UgdG8gdGhlIGVkZ2VzIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3Zlci5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBoYXZlIG11bHRpcGxlIGJhc2UgZWRnZXMhXG4gICAgICAvL1xuICAgICAgdmFyIG5ld0VkZ2VzID0gW107XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhIGNsdXN0ZXIgZWRnZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBjcmVhdGVkIGVkZ2UuXG4gICAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBjcmVhdGVkRWRnZVxuICAgICAgICogQHJldHVybnMge3Zpcy5FZGdlfVxuICAgICAgICovXG4gICAgICB2YXIgZ2V0TmV3RWRnZSA9IGZ1bmN0aW9uIGdldE5ld0VkZ2UoY3JlYXRlZEVkZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbmV3RWRnZXMubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBuZXdFZGdlID0gbmV3RWRnZXNbX2oyXTtcblxuICAgICAgICAgIC8vIFdlIHJlcGxhY2UgYm90aCB0byBhbmQgZnJvbSBlZGdlcyB3aXRoIGEgc2luZ2xlIGNsdXN0ZXIgZWRnZVxuICAgICAgICAgIHZhciBtYXRjaFRvRGlyZWN0aW9uID0gY3JlYXRlZEVkZ2UuZnJvbUlkID09PSBuZXdFZGdlLmZyb21JZCAmJiBjcmVhdGVkRWRnZS50b0lkID09PSBuZXdFZGdlLnRvSWQ7XG4gICAgICAgICAgdmFyIG1hdGNoRnJvbURpcmVjdGlvbiA9IGNyZWF0ZWRFZGdlLmZyb21JZCA9PT0gbmV3RWRnZS50b0lkICYmIGNyZWF0ZWRFZGdlLnRvSWQgPT09IG5ld0VkZ2UuZnJvbUlkO1xuXG4gICAgICAgICAgaWYgKG1hdGNoVG9EaXJlY3Rpb24gfHwgbWF0Y2hGcm9tRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IGNyZWF0ZUVkZ2VzLmxlbmd0aDsgX2ozKyspIHtcbiAgICAgICAgdmFyIGNyZWF0ZWRFZGdlID0gY3JlYXRlRWRnZXNbX2ozXTtcbiAgICAgICAgdmFyIF9lZGdlID0gY3JlYXRlZEVkZ2UuZWRnZTtcbiAgICAgICAgdmFyIG5ld0VkZ2UgPSBnZXROZXdFZGdlKGNyZWF0ZWRFZGdlKTtcblxuICAgICAgICBpZiAobmV3RWRnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGNsdXN0ZXJlZCBlZGdlIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgICBuZXdFZGdlID0gdGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZShjcmVhdGVkRWRnZS5mcm9tSWQsIGNyZWF0ZWRFZGdlLnRvSWQsIF9lZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgbmV3RWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goX2VkZ2UuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxzbyByZWZlcmVuY2UgdGhlIG5ldyBlZGdlIGluIHRoZSBvbGQgZWRnZVxuICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2UuaWRdLmVkZ2VSZXBsYWNlZEJ5SWQgPSBuZXdFZGdlLmlkO1xuXG4gICAgICAgIC8vIGhpZGUgdGhlIHJlcGxhY2VkIGVkZ2VcbiAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UpO1xuICAgICAgICBfZWRnZS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjaGVja3MgdGhlIG9wdGlvbnMgdGhhdCBjYW4gYmUgc3VwcGxpZWQgdG8gdGhlIGRpZmZlcmVudCBjbHVzdGVyIGZ1bmN0aW9uc1xuICAgICAqIGZvciBjZXJ0YWluIGZpZWxkcyBhbmQgaW5zZXJ0cyBkZWZhdWx0cyBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jaGVja09wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgY2hpbGROb2Rlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzLCBzYW1lIGFzIGNoaWxkTm9kZXMgZXhjZXB0IGl0IGFsc28gY29udGFpbnMgYSBzb3VyY2Ugbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICBjaGlsZEVkZ2VzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBlZGdlIG9iamVjdHMsIGlkIGFzIGtleXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgICAgb3B0aW9ucyAgICAgICAgICAgICAgIHwgb2JqZWN0IHdpdGgge2NsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCBwcm9jZXNzUHJvcGVydGllc31cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgcmVmcmVzaERhdGEgfCB3aGVuIHRydWUsIGRvIG5vdCB3cmFwIHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NsdXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG5cbiAgICAgIC8vIFJlbW92ZSBub2RlcyB3aGljaCBhcmUgYWxyZWFkeSBjbHVzdGVyZWRcbiAgICAgIHZhciB0bXBOb2Rlc1RvUmVtb3ZlID0gW107XG4gICAgICBmb3IgKHZhciBfbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkoX25vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0bXBOb2Rlc1RvUmVtb3ZlLnB1c2goX25vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdG1wTm9kZXNUb1JlbW92ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICBkZWxldGUgY2hpbGROb2Rlc09ialt0bXBOb2Rlc1RvUmVtb3ZlW25dXTtcbiAgICAgIH1cblxuICAgICAgLy8ga2lsbCBjb25kaXRpb246IG5vIG5vZGVzIGRvbid0IGJvdGhlclxuICAgICAgaWYgKCgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoY2hpbGROb2Rlc09iaikubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBjbHVzdGVycyBvZiAxIGlmIG9wdGlvbnMgYWxsb3dcbiAgICAgIGlmICgoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA9PSAxICYmIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmFsbG93U2luZ2xlTm9kZUNsdXN0ZXIgIT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjbHVzdGVyTm9kZVByb3BlcnRpZXMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gY29uc3RydWN0IHRoZSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcbiAgICAgIGlmIChvcHRpb25zLnByb2Nlc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBjaGlsZE5vZGUgb3B0aW9uc1xuICAgICAgICB2YXIgY2hpbGROb2Rlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqLmhhc093blByb3BlcnR5KF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoY2hpbGROb2Rlc09ialtfbm9kZUlkMl0pO1xuICAgICAgICAgICAgY2hpbGROb2Rlc09wdGlvbnMucHVzaChjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgY2x1c3RlciBwcm9wZXJ0aWVzIGJhc2VkIG9uIGNoaWxkTm9kZXNcbiAgICAgICAgdmFyIGNoaWxkRWRnZXNPcHRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjaGlsZEVkZ2VzT2JqKSB7XG4gICAgICAgICAgaWYgKGNoaWxkRWRnZXNPYmouaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgY2x1c3RlciBlZGdlcyB3aWxsIGJlIHJlbW92ZWQgb24gY3JlYXRpb24gb2YgdGhlIGNsdXN0ZXIuXG4gICAgICAgICAgICBpZiAoZWRnZUlkLnN1YnN0cigwLCAxMikgIT09ICdjbHVzdGVyRWRnZTonKSB7XG4gICAgICAgICAgICAgIHZhciBfY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhjaGlsZEVkZ2VzT2JqW2VkZ2VJZF0sICdlZGdlJyk7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPcHRpb25zLnB1c2goX2Nsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjaGlsZE5vZGVzT3B0aW9ucywgY2hpbGRFZGdlc09wdGlvbnMpO1xuICAgICAgICBpZiAoIWNsdXN0ZXJOb2RlUHJvcGVydGllcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb2Nlc3NQcm9wZXJ0aWVzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBwcm9wZXJ0aWVzIScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgYW4gdW5pcXVlIGlkO1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9ICdjbHVzdGVyOicgKyB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPSAnY2x1c3Rlcic7XG4gICAgICB9XG5cbiAgICAgIC8vIGdpdmUgdGhlIGNsdXN0ZXJOb2RlIGEgcG9zaXRpb24gaWYgaXQgZG9lcyBub3QgaGF2ZSBvbmUuXG4gICAgICB2YXIgcG9zID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9IHBvcy54O1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICB9XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gcG9zLnk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcmNlIHRoZSBJRCB0byByZW1haW4gdGhlIHNhbWVcbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IGNsdXN0ZXJJZDtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBjbHVzdGVyIE5vZGVcbiAgICAgIC8vIE5vdGUgdGhhdCBhbGxvd1NpbmdsZU5vZGVDbHVzdGVyLCBpZiBwcmVzZW50LCBpcyBzdG9yZWQgaW4gdGhlIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGNsdXN0ZXJOb2RlUHJvcGVydGllcywgQ2x1c3Rlcik7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9IGNoaWxkTm9kZXNPYmo7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcyA9IGNoaWxkRWRnZXNPYmo7XG4gICAgICAvLyBjYWNoZSBhIGNvcHkgZnJvbSB0aGUgY2x1c3RlciBlZGdlIHByb3BlcnRpZXMgaWYgd2UgaGF2ZSB0byByZWNvbm5lY3Qgb3RoZXJzIGxhdGVyIG9uXG4gICAgICBjbHVzdGVyTm9kZS5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcztcblxuICAgICAgLy8gZmluYWxseSBwdXQgdGhlIGNsdXN0ZXIgbm9kZSBpbnRvIGdsb2JhbFxuICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlUHJvcGVydGllcy5pZF0gPSBjbHVzdGVyTm9kZTtcblxuICAgICAgdGhpcy5fY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAvLyBzZXQgSUQgdG8gdW5kZWZpbmVkIHNvIG5vIGR1cGxpY2F0ZXMgYXJpc2VcbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gd3JhcCB1cFxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2JhY2t1cEVkZ2VPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JhY2t1cEVkZ2VPcHRpb25zKGVkZ2UpIHtcbiAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9IHsgcGh5c2ljczogZWRnZS5vcHRpb25zLnBoeXNpY3MgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZXN0b3JlRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRWRnZShlZGdlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxPcHRpb25zID0gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgIGlmIChvcmlnaW5hbE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlZGdlLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBvcmlnaW5hbE9wdGlvbnMucGh5c2ljcyB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgY2x1c3Rlci5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc0NsdXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NsdXN0ZXIobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaXNDbHVzdGVyID09PSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vZGUgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbHVzdGVyIG5vZGUgYmFzZWQgb24gd2hhdCdzIGluc2lkZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGlsZE5vZGVzT2JqICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENsdXN0ZXJQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaikge1xuICAgICAgdmFyIGNoaWxkS2V5cyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoY2hpbGROb2Rlc09iaik7XG4gICAgICB2YXIgbWluWCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgdmFyIG1heFggPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueDtcbiAgICAgIHZhciBtaW5ZID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLnk7XG4gICAgICB2YXIgbWF4WSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbaV1dO1xuICAgICAgICBtaW5YID0gbm9kZS54IDwgbWluWCA/IG5vZGUueCA6IG1pblg7XG4gICAgICAgIG1heFggPSBub2RlLnggPiBtYXhYID8gbm9kZS54IDogbWF4WDtcbiAgICAgICAgbWluWSA9IG5vZGUueSA8IG1pblkgPyBub2RlLnkgOiBtaW5ZO1xuICAgICAgICBtYXhZID0gbm9kZS55ID4gbWF4WSA/IG5vZGUueSA6IG1heFk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHg6IDAuNSAqIChtaW5YICsgbWF4WCksIHk6IDAuNSAqIChtaW5ZICsgbWF4WSkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgY2x1c3RlciBieSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gIGNsdXN0ZXJOb2RlSWQgfCB0aGUgSUQgb2YgdGhlIGNsdXN0ZXIgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWZyZXNoRGF0YSB8IHdyYXAgdXAgYWZ0ZXJ3YXJkcyBpZiBub3QgdHJ1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvcGVuQ2x1c3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5DbHVzdGVyKGNsdXN0ZXJOb2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAoY2x1c3Rlck5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2x1c3Rlck5vZGVJZCBzdXBwbGllZCB0byBvcGVuQ2x1c3Rlci4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICBpZiAoY2x1c3Rlck5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJOb2RlLmlzQ2x1c3RlciAhPT0gdHJ1ZSB8fCBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbm9kZTonICsgY2x1c3Rlck5vZGVJZCArICcgaXMgbm90IGEgdmFsaWQgY2x1c3Rlci4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBjbHVzdGVyIGlzIGNsdXN0ZXJlZCBpdHNlbGZcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuZmluZE5vZGUoY2x1c3Rlck5vZGVJZCk7XG4gICAgICB2YXIgcGFyZW50SW5kZXggPSBzdGFjay5pbmRleE9mKGNsdXN0ZXJOb2RlSWQpIC0gMTtcbiAgICAgIGlmIChwYXJlbnRJbmRleCA+PSAwKSB7XG4gICAgICAgIC8vIEN1cnJlbnQgY2x1c3RlciBpcyBjbHVzdGVyZWQ7IHRyYW5zZmVyIGNvbnRhaW5lZCBub2RlcyBhbmQgZWRnZXMgdG8gcGFyZW50XG4gICAgICAgIHZhciBwYXJlbnRDbHVzdGVyTm9kZUlkID0gc3RhY2tbcGFyZW50SW5kZXhdO1xuICAgICAgICB2YXIgcGFyZW50Q2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkubm9kZXNbcGFyZW50Q2x1c3Rlck5vZGVJZF07XG5cbiAgICAgICAgLy8gY2x1c3RlcmluZy5jbHVzdGVyZWROb2RlcyBhbmQgY2x1c3RlcmluZy5jbHVzdGVyZWRFZGdlcyByZW1haW4gdW5jaGFuZ2VkXG4gICAgICAgIHBhcmVudENsdXN0ZXJOb2RlLl9vcGVuQ2hpbGRDbHVzdGVyKGNsdXN0ZXJOb2RlSWQpO1xuXG4gICAgICAgIC8vIEFsbCBjb21wb25lbnRzIG9mIGNoaWxkIGNsdXN0ZXIgbm9kZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWQuIEl0IGNhbiBkaWUgbm93LlxuICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuICAgICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbWFpbiBib2R5XG4gICAgICB2YXIgY29udGFpbmVkTm9kZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcztcbiAgICAgIHZhciBjb250YWluZWRFZGdlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzO1xuXG4gICAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBwb3NpdGlvbiB0aGUgbm9kZXMgYWZ0ZXIgcmVsZWFzZS5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgY2x1c3RlclBvc2l0aW9uID0geyB4OiBjbHVzdGVyTm9kZS54LCB5OiBjbHVzdGVyTm9kZS55IH07XG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQzIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQzKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDNdO1xuICAgICAgICAgICAgcG9zaXRpb25zW19ub2RlSWQzXSA9IHsgeDogY29udGFpbmVkTm9kZS54LCB5OiBjb250YWluZWROb2RlLnkgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uKGNsdXN0ZXJQb3NpdGlvbiwgcG9zaXRpb25zKTtcblxuICAgICAgICBmb3IgKHZhciBfbm9kZUlkNCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChjb250YWluZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkNCkpIHtcbiAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkNF07XG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb25zW19ub2RlSWQ0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnggPSBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLnggPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnggOiBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLng7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnkgPSBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLnkgPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnkgOiBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb3B5IHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBjbHVzdGVyXG4gICAgICAgIHV0aWwuZm9yRWFjaChjb250YWluZWROb2RlcywgZnVuY3Rpb24gKGNvbnRhaW5lZE5vZGUpIHtcbiAgICAgICAgICAvLyBpbmhlcml0IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS54ID0gY2x1c3Rlck5vZGUueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS55ID0gY2x1c3Rlck5vZGUueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZWxlYXNlIG5vZGVzXG4gICAgICBmb3IgKHZhciBfbm9kZUlkNSBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDUpKSB7XG4gICAgICAgICAgdmFyIF9jb250YWluZWROb2RlMiA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkNV07XG5cbiAgICAgICAgICAvLyBpbmhlcml0IHNwZWVkXG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnZ4ID0gY2x1c3Rlck5vZGUudng7XG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnZ5ID0gY2x1c3Rlck5vZGUudnk7XG5cbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IHRydWUgfSk7XG5cbiAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkNV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29weSB0aGUgY2x1c3Rlck5vZGUgZWRnZXMgYmVjYXVzZSB3ZSBjYW5ub3QgaXRlcmF0ZSBvdmVyIGFuIG9iamVjdCB0aGF0IHdlIGFkZCBvciByZW1vdmUgZnJvbS5cbiAgICAgIHZhciBlZGdlc1RvQmVEZWxldGVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJOb2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2VzVG9CZURlbGV0ZWQucHVzaChjbHVzdGVyTm9kZS5lZGdlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFjdHVhbGx5IGhhbmRsaW5nIHRoZSBkZWxldGluZy5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVkZ2VzVG9CZURlbGV0ZWQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzVG9CZURlbGV0ZWRbX2kyXTtcbiAgICAgICAgdmFyIG90aGVyTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgY2x1c3Rlck5vZGVJZCk7XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW290aGVyTm9kZUlkXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJJZCA9IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNbal07XG4gICAgICAgICAgdmFyIHRyYW5zZmVyRWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0cmFuc2ZlcklkXTtcbiAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIG90aGVyIG5vZGUgaXMgaW4gYW5vdGhlciBjbHVzdGVyLCB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgb2YgdGhpcyBlZGdlIHRvIHRoZSBvdGhlciBjbHVzdGVyXG4gICAgICAgICAgaWYgKG90aGVyTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0cmFuc2ZlciBvd25lcnNoaXA6XG4gICAgICAgICAgICB2YXIgb3RoZXJDbHVzdGVyID0gdGhpcy5ib2R5Lm5vZGVzW290aGVyTm9kZS5jbHVzdGVySWRdO1xuICAgICAgICAgICAgb3RoZXJDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzW3RyYW5zZmVyRWRnZS5pZF0gPSB0cmFuc2ZlckVkZ2U7XG5cbiAgICAgICAgICAgIC8vIGRlbGV0ZSBsb2NhbCByZWZlcmVuY2VcbiAgICAgICAgICAgIGRlbGV0ZSBjb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdO1xuXG4gICAgICAgICAgICAvLyBnZXQgdG8gYW5kIGZyb21cbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSB0cmFuc2ZlckVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgdmFyIHRvSWQgPSB0cmFuc2ZlckVkZ2UudG9JZDtcbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckVkZ2UudG9JZCA9PSBvdGhlck5vZGVJZCkge1xuICAgICAgICAgICAgICB0b0lkID0gb3RoZXJOb2RlLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyb21JZCA9IG90aGVyTm9kZS5jbHVzdGVySWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgY2x1c3RlciBlZGdlIGZyb20gdGhlIG90aGVyQ2x1c3RlclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIHRyYW5zZmVyRWRnZSwgb3RoZXJDbHVzdGVyLmNsdXN0ZXJFZGdlUHJvcGVydGllcywgeyBoaWRkZW46IGZhbHNlLCBwaHlzaWNzOiB0cnVlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN0b3JlRWRnZSh0cmFuc2ZlckVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgcmVsZWFzaW5nIG9mIHRoZSBlZGdlc1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNvbnRhaW5lZEVkZ2VzKSB7XG4gICAgICAgIGlmIChjb250YWluZWRFZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UoY29udGFpbmVkRWRnZXNbZWRnZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGNsdXN0ZXJOb2RlXG4gICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NsdXN0ZXIuaWR9IGNsdXN0ZXJJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Tm9kZS5pZD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE5vZGVzSW5DbHVzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3RlcklkKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IFtdO1xuICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyKGNsdXN0ZXJJZCkgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF0uY29udGFpbmVkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQ2IGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQ2KSkge1xuICAgICAgICAgICAgbm9kZXNBcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkNl0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YWNrIGNsdXN0ZXJJZCdzIHRoYXQgYSBjZXJ0YWluIG5vZGUgcmVzaWRlcyBpbi4gY2x1c3RlciBBIC0+IGNsdXN0ZXIgQiAtPiBjbHVzdGVyIEMgLT4gbm9kZVxuICAgICAqXG4gICAgICogSWYgYSBub2RlIGNhbid0IGJlIGZvdW5kIGluIHRoZSBjaGFpbiwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmROb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE5vZGUobm9kZUlkKSB7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgd2hpbGUgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5pZCk7XG5cbiAgICAgICAgbm9kZUlkID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICBzdGFjay5wdXNoKG5vZGUuaWQpO1xuXG4gICAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBjbHVzdGVyZWQgbm9kZUlkLCB1cGRhdGUgd2l0aCB0aGUgbmV3IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBjbHVzdGVyZWROb2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVDbHVzdGVyZWROb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ2x1c3RlcmVkTm9kZShjbHVzdGVyZWROb2RlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChjbHVzdGVyZWROb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLicpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZS4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXS5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBiYXNlIGVkZ2VJZCwgdXBkYXRlIGFsbCByZWxhdGVkIGNsdXN0ZXJlZCBlZGdlcyB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IHN0YXJ0RWRnZUlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2Uoc3RhcnRFZGdlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChzdGFydEVkZ2VJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UuJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3N0YXJ0RWRnZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YXJ0RWRnZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGxFZGdlSWRzID0gdGhpcy5nZXRDbHVzdGVyZWRFZGdlcyhzdGFydEVkZ2VJZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbYWxsRWRnZUlkc1tpXV07XG4gICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0YWNrIG9mIGNsdXN0ZXJFZGdlSWQncyAoK2Jhc2UgZWRnZWlkKSB0aGF0IGEgYmFzZSBlZGdlIGlzIHRoZSBzYW1lIGFzLiBjbHVzdGVyIGVkZ2UgQyAtPiBjbHVzdGVyIGVkZ2UgQiAtPiBjbHVzdGVyIGVkZ2UgQSAtPiBiYXNlIGVkZ2UoZWRnZUlkKVxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDbHVzdGVyZWRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsdXN0ZXJlZEVkZ2VzKGVkZ2VJZCkge1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICB3aGlsZSAoZWRnZUlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIHN0YWNrLnB1c2godGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS5lZGdlUmVwbGFjZWRCeUlkO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBiYXNlIGVkZ2UgaWQgb2YgY2x1c3RlckVkZ2VJZC4gY2x1c3RlciBlZGdlIChjbHVzdGVyZWRFZGdlSWQpIC0+IGNsdXN0ZXIgZWRnZSBCIC0+IGNsdXN0ZXIgZWRnZSBDIC0+IGJhc2UgZWRnZVxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHt2aXMuRWRnZS5pZH0gYmFzZUVkZ2VJZFxuICAgICAqXG4gICAgICogVE9ETzogZGVwcmVjYXRlIGluIDUuMC4wLiBNZXRob2QgZ2V0QmFzZUVkZ2VzKCkgaXMgdGhlIGNvcnJlY3Qgb25lIHRvIHVzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0QmFzZUVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlRWRnZShjbHVzdGVyZWRFZGdlSWQpIHtcbiAgICAgIC8vIEp1c3Qga2x1ZGdlIHRoaXMgYnkgcmV0dXJuaW5nIHRoZSBmaXJzdCBiYXNlIGVkZ2UgaWQgZm91bmRcbiAgICAgIHJldHVybiB0aGlzLmdldEJhc2VFZGdlcyhjbHVzdGVyZWRFZGdlSWQpWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVndWxhciBlZGdlcyBmb3IgdGhpcyBjbHVzdGVyZWQgZWRnZSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fSBhbGwgYmFzZUVkZ2VJZCdzIHVuZGVyIHRoaXMgY2x1c3RlcmVkIGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0QmFzZUVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZUVkZ2VzKGNsdXN0ZXJlZEVkZ2VJZCkge1xuICAgICAgdmFyIElkc1RvSGFuZGxlID0gW2NsdXN0ZXJlZEVkZ2VJZF07XG4gICAgICB2YXIgZG9uZUlkcyA9IFtdO1xuICAgICAgdmFyIGZvdW5kSWRzID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICB3aGlsZSAoSWRzVG9IYW5kbGUubGVuZ3RoID4gMCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIHZhciBuZXh0SWQgPSBJZHNUb0hhbmRsZS5wb3AoKTtcbiAgICAgICAgaWYgKG5leHRJZCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gUGFyYW5vaWEgaGVyZSBhbmQgb253YXJkc1xuICAgICAgICB2YXIgbmV4dEVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbbmV4dElkXTtcbiAgICAgICAgaWYgKG5leHRFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb3VudGVyKys7XG5cbiAgICAgICAgdmFyIHJlcGxhY2luZ0lkcyA9IG5leHRFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuICAgICAgICBpZiAocmVwbGFjaW5nSWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBuZXh0SWQgaXMgYSBiYXNlIGlkXG4gICAgICAgICAgZm91bmRJZHMucHVzaChuZXh0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFub3RoZXIgY2x1c3RlciBlZGdlLCB1bnJhdmVsIHRoaXMgb25lIGFzIHdlbGxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2luZ0lkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2luZ0lkID0gcmVwbGFjaW5nSWRzW2ldO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgaWYgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBUT0RPOiBuZXZlciB0cmlnZ2VyczsgZmluZCBhIHRlc3QtY2FzZSB3aGljaCBkb2VzXG4gICAgICAgICAgICBpZiAoSWRzVG9IYW5kbGUuaW5kZXhPZihyZXBsYWNpbmdJZHMpICE9PSAtMSB8fCBkb25lSWRzLmluZGV4T2YocmVwbGFjaW5nSWRzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIElkc1RvSGFuZGxlLnB1c2gocmVwbGFjaW5nSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmVJZHMucHVzaChuZXh0SWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm91bmRJZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJZCB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBlZGdlXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Q29ubmVjdGVkSWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29ubmVjdGVkSWQoZWRnZSwgbm9kZUlkKSB7XG4gICAgICBpZiAoZWRnZS50b0lkICE9IG5vZGVJZCkge1xuICAgICAgICByZXR1cm4gZWRnZS50b0lkO1xuICAgICAgfSBlbHNlIGlmIChlZGdlLmZyb21JZCAhPSBub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGRldGVybWluZSBob3cgbWFueSBjb25uZWN0aW9ucyBkZW5vdGUgYW4gaW1wb3J0YW50IGh1Yi5cbiAgICAgKiBXZSB0YWtlIHRoZSBtZWFuICsgMipzdGQgYXMgdGhlIGltcG9ydGFudCBodWIgc2l6ZS4gKEFzc3VtaW5nIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBvZiBkYXRhLCB+Mi4yJSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEh1YlNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SHViU2l6ZSgpIHtcbiAgICAgIHZhciBhdmVyYWdlID0gMDtcbiAgICAgIHZhciBhdmVyYWdlU3F1YXJlZCA9IDA7XG4gICAgICB2YXIgaHViQ291bnRlciA9IDA7XG4gICAgICB2YXIgbGFyZ2VzdEh1YiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICBpZiAoX25vZGUuZWRnZXMubGVuZ3RoID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICAgIGxhcmdlc3RIdWIgPSBfbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYXZlcmFnZSArPSBfbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIGF2ZXJhZ2VTcXVhcmVkICs9IE1hdGgucG93KF9ub2RlLmVkZ2VzLmxlbmd0aCwgMik7XG4gICAgICAgIGh1YkNvdW50ZXIgKz0gMTtcbiAgICAgIH1cbiAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlIC8gaHViQ291bnRlcjtcbiAgICAgIGF2ZXJhZ2VTcXVhcmVkID0gYXZlcmFnZVNxdWFyZWQgLyBodWJDb3VudGVyO1xuXG4gICAgICB2YXIgdmFyaWFuY2UgPSBhdmVyYWdlU3F1YXJlZCAtIE1hdGgucG93KGF2ZXJhZ2UsIDIpO1xuICAgICAgdmFyIHN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICAgICAgdmFyIGh1YlRocmVzaG9sZCA9IE1hdGguZmxvb3IoYXZlcmFnZSArIDIgKiBzdGFuZGFyZERldmlhdGlvbik7XG5cbiAgICAgIC8vIGFsd2F5cyBoYXZlIGF0IGxlYXN0IG9uZSB0byBjbHVzdGVyXG4gICAgICBpZiAoaHViVGhyZXNob2xkID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICBodWJUaHJlc2hvbGQgPSBsYXJnZXN0SHViO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHViVGhyZXNob2xkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBlZGdlIGZvciB0aGUgY2x1c3RlciByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gZnJvbUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0b0lkXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZX0gYmFzZUVkZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtFZGdlfSBuZXdseSBjcmVhdGVkIGNsdXN0ZXJlZCBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIGJhc2VFZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIGV4dHJhT3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUgb3B0aW9ucyBvZiB0aGUgZWRnZSB3ZSB3aWxsIHJlcGxhY2VcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGJhc2VFZGdlLCAnZWRnZScpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0aWVzIG9mIGNsdXN0ZXJFZGdlcyBhcmUgc3VwZXJpbXBvc2VkIG9uIGl0XG4gICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBlZGdlXG4gICAgICBjbG9uZWRPcHRpb25zLmZyb20gPSBmcm9tSWQ7XG4gICAgICBjbG9uZWRPcHRpb25zLnRvID0gdG9JZDtcbiAgICAgIGNsb25lZE9wdGlvbnMuaWQgPSAnY2x1c3RlckVkZ2U6JyArIHV0aWwucmFuZG9tVVVJRCgpO1xuXG4gICAgICAvLyBhcHBseSB0aGUgZWRnZSBzcGVjaWZpYyBvcHRpb25zIHRvIGl0IGlmIHNwZWNpZmllZFxuICAgICAgaWYgKGV4dHJhT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZShjbG9uZWRPcHRpb25zKTtcbiAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMgPSBbYmFzZUVkZ2UuaWRdO1xuICAgICAgbmV3RWRnZS5jb25uZWN0KCk7XG5cbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgZWRnZVxuICAgICAgdGhpcy5ib2R5LmVkZ2VzW25ld0VkZ2UuaWRdID0gbmV3RWRnZTtcblxuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBwYXNzZWQgY2hpbGQgbm9kZXMgYW5kIGVkZ2VzIHRvIHRoZSBnaXZlbiBjbHVzdGVyIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBjaGlsZE5vZGVzICBoYXNoIG9mIG5vZGVzIG9yIHNpbmdsZSBub2RlIHRvIGFkZCBpbiBjbHVzdGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8RWRnZX0gY2hpbGRFZGdlcyAgaGFzaCBvZiBlZGdlcyBvciBzaW5nbGUgZWRnZSB0byB0YWtlIGludG8gYWNjb3VudCB3aGVuIGNsdXN0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNsdXN0ZXJOb2RlICBjbHVzdGVyIG5vZGUgdG8gYWRkIG5vZGVzIGFuZCBlZGdlcyB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbHVzdGVyRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXMsIGNoaWxkRWRnZXMsIGNsdXN0ZXJOb2RlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChjaGlsZEVkZ2VzIGluc3RhbmNlb2YgRWRnZSkge1xuICAgICAgICB2YXIgZWRnZSA9IGNoaWxkRWRnZXM7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgY2hpbGRFZGdlcyA9IG9iajtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkTm9kZXMgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHZhciBfbm9kZTIgPSBjaGlsZE5vZGVzO1xuICAgICAgICB2YXIgX29iaiA9IHt9O1xuICAgICAgICBfb2JqW19ub2RlMi5pZF0gPSBfbm9kZTI7XG4gICAgICAgIGNoaWxkTm9kZXMgPSBfb2JqO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3Rlck5vZGUgPT09IHVuZGVmaW5lZCB8fCBjbHVzdGVyTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19jbHVzdGVyRWRnZXM6IHBhcmFtZXRlciBjbHVzdGVyTm9kZSByZXF1aXJlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgcmVxdWlyZWQgcHJvcGVydGllcyBmcm9tIHRoZSBjbHVzdGVyIG5vZGVcbiAgICAgICAgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0gY2x1c3Rlck5vZGUuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgdGhlIG5ldyBlZGdlcyB0aGF0IHdpbGwgY29ubmVjdCB0byB0aGUgY2x1c3Rlci5cbiAgICAgIC8vIEFsbCBzZWxmLXJlZmVyZW5jaW5nIGVkZ2VzIHdpbGwgYmUgYWRkZWQgdG8gY2hpbGRFZGdlcyBoZXJlLlxuICAgICAgdGhpcy5fY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXMsIGNoaWxkRWRnZXMsIGNsdXN0ZXJOb2RlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAvLyBkaXNhYmxlIHRoZSBjaGlsZEVkZ2VzXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlcykge1xuICAgICAgICBpZiAoY2hpbGRFZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfZWRnZTIgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBvcHRpb25zIGJlZm9yZSBjaGFuZ2luZ1xuICAgICAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UyKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgcGh5c2ljcyBhbmQgaGlkZSB0aGUgZWRnZVxuICAgICAgICAgICAgX2VkZ2UyLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGlzYWJsZSB0aGUgY2hpbGROb2Rlc1xuICAgICAgZm9yICh2YXIgX25vZGVJZDcgaW4gY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoY2hpbGROb2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkNykpIHtcbiAgICAgICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzW19ub2RlSWQ3XSA9IHtcbiAgICAgICAgICAgIGNsdXN0ZXJJZDogY2x1c3Rlck5vZGUuaWQsXG4gICAgICAgICAgICBub2RlOiB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDddXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDddLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpbiB3aGljaCBjbHVzdGVyIGdpdmVuIG5vZGVJZCByZXNpZGVzLlxuICAgICAqXG4gICAgICogSWYgbm90IGluIGNsdXN0ZXIsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBJZiB5b3Uga25vdyBhIGNsZWFuZXIgd2F5IHRvIGRvIHRoaXMsIHBsZWFzZSBlbmxpZ2h0ZW4gbWUgKHdpbXJpam5kZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge05vZGV8dW5kZWZpbmVkfSBOb2RlIGluc3RhbmNlIGZvciBjbHVzdGVyLCBpZiBwcmVzZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENsdXN0ZXJOb2RlRm9yTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyTm9kZUZvck5vZGUobm9kZUlkKSB7XG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcmVkTm9kZSA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXTtcblxuICAgICAgLy8gTk9URTogSWYgbm8gY2x1c3RlciBpbmZvIGZvdW5kLCBpdCBzaG91bGQgYWN0dWFsbHkgYmUgYW4gZXJyb3JcbiAgICAgIGlmIChjbHVzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcklkID0gY2x1c3RlcmVkTm9kZS5jbHVzdGVySWQ7XG4gICAgICBpZiAoY2x1c3RlcklkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbmRpdGlvbmFsbHkgcmVtb3ZpbmcgaXRlbXMgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIERvbmUgbGlrZSB0aGlzIGJlY2F1c2UgQXJyYXkuZmlsdGVyKCkgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBieSBhbGwgSUUncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19maWx0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsdGVyKGFyciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgdXRpbC5mb3JFYWNoKGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZW0pKSB7XG4gICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYW4gYWxsIGVkZ2VzIGZvciBjaGFuZ2VzIGluIGNsdXN0ZXJpbmcgYW5kIGFkanVzdCB0aGlzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyAoaW50ZXJuYWxseSkgYWZ0ZXIgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UgaW4gbm9kZSBvciBlZGdlIGRhdGEuXG4gICAgICpcbiAgICAgKiBQcmU6IFN0YXRlcyBvZiB0aGlzLmJvZHkubm9kZXMgYW5kIHRoaXMuYm9keS5lZGdlcyBjb25zaXN0ZW50XG4gICAgICogUHJlOiB0aGlzLmNsdXN0ZXJlZE5vZGVzIGFuZCB0aGlzLmNsdXN0ZXJlZEVkZ2UgY29uc2lzdGVudCB3aXRoIGNvbnRhaW5lZE5vZGVzIGFuZCBjb250YWluZWRFZGdlc1xuICAgICAqICAgICAgb2YgY2x1c3RlciBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVN0YXRlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBub2RlSWQgPSB2b2lkIDA7XG4gICAgICB2YXIgZGVsZXRlZE5vZGVJZHMgPSBbXTtcbiAgICAgIHZhciBkZWxldGVkRWRnZUlkcyA9IHt9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGNsdXN0ZXJpbmcgbm9kZXMgb25seVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGNsdXN0ZXIgbm9kZVxuICAgICAgICovXG4gICAgICB2YXIgZWFjaENsdXN0ZXJOb2RlID0gZnVuY3Rpb24gZWFjaENsdXN0ZXJOb2RlKGNhbGxiYWNrKSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaChfdGhpczQuYm9keS5ub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvL1xuICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgcmVndWxhciBub2RlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgZGVsZXRlZCBub2Rlc1xuICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5jbHVzdGVyZWROb2Rlcykge1xuICAgICAgICBpZiAoIXRoaXMuY2x1c3RlcmVkTm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkgY29udGludWU7XG4gICAgICAgIHZhciBfbm9kZTMgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICBpZiAoX25vZGUzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGVkTm9kZUlkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG5vZGVzIGZyb20gY2x1c3RlciBub2Rlc1xuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBub2RlcyBmcm9tIGNsdXN0ZXIgbGlzdFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBkZWxldGVkTm9kZUlkcy5sZW5ndGg7IG4rKykge1xuICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tkZWxldGVkTm9kZUlkc1tuXV07XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBSZW1vdmUgZGVsZXRlZCBlZGdlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG5cbiAgICAgIC8vIEFkZCB0aGUgZGVsZXRlZCBjbHVzdGVyZWQgZWRnZXMgdG8gdGhlIGxpc3RcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmNsdXN0ZXJlZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCB8fCAhZWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENsdXN0ZXIgbm9kZXMgY2FuIGFsc28gY29udGFpbiBlZGdlcyB3aGljaCBhcmUgbm90IGNsdXN0ZXJlZCxcbiAgICAgIC8vIGkuZS4gbm9kZXMgMS0yIHdpdGhpbiBjbHVzdGVyIHdpdGggYW4gZWRnZSBpbiBiZXR3ZWVuLlxuICAgICAgLy8gU28gdGhlIGNsdXN0ZXIgbm9kZXMgYWxzbyBuZWVkIHRvIGJlIHNjYW5uZWQgZm9yIGludmFsaWQgZWRnZXNcbiAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgICAgaWYgKCFlZGdlLmVuZFBvaW50c1ZhbGlkKCkgJiYgIWRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbHNvIHNjYW4gZm9yIGNsdXN0ZXIgZWRnZXMgd2hpY2ggbmVlZCB0byBiZSByZW1vdmVkIGluIHRoZSBhY3RpdmUgbGlzdC5cbiAgICAgIC8vIFJlZ3VsYXIgZWRnZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYmVmb3JlaGFuZCwgc28gdGhpcyBvbmx5IHBpY2tzIHVwIHRoZSBjbHVzdGVyIGVkZ2VzLlxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHNjYW4gdGhlIGNvbnRhaW5lZCBlZGdlcyBmb3IgdmFsaWRpdHlcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmVwbGFjZWRJZHMgPSBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuICAgICAgICBpZiAocmVwbGFjZWRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBudW1WYWxpZCA9IDA7XG5cbiAgICAgICAgICB1dGlsLmZvckVhY2gocmVwbGFjZWRJZHMsIGZ1bmN0aW9uIChjb250YWluZWRFZGdlSWQpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWRFZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbY29udGFpbmVkRWRnZUlkXTtcblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZEVkZ2UgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZWRFZGdlLmVuZFBvaW50c1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgbnVtVmFsaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlzVmFsaWQgPSBudW1WYWxpZCA+IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSB8fCAhaXNWYWxpZCkge1xuICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgZWRnZXMgZnJvbSBjbHVzdGVyIG5vZGVzXG4gICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaChkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGRlbGV0ZWRFZGdlSWQpIHtcbiAgICAgICAgICBkZWxldGUgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXNbZGVsZXRlZEVkZ2VJZF07XG5cbiAgICAgICAgICB1dGlsLmZvckVhY2goY2x1c3Rlck5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBtKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5pZCA9PT0gZGVsZXRlZEVkZ2VJZCkge1xuICAgICAgICAgICAgICBjbHVzdGVyTm9kZS5lZGdlc1ttXSA9IG51bGw7IC8vIERvbid0IHdhbnQgdG8gZGlyZWN0bHkgZGVsZXRlIGhlcmUsIGJlY2F1c2UgaW4gdGhlIGxvb3BcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzID0gX3RoaXM0Ll9maWx0ZXIoZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhZGVsZXRlZEVkZ2VJZHNbaWRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbnVsbHNcbiAgICAgICAgICBjbHVzdGVyTm9kZS5lZGdlcyA9IF90aGlzNC5fZmlsdGVyKGNsdXN0ZXJOb2RlLmVkZ2VzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBmcm9tIGNsdXN0ZXIgbGlzdFxuICAgICAgdXRpbC5mb3JFYWNoKGRlbGV0ZWRFZGdlSWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczQuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgY2x1c3RlciBlZGdlcyBmcm9tIGFjdGl2ZSBsaXN0ICh0aGlzLmJvZHkuZWRnZXMpLlxuICAgICAgLy8gZGVsZXRlZEVkZ2VJZHMgc3RpbGwgY29udGFpbnMgaWQgb2YgcmVndWxhciBlZGdlcywgYnV0IHRoZXNlIHNob3VsZCBhbGxcbiAgICAgIC8vIGJlIGdvbmUgd2hlbiB5b3UgcmVhY2ggaGVyZS5cbiAgICAgIHV0aWwuZm9yRWFjaChkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICBkZWxldGUgX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2hlY2sgY2hhbmdlZCBjbHVzdGVyIHN0YXRlIG9mIGVkZ2VzXG4gICAgICAvL1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBrZXlzIGhlcmUsIGJlY2F1c2UgZWRnZXMgbWF5IGJlIHJlbW92ZWQgaW4gdGhlIGxvb3BcbiAgICAgIHZhciBpZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuYm9keS5lZGdlcyk7XG4gICAgICB1dGlsLmZvckVhY2goaWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICB2YXIgc2hvdWxkQmVDbHVzdGVyZWQgPSBfdGhpczQuX2lzQ2x1c3RlcmVkTm9kZShlZGdlLmZyb21JZCkgfHwgX3RoaXM0Ll9pc0NsdXN0ZXJlZE5vZGUoZWRnZS50b0lkKTtcbiAgICAgICAgaWYgKHNob3VsZEJlQ2x1c3RlcmVkID09PSBfdGhpczQuX2lzQ2x1c3RlcmVkRWRnZShlZGdlLmlkKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gYWxsIGlzIHdlbGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRCZUNsdXN0ZXJlZCkge1xuICAgICAgICAgIC8vIGFkZCBlZGdlIHRvIGNsdXN0ZXJpbmdcbiAgICAgICAgICB2YXIgY2x1c3RlckZyb20gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLmZyb21JZCk7XG4gICAgICAgICAgaWYgKGNsdXN0ZXJGcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2x1c3RlckVkZ2VzKF90aGlzNC5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXSwgZWRnZSwgY2x1c3RlckZyb20pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjbHVzdGVyVG8gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLnRvSWQpO1xuICAgICAgICAgIGlmIChjbHVzdGVyVG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jbHVzdGVyRWRnZXMoX3RoaXM0LmJvZHkubm9kZXNbZWRnZS50b0lkXSwgZWRnZSwgY2x1c3RlclRvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayB0aGF0IGl0IHdvcmtzIGZvciBib3RoIGVkZ2VzIGNsdXN0ZXJlZFxuICAgICAgICAgIC8vICAgICAgIChUaGlzIG1pZ2h0IGJlIHBhcmFub2lhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBoYXBwZW5pbmcsIHRoZSBzdGF0ZSBzaG91bGRcbiAgICAgICAgICAvLyBiZSBwcm9wZXJseSB1cGRhdGVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBpdCAqaXMqIHJlYWNoZWQgZHVyaW5nIG5vcm1hbCBvcGVyYXRpb24sIHRoZW4gd2UgaGF2ZSB0byBpbXBsZW1lbnRcbiAgICAgICAgICAvLyB1bmRvIGNsdXN0ZXJpbmcgZm9yIHRoaXMgZWRnZSBoZXJlLlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlIGVkZ2UgZnJvbSBjbHVzdGVyaW5nIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENsdXN0ZXJzIG1heSBiZSBuZXN0ZWQgdG8gYW55IGxldmVsLiBLZWVwIG9uIG9wZW5pbmcgdW50aWwgbm90aGluZyB0byBvcGVuXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvbnRpbnVlTG9vcCA9IHRydWU7XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgIHZhciBjbHVzdGVyc1RvT3BlbiA9IFtdO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgaWQncyBvZiBjbHVzdGVycyB0aGF0IG5lZWQgb3BlbmluZ1xuICAgICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgICAgdmFyIG51bU5vZGVzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcykubGVuZ3RoO1xuICAgICAgICAgIHZhciBhbGxvd1NpbmdsZSA9IGNsdXN0ZXJOb2RlLm9wdGlvbnMuYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciA9PT0gdHJ1ZTtcbiAgICAgICAgICBpZiAoYWxsb3dTaW5nbGUgJiYgbnVtTm9kZXMgPCAxIHx8ICFhbGxvd1NpbmdsZSAmJiBudW1Ob2RlcyA8IDIpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzVG9PcGVuLnB1c2goY2x1c3Rlck5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gT3BlbiB0aGVtXG4gICAgICAgIGZvciAodmFyIF9uID0gMDsgX24gPCBjbHVzdGVyc1RvT3Blbi5sZW5ndGg7ICsrX24pIHtcbiAgICAgICAgICBfdGhpczQub3BlbkNsdXN0ZXIoY2x1c3RlcnNUb09wZW5bX25dLCB7fSwgZmFsc2UgLyogRG9uJ3QgcmVmcmVzaCwgd2UncmUgaW4gYW4gcmVmcmVzaC91cGRhdGUgYWxyZWFkeSAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZUxvb3AgPSBjbHVzdGVyc1RvT3Blbi5sZW5ndGggPiAwO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBjb250aW51ZUxvb3A7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAoY29udGludWVMb29wKSB7XG4gICAgICAgIF9sb29wMigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSgpOyAvLyBSZWRvIHRoaXMgbWV0aG9kIChyZWN1cnNpb24gcG9zc2libGUhIHNob3VsZCBiZSBzYWZlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBub2RlIHdpdGggZ2l2ZW4gaWQgaXMgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19pc0NsdXN0ZXJlZE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWROb2RlKG5vZGVJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBlZGdlIHdpdGggZ2l2ZW4gaWQgaXMgbm90IHZpc2libGUgZHVlIHRvIGNsdXN0ZXJpbmcuXG4gICAgICpcbiAgICAgKiBBbiBlZGdlIGlzIGNvbnNpZGVyZWQgY2x1c3RlcmVkIGlmOlxuICAgICAqIC0gaXQgaXMgZGlyZWN0bHkgcmVwbGFjZWQgYnkgYSBjbHVzdGVyaW5nIGVkZ2VcbiAgICAgKiAtIGFueSBvZiBpdHMgY29ubmVjdGluZyBub2RlcyBpcyBpbiBhIGNsdXN0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19pc0NsdXN0ZXJlZEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWRFZGdlKGVkZ2VJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2x1c3RlckVuZ2luZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2x1c3RlckVuZ2luZTtcblxuLyoqKi8gfSksXG4vKiAxNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpWydkZWZhdWx0J107XG5cbi8qKlxuICogQSBDbHVzdGVyIGlzIGEgc3BlY2lhbCBOb2RlIHRoYXQgYWxsb3dzIGEgZ3JvdXAgb2YgTm9kZXMgcG9zaXRpb25lZCBjbG9zZWx5IHRvZ2V0aGVyXG4gKiB0byBiZSByZXByZXNlbnRlZCBieSBhIHNpbmdsZSBDbHVzdGVyIE5vZGUuXG4gKlxuICogQGV4dGVuZHMgTm9kZVxuICovXG5cbnZhciBDbHVzdGVyID0gZnVuY3Rpb24gKF9Ob2RlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKENsdXN0ZXIsIF9Ob2RlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheS48SFRNTEltYWdlRWxlbWVudD59aW1hZ2VsaXN0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwbGlzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdE9wdGlvbnMgICAgIEdsb2JhbCBkZWZhdWx0IG9wdGlvbnMgZm9yIG5vZGVzXG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENsdXN0ZXIpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQ2x1c3Rlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2x1c3RlcikpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSk7XG5cbiAgICBfdGhpcy5pc0NsdXN0ZXIgPSB0cnVlO1xuICAgIF90aGlzLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgX3RoaXMuY29udGFpbmVkRWRnZXMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgY2hpbGQgY2x1c3RlciBkYXRhIHRvIGN1cnJlbnQgYW5kIGRpc2Nvbm5lY3QgdGhlIGNoaWxkIGNsdXN0ZXIuXG4gICAqXG4gICAqIFBsZWFzZSBjb25zdWx0IHRoZSBoZWFkZXIgY29tbWVudCBpbiAnQ2x1c3RlcmluZy5qcycgZm9yIHRoZSBmaWVsZHMgc2V0IGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY2hpbGRDbHVzdGVySWQgIGlkIG9mIGNoaWxkIGNsdXN0ZXIgdG8gb3BlblxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKENsdXN0ZXIsIFt7XG4gICAga2V5OiAnX29wZW5DaGlsZENsdXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlbkNoaWxkQ2x1c3RlcihjaGlsZENsdXN0ZXJJZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZENsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGRDbHVzdGVySWRdO1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVkTm9kZXNbY2hpbGRDbHVzdGVySWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlIHdpdGggaWQ6ICcgKyBjaGlsZENsdXN0ZXJJZCArICcgbm90IGluIGN1cnJlbnQgY2x1c3RlcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFjaGlsZENsdXN0ZXIuaXNDbHVzdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZSB3aXRoIGlkOiAnICsgY2hpbGRDbHVzdGVySWQgKyAnIGlzIG5vdCBhIGNsdXN0ZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzY29ubmVjdCBjaGlsZCBjbHVzdGVyIGZyb20gY3VycmVudCBjbHVzdGVyXG4gICAgICBkZWxldGUgdGhpcy5jb250YWluZWROb2Rlc1tjaGlsZENsdXN0ZXJJZF07XG4gICAgICB1dGlsLmZvckVhY2goY2hpbGRDbHVzdGVyLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBkZWxldGUgX3RoaXMyLmNvbnRhaW5lZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyYW5zZmVyIG5vZGVzIGFuZCBlZGdlc1xuICAgICAgdXRpbC5mb3JFYWNoKGNoaWxkQ2x1c3Rlci5jb250YWluZWROb2RlcywgZnVuY3Rpb24gKG5vZGUsIG5vZGVJZCkge1xuICAgICAgICBfdGhpczIuY29udGFpbmVkTm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICB9KTtcbiAgICAgIGNoaWxkQ2x1c3Rlci5jb250YWluZWROb2RlcyA9IHt9O1xuXG4gICAgICB1dGlsLmZvckVhY2goY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIF90aGlzMi5jb250YWluZWRFZGdlc1tlZGdlSWRdID0gZWRnZTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzID0ge307XG5cbiAgICAgIC8vIFRyYW5zZmVyIGVkZ2VzIHdpdGhpbiBjbHVzdGVyIGVkZ2VzIHdoaWNoIGFyZSBjbHVzdGVyZWRcbiAgICAgIHV0aWwuZm9yRWFjaChjaGlsZENsdXN0ZXIuZWRnZXMsIGZ1bmN0aW9uIChjbHVzdGVyRWRnZSkge1xuICAgICAgICB1dGlsLmZvckVhY2goX3RoaXMyLmVkZ2VzLCBmdW5jdGlvbiAocGFyZW50Q2x1c3RlckVkZ2UpIHtcbiAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBvbmx5IGJlIHByZXNlbnQgaW4gYSBzaW5nbGUgY2x1c3RlcmluZyBlZGdlXG4gICAgICAgICAgLy8gTm90IHRlc3RlZCBoZXJlXG4gICAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMuaW5kZXhPZihjbHVzdGVyRWRnZS5pZCk7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgICAgdXRpbC5mb3JFYWNoKGNsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLCBmdW5jdGlvbiAoc3JjSWQpIHtcbiAgICAgICAgICAgIHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goc3JjSWQpO1xuXG4gICAgICAgICAgICAvLyBNYWludGFpbiBjb3JyZWN0IGJvb2trZWVwaW5nIGZvciB0cmFuc2ZlcnJlZCBlZGdlXG4gICAgICAgICAgICBfdGhpczIuYm9keS5lZGdlc1tzcmNJZF0uZWRnZVJlcGxhY2VkQnlJZCA9IHBhcmVudENsdXN0ZXJFZGdlLmlkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGNsdXN0ZXIgZWRnZSBmcm9tIHBhcmVudCBjbHVzdGVyIGVkZ2VcbiAgICAgICAgICBwYXJlbnRDbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmVkZ2VzID0gW107XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDbHVzdGVyO1xufShOb2RlKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2x1c3RlcjtcblxuLyoqKi8gfSksXG4vKiAxODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHRvIGEgdXNhYmxlIGZvcm0uXG4gKlxuICogU3BlY2lmaWNhbGx5LCBzZXQgdXAgdGhpcyBtZXRob2QgZm9yIHRoZSBjYXNlIG9mIHJ1bm5pbmcgb24gbm9kZS5qcyB3aXRoIGpzZG9tIGVuYWJsZWQuXG4gKlxuICogTk9URVM6XG4gKlxuICogKiBPbiBub2RlLmpzLCB3aGVuIGNhbGxpbmcgdGhpcyBkaXJlY3RseSBvdXRzaWRlIG9mIHRoaXMgY2xhc3MsIGB3aW5kb3dgIGlzIG5vdCBkZWZpbmVkLlxuICogICBUaGlzIGhhcHBlbnMgZXZlbiBpZiBqc2RvbSBpcyB1c2VkLlxuICogKiBGb3Igbm9kZS5qcyArIGpzZG9tLCBgd2luZG93YCBpcyBhdmFpbGFibGUgYXQgdGhlIG1vbWVudCB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkLlxuICogICBGb3IgdGhpcyByZWFzb24sIHRoZSBjYWxsZWQgaXMgcGxhY2VkIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gKiAqIEV2ZW4gdGhlbiwgYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKWAgaXMgbm90IGRlZmluZWQsIHNvIGl0IHN0aWxsIG5lZWRzIHRvIGJlIGFkZGVkLlxuICogKiBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBpdCBoYXBwZW5zIHRoYXQgdGhlIHdpbmRvdyBvYmplY3QgaXMgcmVzZXQgZHVyaW5nIGV4ZWN1dGlvbiwgY2F1c2luZ1xuICogICBhIHJ1bnRpbWUgZXJyb3IgZHVlIHRvIG1pc3NpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZSgpYC4gVGhpcyBuZWVkcyB0byBiZSBjb21wZW5zYXRlZCBmb3IsXG4gKiAgIHNlZSBgX3JlcXVlc3ROZXh0RnJhbWUoKWAuXG4gKiAqIFNpbmNlIHRoaXMgaXMgYSBnbG9iYWwgb2JqZWN0LCBpdCBtYXkgYWZmZWN0IG90aGVyIG1vZHVsZXMgYmVzaWRlcyBgTmV0d29ya2AuIFdpdGggbm9ybWFsXG4gKiAgIHVzYWdlLCB0aGlzIGRvZXMgbm90IGNhdXNlIGFueSBwcm9ibGVtcy4gRHVyaW5nIHVuaXQgdGVzdGluZywgZXJyb3JzIG1heSBvY2N1ci4gVGhlc2UgaGF2ZVxuICogICBiZWVuIGNvbXBlbnNhdGVkIGZvciwgc2VlIGNvbW1lbnQgYmxvY2sgaW4gX3JlcXVlc3ROZXh0RnJhbWUoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaW5pdFJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHtcbiAgdmFyIGZ1bmM7XG5cbiAgaWYgKHdpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZnVuYyA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuXG4gIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyB3aW5kb3cgb3IgbWV0aG9kIG5vdCBwcmVzZW50LCBzZXR0aW5nIG1vY2sgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIkNhbGxlZCBtb2NrIHJlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuYztcbiAgfVxufVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKlxuICogVGhlIGNhbnZhcyByZW5kZXJlclxuICovXG5cbnZhciBDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGJvZHksIGNhbnZhcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgIF9pbml0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcblxuICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICB0aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcblxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICAgIGhpZGVFZGdlc09uWm9vbTogZmFsc2UsXG4gICAgICBoaWRlTm9kZXNPbkRyYWc6IGZhbHNlXG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCgpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2FudmFzUmVuZGVyZXIsIFt7XG4gICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2RyYWdTdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZHJhZ0VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3pvb20nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KF90aGlzLnpvb21UaW1lb3V0SWQpO1xuICAgICAgICBfdGhpcy56b29tVGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpcy5fcmVxdWVzdFJlZHJhdy5iaW5kKF90aGlzKSgpO1xuICAgICAgICB9LCAyNTApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3Jlc2l6ZU5vZGVzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmVzaXplTm9kZXMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19yZWRyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgX3RoaXMuX3JlZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfYmxvY2tSZWRyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfYWxsb3dSZWRyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVxdWVzdFJlZHJhdycsIHRoaXMuX3JlcXVlc3RSZWRyYXcuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3N0YXJ0UmVuZGVyaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyArPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19zdG9wUmVuZGVyaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyAtPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBfdGhpcy5yZW5kZXJSZXF1ZXN0cyA+IDA7XG4gICAgICAgIF90aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKF90aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnaGlkZUVkZ2VzT25EcmFnJywgJ2hpZGVFZGdlc09uWm9vbScsICdoaWRlTm9kZXNPbkRyYWcnXTtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBkcmF3aW5nIG9mIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQ2FsbHMgdGhlIGNhbGxiYWNrIHdoZW4gdGhlIG5leHQgZnJhbWUgY2FuIG9yIHdpbGwgYmUgZHJhd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIHRpbWVvdXQgY2FzZSBvbmx5LCB3YWl0IHRoaXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlcXVlc3ROZXh0RnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdE5leHRGcmFtZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIC8vIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgbW9jayB3aW5kb3cgb2JqZWN0IGlzIHJlc2V0IHdoaWxlXG4gICAgICAvLyB0aGUgbmV4dCBmcmFtZSBpcyBzdGlsbCBwZW5kaW5nLiBUaGVuLCBlaXRoZXIgJ3dpbmRvdycgaXMgbm90IHByZXNlbnQsIG9yXG4gICAgICAvLyAncmVxdWVzdEFuaW1hdGlvbkZyYW1lKCknIGlzIG5vdCBwcmVzZW50IGJlY2F1c2UgaXQgaXMgbm90IGRlZmluZWQgb24gdGhlXG4gICAgICAvLyBtb2NrIHdpbmRvdyBvYmplY3QuXG4gICAgICAvL1xuICAgICAgLy8gQXMgYSBjb25zZXF1ZW5jZSwgdW5yZWxhdGVkIHVuaXQgdGVzdHMgbWF5IGFwcGVhciB0byBmYWlsLCBldmVuIGlmIHRoZSBwcm9ibGVtXG4gICAgICAvLyBkZXNjcmliZWQgaGFwcGVucyBpbiB0aGUgY3VycmVudCB1bml0IHRlc3QuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBub3Qgc29tZXRoaW5nIHRoYXQgd2lsbCBoYXBwZW4gaW4gbm9ybWFsIG9wZXJhdGlvbiwgYnV0IHdlIHN0aWxsIG5lZWRcbiAgICAgIC8vIHRvIHRha2UgaXQgaW50byBhY2NvdW50LlxuICAgICAgLy9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuOyAvLyBEb2luZyBgaWYgKHdpbmRvdyA9PT0gdW5kZWZpbmVkKWAgZG9lcyBub3Qgd29yayBoZXJlIVxuXG4gICAgICB2YXIgdGltZXIgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBteVdpbmRvdyA9IHdpbmRvdzsgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IHRoYXQgJ3dpbmRvdycgaXMgcmVzZXRcbiAgICAgIC8vIHdoaWxlIHJ1bm5pbmcgdGhpcyBtZXRob2QuXG5cbiAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB3YWl0IGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gbXlXaW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG15V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHRpbWVyID0gbXlXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGltZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc3RhcnRSZW5kZXJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKHRoaXMuX3JlbmRlclN0ZXAuYmluZCh0aGlzKSwgdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyU3RlcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJTdGVwKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSByZW5kZXJUaW1lciBzbyBhIG5ldyBzY2hlZHVsZWQgYW5pbWF0aW9uIHN0ZXAgY2FuIGJlIHNldFxuICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWRyYXcoKTtcblxuICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKiBjaGFydCB3aWxsIGJlIHJlc2l6ZWQgdG9vLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZXRTaXplJyk7XG4gICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlcXVlc3RSZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdFJlZHJhdygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5yZWRyYXdSZXF1ZXN0ZWQgIT09IHRydWUgJiYgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlICYmIHRoaXMuYWxsb3dSZWRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX3JlZHJhdyhmYWxzZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWRkZW49ZmFsc2VdIHwgVXNlZCB0byBnZXQgdGhlIGZpcnN0IGVzdGltYXRlIG9mIHRoZSBub2RlIHNpemVzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHRoZSBub2RlcyBhcmUgZHJhd24gYWZ0ZXIgd2hpY2ggdGhleSBhcmUgcXVpY2tseSBkcmF3biBvdmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuICAgICAgdmFyIGhpZGRlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2luaXRSZWRyYXcnKTtcblxuICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgd2FzIGhpZGRlbiwgdGhpcyBmaXhlcyBpdCBiYWNrIHVwIVxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLndpZHRoID09PSAwIHx8IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcblxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICAvLyBpZiB0aGUgZGl2IGlzIGhpZGRlbiwgd2Ugc3RvcCB0aGUgcmVkcmF3IGhlcmUgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2xpZW50V2lkdGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdiZWZvcmVEcmF3aW5nJywgY3R4KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSAmJiAodGhpcy56b29taW5nID09PSBmYWxzZSB8fCB0aGlzLnpvb21pbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3RWRnZXMoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZU5vZGVzT25EcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdOb2RlcyhjdHgsIGhpZGRlbik7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2FmdGVyRHJhd2luZycsIGN0eCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGlmIChoaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVzaXplTm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplTm9kZXMoKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgLy8gcmVzaXplIGFsbCBub2Rlc1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgbm9kZS5yZXNpemUoY3R4KTtcbiAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3Tm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd05vZGVzKGN0eCkge1xuICAgICAgdmFyIGFsd2F5c1Nob3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgICAgdmFyIG1hcmdpbiA9IDIwO1xuICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7IHg6IC1tYXJnaW4sIHk6IC1tYXJnaW4gfSk7XG4gICAgICB2YXIgYm90dG9tUmlnaHQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCArIG1hcmdpbixcbiAgICAgICAgeTogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCArIG1hcmdpblxuICAgICAgfSk7XG4gICAgICB2YXIgdmlld2FibGVBcmVhID0ge1xuICAgICAgICB0b3A6IHRvcExlZnQueSxcbiAgICAgICAgbGVmdDogdG9wTGVmdC54LFxuICAgICAgICBib3R0b206IGJvdHRvbVJpZ2h0LnksXG4gICAgICAgIHJpZ2h0OiBib3R0b21SaWdodC54XG5cbiAgICAgICAgLy8gZHJhdyB1bnNlbGVjdGVkIG5vZGVzO1xuICAgICAgfTtmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZCBub2RlcyBhc2lkZVxuICAgICAgICBpZiAobm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKG5vZGVJbmRpY2VzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWx3YXlzU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgodmlld2FibGVBcmVhKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyB0aGUgc2VsZWN0ZWQgbm9kZXMgb24gdG9wXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc2VsZWN0ZWQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tzZWxlY3RlZFtfaV1dO1xuICAgICAgICBub2RlLmRyYXcoY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIGVkZ2VzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2RyYXdFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RWRnZXMoY3R4KSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZSA9IHZvaWQgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlLmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciByZXF1aXJlcyBhIHNldFRpbWVvdXQgb3IgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFRoaXMgd2FzIHJlcXVpcmVkIGJlY2F1c2VcbiAgICAgKiBzb21lIGltcGxlbWVudGF0aW9ucyAoc2FmYXJpIGFuZCBJRTkpIGRpZCBub3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBicm93c2VyVHlwZSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ21zaWUgOS4wJykgIT0gLTEpIHtcbiAgICAgICAgICAvLyBJRSA5XG4gICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ3NhZmFyaScpICE9IC0xKSB7XG4gICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ2Nocm9tZScpIDw9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDYW52YXNSZW5kZXJlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2FudmFzUmVuZGVyZXI7XG5cbi8qKiovIH0pLFxuLyogMTgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIGZyYW1lIGZvciB0aGUgTmV0d29yay5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgb25jZSB3aGVuIGEgTmV0d29yayBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIGZyYW1lXG4gKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gKiBub2Rlcy5cbiAqL1xuXG52YXIgQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhcyhib2R5KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2FudmFzKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gMTtcbiAgICB0aGlzLnJlc2l6ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVzaXplRnVuY3Rpb24gPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2FtZXJhU3RhdGUgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXNWaWV3Q2VudGVyID0ge307XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2FudmFzLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIGJpbmQgdGhlIGV2ZW50c1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub25jZSgncmVzaXplJywgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggPSBvYmoud2lkdGggKiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSA9IG9iai5oZWlnaHQgKiAwLjU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3NldFNpemUnLCB0aGlzLnNldFNpemUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuaGFtbWVyRnJhbWUuZGVzdHJveSgpO1xuICAgICAgICBfdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICBfdGhpcy5fY2xlYW5VcCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F1dG9SZXNpemUnXTtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmVzaXplID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gYSBjaGFuZ2luZyBzaXplIG9mIHRoZSBicm93c2VyLlxuICAgICAgICB0aGlzLl9jbGVhblVwKCk7XG4gICAgICAgIHRoaXMucmVzaXplVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpczIuc2V0U2l6ZSgpO1xuICAgICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgdGhpcy5yZXNpemVGdW5jdGlvbiA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLnJlc2l6ZUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2xlYW5VcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhblVwKCkge1xuICAgICAgLy8gYXV0b21hdGljYWxseSBhZGFwdCB0byBhIGNoYW5naW5nIHNpemUgb2YgdGhlIGJyb3dzZXIuXG4gICAgICBpZiAodGhpcy5yZXNpemVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZXNpemVUaW1lcik7XG4gICAgICB9XG4gICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVGdW5jdGlvbik7XG4gICAgICB0aGlzLnJlc2l6ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19vblJlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbmQgc3RvcmUgdGhlIGNhbWVyYVN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89dGhpcy5waXhlbFJhdGlvXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRDYW1lcmFTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbiA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbyxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FtZXJhU3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0Q2FtZXJhU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICE9PSAwICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAhPT0gMCAmJiB0aGlzLnBpeGVsUmF0aW8gIT09IDAgJiYgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoID4gMCkge1xuICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvIC8gdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0O1xuICAgICAgICB2YXIgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlO1xuXG4gICAgICAgIGlmICh3aWR0aFJhdGlvICE9IDEgJiYgaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIDAuNSAqICh3aWR0aFJhdGlvICsgaGVpZ2h0UmF0aW8pO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoUmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIHdpZHRoUmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIGhlaWdodFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgICAgLy8gdGhpcyBjb21lcyBmcm9tIHRoZSB2aWV3IG1vZHVsZS5cbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3Q2VudGVyID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgICAgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgICAgeDogY3VycmVudFZpZXdDZW50ZXIueCAtIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueCxcbiAgICAgICAgICB5OiBjdXJyZW50Vmlld0NlbnRlci55IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggKz0gZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSArPSBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3ByZXBhcmVWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlVmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEgfHwgdmFsdWUuaW5kZXhPZigncHgnKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignJScpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHVzZSB0aGUgdmFsdWUgc3VwcGxpZWQgZm9yIHdpZHRoIG9yIGhlaWdodDonICsgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSFRNTFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICB3aGlsZSAodGhpcy5ib2R5LmNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdGhpcy5ib2R5LmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmJvZHkuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtbmV0d29yayc7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuZnJhbWUudGFiSW5kZXggPSA5MDA7IC8vIHRhYiBpbmRleCBpcyByZXF1aXJlZCBmb3Iga2V5Y2hhcm0gdG8gYmluZCBrZXlzdHJva2VzIHRvIHRoZSBkaXYgaW5zdGVhZCBvZiB0aGUgd2luZG93XG5cbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmNhbnZhcyk7XG5cbiAgICAgIGlmICghdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcbiAgICAgICAgbm9DYW52YXMuaW5uZXJIVE1MID0gJ0Vycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhcyc7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSBmcmFtZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgIHRoaXMuYm9keS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG5cbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gMTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBiaW5kcyBoYW1tZXIsIGl0IGNhbiBiZSByZXBlYXRlZCBvdmVyIGFuZCBvdmVyIGR1ZSB0byB0aGUgdW5pcXVlbmVzcyBjaGVjay5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZEhhbW1lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9O1xuXG4gICAgICAvLyBpbml0IGhhbW1lclxuICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUuY2FudmFzKTtcbiAgICAgIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG4gICAgICAvLyBlbmFibGUgdG8gZ2V0IGJldHRlciByZXNwb25zZSwgdG9kbzogdGVzdCBvbiBtb2JpbGUuXG4gICAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCB9KTtcblxuICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbignZG91YmxldGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oJ3ByZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5tb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyhldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oJ3BpbmNoJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2goZXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE86IG5lYXRseSBjbGVhbnVwIHRoZXNlIGhhbmRsZXJzIHdoZW4gcmUtY3JlYXRpbmcgdGhlIENhbnZhcywgSUYgdGhlc2UgYXJlIGRvbmUgd2l0aCBoYW1tZXIsIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB3aWxsIG5vdCB3b3JrP1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dChldmVudCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5oYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZSk7XG4gICAgICBoYW1tZXJVdGlsLm9uUmVsZWFzZSh0aGlzLmhhbW1lckZyYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyBzaXplIGZvciB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCAgIFdpZHRoIGluIHBpeGVscyBvciBwZXJjZW50YWdlIChmb3IgZXhhbXBsZSAnODAwcHgnXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgJzUwJScpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAgSGVpZ2h0IGluIHBpeGVscyBvciBwZXJjZW50YWdlICAoZm9yIGV4YW1wbGUgJzQwMHB4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICczMCUnKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLmhlaWdodDtcblxuICAgICAgd2lkdGggPSB0aGlzLl9wcmVwYXJlVmFsdWUod2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5fcHJlcGFyZVZhbHVlKGhlaWdodCk7XG5cbiAgICAgIHZhciBlbWl0RXZlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBvbGRXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoO1xuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodDtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBwaXhlbCByYXRpb1xuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IENvbW1lbnQgaW4gZm9sbG93aW5nIGlzIHJhdGhlciBpbmNvbnNpc3RlbnQ7IHRoaXMgaXMgdGhlIE9OTFkgcGxhY2UgaW4gdGhlIGNvZGVcbiAgICAgIC8vICAgICAgIHdoZXJlIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgcGl4ZWwgcmF0aW8gY291bGQgY2hhbmdlIGF0IHJ1bnRpbWUuXG4gICAgICAvLyAgICAgICBUaGUgb25seSB3YXkgSSBjYW4gdGhpbmsgb2YgdGhpcyBoYXBwZW5pbmcgaXMgYSByb3RhdGluZyBzY3JlZW4gb3IgdGFibGV0OyBidXQgdGhlblxuICAgICAgLy8gICAgICAgdGhlcmUgc2hvdWxkIGJlIGEgbWVjaGFuaXNtIGZvciByZWxvYWRpbmcgdGhlIGRhdGEgKFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgcHJlc2VudCkuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgSWYgdGhlIGFzc3VtcHRpb24gaXMgdHJ1ZSAoaS5lLiBwaXhlbCByYXRpbyBjYW4gY2hhbmdlIGF0IHJ1bnRpbWUpLCB0aGVuICphbGwqIHVzYWdlXG4gICAgICAvLyAgICAgICBvZiBwaXhlbCByYXRpbyBtdXN0IGJlIG92ZXJoYXVsZWQgZm9yIHRoaXMuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgRm9yIHRoZSB0aW1lIGJlaW5nLCBJIHdpbGwgaHVtb3IgdGhlIGFzc3VtcHRpb24gaGVyZSwgYW5kIGluIHRoZSByZXN0IG9mIHRoZSBjb2RlIGFzc3VtZSBpdCBpc1xuICAgICAgLy8gICAgICAgY29uc3RhbnQuXG4gICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbzsgLy8gd2UgY2FjaGUgdGhpcyBiZWNhdXNlIHRoZSBjYW1lcmEgc3RhdGUgc3RvcmFnZSBuZWVkcyB0aGUgb2xkIHZhbHVlXG4gICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgIGlmICh3aWR0aCAhPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG5cbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNsaWVudEhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHdvdWxkIGFkYXB0IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHRvIHRoZSB3aWR0aCBmcm9tIDEwMCUgaWYgYW5kIG9ubHkgaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBjaGFuZ2UuXG5cbiAgICAgICAgdmFyIG5ld1dpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGNhbWVyYSBpZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzaXplLlxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT09IG5ld1dpZHRoIHx8IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT09IG5ld1dpZHRoKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbWl0RXZlbnQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzaXplJywge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBvbGRXaWR0aDogTWF0aC5yb3VuZChvbGRXaWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgb2xkSGVpZ2h0OiBNYXRoLnJvdW5kKG9sZEhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgY2FtZXJhIG9uIGNoYW5nZS5cbiAgICAgICAgdGhpcy5fc2V0Q2FtZXJhU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGluaXRpYWxpemVkIHNvIHRoZSBnZXQgYW5kIHNldCBjYW1lcmEgd2lsbCB3b3JrIGZyb20gbm93IG9uLlxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gZW1pdEV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHBpeGVsIHJhdGlvIGZvciB2YXJpb3VzIGJyb3dzZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lUGl4ZWxSYXRpbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVQaXhlbFJhdGlvKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuICAgICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtZXJhdG9yID0gMTtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyAod2luZG93ICE9PSB1bmRlZmluZWQpIGRvZXNuJ3Qgd29yayBoZXJlIVxuICAgICAgICAvLyBQcm90ZWN0aW9uIGR1cmluZyB1bml0IHRlc3RzLCB3aGVyZSAnd2luZG93JyBjYW4gYmUgbWlzc2luZ1xuICAgICAgICBudW1lcmF0b3IgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVub21pbmF0b3IgPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICByZXR1cm4gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGF6eSBkZXRlcm1pbmF0aW9uIG9mIHBpeGVsIHJhdGlvLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldFBpeGVsUmF0aW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UGl4ZWxSYXRpbygpIHtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHRoaXMuX2RldGVybWluZVBpeGVsUmF0aW8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgY29udGFpbmVkIGNvbnRleHQsIGJhc2VkIG9uIGl0cyBwaXhlbFJhdGlvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFRyYW5zZm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdldENvbnRleHQoKTtcbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmF4IGNvbnRleHQnKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWCBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KSB0b1xuICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19YY29udmVydERPTXRvQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0RE9NdG9DYW52YXMoeCkge1xuICAgICAgcmV0dXJuICh4IC0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pIHRvXG4gICAgICogdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX1hjb252ZXJ0Q2FudmFzVG9ET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRDYW52YXNUb0RPTSh4KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBZIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX1ljb252ZXJ0RE9NdG9DYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRET010b0NhbnZhcyh5KSB7XG4gICAgICByZXR1cm4gKHkgLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgKiB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfWWNvbnZlcnRDYW52YXNUb0RPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydENhbnZhc1RvRE9NKHkpIHtcbiAgICAgIHJldHVybiB5ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2FudmFzVG9ET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW52YXNUb0RPTShwb3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX1hjb252ZXJ0Q2FudmFzVG9ET00ocG9zLngpLFxuICAgICAgICB5OiB0aGlzLl9ZY29udmVydENhbnZhc1RvRE9NKHBvcy55KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnRE9NdG9DYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBET010b0NhbnZhcyhwb3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9zLngpLFxuICAgICAgICB5OiB0aGlzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvcy55KVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhbnZhcztcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2FudmFzO1xuXG4vKioqLyB9KSxcbi8qIDE4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgTmV0d29ya1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KVsnZGVmYXVsdCddO1xuXG4vKipcbiAqIFRoZSB2aWV3XG4gKi9cblxudmFyIFZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBWaWV3KGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBWaWV3KTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvIHRoaXMucmVuZGVyUmVmcmVzaFJhdGU7XG4gICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9ICdlYXNlSW5PdXRRdWludCc7XG4gICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICB0aGlzLnNvdXJjZVNjYWxlID0gMDtcbiAgICB0aGlzLnRhcmdldFNjYWxlID0gMDtcbiAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcblxuICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2ZpdCcsIHRoaXMuZml0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdhbmltYXRpb25GaW5pc2hlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfc3RvcFJlbmRlcmluZycpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCd1bmxvY2tOb2RlJywgdGhpcy5yZWxlYXNlTm9kZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmlldywgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHpvb21zIG91dCB0byBmaXQgYWxsIGRhdGEgb24gc2NyZWVuIGJhc2VkIG9uIGFtb3VudCBvZiBub2Rlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17e25vZGVzPUFycmF5fX1dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdGlhbFpvb209ZmFsc2VdICB8IHpvb20gYmFzZWQgb24gZml0dGVkIGZvcm11bGEgb3IgcmFuZ2UsIHRydWUgPSBmaXR0ZWQsIGRlZmF1bHQgPSBmYWxzZTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml0KCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgbm9kZXM6IFtdIH07XG4gICAgICB2YXIgaW5pdGlhbFpvb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgcmFuZ2UgPSB2b2lkIDA7XG4gICAgICB2YXIgem9vbUxldmVsID0gdm9pZCAwO1xuICAgICAgb3B0aW9ucyA9ICgwLCBfYXNzaWduMlsnZGVmYXVsdCddKSh7fSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5ub2RlcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9wdGlvbnMubm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbml0aWFsWm9vbSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBjaGVjayBpZiBtb3JlIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24uIElmIHNvLCB3ZSB1c2UgdGhlIHJhbmdlLCBub3QgdGhlIGFwcHJveGltYXRpb24uXG4gICAgICAgIHZhciBwb3NpdGlvbkRlZmluZWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uRGVmaW5lZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb25EZWZpbmVkID4gMC41ICogdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG5cbiAgICAgICAgdmFyIG51bWJlck9mTm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICB6b29tTGV2ZWwgPSAxMi42NjIgLyAobnVtYmVyT2ZOb2RlcyArIDcuNDE0NykgKyAwLjA5NjQ4MjI7IC8vIHRoaXMgaXMgb2J0YWluZWQgZnJvbSBmaXR0aW5nIGEgZGF0YXNldCBmcm9tIDUgcG9pbnRzIHdpdGggc2NhbGUgbGV2ZWxzIHRoYXQgbG9va2VkIGdvb2QuXG5cbiAgICAgICAgLy8gY29ycmVjdCBmb3IgbGFyZ2VyIGNhbnZhc3Nlcy5cbiAgICAgICAgdmFyIGZhY3RvciA9IE1hdGgubWluKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAvIDYwMCwgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDYwMCk7XG4gICAgICAgIHpvb21MZXZlbCAqPSBmYWN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVzaXplTm9kZXMnKTtcbiAgICAgICAgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuXG4gICAgICAgIHZhciB4RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhYIC0gcmFuZ2UubWluWCkgKiAxLjE7XG4gICAgICAgIHZhciB5RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhZIC0gcmFuZ2UubWluWSkgKiAxLjE7XG5cbiAgICAgICAgdmFyIHhab29tTGV2ZWwgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggLyB4RGlzdGFuY2U7XG4gICAgICAgIHZhciB5Wm9vbUxldmVsID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIHlEaXN0YW5jZTtcblxuICAgICAgICB6b29tTGV2ZWwgPSB4Wm9vbUxldmVsIDw9IHlab29tTGV2ZWwgPyB4Wm9vbUxldmVsIDogeVpvb21MZXZlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvb21MZXZlbCA+IDEuMCkge1xuICAgICAgICB6b29tTGV2ZWwgPSAxLjA7XG4gICAgICB9IGVsc2UgaWYgKHpvb21MZXZlbCA9PT0gMCkge1xuICAgICAgICB6b29tTGV2ZWwgPSAxLjA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXIgPSBOZXR3b3JrVXRpbC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge1xuICAgICAgICBwb3NpdGlvbjogY2VudGVyLFxuICAgICAgICBzY2FsZTogem9vbUxldmVsLFxuICAgICAgICBhbmltYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAgICB9O1xuICAgICAgdGhpcy5tb3ZlVG8oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gYW5pbWF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXIgYSBub2RlIGluIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKG5vZGVJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLngsXG4gICAgICAgICAgeTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICBvcHRpb25zLmxvY2tlZE9uTm9kZSA9IG5vZGVJZDtcblxuICAgICAgICB0aGlzLm1vdmVUbyhvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOb2RlOiAnICsgbm9kZUlkICsgJyBjYW5ub3QgYmUgZm91bmQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIG1vdmUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5wb3NpdGlvbiA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gcG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLmFuaW1hdGlvbiA9IHtkdXJhdGlvbjpudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOlN0cmluZ30gfHwgQm9vbGVhbiAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldC55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5vZmZzZXQueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID0gMTAwMDtcbiAgICAgIH0gLy8gZGVmYXVsdCBkdXJhdGlvblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gPSAnZWFzZUluT3V0UXVhZCc7XG4gICAgICB9IC8vIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG5cbiAgICAgIHRoaXMuYW5pbWF0ZVZpZXcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMudGltZSAgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBhbmltYXRlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIGFuaW1hdGUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5lYXNpbmdGdW5jdGlvbiA9IFN0cmluZyAgICAgICAgICAgLy8gbGluZWFyLCBlYXNlSW5RdWFkLCBlYXNlT3V0UXVhZCwgZWFzZUluT3V0UXVhZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgZWFzZUluT3V0Q3ViaWMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJblF1YXJ0LCBlYXNlT3V0UXVhcnQsIGVhc2VJbk91dFF1YXJ0LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWludCwgZWFzZU91dFF1aW50LCBlYXNlSW5PdXRRdWludFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhbmltYXRlVmlldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVWaWV3KG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuICAgICAgLy8gcmVsZWFzZSBpZiBzb21ldGhpbmcgZm9jdXNzZWQgb24gdGhlIG5vZGVcbiAgICAgIHRoaXMucmVsZWFzZU5vZGUoKTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gb3B0aW9ucy5sb2NrZWRPbk5vZGU7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcmNlZnVsbHkgY29tcGxldGUgdGhlIG9sZCBhbmltYXRpb24gaWYgaXQgd2FzIHN0aWxsIHJ1bm5pbmdcbiAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgIT0gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uUmVkcmF3KHRydWUpOyAvLyBieSBzZXR0aW5nIGVhc2luZ3RpbWUgdG8gMSwgd2UgZmluaXNoIHRoZSBhbmltYXRpb24uXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlU2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHRoaXMuc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgICAvLyBzZXQgdGhlIHNjYWxlIHNvIHRoZSB2aWV3Q2VudGVyIGlzIGJhc2VkIG9uIHRoZSBjb3JyZWN0IHpvb20gbGV2ZWwuIFRoaXMgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgdHJhbnNpdGlvblJlZHJhd1xuICAgICAgLy8gYnV0IGF0IGxlYXN0IHRoZW4gd2UnbGwgaGF2ZSB0aGUgdGFyZ2V0IHRyYW5zaXRpb25cbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgIHZhciB2aWV3Q2VudGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gb3B0aW9ucy5wb3NpdGlvbi54LFxuICAgICAgICB5OiB2aWV3Q2VudGVyLnkgLSBvcHRpb25zLnBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC54LFxuICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC55XG5cbiAgICAgICAgLy8gaWYgdGhlIHRpbWUgaXMgc2V0IHRvIDAsIGRvbid0IGRvIGFuIGFuaW1hdGlvblxuICAgICAgfTtpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB0aGlzLl9sb2NrZWRSZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0aGlzLnRhcmdldFRyYW5zbGF0aW9uO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxIC8gKDYwICogb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gKiAwLjAwMSkgfHwgMSAvIDYwOyAvLyA2MCBmb3IgNjAgc2Vjb25kcywgMC4wMDEgZm9yIG1pbGxpJ3NcbiAgICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuXG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5fdHJhbnNpdGlvblJlZHJhdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3N0YXJ0UmVuZGVyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXNlZCB0byBhbmltYXRlIHNtb290aGx5IGJ5IGhpamFja2luZyB0aGUgcmVkcmF3IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19sb2NrZWRSZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9ja2VkUmVkcmF3KCkge1xuICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLngsXG4gICAgICAgIHk6IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxvY2tlZE9uTm9kZUlkXS55XG4gICAgICB9O1xuICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gbm9kZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG5vZGVQb3NpdGlvbi55XG4gICAgICB9O1xuICAgICAgdmFyIHNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB2YXIgdGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQueCxcbiAgICAgICAgeTogc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC55XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRhcmdldFRyYW5zbGF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBzdGF0ZSBvZiBhIGxvY2tlZCBvbiBOb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbGVhc2VOb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZU5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCdpbml0UmVkcmF3JywgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaW5pc2hlZD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdHJhbnNpdGlvblJlZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2l0aW9uUmVkcmF3KCkge1xuICAgICAgdmFyIGZpbmlzaGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgdGhpcy5lYXNpbmdUaW1lICs9IHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG4gICAgICB0aGlzLmVhc2luZ1RpbWUgPSBmaW5pc2hlZCA9PT0gdHJ1ZSA/IDEuMCA6IHRoaXMuZWFzaW5nVGltZTtcblxuICAgICAgdmFyIHByb2dyZXNzID0gdXRpbC5lYXNpbmdGdW5jdGlvbnNbdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbl0odGhpcy5lYXNpbmdUaW1lKTtcblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnNvdXJjZVNjYWxlICsgKHRoaXMudGFyZ2V0U2NhbGUgLSB0aGlzLnNvdXJjZVNjYWxlKSAqIHByb2dyZXNzO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnggLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngpICogcHJvZ3Jlc3MsXG4gICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnkgLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkpICogcHJvZ3Jlc3NcblxuICAgICAgICAvLyBjbGVhbnVwXG4gICAgICB9O2lmICh0aGlzLmVhc2luZ1RpbWUgPj0gMS4wKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB0aGlzLl9sb2NrZWRSZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdhbmltYXRpb25GaW5pc2hlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2NhbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWaWV3UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmlldztcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVmlldztcblxuLyoqKi8gfSksXG4vKiAxODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBOYXZpZ2F0aW9uSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTg0KVsnZGVmYXVsdCddO1xudmFyIFBvcHVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODUpWydkZWZhdWx0J107XG5cbi8qKlxuICogSGFuZGxlciBmb3IgaW50ZXJhY3Rpb25zXG4gKi9cblxudmFyIEludGVyYWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb25IYW5kbGVyfSBzZWxlY3Rpb25IYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcmFjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgSW50ZXJhY3Rpb25IYW5kbGVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gc2VsZWN0aW9uSGFuZGxlcjtcbiAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyID0gbmV3IE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcyk7XG5cbiAgICAvLyBiaW5kIHRoZSBldmVudHMgZnJvbSBoYW1tZXIgdG8gZnVuY3Rpb25zIGluIHRoaXMgb2JqZWN0XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwID0gdGhpcy5vblRhcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoID0gdGhpcy5vblRvdWNoLmJpbmQodGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwID0gdGhpcy5vbkRvdWJsZVRhcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQgPSB0aGlzLm9uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydCA9IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnID0gdGhpcy5vbkRyYWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kID0gdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsID0gdGhpcy5vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaCA9IHRoaXMub25QaW5jaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlID0gdGhpcy5vblJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0ID0gdGhpcy5vbkNvbnRleHQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICB0aGlzLnBpbmNoID0ge307XG4gICAgdGhpcy5wb3B1cCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvcHVwT2JqID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9wdXBUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlci5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNwZWVkOiB7IHg6IDEwLCB5OiAxMCwgem9vbTogMC4wMiB9LFxuICAgICAgICBiaW5kVG9XaW5kb3c6IHRydWVcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uQnV0dG9uczogZmFsc2UsXG4gICAgICB0b29sdGlwRGVsYXk6IDMwMCxcbiAgICAgIHpvb21WaWV3OiB0cnVlLFxuICAgICAgem9vbVNwZWVkOiAxXG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShJbnRlcmFjdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5wb3B1cFRpbWVyKTtcbiAgICAgICAgZGVsZXRlIF90aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXI7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZXh0ZW5kIGFsbCBidXQgdGhlIHZhbHVlcyBpbiBmaWVsZHNcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnaGlkZUVkZ2VzT25EcmFnJywgJ2hpZGVFZGdlc09uWm9vbScsICdoaWRlTm9kZXNPbkRyYWcnLCAna2V5Ym9hcmQnLCAnbXVsdGlzZWxlY3QnLCAnc2VsZWN0YWJsZScsICdzZWxlY3RDb25uZWN0ZWRFZGdlcyddO1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIG1lcmdlIHRoZSBrZXlib2FyZCBvcHRpb25zIGluLlxuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdrZXlib2FyZCcpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMudG9vbHRpcCwgb3B0aW9ucy50b29sdGlwKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9vbHRpcC5jb2xvciA9IHV0aWwucGFyc2VDb2xvcihvcHRpb25zLnRvb2x0aXAuY29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvaW50ZXIgbG9jYXRpb24gZnJvbSBhIHRvdWNoIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB0b3VjaFxuICAgICAqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb2ludGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRlcih0b3VjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdG91Y2gueCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyksXG4gICAgICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT24gc3RhcnQgb2YgYSB0b3VjaCBnZXN0dXJlLCBzdG9yZSB0aGUgcG9pbnRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uVG91Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDUwKSB7XG4gICAgICAgIHRoaXMuZHJhZy5wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGluY2guc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0YXAvY2xpY2sgZXZlbnQ6IHNlbGVjdC91bnNlbGVjdCBhIG5vZGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uVGFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25UYXAoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdCAmJiAoZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLmN0cmxLZXkgfHwgZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLm1ldGFLZXkpO1xuXG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBldmVudCwgbXVsdGlzZWxlY3QpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2NsaWNrJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkb3VibGV0YXAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uRG91YmxlVGFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZG91YmxlQ2xpY2snLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGxvbmcgdGFwIGV2ZW50OiBtdWx0aSBzZWxlY3Qgbm9kZXNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uSG9sZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uSG9sZChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBtdWx0aXNlbGVjdCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zLm11bHRpc2VsZWN0O1xuXG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBldmVudCwgbXVsdGlzZWxlY3QpO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY2xpY2snLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnaG9sZCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgdGhlIHJlbGVhc2Ugb2YgdGhlIHNjcmVlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblJlbGVhc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlbGVhc2UoZXZlbnQpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gMTApIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3JlbGVhc2UnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIC8vIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZXZlbnQgYmVjYXVzZSB3ZSBoYXZlIHR3byBoYW1tZXIgaW5zdGFuY2VzLiAob24gY2FudmFzIGFuZCBvbiBmcmFtZSlcbiAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uQ29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29udGV4dChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ29uY29udGV4dCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYW5kIGRlc2VsZWN0IG5vZGVzIGRlcGVuZGluZyBjdXJyZW50IHNlbGVjdGlvbiBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBGb3IgY2hhbmdpbmcgbm9kZXMsIHNlbGVjdC9kZXNlbGVjdCBldmVudHMgYXJlIGZpcmVkLlxuICAgICAqXG4gICAgICogTk9URTogRm9yIGEgZ2l2ZW4gZWRnZSwgaWYgb25lIGNvbm5lY3Rpbmcgbm9kZSBpcyBkZXNlbGVjdGVkIGFuZCB3aXRoIHRoZSBzYW1lXG4gICAgICogICAgICAgY2xpY2sgdGhlIG90aGVyIG5vZGUgaXMgc2VsZWN0ZWQsIG5vIGV2ZW50cyBmb3IgdGhlIGVkZ2Ugd2lsbCBmaXJlLlxuICAgICAqICAgICAgIEl0IHdhcyBzZWxlY3RlZCBhbmQgaXQgd2lsbCByZW1haW4gc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBUT0RPOiBUaGlzIGlzIGFsbCBTZWxlY3Rpb25IYW5kbGVyIGNhbGxzOyB0aGUgbWV0aG9kIHNob3VsZCBiZSBtb3ZlZCB0byB0aGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWRkPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja1NlbGVjdGlvbkNoYW5nZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlciwgZXZlbnQpIHtcbiAgICAgIHZhciBhZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChhZGQgPT09IHRydWUpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPblBvaW50KHBvaW50ZXIpO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIC8vIFNlZSBOT1RFIGluIG1ldGhvZCBjb21tZW50IGZvciB0aGUgcmVhc29uIHRvIGRvIGl0IGxpa2UgdGhpc1xuICAgICAgdmFyIGRlc2VsZWN0ZWRJdGVtcyA9IHRoaXMuX2RldGVybWluZURpZmZlcmVuY2UocHJldmlvdXNTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgdmFyIHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9kZXRlcm1pbmVEaWZmZXJlbmNlKGN1cnJlbnRTZWxlY3Rpb24sIHByZXZpb3VzU2VsZWN0aW9uKTtcblxuICAgICAgaWYgKGRlc2VsZWN0ZWRJdGVtcy5lZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkZXNlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXNlbGVjdGVkSXRlbXMubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZGVzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtcy5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZEl0ZW1zLmVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlyZSB0aGUgc2VsZWN0IGV2ZW50IGlmIGFueXRoaW5nIGhhcyBiZWVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWRcbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBzZWxlY3Qgb3IgdW5zZWxlY3RcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG5vZGUgYW5kIGVkZ2UgaWQncyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgc2Vjb25kIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX0gZmlyc3RTZXRcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19IHNlY29uZFNldFxuICAgICAqIEByZXR1cm5zIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kZXRlcm1pbmVEaWZmZXJlbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZURpZmZlcmVuY2UoZmlyc3RTZXQsIHNlY29uZFNldCkge1xuICAgICAgdmFyIGFycmF5RGlmZiA9IGZ1bmN0aW9uIGFycmF5RGlmZihmaXJzdEFyciwgc2Vjb25kQXJyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmlyc3RBcnJbaV07XG4gICAgICAgICAgaWYgKHNlY29uZEFyci5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IGFycmF5RGlmZihmaXJzdFNldC5ub2Rlcywgc2Vjb25kU2V0Lm5vZGVzKSxcbiAgICAgICAgZWRnZXM6IGFycmF5RGlmZihmaXJzdFNldC5lZGdlcywgc2Vjb25kU2V0LmVkZ2VzKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBvbkRyYWdTdGFydC5cbiAgICAgKiBJdCBpcyBzZXBhcmF0ZWQgb3V0IGJlY2F1c2Ugd2UgY2FuIHRoZW4gb3ZlcmxvYWQgaXQgZm9yIHRoZSBkYXRhbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgICAgLy9pbiBjYXNlIHRoZSB0b3VjaCBldmVudCB3YXMgdHJpZ2dlcmVkIG9uIGFuIGV4dGVybmFsIGRpdiwgZG8gdGhlIGluaXRpYWwgdG91Y2ggbm93LlxuICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gbm90ZTogZHJhZy5wb2ludGVyIGlzIHNldCBpbiBvblRvdWNoIHRvIGdldCB0aGUgaW5pdGlhbCB0b3VjaCBsb2NhdGlvblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHRoaXMuZHJhZy5wb2ludGVyKTtcblxuICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24gPSBbXTtcbiAgICAgIHRoaXMuZHJhZy50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSBub2RlLmlkO1xuICAgICAgICAvLyBzZWxlY3QgdGhlIGNsaWNrZWQgbm9kZSBpZiBub3QgeWV0IHNlbGVjdGVkXG4gICAgICAgIGlmIChub2RlLmlzU2VsZWN0ZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWZ0ZXIgc2VsZWN0IHRvIGNvbnRhaW4gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlcik7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3Rpb25PYmoubm9kZXM7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSB3aXRoIHRoZSBzZWxlY3RlZCBub2RlcyBhbmQgdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24gYW5kIHN0YXR1c1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gc2VsZWN0aW9uW25vZGVJZF07XG4gICAgICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgICAgaWQ6IG9iamVjdC5pZCxcbiAgICAgICAgICAgICAgbm9kZTogb2JqZWN0LFxuXG4gICAgICAgICAgICAgIC8vIHN0b3JlIG9yaWdpbmFsIHgsIHksIHhGaXhlZCBhbmQgeUZpeGVkLCBtYWtlIHRoZSBub2RlIHRlbXBvcmFyaWx5IEZpeGVkXG4gICAgICAgICAgICAgIHg6IG9iamVjdC54LFxuICAgICAgICAgICAgICB5OiBvYmplY3QueSxcbiAgICAgICAgICAgICAgeEZpeGVkOiBvYmplY3Qub3B0aW9ucy5maXhlZC54LFxuICAgICAgICAgICAgICB5Rml4ZWQ6IG9iamVjdC5vcHRpb25zLmZpeGVkLnlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9iamVjdC5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgb2JqZWN0Lm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24ucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIHRodXMgdGhlIHZpZXcgaXMgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZHJhZyBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZHJhZy5waW5jaGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHRoZSBmb2N1cyBvbiBub2RlIGlmIGl0IGlzIGZvY3Vzc2VkIG9uIGJ5IHRoZSBmb2N1c09uTm9kZVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndW5sb2NrTm9kZScpO1xuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZGVsdGEncyBhbmQgbmV3IGxvY2F0aW9uXG4gICAgICAgIHZhciBkZWx0YVggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICB2YXIgZGVsdGFZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcblxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gICAgICAgIHNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdGlvbi5ub2RlO1xuICAgICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuICAgICAgICAgIGlmIChzZWxlY3Rpb24ueEZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS54ID0gX3RoaXMyLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9YY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi54KSArIGRlbHRhWCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuICAgICAgICAgIGlmIChzZWxlY3Rpb24ueUZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS55ID0gX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9ZY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi55KSArIGRlbHRhWSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzdGFydCB0aGUgc2ltdWxhdGlvbiBvZiB0aGUgcGh5c2ljc1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdGhlIG5ldHdvcmtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMuZHJhZy5wb2ludGVyLng7XG4gICAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcblxuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgICAgeDogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnggKyBkaWZmWCxcbiAgICAgICAgICAgIHk6IHRoaXMuZHJhZy50cmFuc2xhdGlvbi55ICsgZGlmZllcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICB0aGlzLmRyYWcuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmRyYWcuc2VsZWN0aW9uO1xuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIHNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB4Rml4ZWQgYW5kIHlGaXhlZFxuICAgICAgICAgIHMubm9kZS5vcHRpb25zLmZpeGVkLnggPSBzLnhGaXhlZDtcbiAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC55ID0gcy55Rml4ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ0VuZCcsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdFbmQnLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlciksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBpbmNoIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25QaW5jaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGluY2goZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG5cbiAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnBpbmNoWydzY2FsZSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waW5jaC5zY2FsZSA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IGVuYWJsZWQgbW92aW5nIHdoaWxlIHBpbmNoaW5nP1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5waW5jaC5zY2FsZSAqIGV2ZW50LnNjYWxlO1xuICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tIHRoZSBuZXR3b3JrIGluIG9yIG91dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBhIG51bWJlciBhcm91bmQgMSwgYW5kIGJldHdlZW4gMC4wMSBhbmQgMTBcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgUG9zaXRpb24gb24gc2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnem9vbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20oc2NhbGUsIHBvaW50ZXIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIHNjYWxlT2xkID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGlmIChzY2FsZSA8IDAuMDAwMDEpIHtcbiAgICAgICAgICBzY2FsZSA9IDAuMDAwMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxlID4gMTApIHtcbiAgICAgICAgICBzY2FsZSA9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmRyYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmRyYWcuZHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh0aGlzLmRyYWcucG9pbnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vICsgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDJcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG5cbiAgICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHR4LCB5OiB0eSB9O1xuXG4gICAgICAgIGlmIChwcmVTY2FsZURyYWdQb2ludGVyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwb3N0U2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NKHByZVNjYWxlRHJhZ1BvaW50ZXIpO1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnggPSBwb3N0U2NhbGVEcmFnUG9pbnRlci54O1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnkgPSBwb3N0U2NhbGVEcmFnUG9pbnRlci55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcXVlc3RSZWRyYXcnKTtcblxuICAgICAgICBpZiAoc2NhbGVPbGQgPCBzY2FsZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICcrJyxcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd6b29tJywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnLScsXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgICAgICBwb2ludGVyOiBwb2ludGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tIHRoZSB0aW1lbGluZVxuICAgICAqIFNlZSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgICAqICAgICBodHRwczovL2dpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMvaXNzdWVzLzI1NlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZVdoZWVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJldHJpZXZlIGRlbHRhXG4gICAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAgICAgLyogSUUvT3BlcmEuICovXG4gICAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgICAgIC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAgICAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgICAgICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAgICAgICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICAgICAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIHZhciB6b29tID0gZGVsdGEgKiAodGhpcy5vcHRpb25zLnpvb21TcGVlZCAvIDEwKTtcbiAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICB6b29tID0gem9vbSAvICgxIC0gem9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjYWxlICo9IDEgKyB6b29tO1xuXG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb2ludGVyIGxvY2F0aW9uXG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuXG4gICAgICAgICAgLy8gYXBwbHkgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWwuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW91c2UgbW92ZSBoYW5kbGVyIGZvciBjaGVja2luZyB3aGV0aGVyIHRoZSB0aXRsZSBtb3ZlcyBvdmVyIGEgbm9kZSB3aXRoIGEgdGl0bGUuXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZU1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgIHZhciBwb3B1cFZpc2libGUgPSBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZSBpcyBzdGlsbCBzZWxlY3RlZFxuICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cC5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2tIaWRlUG9wdXAocG9pbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcG9wdXAgd2FzIG5vdCBoaWRkZW4gYWJvdmVcbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHBvcHVwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBiaW5kIHRoZSBrZXlib2FyZCB0byB0aGUgZGl2LCB3ZSBoYXZlIHRvIGhpZ2hsaWdodCBpdCB0byB1c2UgaXQuIFRoaXMgaGlnaGxpZ2h0cyBpdCBvbiBtb3VzZSBvdmVyLlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3cgPT09IGZhbHNlICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IGEgdGltZW91dCB0aGF0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIHBvc2l0aW9uZWQgYWJvdmUgYW4gZWxlbWVudFxuICAgICAgaWYgKHBvcHVwVmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBvcHVwVGltZXIpOyAvLyBzdG9wIGFueSBydW5uaW5nIGNhbGN1bGF0aW9uVGltZXJcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuX2NoZWNrU2hvd1BvcHVwKHBvaW50ZXIpO1xuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy50b29sdGlwRGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGluZyBob3ZlciBoaWdobGlnaHRzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5ob3Zlck9iamVjdChldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYW4gZWxlbWVudCBvbiB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIG5ldHdvcmtcbiAgICAgKiAoYSBub2RlIG9yIGVkZ2UpLiBJZiBzbywgYW5kIGlmIHRoaXMgZWxlbWVudCBoYXMgYSB0aXRsZSxcbiAgICAgKiBzaG93IGEgcG9wdXAgd2luZG93IHdpdGggaXRzIHRpdGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jaGVja1Nob3dQb3B1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3dQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCxcbiAgICAgICAgYm90dG9tOiB5XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJldmlvdXNQb3B1cE9iaklkID0gdGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy5wb3B1cE9iai5pZDtcbiAgICAgIHZhciBub2RlVW5kZXJDdXJzb3IgPSBmYWxzZTtcbiAgICAgIHZhciBwb3B1cFR5cGUgPSAnbm9kZSc7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGEgbm9kZSBpcyB1bmRlciB0aGUgY3Vyc29yLlxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZWFyY2ggdGhlIG5vZGVzIGZvciBvdmVybGFwLCBzZWxlY3QgdGhlIHRvcCBvbmUgaW4gY2FzZSBvZiBtdWx0aXBsZSBub2Rlc1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICBub2RlVW5kZXJDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSW5kaWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGUgb25lIHdoaWNoIGlzIGRyYXduIG9uIHRvcCBvZiB0aGUgb3RoZXJzXG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IG5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgLy8gaWYgeW91IGhvdmVyIG92ZXIgYSBub2RlLCB0aGUgdGl0bGUgb2YgdGhlIGVkZ2UgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHNob3duLlxuICAgICAgICAgIG5vZGVVbmRlckN1cnNvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCAmJiBub2RlVW5kZXJDdXJzb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHNlYXJjaCB0aGUgZWRnZXMgZm9yIG92ZXJsYXBcbiAgICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBlZGdlID0gdm9pZCAwO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG4gICAgICAgICAgaWYgKGVkZ2UuaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUluZGljZXNbX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IGVkZ2VzW292ZXJsYXBwaW5nRWRnZXNbb3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgcG9wdXBUeXBlID0gJ2VkZ2UnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2hvdyBwb3B1cCBtZXNzYWdlIHdpbmRvd1xuICAgICAgICBpZiAodGhpcy5wb3B1cE9iai5pZCAhPT0gcHJldmlvdXNQb3B1cE9iaklkKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cCA9IG5ldyBQb3B1cCh0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPSBwb3B1cFR5cGU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkID0gdGhpcy5wb3B1cE9iai5pZDtcblxuICAgICAgICAgIC8vIGFkanVzdCBhIHNtYWxsIG9mZnNldCBzdWNoIHRoYXQgdGhlIG1vdXNlIGN1cnNvciBpcyBsb2NhdGVkIGluIHRoZVxuICAgICAgICAgIC8vIGJvdHRvbSBsZWZ0IGxvY2F0aW9uIG9mIHRoZSBwb3B1cCwgYW5kIHlvdSBjYW4gZWFzaWx5IG1vdmUgb3ZlciB0aGVcbiAgICAgICAgICAvLyBwb3B1cCBhcmVhXG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNldFRleHQodGhpcy5wb3B1cE9iai5nZXRUaXRsZSgpKTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzaG93UG9wdXAnLCB0aGlzLnBvcHVwT2JqLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2hpZGVQb3B1cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBvcHVwIG11c3QgYmUgaGlkZGVuLCB3aGljaCBpcyB0aGUgY2FzZSB3aGVuIHRoZSBtb3VzZSBpcyBub1xuICAgICAqIGxvbmdlciBob3ZlcmluZyBvbiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jaGVja0hpZGVQb3B1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0hpZGVQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgIHZhciBzdGlsbE9uT2JqID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPT09ICdub2RlJykge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBtb3VzZSBpcyBzdGlsbCBvbmUgdGhlIG5vZGUsIHdlIGhhdmUgdG8gY2hlY2sgaWYgaXQgaXMgbm90IGFsc28gb24gb25lIHRoYXQgaXMgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgIC8vIHdlIGluaXRpYWxseSBvbmx5IGNoZWNrIHN0aWxsT25PYmogYmVjYXVzZSB0aGlzIGlzIG11Y2ggZmFzdGVyLlxuICAgICAgICAgIGlmIChzdGlsbE9uT2JqID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgb3Zlck5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuICAgICAgICAgICAgc3RpbGxPbk9iaiA9IG92ZXJOb2RlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG92ZXJOb2RlLmlkID09PSB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWxsT25PYmogPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdoaWRlUG9wdXAnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludGVyYWN0aW9uSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW50ZXJhY3Rpb25IYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xudmFyIGhhbW1lclV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBrZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXG4vKipcbiAqIE5hdmlnYXRpb24gSGFuZGxlclxuICovXG5cbnZhciBOYXZpZ2F0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBOYXZpZ2F0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgdGhpcy5ib3VuZEZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2FjdGl2YXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIF90aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVhY3RpdmF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3RoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShOYXZpZ2F0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciByZWZyZXNoZXMgbmF2aWdhdGlvbiBhbmQgc2V0cyBrZXkgYmluZGluZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uQnV0dG9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xlYW5OYXZpZ2F0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW5OYXZpZ2F0aW9uKCkge1xuICAgICAgLy8gY2xlYW4gaGFtbWVyIGJpbmRpbmdzXG4gICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFuIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25ET00gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBub2Rlcy4gVGhleSBhcmUgZHJhd24gb3ZlciB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgYW5kIGFyZSBub3QgYWZmZWN0ZWQgYnkgc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG4gICAgICogdGhleSBoYXZlIGEgdHJpZ2dlckZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBvbiBjbGljay4gSWYgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIGlzIGRlcGVuZGVudFxuICAgICAqIG9uIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIG9yIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCwgd2UgZmxhZyBob3Jpem9udGFsQWxpZ25MZWZ0IGFuZCB2ZXJ0aWNhbEFsaWduVG9wIGZhbHNlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbG9jYXRpb24gd2lsbCBiZSBjb3JyZWN0ZWQgYnkgdGhlIF9yZWxvY2F0ZU5hdmlnYXRpb24gZnVuY3Rpb24gb24gYSBzaXplIGNoYW5nZSBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG9hZE5hdmlnYXRpb25FbGVtZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcblxuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NID0ge307XG4gICAgICB2YXIgbmF2aWdhdGlvbkRpdnMgPSBbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcsICd6b29tSW4nLCAnem9vbU91dCcsICd6b29tRXh0ZW5kcyddO1xuICAgICAgdmFyIG5hdmlnYXRpb25EaXZBY3Rpb25zID0gWydfbW92ZVVwJywgJ19tb3ZlRG93bicsICdfbW92ZUxlZnQnLCAnX21vdmVSaWdodCcsICdfem9vbUluJywgJ196b29tT3V0JywgJ19maXQnXTtcblxuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLmNsYXNzTmFtZSA9ICd2aXMtbmF2aWdhdGlvbic7XG4gICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF2aWdhdGlvbkRpdnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dLmNsYXNzTmFtZSA9ICd2aXMtYnV0dG9uIHZpcy0nICsgbmF2aWdhdGlvbkRpdnNbaV07XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuXG4gICAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuICAgICAgICBpZiAobmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0gPT09ICdfZml0Jykge1xuICAgICAgICAgIGhhbW1lclV0aWwub25Ub3VjaChoYW1tZXIsIHRoaXMuX2ZpdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW1tZXJVdGlsLm9uVG91Y2goaGFtbWVyLCB0aGlzLmJpbmRUb1JlZHJhdy5iaW5kKHRoaXMsIG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXNlIGEgaGFtbWVyIGZvciB0aGUgcmVsZWFzZSBzbyB3ZSBkbyBub3QgcmVxdWlyZSB0aGUgb25lIHVzZWQgaW4gdGhlIHJlc3Qgb2YgdGhlIG5ldHdvcmtcbiAgICAgIC8vIHRoZSBvbmUgdGhlIHJlc3QgdXNlcyBjYW4gYmUgb3ZlcmxvYWRlZCBieSB0aGUgbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgIHZhciBoYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgaGFtbWVyVXRpbC5vblJlbGVhc2UoaGFtbWVyRnJhbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLl9zdG9wTW92ZW1lbnQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lckZyYW1lKTtcblxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiaW5kVG9SZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVG9SZWRyYXcoYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID0gdGhpc1thY3Rpb25dLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UmVkcmF3JywgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3N0YXJ0UmVuZGVyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VuYmluZEZyb21SZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRGcm9tUmVkcmF3KGFjdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZignaW5pdFJlZHJhdycsIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdG9wUmVuZGVyaW5nJyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdCgpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNzAwKSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB1Z2x5IGhhY2sgdG8gYXZvaWQgaGFtbWVyJ3MgZG91YmxlIGZpcmVpbmcgb2YgZXZlbnQgKGJlY2F1c2Ugd2UgdXNlIHJlbGVhc2U/KVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdmaXQnLCB7IGR1cmF0aW9uOiA3MDAgfSk7XG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc3RvcE1vdmVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BNb3ZlbWVudCgpIHtcbiAgICAgIGZvciAodmFyIGJvdW5kQWN0aW9uIGluIHRoaXMuYm91bmRGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoYm91bmRBY3Rpb24pKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCdpbml0UmVkcmF3JywgdGhpcy5ib3VuZEZ1bmN0aW9uc1tib3VuZEFjdGlvbl0pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdG9wUmVuZGVyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbW92ZVVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVVcCgpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21vdmVEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVEb3duKCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbW92ZUxlZnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUxlZnQoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tb3ZlUmlnaHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVJpZ2h0KCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfem9vbUluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21JbigpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgKiAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0eCwgeTogdHkgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7XG4gICAgICAgIGRpcmVjdGlvbjogJysnLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3pvb21PdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfem9vbU91dCgpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgLyAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0eCwgeTogdHkgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7XG4gICAgICAgIGRpcmVjdGlvbjogJy0nLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmQgYWxsIGtleXMgdXNpbmcga2V5Y2hhcm0uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7IGNvbnRhaW5lcjogd2luZG93LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oe1xuICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLmNhbnZhcy5mcmFtZSxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmtleWNoYXJtLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCd1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoJ19tb3ZlVXAnKTtcbiAgICAgICAgICB9LCAna2V5ZG93bicpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoJ19tb3ZlRG93bicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdsZWZ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX21vdmVMZWZ0Jyk7XG4gICAgICAgICAgfSwgJ2tleWRvd24nKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3JpZ2h0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX21vdmVSaWdodCcpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCc9JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdudW0rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdudW0tJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21PdXQnKTtcbiAgICAgICAgICB9LCAna2V5ZG93bicpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnLScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleWRvd24nKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ1snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KCdfem9vbU91dCcpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCddJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdwYWdldXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KCdfem9vbUluJyk7XG4gICAgICAgICAgfSwgJ2tleWRvd24nKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3BhZ2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21PdXQnKTtcbiAgICAgICAgICB9LCAna2V5ZG93bicpO1xuXG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCd1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfbW92ZVVwJyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ19tb3ZlRG93bicpO1xuICAgICAgICAgIH0sICdrZXl1cCcpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnbGVmdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfbW92ZUxlZnQnKTtcbiAgICAgICAgICB9LCAna2V5dXAnKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3JpZ2h0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ19tb3ZlUmlnaHQnKTtcbiAgICAgICAgICB9LCAna2V5dXAnKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJz0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXl1cCcpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnbnVtKycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfem9vbUluJyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdudW0tJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCctJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdbJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCddJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tSW4nKTtcbiAgICAgICAgICB9LCAna2V5dXAnKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3BhZ2V1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfem9vbUluJyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdwYWdlZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfem9vbU91dCcpO1xuICAgICAgICAgIH0sICdrZXl1cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOYXZpZ2F0aW9uSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTmF2aWdhdGlvbkhhbmRsZXI7XG5cbi8qKiovIH0pLFxuLyogMTg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFBvcHVwIGlzIGEgY2xhc3MgdG8gY3JlYXRlIGEgcG9wdXAgd2luZG93IHdpdGggc29tZSB0ZXh0XG4gKi9cbnZhciBQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgICAgIFRoZSBjb250YWluZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIG92ZXJmbG93TWV0aG9kICBIb3cgdGhlIHBvcHVwIHNob3VsZCBhY3QgdG8gb3ZlcmZsb3dpbmcgKCdmbGlwJyBvciAnY2FwJylcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHVwKGNvbnRhaW5lciwgb3ZlcmZsb3dNZXRob2QpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBQb3B1cCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm92ZXJmbG93TWV0aG9kID0gb3ZlcmZsb3dNZXRob2QgfHwgJ2NhcCc7XG5cbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBmcmFtZVxuICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtdG9vbHRpcCc7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgICBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoUG9wdXAsIFt7XG4gICAga2V5OiAnc2V0UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnggPSBwYXJzZUludCh4KTtcbiAgICAgIHRoaXMueSA9IHBhcnNlSW50KHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCBmb3IgdGhlIHBvcHVwIHdpbmRvdy4gVGhpcyBjYW4gYmUgSFRNTCBjb2RlIG9yIHRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBFbGVtZW50fSBjb250ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0KGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB0aGlzLmZyYW1lLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFtZS5pbm5lckhUTUwgPSBjb250ZW50OyAvLyBzdHJpbmcgY29udGFpbmluZyB0ZXh0IG9yIEhUTUxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb1Nob3ddICAgIFNob3cgb3IgaGlkZSB0aGUgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KGRvU2hvdykge1xuICAgICAgaWYgKGRvU2hvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRvU2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb1Nob3cgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgICAgIHRvcCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3dNZXRob2QgPT0gJ2ZsaXAnKSB7XG4gICAgICAgICAgdmFyIGlzTGVmdCA9IGZhbHNlLFxuICAgICAgICAgICAgICBpc1RvcCA9IHRydWU7IC8vIFdoZXJlIGFyb3VuZCB0aGUgcG9zaXRpb24gaXQncyBsb2NhdGVkXG5cbiAgICAgICAgICBpZiAodGhpcy55IC0gaGVpZ2h0IDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc1RvcCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnggKyB3aWR0aCA+IG1heFdpZHRoIC0gdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc0xlZnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnggLSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNUb3ApIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMueSAtIGhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gdGhpcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLnkgLSBoZWlnaHQ7XG4gICAgICAgICAgaWYgKHRvcCArIGhlaWdodCArIHRoaXMucGFkZGluZyA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gbWF4SGVpZ2h0IC0gaGVpZ2h0IC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9wIDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVmdCA9IHRoaXMueDtcbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoICsgdGhpcy5wYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtYXhXaWR0aCAtIHdpZHRoIC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVmdCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcG9wdXAgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZnJhbWUpOyAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9wdXA7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBvcHVwO1xuXG4vKioqLyB9KSxcbi8qIDE4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpWydkZWZhdWx0J107XG52YXIgRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpWydkZWZhdWx0J107XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLyoqXG4gKiBUaGUgaGFuZGxlciBmb3Igc2VsZWN0aW9uc1xuICovXG5cbnZhciBTZWxlY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gU2VsZWN0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgU2VsZWN0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uT2JqID0geyBub2RlczogW10sIGVkZ2VzOiBbXSB9O1xuICAgIHRoaXMuaG92ZXJPYmogPSB7IG5vZGVzOiB7fSwgZWRnZXM6IHt9IH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZGF0YUNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU2VsZWN0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ211bHRpc2VsZWN0JywgJ2hvdmVyQ29ubmVjdGVkRWRnZXMnLCAnc2VsZWN0YWJsZScsICdzZWxlY3RDb25uZWN0ZWRFZGdlcyddO1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZXMgdGhlIHNlbGVjdGlvbiBwYXJ0IG9mIHRoZSB0YXA7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0T25Qb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgIC8vIHVuc2VsZWN0IGFmdGVyIGdldHRpbmcgdGhlIG9iamVjdHMgaW4gb3JkZXIgdG8gcmVzdG9yZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RBZGRpdGlvbmFsT25Qb2ludChwb2ludGVyKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldE5vZGVBdChwb2ludGVyKSB8fCB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTtcblxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Rpb25DaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhbmRhcmQgZmllbGRzIGZvciBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIE9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2luaXRCYXNlRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcikge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgcHJvcGVydGllc1sncG9pbnRlciddID0ge1xuICAgICAgICBET006IHsgeDogcG9pbnRlci54LCB5OiBwb2ludGVyLnkgfSxcbiAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKVxuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXNbJ2V2ZW50J10gPSBldmVudDtcblxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gZXZlbnQgd2hpY2ggdGhlIHVzZXIgY2FuIGNhdGNoLlxuICAgICAqXG4gICAgICogVGhpcyBhZGRzIHNvbWUgZXh0cmEgZGF0YSB0byB0aGUgZXZlbnQgd2l0aCByZXNwZWN0IHRvIGN1cnNvciBwb3NpdGlvbiBhbmRcbiAgICAgKiBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgICAgICAgICBPYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBvbGRTZWxlY3Rpb24gICAgICAgICAgICAgSWYgcHJlc2VudCwgc2VsZWN0aW9uIHN0YXRlIGJlZm9yZSBldmVudCBvY2N1cmVkXG4gICAgICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gW2VtcHR5U2VsZWN0aW9uPWZhbHNlXSAgSW5kaWNhdGUgaWYgc2VsZWN0aW9uIGRhdGEgc2hvdWxkIGJlIHBhc3NlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2VuZXJhdGVDbGlja0V2ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlQ2xpY2tFdmVudChldmVudFR5cGUsIGV2ZW50LCBwb2ludGVyLCBvbGRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBlbXB0eVNlbGVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5faW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcik7XG5cbiAgICAgIGlmIChlbXB0eVNlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gW107XG4gICAgICAgIHByb3BlcnRpZXMuZWRnZXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gdG1wLm5vZGVzO1xuICAgICAgICBwcm9wZXJ0aWVzLmVkZ2VzID0gdG1wLmVkZ2VzO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllc1sncHJldmlvdXNTZWxlY3Rpb24nXSA9IG9sZFNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PSAnY2xpY2snKSB7XG4gICAgICAgIC8vIEZvciB0aGUgdGltZSBiZWluZywgcmVzdHJpY3QgdGhpcyBmdW5jdGlvbmFsaXR5IHRvXG4gICAgICAgIC8vIGp1c3QgdGhlIGNsaWNrIGV2ZW50LlxuICAgICAgICBwcm9wZXJ0aWVzLml0ZW1zID0gdGhpcy5nZXRDbGlja2VkSXRlbXMocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5jb250cm9sRWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuY29udHJvbEVkZ2UgPSBldmVudC5jb250cm9sRWRnZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChldmVudFR5cGUsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzPXRoaXMub3B0aW9ucy5zZWxlY3RDb25uZWN0ZWRFZGdlc11cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0T2JqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXM7XG5cbiAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0Q29ubmVjdGVkRWRnZXMob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqLnNlbGVjdCgpO1xuICAgICAgICB0aGlzLl9hZGRUb1NlbGVjdGlvbihvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVzZWxlY3RPYmplY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlbGVjdE9iamVjdChvYmopIHtcbiAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkge1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcG9zaXRpb24gb2JqZWN0IGluIGNhbnZhc3NwYWNlIGZyb20gYSBzaW5nbGUgcG9pbnQgaW4gc2NyZWVuc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wb2ludGVyVG9Qb3NpdGlvbk9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKSB7XG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBjYW52YXNQb3MueCAtIDEsXG4gICAgICAgIHRvcDogY2FudmFzUG9zLnkgKyAxLFxuICAgICAgICByaWdodDogY2FudmFzUG9zLnggKyAxLFxuICAgICAgICBib3R0b206IGNhbnZhc1Bvcy55IC0gMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvcCBub2RlIGF0IHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybk5vZGU9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHtOb2RlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE5vZGVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVBdChwb2ludGVyKSB7XG4gICAgICB2YXIgcmV0dXJuTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgLy8gd2UgZmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBuYXZpZ2F0aW9uIGNvbnRyb2xzIGVsZW1lbnRcbiAgICAgIHZhciBwb3NpdGlvbk9iamVjdCA9IHRoaXMuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSB0aGlzLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb3NpdGlvbk9iamVjdCk7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgbm9kZXMsIHNlbGVjdCB0aGUgbGFzdCBvbmUsIHRoaXMgaXMgdGhlXG4gICAgICAvLyBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcbiAgICAgIGlmIChvdmVybGFwcGluZ05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHJldHVybk5vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgZWRnZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3QsIHNlbGVjdG9yIGlzIGFyb3VuZCBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG92ZXJsYXBwaW5nRWRnZXMgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRFZGdlc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBub2RlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybiB7bnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG4gICAgICB0aGlzLl9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpO1xuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlZGdlcyBuZWFyZXN0IHRvIHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybkVkZ2U9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHtFZGdlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEVkZ2VBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VBdChwb2ludGVyKSB7XG4gICAgICB2YXIgcmV0dXJuRWRnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVkZ2VzLCBwaWNrIGNsb3Nlc3Qgd2l0aGluIDEwXG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgbWluZGlzdCA9IDEwO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZSA9IG51bGw7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCkge1xuICAgICAgICAgIHZhciB4RnJvbSA9IGVkZ2UuZnJvbS54O1xuICAgICAgICAgIHZhciB5RnJvbSA9IGVkZ2UuZnJvbS55O1xuICAgICAgICAgIHZhciB4VG8gPSBlZGdlLnRvLng7XG4gICAgICAgICAgdmFyIHlUbyA9IGVkZ2UudG8ueTtcbiAgICAgICAgICB2YXIgZGlzdCA9IGVkZ2UuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgY2FudmFzUG9zLngsIGNhbnZhc1Bvcy55KTtcbiAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZSA9IGVkZ2VJZDtcbiAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocmV0dXJuRWRnZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZWRnZXNbb3ZlcmxhcHBpbmdFZGdlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdFZGdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYWRkVG9TZWxlY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9TZWxlY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tvYmouaWRdID0gb2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgb2JqZWN0IHRvIHRoZSBzZWxlY3Rpb24gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FkZFRvSG92ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9Ib3ZlcihvYmopIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHRoaXMuaG92ZXJPYmoubm9kZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzaW5nbGUgb3B0aW9uIGZyb20gc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZW1vdmVGcm9tU2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21TZWxlY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbb2JqLmlkXTtcbiAgICAgICAgdGhpcy5fdW5zZWxlY3RDb25uZWN0ZWRFZGdlcyhvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW29iai5pZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3QgYWxsLiBUaGUgc2VsZWN0aW9uT2JqIGlzIHVzZWZ1bCBmb3IgdGhpcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5zZWxlY3RBbGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdEFsbCgpIHtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0udW5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbZWRnZUlkXS51bnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uT2JqID0geyBub2Rlczoge30sIGVkZ2VzOiB7fSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRTZWxlY3RlZE5vZGVDb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZE5vZGVDb3VudCgpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRTZWxlY3RlZE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWROb2RlKCkge1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzZWxlY3RlZCBlZGdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRTZWxlY3RlZEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWRFZGdlKCkge1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgZWRnZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFNlbGVjdGVkRWRnZUNvdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkRWRnZUNvdW50KCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0U2VsZWN0ZWRPYmplY3RDb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZE9iamVjdENvdW50KCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbnl0aGluZyBpcyBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NlbGVjdGlvbklzRW1wdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0aW9uSXNFbXB0eSgpIHtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiBvbmUgb2YgdGhlIHNlbGVjdGVkIG5vZGVzIGlzIGEgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbHVzdGVySW5TZWxlY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckluU2VsZWN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0uY2x1c3RlclNpemUgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2VsZWN0Q29ubmVjdGVkRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgZWRnZS5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5fYWRkVG9TZWxlY3Rpb24oZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZWN0IHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2hvdmVyQ29ubmVjdGVkRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaG92ZXJDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICBlZGdlLmhvdmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1bnNlbGVjdCB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191bnNlbGVjdENvbm5lY3RlZEVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Vuc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgZWRnZS51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgaGlnaGxpZ2h0IGZyb20gYSBub2RlIG9yIGVkZ2UsIGluIHJlc3BvbnNlIHRvIG1vdXNlIG1vdmVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7Tm9kZXx2aXMuRWRnZX0gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW1pdEJsdXJFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm5vZGUgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnYmx1ck5vZGUnLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmVkZ2UgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnYmx1ckVkZ2UnLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgaGlnaGxpZ2h0IGZvciBhIG5vZGUgb3IgZWRnZSwgaW4gcmVzcG9uc2UgdG8gbW91c2UgbW92ZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtOb2RlfHZpcy5FZGdlfSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaG92ZXJDaGFuZ2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW1pdEhvdmVyRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0SG92ZXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgdmFyIGhvdmVyQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAob2JqZWN0LmhvdmVyID09PSBmYWxzZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKG9iamVjdCk7XG4gICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5ub2RlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2hvdmVyTm9kZScsIHByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMuZWRnZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdob3ZlckVkZ2UnLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG92ZXJDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWN0aW9ucyBpbiByZXNwb25zZSB0byBhIG1vdXNlIG1vdmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIHwgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdob3Zlck9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyT2JqZWN0KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBob3ZlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbm9kZSBob3ZlciBoaWdobGlnaHRzXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ob3Zlck9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5ob3Zlck9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgb2JqZWN0LmlkICE9IG5vZGVJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZpbmcgYWxsIGVkZ2UgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuaG92ZXJPYmouZWRnZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJPYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBob3ZlciBoYXMgYmVlbiBjaGFuZ2VkIGhlcmUgaXQgbWVhbnMgdGhhdCB0aGUgbm9kZSBoYXMgYmVlbiBob3ZlcmVkIG92ZXIgb3Igb2ZmXG4gICAgICAgICAgLy8gd2UgdGhlbiBkbyBub3QgdXNlIHRoZSBlbWl0Qmx1ckV2ZW50IG1ldGhvZCBoZXJlLlxuICAgICAgICAgIGlmIChob3ZlckNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgdGhlIGJsdXIgcmVtYWlucyB0aGUgc2FtZSBhbmQgdGhlIG9iamVjdCBpcyB1bmRlZmluZWQgKG1vdXNlIG9mZikgb3IgYW5vdGhlclxuICAgICAgICAgIC8vIGVkZ2UgaGFzIGJlZW4gaG92ZXJlZCwgb3IgYW5vdGhlciBub2RlIGhhcyBiZWVuIGhvdmVyZWQgd2UgYmx1ciB0aGUgZWRnZS5cbiAgICAgICAgICBlbHNlIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlICYmIG9iamVjdC5pZCAhPSBlZGdlSWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiAhb2JqZWN0LmhvdmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGhvdmVyZWRFZGdlc0NvdW50ID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKSh0aGlzLmhvdmVyT2JqLmVkZ2VzKS5sZW5ndGg7XG4gICAgICAgIHZhciBob3ZlcmVkTm9kZXNDb3VudCA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkodGhpcy5ob3Zlck9iai5ub2RlcykubGVuZ3RoO1xuICAgICAgICB2YXIgbmV3T25seUhvdmVyZWRFZGdlID0gb2JqZWN0IGluc3RhbmNlb2YgRWRnZSAmJiBob3ZlcmVkRWRnZXNDb3VudCA9PT0gMCAmJiBob3ZlcmVkTm9kZXNDb3VudCA9PT0gMDtcblxuICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkIHx8IG5ld09ubHlIb3ZlcmVkRWRnZSkge1xuICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRoaXMuZW1pdEhvdmVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiB0aGlzLm9wdGlvbnMuaG92ZXJDb25uZWN0ZWRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2hvdmVyQ29ubmVjdGVkRWRnZXMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHt7bm9kZXM6IEFycmF5LjxzdHJpbmc+LCBlZGdlczogQXJyYXkuPHN0cmluZz59fSBzZWxlY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgdmFyIG5vZGVJZHMgPSB0aGlzLmdldFNlbGVjdGVkTm9kZXMoKTtcbiAgICAgIHZhciBlZGdlSWRzID0gdGhpcy5nZXRTZWxlY3RlZEVkZ2VzKCk7XG4gICAgICByZXR1cm4geyBub2Rlczogbm9kZUlkcywgZWRnZXM6IGVkZ2VJZHMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZXNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gc2VsZWN0aW9uICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFNlbGVjdGVkTm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGVzKCkge1xuICAgICAgdmFyIGlkQXJyYXkgPSBbXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWRBcnJheS5wdXNoKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkQXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2VzXG4gICAgICogQHJldHVybiB7QXJyYXl9IHNlbGVjdGlvbiAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTZWxlY3RlZEVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFZGdlcygpIHtcbiAgICAgIHZhciBpZEFycmF5ID0gW107XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGlkQXJyYXkucHVzaCh0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZEFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxzdHJpbmc+LCBlZGdlczogQXJyYXkuPHN0cmluZz59fSBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICBpZCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIXNlbGVjdGlvbi5ub2RlcyAmJiAhc2VsZWN0aW9uLmVkZ2VzKSB0aHJvdyAnU2VsZWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggbm9kZXMgYW5kL29yIGVkZ2VzIHByb3BlcnRpZXMnO1xuICAgICAgLy8gZmlyc3QgdW5zZWxlY3QgYW55IHNlbGVjdGVkIG5vZGUsIGlmIG9wdGlvbiBpcyB0cnVlIG9yIHVuZGVmaW5lZFxuICAgICAgaWYgKG9wdGlvbnMudW5zZWxlY3RBbGwgfHwgb3B0aW9ucy51bnNlbGVjdEFsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24ubm9kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGlvbi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlkID0gc2VsZWN0aW9uLm5vZGVzW2ldO1xuXG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRdO1xuICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vZGUgd2l0aCBpZCBcIicgKyBpZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZG9uJ3Qgc2VsZWN0IGVkZ2VzIHdpdGggaXRcbiAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChub2RlLCBvcHRpb25zLmhpZ2hsaWdodEVkZ2VzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rpb24uZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZCA9IHNlbGVjdGlvbi5lZGdlc1tpXTtcblxuICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2lkXTtcbiAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdFZGdlIHdpdGggaWQgXCInICsgaWQgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVxdWVzdFJlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB6ZXJvIG9yIG1vcmUgbm9kZXMgd2l0aCB0aGUgb3B0aW9uIHRvIGhpZ2hsaWdodCBlZGdlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gc2VsZWN0aW9uICAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3ROb2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE5vZGVzKHNlbGVjdGlvbikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93ICdTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkcyc7XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHsgbm9kZXM6IHNlbGVjdGlvbiB9LCB7IGhpZ2hsaWdodEVkZ2VzOiBoaWdobGlnaHRFZGdlcyB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIGVkZ2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBzZWxlY3Rpb24gICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdEVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0RWRnZXMoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93ICdTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkcyc7XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHsgZWRnZXM6IHNlbGVjdGlvbiB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0aW9uOiByZW1vdmUgaWRzIG9mIG5vZGVzIHdoaWNoIG5vIGxvbmdlciBleGlzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVNlbGVjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIGlmICghdGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB0aGUgdmlzdWFsIGVsZW1lbnRzIGNsaWNrZWQgd2hpY2ggYXJlIG9uIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKlxuICAgICAqIEFsbCBlbGVtZW50cyBhcmUgcmV0dXJuZWQ7IHRoaXMgaW5jbHVkZXMgbm9kZXMsIGVkZ2VzIGFuZCB0aGVpciBsYWJlbHMuXG4gICAgICogVGhlIG9yZGVyIHJldHVybmVkIGlzIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIGkuZS4gZWxlbWVudCAwIG9mIHRoZSByZXR1cm5cbiAgICAgKiB2YWx1ZSBpcyB0aGUgdG9wbW9zdCBpdGVtIGNsaWNrZWQgb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGNvbnNpc3RzIG9mIGFuIGFycmF5IG9mIHRoZSBmb2xsb3dpbmcgcG9zc2libGUgZWxlbWVudHM6XG4gICAgICpcbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlciwgbGFiZWxJZDowfWAgIC0gbGFiZWwgb2Ygbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZTpudW1iZXIsIGxhYmVsSWQ6MH1gICAgIC0gbGFiZWwgb2YgZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKlxuICAgICAqICMjIE5PVEVTXG4gICAgICpcbiAgICAgKiAtIEN1cnJlbnRseSwgdGhlcmUgaXMgb25seSBvbmUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIGEgbm9kZSBvciBhbiBlZGdlLFxuICAgICAqICAgYnV0IHRoaXMgaXMgZXhwZWN0ZWQgdG8gY2hhbmdlIHNvbWV3aGVyZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIC0gU2luY2UgdGhlcmUgaXMgbm8gei1pbmRleGluZyB5ZXQsIGl0IGlzIG5vdCByZWFsbHkgcG9zc2libGUgdG8gc2V0IHRoZSBub2RlcyBhbmRcbiAgICAgKiAgIGVkZ2VzIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBGb3IgdGhlIHRpbWUgYmVpbmcsIG5vZGVzIGNvbWUgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludGVyICBtb3VzZSBwb3NpdGlvbiBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtfGVkZ2VDbGlja0l0ZW18ZWRnZUxhYmVsQ2xpY2tJdGVtPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDbGlja2VkSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGlja2VkSXRlbXMocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgLy8gTm90ZSByZXZlcnNlIG9yZGVyOyB3ZSB3YW50IHRoZSB0b3Btb3N0IGNsaWNrZWQgaXRlbXMgdG8gYmUgZmlyc3QgaW4gdGhlIGFycmF5XG4gICAgICAvLyBBbHNvIG5vdGUgdGhhdCBzZWxlY3RlZCBub2RlcyBhcmUgZGlzcmVnYXJkZWQgaGVyZTsgdGhlc2Ugbm9ybWFsbHkgZGlzcGxheSBvbiB0b3BcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIGZvciAodmFyIGkgPSBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUuZ2V0SXRlbXNPblBvaW50KHBvaW50KTtcbiAgICAgICAgaXRlbXMucHVzaC5hcHBseShpdGVtcywgcmV0KTsgLy8gQXBwZW5kIHRoZSByZXR1cm4gdmFsdWUgdG8gdGhlIHJ1bm5pbmcgbGlzdC5cbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgZm9yICh2YXIgX2kgPSBlZGdlSW5kaWNlcy5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcbiAgICAgICAgdmFyIF9yZXQgPSBlZGdlLmdldEl0ZW1zT25Qb2ludChwb2ludCk7XG4gICAgICAgIGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIF9yZXQpOyAvLyBBcHBlbmQgdGhlIHJldHVybiB2YWx1ZSB0byB0aGUgcnVubmluZyBsaXN0LlxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTZWxlY3Rpb25IYW5kbGVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTZWxlY3Rpb25IYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhlcmUncyBhIG1peC11cCB3aXRoIHRlcm1zIGluIHRoZSBjb2RlLiBGb2xsb3dpbmcgYXJlIHRoZSBmb3JtYWwgZGVmaW5pdGlvbnM6XG4gKlxuICogICB0cmVlICAgLSBhIHN0cmljdCBoaWVyYXJjaGljYWwgbmV0d29yaywgaS5lLiBldmVyeSBub2RlIGhhcyBhdCBtb3N0IG9uZSBwYXJlbnRcbiAqICAgZm9yZXN0IC0gYSBjb2xsZWN0aW9uIG9mIHRyZWVzLiBUaGVzZSBkaXN0aW5jdCB0cmVlcyBhcmUgdGh1cyBub3QgY29ubmVjdGVkLlxuICpcbiAqIFNvOlxuICogLSBpbiBhIG5ldHdvcmsgdGhhdCBpcyBub3QgYSB0cmVlLCB0aGVyZSBleGlzdCBub2RlcyB3aXRoIG11bHRpcGxlIHBhcmVudHMuXG4gKiAtIGEgbmV0d29yayBjb25zaXN0aW5nIG9mIHVuY29ubmVjdGVkIHN1Yi1uZXR3b3Jrcywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lXG4gKiAgIGlzIG5vdCBhIHRyZWUsIGlzIG5vdCBhIGZvcmVzdC5cbiAqXG4gKiBJbiB0aGUgY29kZSwgdGhlIGRlZmluaXRpb25zIGFyZTpcbiAqXG4gKiAgIHRyZWUgICAtIGFueSBkaXNjb25uZWN0ZWQgc3ViLW5ldHdvcmssIHN0cmljdCBoaWVyYXJjaGljYWwgb3Igbm90LlxuICogICBmb3Jlc3QgLSBhIGJ1bmNoIG9mIHRoZXNlIHN1Yi1uZXR3b3Jrc1xuICpcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHJlZSBhbmQgbm90LXRyZWUgaXMgaW1wb3J0YW50IGluIHRoZSBjb2RlLCBub3RhYmx5IHdpdGhpblxuICogdG8gdGhlIGJsb2NrLXNoaWZ0aW5nIGFsZ29yaXRobS4gVGhlIGFsZ29yaXRobSBhc3N1bWVzIGZvcm1hbCB0cmVlcyBhbmQgZmFpbHNcbiAqIGZvciBub3QtdHJlZXMsIG9mdGVuIGluIGEgc3BlY3RhY3VsYXIgbWFubmVyIChzZWFyY2ggZm9yICdleHBsb2RpbmcgbmV0d29yaycgaW4gdGhlIGlzc3VlcykuXG4gKlxuICogSW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggdGhlIGRlZmluaXRpb25zIGluIHRoZSBmb2xsb3dpbmcgY29kZSwgdGhlIGFkamVjdGl2ZSAnZm9ybWFsJyBpc1xuICogdXNlZC4gSWYgJ2Zvcm1hbCcgaXMgYWJzZW50LCB5b3UgbXVzdCBhc3N1bWUgdGhlIG5vbi1mb3JtYWwgZGVmaW5pdGlvbi5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBOT1RFU1xuICogPT09PT1cbiAqXG4gKiBBIGhpZXJhcmNoaWNhbCBsYXlvdXQgaXMgYSBkaWZmZXJlbnQgdGhpbmcgZnJvbSBhIGhpZXJhcmNoaWNhbCBuZXR3b3JrLlxuICogVGhlIGxheW91dCBpcyBhIHdheSB0byBhcnJhbmdlIHRoZSBub2RlcyBpbiB0aGUgdmlldzsgdGhpcyBjYW4gYmUgZG9uZVxuICogb24gbm9uLWhpZXJhcmNoaWNhbCBuZXR3b3JrcyBhcyB3ZWxsLiBUaGUgY29udmVyc2UgaXMgYWxzbyBwb3NzaWJsZS5cbiAqL1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9zbGljZWRUb0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlZFRvQXJyYXkyKTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBUaW1Tb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgTmV0d29ya1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KVsnZGVmYXVsdCddO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4OSksXG4gICAgSG9yaXpvbnRhbFN0cmF0ZWd5ID0gX3JlcXVpcmUuSG9yaXpvbnRhbFN0cmF0ZWd5LFxuICAgIFZlcnRpY2FsU3RyYXRlZ3kgPSBfcmVxdWlyZS5WZXJ0aWNhbFN0cmF0ZWd5O1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgZGVyaXZlZCBkYXRhIG9uIGN1cnJlbnQgbmV0d29yaywgcmVsYXRpbmcgdG8gaGllcmFyY2h5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgSGllcmFyY2hpY2FsU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2hpY2FsU3RhdHVzKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEhpZXJhcmNoaWNhbFN0YXR1cyk7XG5cbiAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlID0ge307IC8vIGNoaWxkIGlkJ3MgcGVyIG5vZGUgaWRcbiAgICB0aGlzLnBhcmVudFJlZmVyZW5jZSA9IHt9OyAvLyBwYXJlbnQgaWQncyBwZXIgbm9kZSBpZFxuICAgIHRoaXMudHJlZXMgPSB7fTsgLy8gdHJlZSBpZCBwZXIgbm9kZSBpZDsgaS5lLiB0byB3aGljaCB0cmVlIGRvZXMgZ2l2ZW4gbm9kZSBpZCBiZWxvbmdcblxuICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcgPSB7fTsgLy8gVGhlIG5vZGVzIHBlciBsZXZlbCwgaW4gdGhlIGRpc3BsYXkgb3JkZXJcbiAgICB0aGlzLmxldmVscyA9IHt9OyAvLyBoaWVyYXJjaHkgbGV2ZWwgcGVyIG5vZGUgaWRcbiAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4ID0ge307IC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGV2ZWwgc29ydGluZyBvcmRlciwgcGVyIG5vZGUgaWQuXG5cbiAgICB0aGlzLmlzVHJlZSA9IGZhbHNlOyAvLyBUcnVlIGlmIGN1cnJlbnQgbmV0d29yayBpcyBhIGZvcm1hbCB0cmVlXG4gICAgdGhpcy50cmVlSW5kZXggPSAtMTsgLy8gSGlnaGVzdCB0cmVlIGlkIGluIGN1cnJlbnQgbmV0d29yay5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHJlbGF0aW9uIGJldHdlZW4gZ2l2ZW4gbm9kZXMgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50Tm9kZUlkXG4gICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGROb2RlSWRcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShIaWVyYXJjaGljYWxTdGF0dXMsIFt7XG4gICAga2V5OiAnYWRkUmVsYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGlvbihwYXJlbnROb2RlSWQsIGNoaWxkTm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0ucHVzaChjaGlsZE5vZGVJZCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXS5wdXNoKHBhcmVudE5vZGVJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgZm9yIGEgZm9ybWFsIHRyZWUgb3IgZm9ybWFsIGZvcmVzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGNhc2UgaWYgZXZlcnkgbm9kZSBoYXMgYXQgbW9zdCBvbmUgcGFyZW50LlxuICAgICAqXG4gICAgICogUHJlOiBwYXJlbnRSZWZlcmVuY2UgaW5pdCdlZCBwcm9wZXJseSBmb3IgY3VycmVudCBuZXR3b3JrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrSWZUcmVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tJZlRyZWUoKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMucGFyZW50UmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFJlZmVyZW5jZVtpXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5pc1RyZWUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1RyZWUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNlcGFyYXRlIHRyZWVzIGluIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbnVtVHJlZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1UcmVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyZWVJbmRleCArIDE7IC8vIFRoaXMgYXNzdW1lcyB0aGUgaW5kZXhlcyBhcmUgYXNzaWduZWQgY29uc2VjaXRpdmVseVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBhIHRyZWUgaWQgdG8gYSBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB0cmVlSWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VHJlZUluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJlZUluZGV4KG5vZGUsIHRyZWVJZCkge1xuICAgICAgaWYgKHRyZWVJZCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIERvbid0IGJvdGhlclxuXG4gICAgICBpZiAodGhpcy50cmVlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudHJlZXNbbm9kZS5pZF0gPSB0cmVlSWQ7XG4gICAgICAgIHRoaXMudHJlZUluZGV4ID0gTWF0aC5tYXgodHJlZUlkLCB0aGlzLnRyZWVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIGxldmVsIGZvciBnaXZlbiBpZCBpcyBkZWZpbmVkLlxuICAgICAqXG4gICAgICogU2V0cyBsZXZlbCB0byB6ZXJvIGZvciBnaXZlbiBub2RlIGlkIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Vuc3VyZUxldmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlTGV2ZWwobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGV2ZWxzW25vZGVJZF0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbWF4aW11bSBsZXZlbCBvZiBhIGJyYW5jaC5cbiAgICAgKlxuICAgICAqIFRPRE86IE5ldmVyIGVudGVyZWQ7IGZpbmQgYSB0ZXN0IGNhc2UgdG8gdGVzdCB0aGlzIVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TWF4TGV2ZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhMZXZlbChub2RlSWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBhY2N1bXVsYXRvciA9IHt9O1xuXG4gICAgICB2YXIgX2dldE1heExldmVsID0gZnVuY3Rpb24gX2dldE1heExldmVsKG5vZGVJZCkge1xuICAgICAgICBpZiAoYWNjdW11bGF0b3Jbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yW25vZGVJZF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsID0gX3RoaXMubGV2ZWxzW25vZGVJZF07XG4gICAgICAgIGlmIChfdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMuY2hpbGRyZW5SZWZlcmVuY2Vbbm9kZUlkXTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXZlbCA9IE1hdGgubWF4KGxldmVsLCBfZ2V0TWF4TGV2ZWwoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWNjdW11bGF0b3Jbbm9kZUlkXSA9IGxldmVsO1xuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX2dldE1heExldmVsKG5vZGVJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVBXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlQlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsZXZlbERvd25zdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUIuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVBLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUEuaWRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbGV2ZWxcbiAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUIuaWRdID0gdGhpcy5sZXZlbHNbbm9kZUEuaWRdICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbWFsbCB1dGlsIG1ldGhvZCB0byBzZXQgdGhlIG1pbmltdW0gbGV2ZWxzIG9mIHRoZSBub2RlcyB0byB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE1pbkxldmVsVG9aZXJvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWluTGV2ZWxUb1plcm8obm9kZXMpIHtcbiAgICAgIHZhciBtaW5MZXZlbCA9IDFlOTtcbiAgICAgIC8vIGdldCB0aGUgbWluaW11bSBsZXZlbFxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWluTGV2ZWwgPSBNYXRoLm1pbih0aGlzLmxldmVsc1tub2RlSWRdLCBtaW5MZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHN1YnRyYWN0IHRoZSBtaW5pbXVtIGZyb20gdGhlIHNldCBzbyB3ZSBoYXZlIGEgcmFuZ2Ugc3RhcnRpbmcgZnJvbSAwXG4gICAgICBmb3IgKHZhciBfbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmxldmVsc1tfbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsc1tfbm9kZUlkXSAtPSBtaW5MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbiBhbmQgbWF4IHh5LWNvb3JkaW5hdGVzIG9mIGEgZ2l2ZW4gdHJlZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge3ttaW5feDogbnVtYmVyLCBtYXhfeDogbnVtYmVyLCBtaW5feTogbnVtYmVyLCBtYXhfeTogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHJlZVNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShub2RlcywgaW5kZXgpIHtcbiAgICAgIHZhciBtaW5feCA9IDFlOTtcbiAgICAgIHZhciBtYXhfeCA9IC0xZTk7XG4gICAgICB2YXIgbWluX3kgPSAxZTk7XG4gICAgICB2YXIgbWF4X3kgPSAtMWU5O1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy50cmVlcykge1xuICAgICAgICBpZiAodGhpcy50cmVlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4obm9kZS54LCBtaW5feCk7XG4gICAgICAgICAgICBtYXhfeCA9IE1hdGgubWF4KG5vZGUueCwgbWF4X3gpO1xuICAgICAgICAgICAgbWluX3kgPSBNYXRoLm1pbihub2RlLnksIG1pbl95KTtcbiAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgobm9kZS55LCBtYXhfeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbl94OiBtaW5feCxcbiAgICAgICAgbWF4X3g6IG1heF94LFxuICAgICAgICBtaW5feTogbWluX3ksXG4gICAgICAgIG1heF95OiBtYXhfeVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gbm9kZXMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHdvIG5vZGVzIGhhdmUgYSBzYW1lIGFuY2VzdG9yIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNTYW1lUGFyZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU2FtZVBhcmVudChub2RlMSwgbm9kZTIpIHtcbiAgICAgIHZhciBwYXJlbnRzMSA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUxLmlkXTtcbiAgICAgIHZhciBwYXJlbnRzMiA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUyLmlkXTtcbiAgICAgIGlmIChwYXJlbnRzMSA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudHMyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50czIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGFyZW50czFbaV0gPT0gcGFyZW50czJbal0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgaW4gdGhlIHNhbWUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGlzIHNvLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5TYW1lU3ViTmV0d29yaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluU2FtZVN1Yk5ldHdvcmsobm9kZTEsIG5vZGUyKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmVlc1tub2RlMS5pZF0gPT09IHRoaXMudHJlZXNbbm9kZTIuaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdGhlIGRpc3RpbmN0IGxldmVscyBpbiB0aGUgY3VycmVudCBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldExldmVscycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExldmVscygpIHtcbiAgICAgIHJldHVybiAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vZGUgdG8gdGhlIG9yZGVyaW5nIHBlciBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFRvT3JkZXJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb09yZGVyaW5nKG5vZGUsIGxldmVsKSB7XG4gICAgICBpZiAodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNQcmVzZW50ID0gZmFsc2U7XG4gICAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgIGZvciAodmFyIG4gaW4gY3VyTGV2ZWwpIHtcbiAgICAgICAgLy9pZiAoY3VyTGV2ZWxbbl0uaWQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgaWYgKGN1ckxldmVsW25dID09PSBub2RlKSB7XG4gICAgICAgICAgaXNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUHJlc2VudCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFN0YXR1cztcbn0oKTtcblxuLyoqXG4gKiBUaGUgTGF5b3V0IEVuZ2luZVxuICovXG5cblxudmFyIExheW91dEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBMYXlvdXRFbmdpbmUoYm9keSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIExheW91dEVuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgdGhpcy5pbml0aWFsUmFuZG9tU2VlZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xuICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgdGhpcy5zZXRQaHlzaWNzID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5vcHRpb25zQmFja3VwID0geyBwaHlzaWNzOiB7fSB9O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHJhbmRvbVNlZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsZXZlbFNlcGFyYXRpb246IDE1MCxcbiAgICAgICAgbm9kZVNwYWNpbmc6IDEwMCxcbiAgICAgICAgdHJlZVNwYWNpbmc6IDIwMCxcbiAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogJ1VEJywgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgc29ydE1ldGhvZDogJ2h1YnNpemUnIC8vIGh1YnNpemUsIGRpcmVjdGVkXG4gICAgICB9XG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTGF5b3V0RW5naW5lLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2RhdGFDaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhTG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubGF5b3V0TmV0d29yaygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzdGF0aWMgc21vb3RoIGN1cnZlIGluIGNhc2UgaXQgaXMgcmVxdWlyZWRcbiAgICAgICAgdmFyIHR5cGUgPSBfdGhpczIuZGlyZWN0aW9uLmN1cnZlVHlwZSgpO1xuXG4gICAgICAgIC8vIGZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoJ19mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzJywgdHlwZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaGllcmFyY2hpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbDtcbiAgICAgICAgdmFyIHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9IGhpZXJhcmNoaWNhbC5lbmFibGVkO1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoWydyYW5kb21TZWVkJywgJ2ltcHJvdmVkTGF5b3V0J10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ2hpZXJhcmNoaWNhbCcpO1xuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21TZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxSYW5kb21TZWVkID0gb3B0aW9ucy5yYW5kb21TZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgb3ZlcnJpZGRlbiBvcHRpb25zIGZvciBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZWZyZXNoJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsZXZlbCBzZXBhcmF0aW9uIGlzIHRoZSByaWdodCB3YXkgdXBcbiAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1JMJyB8fCBoaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb25TdHJhdGVneSgpO1xuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0Jyk7XG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBuZWVkcyBpdCdzIG93biBwaHlzaWNzIGFuZCBzbW9vdGggY3VydmUgc2V0dGluZ3MsXG4gICAgICAgICAgLy8gd2UgYWRhcHQgdGhlIG90aGVyIG9wdGlvbnMgaWYgbmVlZGVkLlxuICAgICAgICAgIHJldHVybiB0aGlzLmFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkhpZXJhcmNoaWNhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JlZnJlc2gnKTtcbiAgICAgICAgICAgIHJldHVybiB1dGlsLmRlZXBFeHRlbmQoYWxsT3B0aW9ucywgdGhpcy5vcHRpb25zQmFja3VwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQoYWxsT3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgYmFja3VwUGh5c2ljcyA9IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzO1xuXG4gICAgICAgIC8vIHNldCB0aGUgcGh5c2ljc1xuICAgICAgICBpZiAoYWxsT3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQgfHwgYWxsT3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkLFxuICAgICAgICAgICAgc29sdmVyOiAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkO1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3Muc29sdmVyID0gYmFja3VwUGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKGFsbE9wdGlvbnMucGh5c2ljcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzLnNvbHZlciA9ICdoaWVyYXJjaGljYWxSZXB1bHNpb24nO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMucGh5c2ljcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9ICdiYXJuZXNIdXQnO1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHsgc29sdmVyOiAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHN0YXRpYyBzbW9vdGggY3VydmUgaW4gY2FzZSBpdCBpcyByZXF1aXJlZFxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZGlyZWN0aW9uLmN1cnZlVHlwZSgpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgc21vb3RoIGN1cnZlcyBpZiBub3RoaW5nIGlzIGRlZmluZWQuIElmIHNtb290aCBjdXJ2ZXMgaGF2ZSBiZWVuIHR1cm5lZCBvbixcbiAgICAgICAgLy8gdHVybiB0aGVtIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG4gICAgICAgIGlmIChhbGxPcHRpb25zLmVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICBzbW9vdGg6IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogJ2R5bmFtaWMnIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMgPSB7IHNtb290aDogZmFsc2UgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6ICdkeW5hbWljJyB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0geyBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoIH07XG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBhbGxPcHRpb25zLmVkZ2VzLnNtb290aDtcblxuICAgICAgICAgICAgLy8gYWxsb3cgY3VzdG9tIHR5cGVzIGV4Y2VwdCBmb3IgZHluYW1pY1xuICAgICAgICAgICAgaWYgKHNtb290aC50eXBlICE9PSB1bmRlZmluZWQgJiYgc21vb3RoLnR5cGUgIT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICB0eXBlID0gc21vb3RoLnR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgb3B0aW9ucyBtZXJnaW5nOyBzZWUgaWYgdGhlIHN0YW5kYXJkIHJvdXRpbmVzIGNhbiBiZSB1c2VkIGhlcmUuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICAgIHNtb290aDogc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgdHlwZTogc21vb3RoLnR5cGUgPT09IHVuZGVmaW5lZCA/ICdkeW5hbWljJyA6IHNtb290aC50eXBlLFxuICAgICAgICAgICAgICByb3VuZG5lc3M6IHNtb290aC5yb3VuZG5lc3MgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHNtb290aC5yb3VuZG5lc3MsXG4gICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBzbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc21vb3RoLmZvcmNlRGlyZWN0aW9uXG5cbiAgICAgICAgICAgICAgLy8gTk9URTogQ29weWluZyBhbiBvYmplY3QgdG8gc2VsZjsgdGhpcyBpcyBiYXNpY2FsbHkgc2V0dGluZyBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgICAgICAgfTthbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcm91bmRuZXNzOiBzbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBzbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICBmb3JjZURpcmVjdGlvbjogc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3JjZSBhbGwgZWRnZXMgaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cbiAgICAgICAgLy8gT25seSBhcHBsaWVzIHRvIGVkZ2VzIHRoYXQgZG8gbm90IHVzZSB0aGUgZ2xvYmFsIG9wdGlvbnMgZm9yIHNtb290aC5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXMnLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWVkZWRSYW5kb20nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVkZWRSYW5kb20oKSB7XG4gICAgICB2YXIgeCA9IE1hdGguc2luKHRoaXMucmFuZG9tU2VlZCsrKSAqIDEwMDAwO1xuICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzQXJyYXlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb25Jbml0aWFsbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbkluaXRpYWxseShub2Rlc0FycmF5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgICAgIHZhciByYWRpdXMgPSBub2Rlc0FycmF5Lmxlbmd0aCArIDUwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG4gICAgICAgICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgKiB0aGlzLnNlZWRlZFJhbmRvbSgpO1xuICAgICAgICAgIGlmIChub2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgS2FtYWRhIEthd2FpIHRvIHBvc2l0aW9uIG5vZGVzLiBUaGlzIGlzIHF1aXRlIGEgaGVhdnkgYWxnb3JpdGhtIHNvIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBub2RlcyB3ZVxuICAgICAqIGNsdXN0ZXIgdGhlbSBmaXJzdCB0byByZWR1Y2UgdGhlIGFtb3VudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGF5b3V0TmV0d29yaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dE5ldHdvcmsoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlICYmIHRoaXMub3B0aW9ucy5pbXByb3ZlZExheW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcblxuICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiB3ZSBzaG91bGQgS2FtYWRhIEthd2FpIHRvIGxheW91dC4gVGhlIHRocmVzaG9sZCBpcyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgdmlzaWJsZVxuICAgICAgICAvLyBub2RlcyBoYXZlIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHVzZSB0aGlzLlxuICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24gd2UgY29udGludWVcbiAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA8IDAuNSAqIGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIE1BWF9MRVZFTFMgPSAxMDtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgICAgIHZhciBjbHVzdGVyVGhyZXNob2xkID0gMTUwOyAvLyBUT0RPIGFkZCB0aGlzIHRvIG9wdGlvbnNcblxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gRGVmaW5lIHRoZSBvcHRpb25zIGZvciB0aGUgaGlkZGVuIGNsdXN0ZXIgbm9kZXNcbiAgICAgICAgICAvLyBUaGVzZSBvcHRpb25zIGRvbid0IHByb3BhZ2F0ZSBvdXRzaWRlIHRoZSBjbHVzdGVyaW5nIHBoYXNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gU29tZSBvcHRpb25zIGFyZSBleHBsaWNpdGx5IGRpc2FibGVkLCBiZWNhdXNlIHRoZXkgbWF5IGJlIHNldCBpbiBncm91cCBvciBkZWZhdWx0IG5vZGUgb3B0aW9ucy5cbiAgICAgICAgICAvLyBUaGUgY2x1c3RlcnMgYXJlIG5ldmVyIGRpc3BsYXllZCwgc28gbW9zdCBleHBsaWNpdCBzZXR0aW5ncyBoZXJlIHNlcnZlIGFzIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgZXhwbGljaXQgc2V0dGluZyBvZiAnc2hhcGUnIGlzIHRvIGF2b2lkIGBzaGFwZTogJ2ltYWdlJ2A7IGltYWdlcyBhcmUgbm90IHBhc3NlZCB0byB0aGUgaGlkZGVuXG4gICAgICAgICAgLy8gY2x1c3RlciBub2RlcywgbGVhZGluZyB0byBhbiBleGNlcHRpb24gb24gY3JlYXRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBBbGwgc2V0dGluZ3MgaGVyZSBhcmUgcGVyZm9ybWFuY2UgcmVsYXRlZCwgZXhjZXB0IHdoZW4gbm90ZWQgb3RoZXJ3aXNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgdmFyIGNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiAnZWxsaXBzZScsIC8vIEJ1Z2ZpeDogYXZvaWQgdHlwZSAnaW1hZ2UnLCBubyBpbWFnZXMgc3VwcGxpZWRcbiAgICAgICAgICAgICAgbGFiZWw6ICcnLCAvLyBhdm9pZCBsYWJlbCBoYW5kbGluZ1xuICAgICAgICAgICAgICBncm91cDogJycsIC8vIGF2b2lkIGdyb3VwIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGZvbnQ6IHsgbXVsdGk6IGZhbHNlIC8vIGF2b2lkIGZvbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGxhYmVsOiAnJywgLy8gYXZvaWQgbGFiZWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZm9udDogeyBtdWx0aTogZmFsc2UgfSwgLy8gYXZvaWQgZm9udCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSAvLyBhdm9pZCBkcmF3aW5nIHBlbmFsdHkgZm9yIGNvbXBsZXggZWRnZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMsIHdlIGNsdXN0ZXIgYmVmb3JlIHdlIHJ1biB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBwYXJ0IGZhaWxzIHRvIGZpbmQgY2x1c3RlcnMgZm9yIGxhcmdlIHNjYWxlLWZyZWUgbmV0d29ya3MsIHdoaWNoIHNob3VsZFxuICAgICAgICAgICAgLy8gICAgICAgYmUgZWFzaWx5IGNsdXN0ZXJhYmxlLlxuICAgICAgICAgICAgLy8gVE9ETzogZXhhbWluZSB3aHkgdGhpcyBpcyBzb1xuICAgICAgICAgIH07aWYgKGluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0TGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkICYmIGxldmVsIDw9IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLnRpbWUoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1hbnkgbm9kZXMgd2UgZG8gYSBodWJzaXplIGNsdXN0ZXJcbiAgICAgICAgICAgICAgaWYgKGxldmVsICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3RlckJyaWRnZXMoY2x1c3Rlck9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzKGNsdXN0ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBhZnRlciAmJiBsZXZlbCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfbGF5b3V0RmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdUaGlzIG5ldHdvcmsgY291bGQgbm90IGJlIHBvc2l0aW9uZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBpbXByb3ZlZCBsYXlvdXQgYWxnb3JpdGhtLicgKyAnIFBsZWFzZSBkaXNhYmxlIGltcHJvdmVkTGF5b3V0IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vY29uc29sZS50aW1lRW5kKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGJlZm9yZSxsZXZlbCxhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgZWRnZXNcbiAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICBzcHJpbmdMZW5ndGg6IE1hdGgubWF4KDE1MCwgMiAqIHN0YXJ0TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA+IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoZSBjbHVzdGVyaW5nIGRpZG4ndCBzdWNjZWVkIHdpdGhpbiB0aGUgYW1vdW50IG9mIGludGVyYXRpb25zIGFsbG93ZWQsXCIgKyAnIHByb2dyZXNzaW5nIHdpdGggcGFydGlhbCByZXN1bHQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5c3RlbSBmb3IgdGhlc2Ugbm9kZXMgYW5kIGVkZ2VzXG4gICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc29sdmUoaW5kaWNlcywgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLCB0cnVlKTtcblxuICAgICAgICAgIC8vIHNoaWZ0IHRvIGNlbnRlciBwb2ludFxuICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTtcblxuICAgICAgICAgIC8vIHBlcnR1cmIgdGhlIG5vZGVzIGEgbGl0dGxlIGJpdCB0byBmb3JjZSB0aGUgcGh5c2ljcyB0byBraWNrIGluXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDcwO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgLy8gT25seSBwZXJ0dXJiIHRoZSBub2RlcyB0aGF0IGFyZW4ndCBmaXhlZFxuICAgICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2luZGljZXNbX2ldXTtcbiAgICAgICAgICAgIGlmIChfbm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIF9ub2RlLnggKz0gKDAuNSAtIHRoaXMuc2VlZGVkUmFuZG9tKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgICBfbm9kZS55ICs9ICgwLjUgLSB0aGlzLnNlZWRlZFJhbmRvbSgpKSAqIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1bmNsdXN0ZXIgYWxsIGNsdXN0ZXJzXG4gICAgICAgICAgdGhpcy5fZGVjbHVzdGVyQWxsKCk7XG5cbiAgICAgICAgICAvLyByZXBvc2l0aW9uIGFsbCBiZXppZXIgbm9kZXMuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcG9zaXRpb25CZXppZXJOb2RlcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhbGwgdGhlIG5vZGVzIHRvd2FyZHMgdG8gdGhlIGNlbnRlciBzbyBncmF2aXRhdGlvbmFsIHB1bGwgd2lsIG5vdCBtb3ZlIHRoZSBub2RlcyBhd2F5IGZyb20gdmlld1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zaGlmdFRvQ2VudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0VG9DZW50ZXIoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZUNvcmUodGhpcy5ib2R5Lm5vZGVzLCB0aGlzLmJvZHkubm9kZUluZGljZXMpO1xuICAgICAgdmFyIGNlbnRlciA9IE5ldHdvcmtVdGlsLmZpbmRDZW50ZXIocmFuZ2UpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgbm9kZS54IC09IGNlbnRlci54O1xuICAgICAgICBub2RlLnkgLT0gY2VudGVyLnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgY2x1c3RlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGVjbHVzdGVyQWxsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY2x1c3RlckFsbCgpIHtcbiAgICAgIHZhciBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgd2hpbGUgKGNsdXN0ZXJzUHJlc2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlcih0aGlzLmJvZHkubm9kZUluZGljZXNbaV0sIHt9LCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcnwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTZWVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gbGF5b3V0IHRoZSBub2RlcyBpbiBhIGhpZXJhcmNoaWNhbCB3YXkuXG4gICAgICogSXQgY2hlY2tzIGlmIHRoZSBub2RlIGRldGFpbHMgYXJlIHN1cHBsaWVkIGNvcnJlY3RseVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEhpZXJhcmNoaWNhbExheW91dCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IGh1YnMgYW5kIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyBkZWZpbmVkIGEgbGV2ZWwgZm9yIGEgbm9kZS5cbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICBub2RlSWQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBkZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVuZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsID0ge307XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsID0gbmV3IEhpZXJhcmNoaWNhbFN0YXR1cygpO1xuXG4gICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5sZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRlZmluZWRMZXZlbCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdID0gbm9kZS5vcHRpb25zLmxldmVsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5kZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGRlZmluZWQgc29tZSBsZXZlbHMgYnV0IG5vdCBhbGwsIGFsZXJ0IGFuZCBydW4gd2l0aG91dCBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSAmJiBkZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSB0aGUgaGllcmFyY2hpY2FsIGxheW91dCwgbm9kZXMgcmVxdWlyZSBlaXRoZXIgbm8gcHJlZGVmaW5lZCBsZXZlbHMnICsgJyBvciBsZXZlbHMgaGF2ZSB0byBiZSBkZWZpbmVkIGZvciBhbGwgbm9kZXMuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmaW5lIGxldmVscyBpZiB1bmRlZmluZWQgYnkgdGhlIHVzZXJzLiBCYXNlZCBvbiBodWJzaXplLlxuICAgICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHNvcnRNZXRob2QgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2Q7XG4gICAgICAgICAgICBpZiAoc29ydE1ldGhvZCA9PT0gJ2h1YnNpemUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3J0TWV0aG9kID09PSAnZGlyZWN0ZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRNZXRob2QgPT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmFsbGJhY2sgZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBub2RlcyBidXQgbm8gZWRnZXNcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmVuc3VyZUxldmVsKF9ub2RlSWQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgbm9kZXMgcGVyIGxldmVsLlxuICAgICAgICAgIHZhciBkaXN0cmlidXRpb24gPSB0aGlzLl9nZXREaXN0cmlidXRpb24oKTtcblxuICAgICAgICAgIC8vIGdldCB0aGUgcGFyZW50IGNoaWxkcmVuIHJlbGF0aW9ucy5cbiAgICAgICAgICB0aGlzLl9nZW5lcmF0ZU1hcCgpO1xuXG4gICAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uIHRoZSBjYW52YXMuXG4gICAgICAgICAgdGhpcy5fcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbik7XG5cbiAgICAgICAgICAvLyBjb25kZW5zZSB0aGUgd2hpdGVzcGFjZS5cbiAgICAgICAgICB0aGlzLl9jb25kZW5zZUhpZXJhcmNoeSgpO1xuXG4gICAgICAgICAgLy8gc2hpZnQgdG8gY2VudGVyIHNvIGdyYXZpdHkgZG9lcyBub3QgaGF2ZSB0byBkbyBtdWNoXG4gICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NvbmRlbnNlSGllcmFyY2h5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbmRlbnNlSGllcmFyY2h5KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIEdsb2JhbCB2YXIgaW4gdGhpcyBzY29wZSB0byBkZWZpbmUgd2hlbiB0aGUgbW92ZW1lbnQgaGFzIHN0b3BwZWQuXG4gICAgICB2YXIgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGJyYW5jaGVzID0ge307XG4gICAgICAvLyBmaXJzdCB3ZSBoYXZlIHNvbWUgbWV0aG9kcyB0byBoZWxwIHNoaWZ0aW5nIHRyZWVzIGFyb3VuZC5cbiAgICAgIC8vIHRoZSBtYWluIG1ldGhvZCB0byBzaGlmdCB0aGUgdHJlZXNcbiAgICAgIHZhciBzaGlmdFRyZWVzID0gZnVuY3Rpb24gc2hpZnRUcmVlcygpIHtcbiAgICAgICAgdmFyIHRyZWVTaXplcyA9IGdldFRyZWVTaXplcygpO1xuICAgICAgICB2YXIgc2hpZnRCeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZVNpemVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBkaWZmID0gdHJlZVNpemVzW2ldLm1heCAtIHRyZWVTaXplc1tpICsgMV0ubWluO1xuICAgICAgICAgIHNoaWZ0QnkgKz0gZGlmZiArIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC50cmVlU3BhY2luZztcbiAgICAgICAgICBzaGlmdFRyZWUoaSArIDEsIHNoaWZ0QnkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBzaGlmdCBhIHNpbmdsZSB0cmVlIGJ5IGFuIG9mZnNldFxuICAgICAgdmFyIHNoaWZ0VHJlZSA9IGZ1bmN0aW9uIHNoaWZ0VHJlZShpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB0cmVlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwudHJlZXM7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRyZWVzKSB7XG4gICAgICAgICAgaWYgKHRyZWVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlc1tub2RlSWRdID09PSBpbmRleCkge1xuICAgICAgICAgICAgICBfdGhpczMuZGlyZWN0aW9uLnNoaWZ0KG5vZGVJZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGdldCB0aGUgd2lkdGggb2YgYWxsIHRyZWVzXG4gICAgICB2YXIgZ2V0VHJlZVNpemVzID0gZnVuY3Rpb24gZ2V0VHJlZVNpemVzKCkge1xuICAgICAgICB2YXIgdHJlZVdpZHRocyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMy5oaWVyYXJjaGljYWwubnVtVHJlZXMoKTsgaSsrKSB7XG4gICAgICAgICAgdHJlZVdpZHRocy5wdXNoKF90aGlzMy5kaXJlY3Rpb24uZ2V0VHJlZVNpemUoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlV2lkdGhzO1xuICAgICAgfTtcblxuICAgICAgLy8gZ2V0IGEgbWFwIG9mIGFsbCBub2RlcyBpbiB0aGlzIGJyYW5jaFxuICAgICAgdmFyIGdldEJyYW5jaE5vZGVzID0gZnVuY3Rpb24gZ2V0QnJhbmNoTm9kZXMoc291cmNlLCBtYXApIHtcbiAgICAgICAgaWYgKG1hcFtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcFtzb3VyY2UuaWRdID0gdHJ1ZTtcbiAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBnZXRCcmFuY2hOb2RlcyhfdGhpczMuYm9keS5ub2Rlc1tjaGlsZHJlbltpXV0sIG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgYSBtaW4gbWF4IHdpZHRoIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gbW92ZW1lbnQgc3BhY2UgaXQgaGFzIG9uIGVpdGhlciBzaWRlc1xuICAgICAgLy8gd2UgdXNlIG1pbiBtYXggdGVybWlub2xvZ3kgYmVjYXVzZSB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBpbnRlcmNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGF5b3V0XG4gICAgICB2YXIgZ2V0QnJhbmNoQm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hNYXApIHtcbiAgICAgICAgdmFyIG1heExldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxZTk7XG5cbiAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgIHZhciBtYXggPSAtMWU5O1xuICAgICAgICBmb3IgKHZhciBicmFuY2hOb2RlIGluIGJyYW5jaE1hcCkge1xuICAgICAgICAgIGlmIChicmFuY2hNYXAuaGFzT3duUHJvcGVydHkoYnJhbmNoTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMzLmJvZHkubm9kZXNbYnJhbmNoTm9kZV07XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpczMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLlxuXG4gICAgICAgICAgICB2YXIgX2dldFNwYWNlQXJvdW5kTm9kZTIgPSBfdGhpczMuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBicmFuY2hNYXApLFxuICAgICAgICAgICAgICAgIF9nZXRTcGFjZUFyb3VuZE5vZGUzID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0U3BhY2VBcm91bmROb2RlMiwgMiksXG4gICAgICAgICAgICAgICAgbWluU3BhY2VOb2RlID0gX2dldFNwYWNlQXJvdW5kTm9kZTNbMF0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2VOb2RlID0gX2dldFNwYWNlQXJvdW5kTm9kZTNbMV07XG5cbiAgICAgICAgICAgIG1pblNwYWNlID0gTWF0aC5taW4obWluU3BhY2VOb2RlLCBtaW5TcGFjZSk7XG4gICAgICAgICAgICBtYXhTcGFjZSA9IE1hdGgubWluKG1heFNwYWNlTm9kZSwgbWF4U3BhY2UpO1xuXG4gICAgICAgICAgICAvLyB0aGUgd2lkdGggaXMgb25seSByZWxldmFudCBmb3IgdGhlIGxldmVscyB0d28gbm9kZXMgaGF2ZSBpbiBjb21tb24uIFRoaXMgaXMgd2h5IHdlIGZpbHRlciBvbiB0aGlzLlxuICAgICAgICAgICAgaWYgKGxldmVsIDw9IG1heExldmVsKSB7XG4gICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHBvc2l0aW9uLCBtaW4pO1xuICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChwb3NpdGlvbiwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21pbiwgbWF4LCBtaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfTtcblxuICAgICAgLy8gY2hlY2sgd2hhdCB0aGUgbWF4aW11bSBsZXZlbCBpcyB0aGVzZSBub2RlcyBoYXZlIGluIGNvbW1vbi5cbiAgICAgIHZhciBnZXRDb2xsaXNpb25MZXZlbCA9IGZ1bmN0aW9uIGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMikge1xuICAgICAgICB2YXIgbWF4TGV2ZWwxID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRNYXhMZXZlbChub2RlMS5pZCk7XG4gICAgICAgIHZhciBtYXhMZXZlbDIgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldE1heExldmVsKG5vZGUyLmlkKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heExldmVsMSwgbWF4TGV2ZWwyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29uZGVuc2UgZWxlbWVudHMuIFRoZXNlIGNhbiBiZSBub2RlcyBvciBicmFuY2hlcyBkZXBlbmRpbmcgb24gdGhlIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBsZXZlbHNcbiAgICAgICAqIEBwYXJhbSB7Kn0gY2VudGVyUGFyZW50c1xuICAgICAgICovXG4gICAgICB2YXIgc2hpZnRFbGVtZW50c0Nsb3NlciA9IGZ1bmN0aW9uIHNoaWZ0RWxlbWVudHNDbG9zZXIoY2FsbGJhY2ssIGxldmVscywgY2VudGVyUGFyZW50cykge1xuICAgICAgICB2YXIgaGllciA9IF90aGlzMy5oaWVyYXJjaGljYWw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBoaWVyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgICBpZiAobGV2ZWxOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlMSA9IGxldmVsTm9kZXNbal07XG4gICAgICAgICAgICAgIHZhciBub2RlMiA9IGxldmVsTm9kZXNbaiArIDFdO1xuXG4gICAgICAgICAgICAgIC8vIE5PVEU6IGxvZ2ljIG1haW50YWluZWQgYXMgaXQgd2FzOyBpZiBub2RlcyBoYXZlIHNhbWUgYW5jZXN0b3IsXG4gICAgICAgICAgICAgIC8vICAgICAgIHRoZW4gb2YgY291cnNlIHRoZXkgYXJlIGluIHRoZSBzYW1lIHN1Yi1uZXR3b3JrLlxuICAgICAgICAgICAgICBpZiAoaGllci5oYXNTYW1lUGFyZW50KG5vZGUxLCBub2RlMikgJiYgaGllci5pblNhbWVTdWJOZXR3b3JrKG5vZGUxLCBub2RlMikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlMSwgbm9kZTIsIGNlbnRlclBhcmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjYWxsYmFjayBmb3Igc2hpZnRpbmcgYnJhbmNoZXNcbiAgICAgIHZhciBicmFuY2hTaGlmdENhbGxiYWNrID0gZnVuY3Rpb24gYnJhbmNoU2hpZnRDYWxsYmFjayhub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgdmFyIGNlbnRlclBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICB2YXIgcG9zMSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZTEpO1xuICAgICAgICB2YXIgcG9zMiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZTIpO1xuICAgICAgICB2YXIgZGlmZkFicyA9IE1hdGguYWJzKHBvczIgLSBwb3MxKTtcbiAgICAgICAgdmFyIG5vZGVTcGFjaW5nID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTk9XIENIRUNLSU5HOlwiLCBub2RlMS5pZCwgbm9kZTIuaWQsIGRpZmZBYnMpO1xuICAgICAgICBpZiAoZGlmZkFicyA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMSA9IHt9O1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlczIgPSB7fTtcblxuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUxLCBicmFuY2hOb2RlczEpO1xuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUyLCBicmFuY2hOb2RlczIpO1xuXG4gICAgICAgICAgLy8gY2hlY2sgdGhlIGxhcmdlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYnJhbmNoZXNcbiAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSBnZXRDb2xsaXNpb25MZXZlbChub2RlMSwgbm9kZTIpO1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlQm91bmRhcnkxID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCk7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVCb3VuZGFyeTIgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgbWF4MSA9IGJyYW5jaE5vZGVCb3VuZGFyeTFbMV07XG4gICAgICAgICAgdmFyIG1pbjIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzBdO1xuICAgICAgICAgIHZhciBtaW5TcGFjZTIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzJdO1xuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhub2RlMS5pZCwgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCksIG5vZGUyLmlkLFxuICAgICAgICAgIC8vICAgICAgICAgICAgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMyLCBtYXhMZXZlbCksIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgZGlmZkJyYW5jaCA9IE1hdGguYWJzKG1heDEgLSBtaW4yKTtcbiAgICAgICAgICBpZiAoZGlmZkJyYW5jaCA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF4MSAtIG1pbjIgKyBub2RlU3BhY2luZztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAtbWluU3BhY2UyICsgbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gLW1pblNwYWNlMiArIG5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVTRVRUSU5HIE9GRlNFVFwiLCBtYXgxIC0gbWluMiArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcsIC1taW5TcGFjZTIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU0hJRlRJTkdcIiwgbm9kZTIuaWQsIG9mZnNldCk7XG4gICAgICAgICAgICAgIF90aGlzMy5fc2hpZnRCbG9jayhub2RlMi5pZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgaWYgKGNlbnRlclBhcmVudCA9PT0gdHJ1ZSkgX3RoaXMzLl9jZW50ZXJQYXJlbnQobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO30pXG4gICAgICB9O1xuXG4gICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoKGl0ZXJhdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJ0c1wiLG5vZGUuaWQpO1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgdmFyIGFsbEVkZ2VzID0gbm9kZS5lZGdlcztcbiAgICAgICAgdmFyIG5vZGVMZXZlbCA9IF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdO1xuXG4gICAgICAgIC8vIGdhdGhlciBjb25zdGFudHNcbiAgICAgICAgdmFyIEMyID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb247XG4gICAgICAgIHZhciByZWZlcmVuY2VOb2RlcyA9IHt9O1xuICAgICAgICB2YXIgYWJvdmVFZGdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgICAgICBpZiAoZWRnZS50b0lkICE9IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS50b0lkID09IG5vZGVJZCA/IGVkZ2UuZnJvbSA6IGVkZ2UudG87XG4gICAgICAgICAgICByZWZlcmVuY2VOb2Rlc1thbGxFZGdlc1tpXS5pZF0gPSBvdGhlck5vZGU7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbb3RoZXJOb2RlLmlkXSA8IG5vZGVMZXZlbCkge1xuICAgICAgICAgICAgICBhYm92ZUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuICAgICAgICB2YXIgZ2V0RnggPSBmdW5jdGlvbiBnZXRGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgIHN1bSArPSBhIC8gTWF0aC5zcXJ0KGEgKiBhICsgQzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvdWJseSBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgIHZhciBnZXRERnggPSBmdW5jdGlvbiBnZXRERngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdKSAtIHBvaW50O1xuICAgICAgICAgICAgICBzdW0gLT0gQzIgKiBNYXRoLnBvdyhhICogYSArIEMyLCAtMS41KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0R3Vlc3MgPSBmdW5jdGlvbiBnZXRHdWVzcyhpdGVyYXRpb25zLCBlZGdlcykge1xuICAgICAgICAgIHZhciBndWVzcyA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgICAgICAgLy8gTmV3dG9uJ3MgbWV0aG9kIGZvciBvcHRpbWl6YXRpb25cbiAgICAgICAgICB2YXIgZ3Vlc3NNYXAgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBpdGVyYXRpb25zOyBfaTQrKykge1xuICAgICAgICAgICAgdmFyIGZ4ID0gZ2V0RngoZ3Vlc3MsIGVkZ2VzKTtcbiAgICAgICAgICAgIHZhciBkZnggPSBnZXRERngoZ3Vlc3MsIGVkZ2VzKTtcblxuICAgICAgICAgICAgLy8gd2UgbGltaXQgdGhlIG1vdmVtZW50IHRvIGF2b2lkIGluc3RhYmlsaXR5LlxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gNDA7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBNYXRoLm1heCgtbGltaXQsIE1hdGgubWluKGxpbWl0LCBNYXRoLnJvdW5kKGZ4IC8gZGZ4KSkpO1xuICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcyAtIHJhdGlvO1xuICAgICAgICAgICAgLy8gcmVkdWNlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIGlmIChndWVzc01hcFtndWVzc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGd1ZXNzTWFwW2d1ZXNzXSA9IF9pNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGd1ZXNzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3ZlQnJhbmNoID0gZnVuY3Rpb24gbW92ZUJyYW5jaChndWVzcykge1xuICAgICAgICAgIC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcbiAgICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTtcblxuICAgICAgICAgIC8vIGNoZWNrIG1vdmFibGUgYXJlYSBvZiB0aGUgYnJhbmNoXG4gICAgICAgICAgaWYgKGJyYW5jaGVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBicmFuY2hOb2RlcyA9IHt9O1xuICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZSwgYnJhbmNoTm9kZXMpO1xuICAgICAgICAgICAgYnJhbmNoZXNbbm9kZS5pZF0gPSBicmFuY2hOb2RlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJyYW5jaEJvdW5kYXJ5ID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoZXNbbm9kZS5pZF0pO1xuICAgICAgICAgIHZhciBtaW5TcGFjZUJyYW5jaCA9IGJyYW5jaEJvdW5kYXJ5WzJdO1xuICAgICAgICAgIHZhciBtYXhTcGFjZUJyYW5jaCA9IGJyYW5jaEJvdW5kYXJ5WzNdO1xuXG4gICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgdmFyIGJyYW5jaE9mZnNldCA9IDA7XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBicmFuY2hPZmZzZXQgPSBNYXRoLm1pbihkaWZmLCBtYXhTcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgYnJhbmNoT2Zmc2V0ID0gLU1hdGgubWluKC1kaWZmLCBtaW5TcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJyYW5jaE9mZnNldCAhPSAwKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIGJyYW5jaDpcIixicmFuY2hPZmZzZXQsIG1heFNwYWNlQnJhbmNoLCBtaW5TcGFjZUJyYW5jaClcbiAgICAgICAgICAgIF90aGlzMy5fc2hpZnRCbG9jayhub2RlLmlkLCBicmFuY2hPZmZzZXQpO1xuICAgICAgICAgICAgLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbW92ZU5vZGUgPSBmdW5jdGlvbiBtb3ZlTm9kZShndWVzcykge1xuICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpO1xuXG4gICAgICAgICAgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuXG4gICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGU0ID0gX3RoaXMzLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSksXG4gICAgICAgICAgICAgIF9nZXRTcGFjZUFyb3VuZE5vZGU1ID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0U3BhY2VBcm91bmROb2RlNCwgMiksXG4gICAgICAgICAgICAgIG1pblNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTVbMF0sXG4gICAgICAgICAgICAgIG1heFNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTVbMV07XG5cbiAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1pbihub2RlUG9zaXRpb24gKyAobWF4U3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1heChub2RlUG9zaXRpb24gLSAobWluU3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICE9PSBub2RlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgTm9kZTpcIixkaWZmLCBtaW5TcGFjZSwgbWF4U3BhY2UpO1xuICAgICAgICAgICAgX3RoaXMzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFib3ZlRWRnZXMpO1xuICAgICAgICBtb3ZlQnJhbmNoKGd1ZXNzKTtcbiAgICAgICAgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhbGxFZGdlcyk7XG4gICAgICAgIG1vdmVOb2RlKGd1ZXNzKTtcbiAgICAgICAgLy99KVxuICAgICAgfTtcblxuICAgICAgLy8gbWV0aG9kIHRvIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYnJhbmNoZXMuIEJlY2F1c2Ugd2UgZG8gYm90dG9tIHVwLCB3ZSBjYW4gY2VudGVyIHRoZSBwYXJlbnRzLlxuICAgICAgdmFyIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcbiAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLnJldmVyc2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tqXTtcbiAgICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxldmVsTm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoKDEwMDAsIGxldmVsTm9kZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwIElOIFwiICsgaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cbiAgICAgIHZhciBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgPSBmdW5jdGlvbiBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcbiAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLnJldmVyc2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2hpZnRFbGVtZW50c0Nsb3NlcihicmFuY2hTaGlmdENhbGxiYWNrLCBsZXZlbHMsIHRydWUpO1xuICAgICAgICAgIGlmIChzdGlsbFNoaWZ0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRklOSVNIRUQgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwIElOIFwiICsgKGkrMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjZW50ZXIgYWxsIHBhcmVudHNcbiAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50cygpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIF90aGlzMy5fY2VudGVyUGFyZW50KF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjZW50ZXIgYWxsIHBhcmVudHNcbiAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldExldmVscygpO1xuICAgICAgICBsZXZlbHMgPSBsZXZlbHMucmV2ZXJzZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgX3RoaXMzLl9jZW50ZXJQYXJlbnQobGV2ZWxOb2Rlc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyB0aGUgYWN0dWFsIHdvcmsgaXMgZG9uZSBoZXJlLlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuYmxvY2tTaGlmdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoNSk7XG4gICAgICAgIGNlbnRlckFsbFBhcmVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWluaW1pemUgZWRnZSBsZW5ndGhcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVkZ2VNaW5pbWl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoMjApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5wYXJlbnRDZW50cmFsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKTtcbiAgICAgIH1cblxuICAgICAgc2hpZnRUcmVlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZ2l2ZXMgdGhlIHNwYWNlIGFyb3VuZCB0aGUgbm9kZS4gSUYgYSBtYXAgaXMgc3VwcGxpZWQsIGl0IHdpbGwgb25seSBjaGVjayBhZ2FpbnN0IG5vZGVzIE5PVCBpbiB0aGUgbWFwLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBvbmx5IGdldCB0aGUgZGlzdGFuY2VzIHRvIG5vZGVzIG91dHNpZGUgb2YgYSBicmFuY2guXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7Tm9kZS5pZDogdmlzLk5vZGV9fSBtYXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFNwYWNlQXJvdW5kTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSwgbWFwKSB7XG4gICAgICB2YXIgdXNlTWFwID0gdHJ1ZTtcbiAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1c2VNYXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTtcbiAgICAgICAgdmFyIG9yZGVyaW5nID0gdGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICB2YXIgbWluU3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtYXhTcGFjZSA9IDFlOTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHByZXZOb2RlID0gb3JkZXJpbmdbaW5kZXggLSAxXTtcbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtwcmV2Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgcHJldlBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHByZXZOb2RlKTtcbiAgICAgICAgICAgIG1pblNwYWNlID0gcG9zaXRpb24gLSBwcmV2UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBvcmRlcmluZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROb2RlID0gb3JkZXJpbmdbaW5kZXggKyAxXTtcbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtuZXh0Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5leHROb2RlKTtcbiAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2UsIG5leHRQb3MgLSBwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSB1c2UgdGhpcyBtZXRob2QgdG8gY2VudGVyIGEgcGFyZW50IG5vZGUgYW5kIGNoZWNrIGlmIGl0IGRvZXMgbm90IGNyb3NzIG90aGVyIG5vZGVzIHdoZW4gaXQgZG9lcy5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2VudGVyUGFyZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NlbnRlclBhcmVudChub2RlKSB7XG4gICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdKSB7XG4gICAgICAgIHZhciBwYXJlbnRzID0gdGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyZW50SWQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0U3BhY2VBcm91bmROb2RlNiA9IHRoaXMuX2dldFNwYWNlQXJvdW5kTm9kZShwYXJlbnROb2RlKSxcbiAgICAgICAgICAgICAgICBfZ2V0U3BhY2VBcm91bmROb2RlNyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldFNwYWNlQXJvdW5kTm9kZTYsIDIpLFxuICAgICAgICAgICAgICAgIG1pblNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTdbMF0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfZ2V0U3BhY2VBcm91bmROb2RlN1sxXTtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbiAtIG5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGRpZmYgPCAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWF4U3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIHx8IGRpZmYgPiAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWluU3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHBhcmVudE5vZGUsIG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHBsYWNlcyB0aGUgbm9kZXMgb24gdGhlIGNhbnZhcyBiYXNlZCBvbiB0aGUgaGllcmFyY2hpYWwgZGlzdHJpYnV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpc3RyaWJ1dGlvbiB8IG9idGFpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGlzLl9nZXREaXN0cmlidXRpb24oKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wbGFjZU5vZGVzQnlIaWVyYXJjaHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbikge1xuICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXMgPSB7fTtcbiAgICAgIC8vIHN0YXJ0IHBsYWNpbmcgYWxsIHRoZSBsZXZlbCAwIG5vZGVzIGZpcnN0LiBUaGVuIHJlY3Vyc2l2ZWx5IHBvc2l0aW9uIHRoZWlyIGJyYW5jaGVzLlxuICAgICAgZm9yICh2YXIgbGV2ZWwgaW4gZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChkaXN0cmlidXRpb24uaGFzT3duUHJvcGVydHkobGV2ZWwpKSB7XG4gICAgICAgICAgLy8gc29ydCBub2RlcyBpbiBsZXZlbCBieSBwb3NpdGlvbjpcbiAgICAgICAgICB2YXIgbm9kZUFycmF5ID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShkaXN0cmlidXRpb25bbGV2ZWxdKTtcbiAgICAgICAgICBub2RlQXJyYXkgPSB0aGlzLl9pbmRleEFycmF5VG9Ob2Rlcyhub2RlQXJyYXkpO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNvcnQobm9kZUFycmF5KTtcbiAgICAgICAgICB2YXIgaGFuZGxlZE5vZGVDb3VudCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbmVkTm9kZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSBzcGFjaW5nICogaGFuZGxlZE5vZGVDb3VudDtcbiAgICAgICAgICAgICAgLy8gV2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy5cbiAgICAgICAgICAgICAgLy8gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG4gICAgICAgICAgICAgIGlmIChoYW5kbGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGVBcnJheVtpIC0gMV0pICsgc3BhY2luZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBwb3MsIGxldmVsKTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKG5vZGUsIGxldmVsLCBwb3MpO1xuXG4gICAgICAgICAgICAgIGhhbmRsZWROb2RlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcmVjdXJzaXZlbHkgY2FsbGVkIGZ1bmN0aW9uIHRvIGVudW1lcmF0ZSB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgbGFyZ2VzdCBodWJzIGFuZCBwbGFjZSB0aGUgbm9kZXNcbiAgICAgKiBvbiBhIFggcG9zaXRpb24gdGhhdCBlbnN1cmVzIHRoZXJlIHdpbGwgYmUgbm8gb3ZlcmxhcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyZW50TGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcGxhY2VCcmFuY2hOb2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUJyYW5jaE5vZGVzKHBhcmVudElkLCBwYXJlbnRMZXZlbCkge1xuICAgICAgdmFyIGNoaWxkUmVmID0gdGhpcy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIHBhcmVudCwgY2FuY2VsIHRoZSBwbGFjaW5nLiBUaGlzIGNhbiBoYXBwZW4gd2l0aCBtdWx0aXBsZSBwYXJlbnRzIHRvIG9uZSBjaGlsZC5cbiAgICAgIGlmIChjaGlsZFJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBjaGlsZE5vZGVzXG4gICAgICB2YXIgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2godGhpcy5ib2R5Lm5vZGVzW2NoaWxkUmVmW2ldXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZSB0aGUgcG9zaXRpb25zIHRvIG9yZGVyIHRoZSBub2Rlcy5cbiAgICAgIHRoaXMuZGlyZWN0aW9uLnNvcnQoY2hpbGROb2Rlcyk7XG5cbiAgICAgIC8vIHBvc2l0aW9uIHRoZSBjaGlsZE5vZGVzXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBjaGlsZE5vZGVzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbX2k1XTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjaGlsZCBub2RlIGlzIGJlbG93IHRoZSBwYXJlbnQgbm9kZSBhbmQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwb3NpdGlvbmVkLlxuICAgICAgICBpZiAoY2hpbGROb2RlTGV2ZWwgPiBwYXJlbnRMZXZlbCAmJiB0aGlzLnBvc2l0aW9uZWROb2Rlc1tjaGlsZE5vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGFtb3VudCBvZiBzcGFjZSByZXF1aXJlZCBmb3IgdGhpcyBub2RlLiBJZiBwYXJlbnQgdGhlIHdpZHRoIGlzIGJhc2VkIG9uIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4uXG4gICAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG5cbiAgICAgICAgICAvLyB3ZSBnZXQgdGhlIFggb3IgWSB2YWx1ZXMgd2UgbmVlZCBhbmQgc3RvcmUgdGhlbSBpbiBwb3MgYW5kIHByZXZpb3VzUG9zLlxuICAgICAgICAgIC8vIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuICAgICAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjaGlsZE5vZGVzW19pNSAtIDFdKSArIHNwYWNpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKGNoaWxkTm9kZSwgcG9zLCBjaGlsZE5vZGVMZXZlbCk7XG4gICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKGNoaWxkTm9kZSwgY2hpbGROb2RlTGV2ZWwsIHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNlbnRlciB0aGUgcGFyZW50IG5vZGVzLlxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpO1xuICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXSwgY2VudGVyLCBwYXJlbnRMZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGZvciBvdmVybGFwIGFuZCBpZiByZXF1aXJlZCBzaGlmdHMgdGhlIGJyYW5jaC4gSXQgYWxzbyBrZWVwcyByZWNvcmRzIG9mIHBvc2l0aW9uZWQgbm9kZXMuXG4gICAgICogRmluYWxseSBpdCB3aWxsIGNhbGwgX3BsYWNlQnJhbmNoTm9kZXMgdG8gcGxhY2UgdGhlIGJyYW5jaCBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcykge1xuICAgICAgLy8gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBmb3IgZm9ybWFsIHRyZWVzIGFuZCBmb3JtYWwgZm9yZXN0c1xuICAgICAgLy8gRWFybHkgZXhpdCBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZVxuICAgICAgaWYgKCF0aGlzLmhpZXJhcmNoaWNhbC5pc1RyZWUpIHJldHVybjtcblxuICAgICAgLy8gaWYgb3ZlcmxhcCBoYXMgYmVlbiBkZXRlY3RlZCwgd2Ugc2hpZnQgdGhlIGJyYW5jaFxuICAgICAgaWYgKHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1BvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF1dKTtcbiAgICAgICAgaWYgKHBvcyAtIHByZXZpb3VzUG9zIDwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgIHZhciBkaWZmID0gcHJldmlvdXNQb3MgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIC0gcG9zO1xuICAgICAgICAgIHZhciBzaGFyZWRQYXJlbnQgPSB0aGlzLl9maW5kQ29tbW9uUGFyZW50KHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSwgbm9kZS5pZCk7XG4gICAgICAgICAgdGhpcy5fc2hpZnRCbG9jayhzaGFyZWRQYXJlbnQud2l0aENoaWxkLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gPSBub2RlLmlkOyAvLyBzdG9yZSBjaGFuZ2UgaW4gcG9zaXRpb24uXG4gICAgICB0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9IHRydWU7XG4gICAgICB0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKG5vZGUuaWQsIGxldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlcyBhbiBhcnJheSB3aXRoIG5vZGUgaW5kaWNlcyBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICAgICAqIFVzZWQgZm9yIHNvcnRpbmcgYmFzZWQgb24gbm9kZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGUuaWQ+fSBpZEFycmF5XG4gICAgICogQHJldHVybnMge0FycmF5LjxOb2RlPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2luZGV4QXJyYXlUb05vZGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luZGV4QXJyYXlUb05vZGVzKGlkQXJyYXkpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW2lkQXJyYXlbaV1dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGdldCB0aGUgZGlzdHJpYnV0aW9uIG9mIGxldmVscyBiYXNlZCBvbiBodWJzaXplXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXREaXN0cmlidXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdHJpYnV0aW9uKCkge1xuICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHt9O1xuICAgICAgdmFyIG5vZGVJZCA9IHZvaWQgMCxcbiAgICAgICAgICBub2RlID0gdm9pZCAwO1xuXG4gICAgICAvLyB3ZSBmaXggWSBiZWNhdXNlIHRoZSBoaWVyYXJjaHkgaXMgdmVydGljYWwsXG4gICAgICAvLyB3ZSBmaXggWCBzbyB3ZSBkbyBub3QgZ2l2ZSBhIG5vZGUgYW4geCBwb3NpdGlvbiBmb3IgYSBzZWNvbmQgdGltZS5cbiAgICAgIC8vIHRoZSBmaXggb2YgWCBpcyByZW1vdmVkIGFmdGVyIHRoZSB4IHZhbHVlIGhhcyBiZWVuIHNldC5cbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVJZF0gPT09IHVuZGVmaW5lZCA/IDAgOiB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXTtcbiAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5maXgobm9kZSwgbGV2ZWwpO1xuICAgICAgICAgIGlmIChkaXN0cmlidXRpb25bbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRpc3RyaWJ1dGlvbltsZXZlbF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzdHJpYnV0aW9uW2xldmVsXVtub2RlSWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFjdGl2ZSAoaS5lLiB2aXNpYmxlKSBlZGdlcyBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlPn0gQXJyYXkgb2YgZWRnZSBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0QWN0aXZlRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWN0aXZlRWRnZXMobm9kZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgdXRpbC5mb3JFYWNoKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIGlmIChfdGhpczQuYm9keS5lZGdlSW5kaWNlcy5pbmRleE9mKGVkZ2UuaWQpICE9PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGh1YnNpemVzIGZvciBhbGwgYWN0aXZlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0SHViU2l6ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SHViU2l6ZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGh1YlNpemVzID0ge307XG4gICAgICB2YXIgbm9kZUlkcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcblxuICAgICAgdXRpbC5mb3JFYWNoKG5vZGVJZHMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICB2YXIgaHViU2l6ZSA9IF90aGlzNS5fZ2V0QWN0aXZlRWRnZXMobm9kZSkubGVuZ3RoO1xuICAgICAgICBodWJTaXplc1todWJTaXplXSA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgLy8gTWFrZSBhbiBhcnJheSBvZiB0aGUgc2l6ZSBzb3J0ZWQgZGVzY2VuZGluZ1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdXRpbC5mb3JFYWNoKGh1YlNpemVzLCBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXN1bHQucHVzaChOdW1iZXIoc2l6ZSkpO1xuICAgICAgfSk7XG5cbiAgICAgIFRpbVNvcnQuc29ydChyZXN1bHQsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgcmVjdXJzaXZlIGJyYW5jaGluZyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgbGV2ZWxEb3duc3RyZWFtID0gZnVuY3Rpb24gbGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQikge1xuICAgICAgICBfdGhpczYuaGllcmFyY2hpY2FsLmxldmVsRG93bnN0cmVhbShub2RlQSwgbm9kZUIpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGh1YlNpemVzID0gdGhpcy5fZ2V0SHViU2l6ZXMoKTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgaHViU2l6ZSA9IGh1YlNpemVzW2ldO1xuICAgICAgICBpZiAoaHViU2l6ZSA9PT0gMCkgcmV0dXJuICdicmVhayc7XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzNi5ib2R5Lm5vZGVJbmRpY2VzLCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczYuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgICAgaWYgKGh1YlNpemUgPT09IF90aGlzNi5fZ2V0QWN0aXZlRWRnZXMobm9kZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczYuX2NyYXdsTmV0d29yayhsZXZlbERvd25zdHJlYW0sIG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHViU2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChpKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gJ2JyZWFrJykgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVE9ETzogcmVsZWFzZSBmZWF0dXJlXG4gICAgICogVE9ETzogRGV0ZXJtaW5lIGlmIHRoaXMgZmVhdHVyZSBpcyBuZWVkZWQgYXQgYWxsXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDAwO1xuXG4gICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBjb21lIGZyb20gb3B0aW9ucy5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdmFyIGN1c3RvbUNhbGxiYWNrID0gZnVuY3Rpb24gY3VzdG9tQ2FsbGJhY2sobm9kZUEsIG5vZGVCLCBlZGdlKSB7fTtcblxuICAgICAgLy8gVE9ETzogcGVyaGFwcyBtb3ZlIHRvIEhpZXJhcmNoaWNhbFN0YXR1cy5cbiAgICAgIC8vICAgICAgIEJ1dCBJIGN1cnJlbnRseSBkb24ndCBzZWUgdGhlIHBvaW50LCB0aGlzIG1ldGhvZCBpcyBub3QgdXNlZC5cbiAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgdmFyIGxldmVsQSA9IF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVBLmlkXTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKGxldmVsQSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV2ZWxBID0gX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IGN1c3RvbUNhbGxiYWNrKE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlQSwgJ25vZGUnKSwgTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGVCLCAnbm9kZScpLCBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoZWRnZSwgJ2VkZ2UnKSk7XG5cbiAgICAgICAgX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUIuaWRdID0gbGV2ZWxBICsgZGlmZjtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhsZXZlbEJ5RGlyZWN0aW9uKTtcbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb2NhdGUgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2RldGVybWluZUxldmVsc0RpcmVjdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHZhciBtaW5MZXZlbCA9IDEwMDAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGFuIGVkZ2UgZ29pbmcgdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZSAgZWRnZSB0byBjaGVja1xuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlcmUncyBhbm90aGVyIGVkZ2UgZ29pbmcgaW50byB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgKi9cbiAgICAgIHZhciBpc0JpZGlyZWN0aW9uYWwgPSBmdW5jdGlvbiBpc0JpZGlyZWN0aW9uYWwoZWRnZSkge1xuICAgICAgICB1dGlsLmZvckVhY2goX3RoaXM4LmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChvdGhlckVkZ2UpIHtcbiAgICAgICAgICBpZiAob3RoZXJFZGdlLnRvSWQgPT09IGVkZ2UuZnJvbUlkICYmIG90aGVyRWRnZS5mcm9tSWQgPT09IGVkZ2UudG9JZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGV2ZWxCeURpcmVjdGlvbiA9IGZ1bmN0aW9uIGxldmVsQnlEaXJlY3Rpb24obm9kZUEsIG5vZGVCLCBlZGdlKSB7XG4gICAgICAgIHZhciBsZXZlbEEgPSBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF07XG4gICAgICAgIHZhciBsZXZlbEIgPSBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQi5pZF07XG5cbiAgICAgICAgaWYgKGlzQmlkaXJlY3Rpb25hbChlZGdlKSAmJiBsZXZlbEEgIT09IHVuZGVmaW5lZCAmJiBsZXZlbEIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIERvbid0IHJlZG8gdGhlIGxldmVsIGRldGVybWluYXRpb24gaWYgYWxyZWFkeSBkb25lIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXZlbEEgPSBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF0gPSBtaW5MZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZS50b0lkID09IG5vZGVCLmlkKSB7XG4gICAgICAgICAgX3RoaXM4LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUIuaWRdID0gbGV2ZWxBICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQi5pZF0gPSBsZXZlbEEgLSAxO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jcmF3bE5ldHdvcmsobGV2ZWxCeURpcmVjdGlvbik7XG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5zZXRNaW5MZXZlbFRvWmVybyh0aGlzLmJvZHkubm9kZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm9va2tlZXBpbmcgb2YgcGFyZW50IGFuZCBjaGlsZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2VuZXJhdGVNYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVNYXAoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIGZpbGxJblJlbGF0aW9ucyA9IGZ1bmN0aW9uIGZpbGxJblJlbGF0aW9ucyhwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKF90aGlzOS5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF0gPiBfdGhpczkuaGllcmFyY2hpY2FsLmxldmVsc1twYXJlbnROb2RlLmlkXSkge1xuICAgICAgICAgIF90aGlzOS5oaWVyYXJjaGljYWwuYWRkUmVsYXRpb24ocGFyZW50Tm9kZS5pZCwgY2hpbGROb2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGZpbGxJblJlbGF0aW9ucyk7XG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5jaGVja0lmVHJlZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyYXdsIG92ZXIgdGhlIGVudGlyZSBuZXR3b3JrIGFuZCB1c2UgYSBjYWxsYmFjayBvbiBlYWNoIG5vZGUgY291cGxlIHRoYXQgaXMgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrPWZ1bmN0aW9uKCl7fV0gICAgICAgICAgfCB3aWxsIHJlY2VpdmUgbm9kZUEsIG5vZGVCIGFuZCB0aGUgY29ubmVjdGluZyBlZGdlLiBBIGFuZCBCIGFyZSBkaXN0aW5jdC5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHN0YXJ0aW5nTm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyYXdsTmV0d29yaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmF3bE5ldHdvcmsoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XG4gICAgICB2YXIgc3RhcnRpbmdOb2RlSWQgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuXG4gICAgICB2YXIgY3Jhd2xlciA9IGZ1bmN0aW9uIGNyYXdsZXIobm9kZSwgdHJlZSkge1xuICAgICAgICBpZiAocHJvZ3Jlc3Nbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzMTAuaGllcmFyY2hpY2FsLnNldFRyZWVJbmRleChub2RlLCB0cmVlKTtcblxuICAgICAgICAgIHByb2dyZXNzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBlZGdlcyA9IF90aGlzMTAuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ICc9PT0nIGJlY2F1c2UgaWQncyBjYW4gYmUgc3RyaW5nIGFuZCBudW1lcmljXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZWRnZS5mcm9tO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPSBjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgJyE9PScgYmVjYXVzZSBpZCdzIGNhbiBiZSBzdHJpbmcgYW5kIG51bWVyaWNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBjaGlsZE5vZGUsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIGNyYXdsZXIoY2hpbGROb2RlLCB0cmVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHN0YXJ0aW5nTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ3Jhd2wgb3ZlciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIHRyZWVJbmRleCA9IDA7IC8vIFNlcnZlcyB0byBwYXNzIGEgdW5pcXVlIGlkIGZvciB0aGUgY3VycmVudCBkaXN0aW5jdCB0cmVlXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuXG4gICAgICAgICAgaWYgKHByb2dyZXNzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGNyYXdsZXIobm9kZSwgdHJlZUluZGV4KTtcbiAgICAgICAgICAgIHRyZWVJbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3Jhd2wgZnJvbSB0aGUgZ2l2ZW4gc3RhcnRpbmcgbm9kZVxuICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3N0YXJ0aW5nTm9kZUlkXTtcbiAgICAgICAgaWYgKF9ub2RlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignTm9kZSBub3QgZm91bmQ6Jywgc3RhcnRpbmdOb2RlSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjcmF3bGVyKF9ub2RlMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hpZnQgYSBicmFuY2ggYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NoaWZ0QmxvY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hpZnRCbG9jayhwYXJlbnRJZCwgZGlmZikge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB7fTtcbiAgICAgIHZhciBzaGlmdGVyID0gZnVuY3Rpb24gc2hpZnRlcihwYXJlbnRJZCkge1xuICAgICAgICBpZiAocHJvZ3Jlc3NbcGFyZW50SWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2dyZXNzW3BhcmVudElkXSA9IHRydWU7XG4gICAgICAgIF90aGlzMTEuZGlyZWN0aW9uLnNoaWZ0KHBhcmVudElkLCBkaWZmKTtcblxuICAgICAgICB2YXIgY2hpbGRSZWYgPSBfdGhpczExLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG4gICAgICAgIGlmIChjaGlsZFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2hpZnRlcihjaGlsZFJlZltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2hpZnRlcihwYXJlbnRJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGNvbW1vbiBwYXJlbnQgYmV0d2VlbiBicmFuY2hlcy5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkQVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGRCXG4gICAgICogQHJldHVybnMge3tmb3VuZFBhcmVudCwgd2l0aENoaWxkfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZENvbW1vblBhcmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQ29tbW9uUGFyZW50KGNoaWxkQSwgY2hpbGRCKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXJlbnRzID0ge307XG4gICAgICB2YXIgaXRlcmF0ZVBhcmVudHMgPSBmdW5jdGlvbiBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gX3RoaXMxMi5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW2NoaWxkXTtcbiAgICAgICAgaWYgKHBhcmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRSZWZbaV07XG4gICAgICAgICAgICBwYXJlbnRzW3BhcmVudF0gPSB0cnVlO1xuICAgICAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgcGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZmluZFBhcmVudCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlZiA9IF90aGlzMTIuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtjaGlsZF07XG4gICAgICAgIGlmIChwYXJlbnRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50UmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50UmVmW2ldO1xuICAgICAgICAgICAgaWYgKHBhcmVudHNbcGFyZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGZvdW5kUGFyZW50OiBwYXJlbnQsIHdpdGhDaGlsZDogY2hpbGQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBicmFuY2ggPSBmaW5kUGFyZW50KHBhcmVudHMsIHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoYnJhbmNoLmZvdW5kUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvdW5kUGFyZW50OiBudWxsLCB3aXRoQ2hpbGQ6IGNoaWxkIH07XG4gICAgICB9O1xuXG4gICAgICBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZEEpO1xuICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGRCKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0cmF0ZWd5IHBhdHRlcm4gZm9yIGhhbmRsaW5nIHRoZSBjb29yZGluYXRlcyBnaXZlbiB0aGUgY3VycmVudCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaW5kaXZpZHVhbCBpbnN0YW5jZXMgY29udGFpbiBhbGwgdGhlIG9wZXJhdGlvbnMgYW5kIGRhdGEgc3BlY2lmaWMgdG8gYSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90VXBkYXRlPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldERpcmVjdGlvblN0cmF0ZWd5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlyZWN0aW9uU3RyYXRlZ3koKSB7XG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnVUQnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnO1xuXG4gICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG5ldyBWZXJ0aWNhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgSG9yaXpvbnRhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIGEgYnJhbmNoIGZyb20gdGhlIHBhc3NlZCBsaXN0IG9mIGNoaWxkIG5vZGVzXG4gICAgICpcbiAgICAgKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGUgcG9zaXRpb25zIG9mIGFsbCB0aGUgY2hpbGQgbm9kZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZXx2aXMuTm9kZS5pZD59IGNoaWxkTm9kZXMgIEFycmF5IG9mIGVpdGhlciBjaGlsZCBub2RlcyBvciBub2RlIGlkJ3NcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENlbnRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpIHtcbiAgICAgIHZhciBtaW5Qb3MgPSAxZTk7XG4gICAgICB2YXIgbWF4UG9zID0gLTFlOTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2ldLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgY2hpbGROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGNoaWxkTm9kZSk7XG4gICAgICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgcG9zaXRpb24pO1xuICAgICAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDAuNSAqIChtaW5Qb3MgKyBtYXhQb3MpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGF5b3V0RW5naW5lO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBMYXlvdXRFbmdpbmU7XG5cbi8qKiovIH0pLFxuLyogMTg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qKioqXG4gKiBUaGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTWFyY28gWmljY2FyZGlcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqKioqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZC5leHBvcnRzKTtcbiAgICBnbG9iYWwudGltc29ydCA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgZXhwb3J0cy5zb3J0ID0gc29ydDtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xuXG4gIHZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xuXG4gIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuICB2YXIgUE9XRVJTX09GX1RFTiA9IFsxZTAsIDFlMSwgMWUyLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTldO1xuXG4gIGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICBpZiAoeCA8IDFlNSkge1xuICAgICAgaWYgKHggPCAxZTIpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTEgPyAwIDogMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAxZTQpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTMgPyAyIDogMztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuXG4gICAgaWYgKHggPCAxZTcpIHtcbiAgICAgIHJldHVybiB4IDwgMWU2ID8gNSA6IDY7XG4gICAgfVxuXG4gICAgaWYgKHggPCAxZTkpIHtcbiAgICAgIHJldHVybiB4IDwgMWU4ID8gNyA6IDg7XG4gICAgfVxuXG4gICAgcmV0dXJuIDk7XG4gIH1cblxuICBmdW5jdGlvbiBhbHBoYWJldGljYWxDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKH4gfmEgPT09IGEgJiYgfiB+YiA9PT0gYikge1xuICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhIDwgMCB8fCBiIDwgMCkge1xuICAgICAgICBpZiAoYiA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPj0gMCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYSA9IC1hO1xuICAgICAgICBiID0gLWI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbCA9IGxvZzEwKGEpO1xuICAgICAgdmFyIGJsID0gbG9nMTAoYik7XG5cbiAgICAgIHZhciB0ID0gMDtcblxuICAgICAgaWYgKGFsIDwgYmwpIHtcbiAgICAgICAgYSAqPSBQT1dFUlNfT0ZfVEVOW2JsIC0gYWwgLSAxXTtcbiAgICAgICAgYiAvPSAxMDtcbiAgICAgICAgdCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhbCA+IGJsKSB7XG4gICAgICAgIGIgKj0gUE9XRVJTX09GX1RFTlthbCAtIGJsIC0gMV07XG4gICAgICAgIGEgLz0gMTA7XG4gICAgICAgIHQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHZhciBhU3RyID0gU3RyaW5nKGEpO1xuICAgIHZhciBiU3RyID0gU3RyaW5nKGIpO1xuXG4gICAgaWYgKGFTdHIgPT09IGJTdHIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBhU3RyIDwgYlN0ciA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgdmFyIHIgPSAwO1xuXG4gICAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgIHIgfD0gbiAmIDE7XG4gICAgICBuID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuICsgcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICBydW5IaSsrO1xuICAgICAgfVxuXG4gICAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICBydW5IaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBydW5IaSAtIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gICAgaGktLTtcblxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgICAgYXJyYXlbaGktLV0gPSB0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cblxuICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG5cbiAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICB2YXIgcmlnaHQgPSBzdGFydDtcblxuICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICB2YXIgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQrKztcbiAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCsrO1xuXG4gICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICB2YXIgVGltU29ydCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbVNvcnQpO1xuXG4gICAgICB0aGlzLmFycmF5ID0gbnVsbDtcbiAgICAgIHRoaXMuY29tcGFyZSA9IG51bGw7XG4gICAgICB0aGlzLm1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMudG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICAgICAgdGhpcy5zdGFja0xlbmd0aCA9IDA7XG4gICAgICB0aGlzLnJ1blN0YXJ0ID0gbnVsbDtcbiAgICAgIHRoaXMucnVuTGVuZ3RoID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhY2tTaXplID0gMDtcblxuICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcblxuICAgICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgICAgICB0aGlzLnRtcFN0b3JhZ2VMZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50bXAgPSBuZXcgQXJyYXkodGhpcy50bXBTdG9yYWdlTGVuZ3RoKTtcblxuICAgICAgdGhpcy5zdGFja0xlbmd0aCA9IHRoaXMubGVuZ3RoIDwgMTIwID8gNSA6IHRoaXMubGVuZ3RoIDwgMTU0MiA/IDEwIDogdGhpcy5sZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuXG4gICAgICB0aGlzLnJ1blN0YXJ0ID0gbmV3IEFycmF5KHRoaXMuc3RhY2tMZW5ndGgpO1xuICAgICAgdGhpcy5ydW5MZW5ndGggPSBuZXcgQXJyYXkodGhpcy5zdGFja0xlbmd0aCk7XG4gICAgfVxuXG4gICAgVGltU29ydC5wcm90b3R5cGUucHVzaFJ1biA9IGZ1bmN0aW9uIHB1c2hSdW4ocnVuU3RhcnQsIHJ1bkxlbmd0aCkge1xuICAgICAgdGhpcy5ydW5TdGFydFt0aGlzLnN0YWNrU2l6ZV0gPSBydW5TdGFydDtcbiAgICAgIHRoaXMucnVuTGVuZ3RoW3RoaXMuc3RhY2tTaXplXSA9IHJ1bkxlbmd0aDtcbiAgICAgIHRoaXMuc3RhY2tTaXplICs9IDE7XG4gICAgfTtcblxuICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlUnVucyA9IGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICAgIHdoaWxlICh0aGlzLnN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgaWYgKG4gPj0gMSAmJiB0aGlzLnJ1bkxlbmd0aFtuIC0gMV0gPD0gdGhpcy5ydW5MZW5ndGhbbl0gKyB0aGlzLnJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHRoaXMucnVuTGVuZ3RoW24gLSAyXSA8PSB0aGlzLnJ1bkxlbmd0aFtuXSArIHRoaXMucnVuTGVuZ3RoW24gLSAxXSkge1xuXG4gICAgICAgICAgaWYgKHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJ1bkxlbmd0aFtuXSA+IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVyZ2VBdChuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVGltU29ydC5wcm90b3R5cGUuZm9yY2VNZXJnZVJ1bnMgPSBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgIHdoaWxlICh0aGlzLnN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgaWYgKG4gPiAwICYmIHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VBdChuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VBdCA9IGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuXG4gICAgICB2YXIgc3RhcnQxID0gdGhpcy5ydW5TdGFydFtpXTtcbiAgICAgIHZhciBsZW5ndGgxID0gdGhpcy5ydW5MZW5ndGhbaV07XG4gICAgICB2YXIgc3RhcnQyID0gdGhpcy5ydW5TdGFydFtpICsgMV07XG4gICAgICB2YXIgbGVuZ3RoMiA9IHRoaXMucnVuTGVuZ3RoW2kgKyAxXTtcblxuICAgICAgdGhpcy5ydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgICAgaWYgKGkgPT09IHRoaXMuc3RhY2tTaXplIC0gMykge1xuICAgICAgICB0aGlzLnJ1blN0YXJ0W2kgKyAxXSA9IHRoaXMucnVuU3RhcnRbaSArIDJdO1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aFtpICsgMV0gPSB0aGlzLnJ1bkxlbmd0aFtpICsgMl07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2tTaXplLS07XG5cbiAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICBzdGFydDEgKz0gaztcbiAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICAgIHRoaXMubWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUaW1Tb3J0LnByb3RvdHlwZS5tZXJnZUxvdyA9IGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG5cbiAgICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIHZhciB0bXAgPSB0aGlzLnRtcDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcblxuICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluR2FsbG9wID0gdGhpcy5taW5HYWxsb3A7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBtaW5HYWxsb3ApO1xuXG4gICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtaW5HYWxsb3AtLTtcbiAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICBtaW5HYWxsb3AgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluR2FsbG9wICs9IDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlSGlnaCA9IGZ1bmN0aW9uIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgdmFyIHRtcCA9IHRoaXMudG1wO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgIHZhciBjdXN0b21EZXN0ID0gMDtcblxuICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5HYWxsb3AgPSB0aGlzLm1pbkdhbGxvcDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBtaW5HYWxsb3ApO1xuXG4gICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1pbkdhbGxvcC0tO1xuICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgIG1pbkdhbGxvcCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5HYWxsb3AgKz0gMjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICAgIHRoaXMubWluR2FsbG9wID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGltU29ydDtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW4gb25seSBzb3J0IGFycmF5cycpO1xuICAgIH1cblxuICAgIGlmICghY29tcGFyZSkge1xuICAgICAgY29tcGFyZSA9IGFscGhhYmV0aWNhbENvbXBhcmU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGkgPSBsbztcbiAgICAgIGxvID0gY29tcGFyZTtcbiAgICAgIGNvbXBhcmUgPSBhbHBoYWJldGljYWxDb21wYXJlO1xuICAgIH1cblxuICAgIGlmICghbG8pIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKCFoaSkge1xuICAgICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gICAgZG8ge1xuICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgfVxuXG4gICAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgICAgdHMubWVyZ2VSdW5zKCk7XG5cbiAgICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgICBsbyArPSBydW5MZW5ndGg7XG4gICAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlZlcnRpY2FsU3RyYXRlZ3kgPSBleHBvcnRzLkhvcml6b250YWxTdHJhdGVneSA9IHVuZGVmaW5lZDtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEhlbHBlciBjbGFzc2VzIGZvciBMYXlvdXRFbmdpbmUuXG4gKlxuICogU3RyYXRlZ3kgcGF0dGVybiBmb3IgdXNhZ2Ugb2YgZGlyZWN0aW9uIG1ldGhvZHMgZm9yIGhpZXJhcmNoaWNhbCBsYXlvdXRzLlxuICovXG52YXIgVGltU29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xuXG4vKipcbiAqIEludGVyZmFjZSBkZWZpbml0aW9uIGZvciBkaXJlY3Rpb24gc3RyYXRlZ3kgY2xhc3Nlcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGRlc2NyaWJlcyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgU3RyYXRlZ3lcbiAqIHBhdHRlcm4gY2xhc3NlcyB1c2VkIHRvIGRpZmZlcmVudGlhdGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAqIGRpcmVjdGlvbiBvZiBoaWVyYXJjaGljYWwgcmVzdWx0cy5cbiAqXG4gKiBGb3IgYSBnaXZlbiBkaXJlY3Rpb24sIG9uZSBjb29yZGluYXRlIHdpbGwgYmUgJ2ZpeGVkJywgbWVhbmluZyB0aGF0IGl0IGlzXG4gKiBkZXRlcm1pbmVkIGJ5IGxldmVsLlxuICogVGhlIG90aGVyIGNvb3JkaW5hdGUgaXMgJ3VuZml4ZWQnLCBtZWFuaW5nIHRoYXQgdGhlIG5vZGVzIG9uIGEgZ2l2ZW4gbGV2ZWxcbiAqIGNhbiBzdGlsbCBtb3ZlIGFsb25nIHRoYXQgY29vcmRpbmF0ZS4gU286XG4gKlxuICogLSBgdmVydGljYWxgIGxheW91dDogYHhgIHVuZml4ZWQsIGB5YCBmaXhlZCBwZXIgbGV2ZWxcbiAqIC0gYGhvcml6b250YWxgIGxheW91dDogYHhgIGZpeGVkIHBlciBsZXZlbCwgYHlgIHVuZml4ZWRcbiAqXG4gKiBUaGUgbG9jYWwgbWV0aG9kcyBhcmUgc3R1YnMgYW5kIHNob3VsZCBiZSByZWdhcmRlZCBhcyBhYnN0cmFjdC5cbiAqIERlcml2ZWQgY2xhc3NlcyAqKm11c3QqKiBpbXBsZW1lbnQgYWxsIHRoZSBtZXRob2RzIHRoZW1zZWx2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgRGlyZWN0aW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaXJlY3Rpb25JbnRlcmZhY2UoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRGlyZWN0aW9uSW50ZXJmYWNlKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKERpcmVjdGlvbkludGVyZmFjZSwgW3tcbiAgICBrZXk6ICdhYnN0cmFjdCcsXG5cbiAgICAvKiogQGlnbm9yZSAqKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyFcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGR1bW15IGNhbGwgd2hpY2ggaXMgdXNlZCB0byBzdXBwcmVzcyB0aGUganNkb2MgZXJyb3JzIG9mIHR5cGU6XG4gICAgICpcbiAgICAgKiAgIFwiJ3BhcmFtJyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkXCJcbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ2Zha2VfdXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZV91c2UoKSB7fVxuICAgIC8vIERvIG5vdGhpbmcgc3BlY2lhbFxuXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIHRvIHVzZSB0byB0cmFuc2xhdGUgZHluYW1pYyBjdXJ2ZXMgdG8sIGluIHRoZSBjYXNlIG9mIGhpZXJhcmNoaWNhbCBsYXlvdXQuXG4gICAgICogRHluYW1pYyBjdXJ2ZXMgZG8gbm90IHdvcmsgZm9yIHRoZXNlLlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIHNob3VsZCBiZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhY3R1YWwgZGlyZWN0aW9uIG9mIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IERpcmVjdGlvbiwgZWl0aGVyICd2ZXJ0aWNhbCcgb3IgJ2hvcml6b250YWwnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2N1cnZlVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0aGF0IGlzIG5vdCBmaXhlZCBmb3IgdGhpcyBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVhZFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVmFsdWUgb2YgdGhlIHVuZml4ZWQgY29vcmRpbmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdGhhdCBpcyBub3QgZml4ZWQgZm9yIHRoaXMgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWxdIGlmIHNwZWNpZmllZCwgdGhlIGhpZXJhcmNoeSBsZXZlbCB0aGF0IHRoaXMgbm9kZSBzaG91bGQgYmUgZml4ZWQgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSwgcG9zaXRpb24sIGxldmVsKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdpZHRoIG9mIGEgdHJlZS5cbiAgICAgKlxuICAgICAqIEEgYHRyZWVgIGhlcmUgaXMgYSBzdWJzZXQgb2Ygbm9kZXMgd2l0aGluIHRoZSBuZXR3b3JrIHdoaWNoIGFyZSBub3QgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzLFxuICAgICAqIG9ubHkgYW1vbmcgdGhlbXNlbHZlcy4gSW4gZXNzZW5jZSwgaXQgaXMgYSBzdWItbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggbnVtYmVyIG9mIGEgdHJlZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHdpZHRoIG9mIGEgdHJlZSBpbiB0aGUgdmlldyBjb29yZGluYXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUcmVlU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB0aGlzLmZha2VfdXNlKGluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29ydCBhcnJheSBvZiBub2RlcyBvbiB0aGUgdW5maXhlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBjaHJvbWUgaGFzIG5vbi1zdGFibGUgc29ydGluZyBpbXBsZW1lbnRhdGlvbiwgd2hpY2hcbiAgICAgKiBoYXMgYSB0ZW5kZW5jeSB0byBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBhcnJheSBpdGVtcyxcbiAgICAgKiBldmVuIGlmIHRoZSBjdXN0b20gc29ydCBmdW5jdGlvbiByZXR1cm5zIDAuXG4gICAgICpcbiAgICAgKiBGb3IgdGhpcyByZWFzb24sIGFuIGV4dGVybmFsIHNvcnQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCxcbiAgICAgKiB3aGljaCBoYXMgdGhlIGFkZGVkIGJlbmVmaXQgb2YgYmVpbmcgZmFzdGVyIHRoYW4gdGhlIHN0YW5kYXJkXG4gICAgICogcGxhdGZvcm1zIGltcGxlbWVudGF0aW9uLiBUaGlzIGhhcyBiZWVuIHZlcmlmaWVkIG9uIGBub2RlLmpzYCxcbiAgICAgKiBgZmlyZWZveGAgYW5kIGBjaHJvbWVgIChhbGwgbGludXgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVBcnJheSBhcnJheSBvZiBub2RlcyB0byBzb3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlQXJyYXkpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiB0aGUgZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSB0byB0aGUgZ2l2ZW4gbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgVGhlIGxldmVsIHRvIGZpeCB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXgobm9kZSwgbGV2ZWwpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSwgbGV2ZWwpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvZmZzZXQgdG8gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZUlkfSBub2RlSWQgSWQgb2YgdGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmYgT2Zmc2V0IHRvIGFkZCB0byB0aGUgdW5maXhlZCBjb29yZGluYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGVJZCwgZGlmZik7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEaXJlY3Rpb25JbnRlcmZhY2U7XG59KCk7XG5cbi8qKlxuICogVmVydGljYWwgU3RyYXRlZ3lcbiAqXG4gKiBDb29yZGluYXRlIGB5YCBpcyBmaXhlZCBvbiBsZXZlbHMsIGNvb3JkaW5hdGUgYHhgIGlzIHVuZml4ZWQuXG4gKlxuICogQGV4dGVuZHMgRGlyZWN0aW9uSW50ZXJmYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIFZlcnRpY2FsU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX0RpcmVjdGlvbkludGVyZmFjZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShWZXJ0aWNhbFN0cmF0ZWd5LCBfRGlyZWN0aW9uSW50ZXJmYWNlKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGxheW91dCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBMYXlvdXRFbmdpbmUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBWZXJ0aWNhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIFZlcnRpY2FsU3RyYXRlZ3kpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoVmVydGljYWxTdHJhdGVneS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoVmVydGljYWxTdHJhdGVneSkpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmVydGljYWxTdHJhdGVneSwgW3tcbiAgICBrZXk6ICdjdXJ2ZVR5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLng7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBub2RlLnggPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHJlZVNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4geyBtaW46IHJlcy5taW5feCwgbWF4OiByZXMubWF4X3ggfTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc29ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICBUaW1Tb3J0LnNvcnQobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS55ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueCArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmVydGljYWxTdHJhdGVneTtcbn0oRGlyZWN0aW9uSW50ZXJmYWNlKTtcblxuLyoqXG4gKiBIb3Jpem9udGFsIFN0cmF0ZWd5XG4gKlxuICogQ29vcmRpbmF0ZSBgeGAgaXMgZml4ZWQgb24gbGV2ZWxzLCBjb29yZGluYXRlIGB5YCBpcyB1bmZpeGVkLlxuICpcbiAqIEBleHRlbmRzIERpcmVjdGlvbkludGVyZmFjZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBIb3Jpem9udGFsU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX0RpcmVjdGlvbkludGVyZmFjZTIpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoSG9yaXpvbnRhbFN0cmF0ZWd5LCBfRGlyZWN0aW9uSW50ZXJmYWNlMik7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXQgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgTGF5b3V0RW5naW5lIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gSG9yaXpvbnRhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEhvcml6b250YWxTdHJhdGVneSk7XG5cbiAgICB2YXIgX3RoaXMyID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoSG9yaXpvbnRhbFN0cmF0ZWd5Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShIb3Jpem9udGFsU3RyYXRlZ3kpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzMi5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSG9yaXpvbnRhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogJ2N1cnZlVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnk7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBub2RlLnkgPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHJlZVNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4geyBtaW46IHJlcy5taW5feSwgbWF4OiByZXMubWF4X3kgfTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc29ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICBUaW1Tb3J0LnNvcnQobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS55IC0gYi55O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS54ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueSArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSG9yaXpvbnRhbFN0cmF0ZWd5O1xufShEaXJlY3Rpb25JbnRlcmZhY2UpO1xuXG5leHBvcnRzLkhvcml6b250YWxTdHJhdGVneSA9IEhvcml6b250YWxTdHJhdGVneTtcbmV4cG9ydHMuVmVydGljYWxTdHJhdGVneSA9IFZlcnRpY2FsU3RyYXRlZ3k7XG5cbi8qKiovIH0pLFxuLyogMTkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG4vKipcbiAqIENsZWFycyB0aGUgdG9vbGJhciBkaXYgZWxlbWVudCBvZiBjaGlsZHJlblxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIE1hbmlwdWxhdGlvblN5c3RlbSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb25IYW5kbGVyfSBzZWxlY3Rpb25IYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBNYW5pcHVsYXRpb25TeXN0ZW0oYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE1hbmlwdWxhdGlvblN5c3RlbSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG5cbiAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lZGl0TW9kZURpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzID0gW107XG4gICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMgPSBbXTtcblxuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLnRlbXBvcmFyeUlkcyA9IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfTtcbiAgICB0aGlzLmd1aUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGluaXRpYWxseUFjdGl2ZTogZmFsc2UsXG4gICAgICBhZGROb2RlOiB0cnVlLFxuICAgICAgYWRkRWRnZTogdHJ1ZSxcbiAgICAgIGVkaXROb2RlOiB1bmRlZmluZWQsXG4gICAgICBlZGl0RWRnZTogdHJ1ZSxcbiAgICAgIGRlbGV0ZU5vZGU6IHRydWUsXG4gICAgICBkZWxldGVFZGdlOiB0cnVlLFxuICAgICAgY29udHJvbE5vZGVTdHlsZToge1xuICAgICAgICBzaGFwZTogJ2RvdCcsXG4gICAgICAgIHNpemU6IDYsXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogJyNmZjAwMDAnLFxuICAgICAgICAgIGJvcmRlcjogJyMzYzNjM2MnLFxuICAgICAgICAgIGhpZ2hsaWdodDogeyBiYWNrZ3JvdW5kOiAnIzA3Zjk2OCcsIGJvcmRlcjogJyMzYzNjM2MnIH1cbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IDJcbiAgICAgIH1cbiAgICB9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9jbGVhbigpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZGF0YUNoYW5nZWQnLCB0aGlzLl9yZXN0b3JlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVzZXREYXRhJywgdGhpcy5fcmVzdG9yZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBzb21ldGhpbmcgY2hhbmdlcyBpbiB0aGUgZGF0YSBkdXJpbmcgZWRpdGluZywgc3dpdGNoIGJhY2sgdG8gdGhlIGluaXRpYWwgZGF0YW1hbmlwdWxhdGlvbiBzdGF0ZSBhbmQgY2xvc2UgYWxsIGVkaXQgbW9kZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTWFuaXB1bGF0aW9uU3lzdGVtLCBbe1xuICAgIGtleTogJ19yZXN0b3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmUoKSB7XG4gICAgICBpZiAodGhpcy5pbk1vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBpZiAoYWxsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGFsbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBnbG9iYWxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGFsbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGdsb2JhbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZWRpdC1tb2RlLiBEcmF3cyB0aGUgRE9NIHJlcXVpcmVkIGFuZCBjbGVhbnMgdXAgYWZ0ZXIgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9nZ2xlRWRpdE1vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFZGl0TW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRWRpdE1vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUVkaXRNb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtYWluIHRvb2xiYXIuIFJlbW92ZXMgZnVuY3Rpb25zIGJvdW5kIHRvIHRoZSBzZWxlY3QgZXZlbnQuIEJpbmRzIGFsbCB0aGUgYnV0dG9ucyBvZiB0aGUgdG9vbGJhci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Nob3dNYW5pcHVsYXRvclRvb2xiYXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93TWFuaXB1bGF0b3JUb29sYmFyKCkge1xuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIC8vIHJlc2V0IGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgIC8vIGlmIHRoZSBndWkgaXMgZW5hYmxlZCwgZHJhdyBhbGwgZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGEgX3Jlc3RvcmUgd2lsbCBoaWRlIHRoZXNlIG1lbnVzXG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkTm9kZUNvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3RlZEVkZ2VDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkVG90YWxDb3VudCA9IHNlbGVjdGVkTm9kZUNvdW50ICsgc2VsZWN0ZWRFZGdlQ291bnQ7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdmFyIG5lZWRTZXBlcmF0b3IgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZE5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID09PSAxICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYnV0dG9uc1xuICAgICAgICBpZiAoc2VsZWN0ZWRUb3RhbENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID4gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIHRoaXMudG9nZ2xlRWRpdE1vZGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGlzIGJhciBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHNlbGVjdGVkXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudCgnc2VsZWN0JywgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWRyYXcgdG8gc2hvdyBhbnkgcG9zc2libGUgY2hhbmdlc1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgdG9vbGJhciBmb3IgYWRkaW5nIE5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZE5vZGVNb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZU1vZGUoKSB7XG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHRoaXMuaW5Nb2RlID0gJ2FkZE5vZGUnO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVsnYWRkRGVzY3JpcHRpb24nXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkRGVzY3JpcHRpb24nXSk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoJ2NsaWNrJywgdGhpcy5fcGVyZm9ybUFkZE5vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2FsbCB0aGUgYm91bmQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIHRoZSBub2RlLiBUaGUgbm9kZSBoYXMgdG8gYmUgc2VsZWN0ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VkaXROb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE5vZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmluTW9kZSA9ICdlZGl0Tm9kZSc7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgbm9kZS5vcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICBkYXRhLnggPSBub2RlLng7XG4gICAgICAgICAgICBkYXRhLnkgPSBub2RlLnk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdE5vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0Tm9kZShkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczIuaW5Nb2RlID09PSAnZWRpdE5vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMyLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnZWRpdENsdXN0ZXJFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0Q2x1c3RlckVycm9yJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIG5vZGVzLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdGhlIHRvb2xiYXIgdG8gY29ubmVjdCBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRFZGdlTW9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2VNb2RlKCkge1xuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9ICdhZGRFZGdlJztcbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbJ2VkZ2VEZXNjcmlwdGlvbiddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGdlRGVzY3JpcHRpb24nXSk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBmdW5jdGlvbnNcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25Ub3VjaCcsIHRoaXMuX2hhbmRsZUNvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZ0VuZCcsIHRoaXMuX2ZpbmlzaENvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZycsIHRoaXMuX2RyYWdDb250cm9sTm9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25SZWxlYXNlJywgdGhpcy5fZmluaXNoQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnU3RhcnQnLCB0aGlzLl9kcmFnU3RhcnRFZGdlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkhvbGQnLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGVkaXQgZWRnZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWRpdEVkZ2VNb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEVkZ2VNb2RlKCkge1xuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc24ndCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5pbk1vZGUgPSAnZWRpdEVkZ2UnO1xuICAgICAgaWYgKCgwLCBfdHlwZW9mM1snZGVmYXVsdCddKSh0aGlzLm9wdGlvbnMuZWRpdEVkZ2UpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXRFZGdlLmVkaXRXaXRob3V0RHJhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZXMoKVswXTtcbiAgICAgICAgaWYgKHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgICAgIHRoaXMuX3BlcmZvcm1FZGl0RWRnZShlZGdlLmZyb20sIGVkZ2UudG8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVsnZWRpdEVkZ2VEZXNjcmlwdGlvbiddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0RWRnZURlc2NyaXB0aW9uJ10pO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYodGhpcy5jbG9zZURpdiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VzKClbMF07XG4gICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTtcblxuICAgICAgICAvLyBjcmVhdGUgY29udHJvbCBub2Rlc1xuICAgICAgICB2YXIgY29udHJvbE5vZGVGcm9tID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShfZWRnZS5mcm9tLngsIF9lZGdlLmZyb20ueSk7XG4gICAgICAgIHZhciBjb250cm9sTm9kZVRvID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShfZWRnZS50by54LCBfZWRnZS50by55KTtcblxuICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVUby5pZCk7XG5cbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlRnJvbS5pZF0gPSBjb250cm9sTm9kZUZyb207XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tjb250cm9sTm9kZVRvLmlkXSA9IGNvbnRyb2xOb2RlVG87XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpO1xuXG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIFVJIGZ1bmN0aW9ucywgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2YgX3RlbXBvcmFyeUJpbmRVSVxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uVG91Y2gnLCB0aGlzLl9jb250cm9sTm9kZVRvdWNoLmJpbmQodGhpcykpOyAvLyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvblRhcCcsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkhvbGQnLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnU3RhcnQnLCB0aGlzLl9jb250cm9sTm9kZURyYWdTdGFydC5iaW5kKHRoaXMpKTsgLy8gdXNlZCB0byBzZWxlY3QgY29udHJvbCBub2RlXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnJywgdGhpcy5fY29udHJvbE5vZGVEcmFnLmJpbmQodGhpcykpOyAvLyB1c2VkIHRvIGRyYWcgY29udHJvbCBub2RlXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnRW5kJywgdGhpcy5fY29udHJvbE5vZGVEcmFnRW5kLmJpbmQodGhpcykpOyAvLyB1c2VkIHRvIGNvbm5lY3Qgb3IgcmV2ZXJ0IGNvbnRyb2wgbm9kZXNcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbk1vdXNlTW92ZScsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcblxuICAgICAgICAvLyBjcmVhdGUgZnVuY3Rpb24gdG8gcG9zaXRpb24gY29udHJvbCBub2RlcyBjb3JyZWN0bHkgb24gbW92ZW1lbnRcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSBjbGVhbmVkIHVwIGJlY2F1c2Ugd2UgdXNlIHRoZSB0ZW1wb3JhcnkgYmluZFxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoJ2JlZm9yZURyYXdpbmcnLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IF9lZGdlLmVkZ2VUeXBlLmZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KTtcbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVGcm9tLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnggPSBwb3NpdGlvbnMuZnJvbS54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnkgPSBwb3NpdGlvbnMuZnJvbS55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVUby5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueCA9IHBvc2l0aW9ucy50by54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVUby55ID0gcG9zaXRpb25zLnRvLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWxldGUgZXZlcnl0aGluZyBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVNlbGVjdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlU2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9ICdkZWxldGUnO1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlcygpO1xuICAgICAgdmFyIHNlbGVjdGVkRWRnZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIGRlbGV0ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3NlbGVjdGVkTm9kZXNbaV1dLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bJ2RlbGV0ZUNsdXN0ZXJFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydkZWxldGVDbHVzdGVyRXJyb3InXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVFZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVsZXRlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9O1xuICAgICAgICBpZiAoZGVsZXRlRnVuY3Rpb24ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24oZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczMuaW5Nb2RlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGZpbmFsaXplZERhdGEuZWRnZXMpO1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5ub2Rlcyk7XG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgICAgICAgIF90aGlzMy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICAgICAgICBfdGhpczMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBkZWxldGUgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZEVkZ2VzKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQUklWQVRFICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8vXG5cbiAgICAvKipcbiAgICAgKiBkcmF3IG9yIHJlbW92ZSB0aGUgRE9NXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldHVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIEVuYWJsZSB0aGUgR1VJXG4gICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlV3JhcHBlcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVNYW5pcHVsYXRpb25ET00oKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBndWlcbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSBkaXYgb3ZlcmxheXMgdGhhdCBjb250YWluIHRoZSBET01cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlV3JhcHBlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlV3JhcHBlcnMoKSB7XG4gICAgICAvLyBsb2FkIHRoZSBtYW5pcHVsYXRvciBIVE1MIGVsZW1lbnRzLiBBbGwgc3R5bGluZyBkb25lIGluIGNzcy5cbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmNsYXNzTmFtZSA9ICd2aXMtbWFuaXB1bGF0aW9uJztcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIH1cblxuICAgICAgLy8gY29udGFpbmVyIGZvciB0aGUgZWRpdCBidXR0b24uXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5jbGFzc05hbWUgPSAndmlzLWVkaXQtbW9kZSc7XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnRhaW5lciBmb3IgdGhlIGNsb3NlIGRpdiBidXR0b25cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LmNsYXNzTmFtZSA9ICd2aXMtY2xvc2UnO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNsb3NlRGl2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIG5ldyB0YXJnZXQgbm9kZS4gVXNlZCBmb3IgY3JlYXRpbmcgbmV3IGVkZ2VzIGFuZCBlZGl0aW5nIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldE5ld1RhcmdldE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TmV3VGFyZ2V0Tm9kZSh4LCB5KSB7XG4gICAgICB2YXIgY29udHJvbE5vZGVTdHlsZSA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmNvbnRyb2xOb2RlU3R5bGUpO1xuXG4gICAgICBjb250cm9sTm9kZVN0eWxlLmlkID0gJ3RhcmdldE5vZGUnICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5waHlzaWNzID0gZmFsc2U7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnggPSB4O1xuICAgICAgY29udHJvbE5vZGVTdHlsZS55ID0geTtcblxuICAgICAgLy8gd2UgaGF2ZSB0byBkZWZpbmUgdGhlIGJvdW5kaW5nIGJveCBpbiBvcmRlciBmb3IgdGhlIG5vZGVzIHRvIGJlIGRyYXduIGltbWVkaWF0ZWx5XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZShjb250cm9sTm9kZVN0eWxlKTtcbiAgICAgIG5vZGUuc2hhcGUuYm91bmRpbmdCb3ggPSB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHksIGJvdHRvbTogeSB9O1xuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGVkaXQgYnV0dG9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVFZGl0QnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRCdXR0b24oKSB7XG4gICAgICAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoaWYgYXBwbGljYWJsZSlcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIC8vIHJlc2V0IHRoZSBtYW5pcHVsYXRpb25ET01cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgIC8vIGVtcHR5IHRoZSBlZGl0TW9kZURpdlxuICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGVudHMgZm9yIHRoZSBlZGl0TW9kZSBidXR0b25cbiAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2VkaXRNb2RlJywgJ3Zpcy1idXR0b24gdmlzLWVkaXQgdmlzLWVkaXQtbW9kZScsIGxvY2FsZVsnZWRpdCddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0J10pO1xuICAgICAgdGhpcy5lZGl0TW9kZURpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICAvLyBiaW5kIGEgaGFtbWVyIGxpc3RlbmVyIHRvIHRoZSBidXR0b24sIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlLlxuICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGNsZWFucyB1cCBhZnRlciBldmVyeXRoaW5nIHRoaXMgbW9kdWxlIGRvZXMuIFRlbXBvcmFyeSBlbGVtZW50cywgZnVuY3Rpb25zIGFuZCBldmVudHMgYXJlIHJlbW92ZWQsIHBoeXNpY3MgcmVzdG9yZWQsIGhhbW1lcnMgcmVtb3ZlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2xlYW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICAvLyBub3QgaW4gbW9kZVxuICAgICAgdGhpcy5pbk1vZGUgPSBmYWxzZTtcblxuICAgICAgLy8gX2NsZWFuIHRoZSBkaXZzXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG5cbiAgICAgICAgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcbiAgICAgICAgdGhpcy5fY2xlYW5NYW5pcHVsYXRvckhhbW1lcnMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXNcbiAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7XG5cbiAgICAgIC8vIHJlc3RvcmUgb3ZlcmxvYWRlZCBVSSBmdW5jdGlvbnNcbiAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeVVJcygpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zXG4gICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlFdmVudHMoKTtcblxuICAgICAgLy8gcmVzdG9yZSB0aGUgcGh5c2ljcyBpZiByZXF1aXJlZFxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzdG9yZVBoeXNpY3MnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFYWNoIGRvbSBlbGVtZW50IGhhcyBpdCdzIG93biBoYW1tZXIuIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMuIFRoaXMgY2xlYW5zIHRoZW0gdXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzKCkge1xuICAgICAgLy8gX2NsZWFuIGhhbW1lciBiaW5kaW5nc1xuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBET00gZWxlbWVudHMgY3JlYXRlZCBieSB0aGlzIG1vZHVsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZU1hbmlwdWxhdGlvbkRPTSgpIHtcbiAgICAgIC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAvLyBlbXB0eSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5jbG9zZURpdik7XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHJlZmVyZW5jZXMgdG8gdW5kZWZpbmVkXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHNlcGVyYXRvciBsaW5lLiB0aGUgaW5kZXggaXMgdG8gZGlmZmVyZW50aWF0ZSBpbiB0aGUgbWFuaXB1bGF0aW9uIGRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlU2VwZXJhdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVNlcGVyYXRvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bJ3NlcGVyYXRvckxpbmVEaXYnICsgaW5kZXhdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVsnc2VwZXJhdG9yTGluZURpdicgKyBpbmRleF0uY2xhc3NOYW1lID0gJ3Zpcy1zZXBhcmF0b3ItbGluZSc7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVsnc2VwZXJhdG9yTGluZURpdicgKyBpbmRleF0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlQWRkTm9kZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignYWRkTm9kZScsICd2aXMtYnV0dG9uIHZpcy1hZGQnLCBsb2NhbGVbJ2FkZE5vZGUnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkTm9kZSddKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmFkZE5vZGVNb2RlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVBZGRFZGdlQnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdhZGRFZGdlJywgJ3Zpcy1idXR0b24gdmlzLWNvbm5lY3QnLCBsb2NhbGVbJ2FkZEVkZ2UnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkRWRnZSddKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmFkZEVkZ2VNb2RlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVFZGl0Tm9kZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2VkaXROb2RlJywgJ3Zpcy1idXR0b24gdmlzLWVkaXQnLCBsb2NhbGVbJ2VkaXROb2RlJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2VkaXROb2RlJ10pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZWRpdE5vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUVkaXRFZGdlQnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignZWRpdEVkZ2UnLCAndmlzLWJ1dHRvbiB2aXMtZWRpdCcsIGxvY2FsZVsnZWRpdEVkZ2UnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRpdEVkZ2UnXSk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5lZGl0RWRnZU1vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZURlbGV0ZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgZGVsZXRlQnRuQ2xhc3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkZWxldGVCdG5DbGFzcyA9ICd2aXMtYnV0dG9uIHZpcy1kZWxldGUtcnRsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUJ0bkNsYXNzID0gJ3Zpcy1idXR0b24gdmlzLWRlbGV0ZSc7XG4gICAgICB9XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdkZWxldGUnLCBkZWxldGVCdG5DbGFzcywgbG9jYWxlWydkZWwnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZGVsJ10pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZGVsZXRlU2VsZWN0ZWQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUJhY2tCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2JhY2snLCAndmlzLWJ1dHRvbiB2aXMtYmFjaycsIGxvY2FsZVsnYmFjayddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydiYWNrJ10pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtsYWJlbH0gbGFiZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxDbGFzc05hbWVcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgbGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbENsYXNzTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJ3Zpcy1sYWJlbCc7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdEaXYnXS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3NOYW1lO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnTGFiZWwnXS5pbm5lckhUTUwgPSBsYWJlbDtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0xhYmVsJ10pO1xuICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlRGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRGVzY3JpcHRpb24obGFiZWwpIHtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUJ1dHRvbignZGVzY3JpcHRpb24nLCAndmlzLWJ1dHRvbiB2aXMtbm9uZScsIGxhYmVsKSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRW5kIG9mIERPTSBmdW5jdGlvbnMgZm9yIGJ1dHRvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgYmluZHMgYW4gZXZlbnQgdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG5ld0Z1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3RlbXBvcmFyeUJpbmRFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kRXZlbnQoZXZlbnQsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGJvdW5kRnVuY3Rpb246IG5ld0Z1bmN0aW9uXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKGV2ZW50LCBuZXdGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBvdmVycmlkZXMgYW4gVUkgZnVuY3Rpb24gdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gVUlmdW5jdGlvbk5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ190ZW1wb3JhcnlCaW5kVUknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVtcG9yYXJ5QmluZFVJKFVJZnVuY3Rpb25OYW1lLCBuZXdGdW5jdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW1VJZnVuY3Rpb25OYW1lXSA9IHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV07XG4gICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gPSBuZXdGdW5jdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiAnICsgVUlmdW5jdGlvbk5hbWUgKyAnIHBvc3NpYmxlIGFyZTogJyArICgwLCBfc3RyaW5naWZ5MlsnZGVmYXVsdCddKSgoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuYm9keS5ldmVudExpc3RlbmVycykpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBvdmVycmlkZGVuIFVJIGZ1bmN0aW9ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191bmJpbmRUZW1wb3JhcnlVSXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5VUlzKCkge1xuICAgICAgZm9yICh2YXIgZnVuY3Rpb25OYW1lIGluIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tmdW5jdGlvbk5hbWVdID0gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgdGhlIGV2ZW50cyBjcmVhdGVkIGJ5IF90ZW1wb3JhcnlCaW5kRXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ldmVudDtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW2ldLmJvdW5kRnVuY3Rpb247XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihldmVudE5hbWUsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmQgYW4gaGFtbWVyIGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBib3VuZEZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19iaW5kSGFtbWVyVG9EaXYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lclRvRGl2KGRvbUVsZW1lbnQsIGJvdW5kRnVuY3Rpb24pIHtcbiAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKGRvbUVsZW1lbnQsIHt9KTtcbiAgICAgIGhhbW1lclV0aWwub25Ub3VjaChoYW1tZXIsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWF0bHkgY2xlYW4gdXAgdGVtcG9yYXJ5IGVkZ2VzIGFuZCBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpIHtcbiAgICAgIC8vIF9jbGVhbiB0ZW1wb3JhcnkgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXS5kaXNjb25uZWN0KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dO1xuICAgICAgICB2YXIgaW5kZXhUZW1wRWRnZSA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5pbmRleE9mKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldKTtcbiAgICAgICAgaWYgKGluZGV4VGVtcEVkZ2UgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnNwbGljZShpbmRleFRlbXBFZGdlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBfY2xlYW4gdGVtcG9yYXJ5IG5vZGVzXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldXTtcbiAgICAgICAgdmFyIGluZGV4VGVtcE5vZGUgPSB0aGlzLmJvZHkubm9kZUluZGljZXMuaW5kZXhPZih0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tfaV0pO1xuICAgICAgICBpZiAoaW5kZXhUZW1wTm9kZSAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMuc3BsaWNlKGluZGV4VGVtcE5vZGUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVtcG9yYXJ5SWRzID0geyBub2RlczogW10sIGVkZ2VzOiBbXSB9O1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoZSB0b3VjaCBpcyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGluaXRpYWwgY2xpY2tcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY29udHJvbE5vZGVUb3VjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZVRvdWNoKGV2ZW50KSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZSBkcmFnIHN0YXJ0IGlzIHVzZWQgdG8gbWFyayBvbmUgb2YgdGhlIGNvbnRyb2wgbm9kZXMgYXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0KCkgLyogZXZlbnQgKi97XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuICAgICAgdmFyIHRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzFdXTtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgZnJvbVNlbGVjdCA9IGZyb20uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgdG9TZWxlY3QgPSB0by5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgaWYgKGZyb21TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gZnJvbTtcbiAgICAgICAgZWRnZS5lZGdlVHlwZS5mcm9tID0gZnJvbTtcbiAgICAgIH0gZWxzZSBpZiAodG9TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdG87XG4gICAgICAgIGVkZ2UuZWRnZVR5cGUudG8gPSB0bztcbiAgICAgIH1cblxuICAgICAgLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgc2VsZWN0IGl0IGhlcmUuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdCh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZHJhZ2dpbmcgdGhlIGNvbnRyb2wgbm9kZXMgb3IgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jb250cm9sTm9kZURyYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnKGV2ZW50KSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdkaXNhYmxlUGh5c2ljcycpO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueCA9IHBvcy54O1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueSA9IHBvcy55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgdmFyIGRpZmZYID0gcG9pbnRlci54IC0gdGhpcy5sYXN0VG91Y2gueDtcbiAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5sYXN0VG91Y2gueTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24ueCArIGRpZmZYLFxuICAgICAgICAgIHk6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnkgKyBkaWZmWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3Rpbmcgb3IgcmVzdG9yaW5nIHRoZSBjb250cm9sIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jb250cm9sTm9kZURyYWdFbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICAvLyBpZiB0aGUgbm9kZSB0aGF0IHdhcyBkcmFnZ2VkIGlzIG5vdCBhIGNvbnRyb2wgbm9kZSwgcmV0dXJuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSB1c2UgdGhlIHNlbGVjdGlvbiB0byBmaW5kIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZC4gV2UgZXhwbGljaXRseSBERXNlbGVjdCB0aGUgY29udHJvbCBub2RlIGhlcmUuXG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChvdmVybGFwcGluZ05vZGVJZHNbaV0gIT09IHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCA9PT0gZnJvbS5pZCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKG5vZGUuaWQsIGVkZ2UudG8uaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBub2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UudXBkYXRlRWRnZVR5cGUoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzdG9yZVBoeXNpY3MnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEFERCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgLyoqXG4gICAgICogdGhlIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzZWxlY3Rpb24gZXZlbnQuIEl0IGNoZWNrcyBpZiB5b3Ugd2FudCB0byBjb25uZWN0IGEgY2x1c3RlciBhbmQgY2hhbmdlcyB0aGUgZGVzY3JpcHRpb25cbiAgICAgKiB0byB3YWxrIHRoZSB1c2VyIHRocm91Z2ggdGhlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVDb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3QoZXZlbnQpIHtcbiAgICAgIC8vIGNoZWNrIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwMCkge1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuXG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbm9kZSB0aGUgdGVtcG9yYXJ5IGxpbmUgY2FuIGxvb2sgYXRcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShub2RlLngsIG5vZGUueSk7XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGFyZ2V0Tm9kZS5pZF0gPSB0YXJnZXROb2RlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2godGFyZ2V0Tm9kZS5pZCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBlZGdlXG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkVkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uoe1xuICAgICAgICAgICAgICBpZDogJ2Nvbm5lY3Rpb25FZGdlJyArIHV0aWwucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgICBmcm9tOiBub2RlLmlkLFxuICAgICAgICAgICAgICB0bzogdGFyZ2V0Tm9kZS5pZCxcbiAgICAgICAgICAgICAgcGh5c2ljczogZmFsc2UsXG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRpbnVvdXMnLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2Nvbm5lY3Rpb25FZGdlLmlkXSA9IGNvbm5lY3Rpb25FZGdlO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuXG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKHRhcmdldE5vZGUuaWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmFnQ29udHJvbE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ0NvbnRyb2xOb2RlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICAvLyByZW1lbWJlciB0aGUgZWRnZSBpZFxuICAgICAgdmFyIGNvbm5lY3RGcm9tSWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0RnJvbUlkID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQ7XG4gICAgICB9XG4gICAgICAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXMuaW5kZXhPZihvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHsgZnJvbTogY29ubmVjdEZyb21JZCwgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkIH07XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY29udHJvbE5vZGVEcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSB0ZW1wIG5vZGUgaW4gdGhlIGFkZCBlZGdlIG1vZGUuXG4gICAgICAgIHRhcmdldE5vZGUueCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICAgIHRhcmdldE5vZGUueSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMubGFzdFRvdWNoLng7XG4gICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMubGFzdFRvdWNoLnk7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnggKyBkaWZmWCxcbiAgICAgICAgICB5OiB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbi55ICsgZGlmZllcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRoZSBuZXcgZWRnZSB0byB0aGUgdGFyZ2V0IGlmIG9uZSBleGlzdHMsIG90aGVyd2lzZSByZW1vdmUgdGVtcCBsaW5lXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmlzaENvbm5lY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluaXNoQ29ubmVjdChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgLy8gcmVtZW1iZXIgdGhlIGVkZ2UgaWRcbiAgICAgIHZhciBjb25uZWN0RnJvbUlkID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29ubmVjdEZyb21JZCA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXV0uZnJvbUlkO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXMuaW5kZXhPZihvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjbGVhbiB0ZW1wb3Jhcnkgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTtcblxuICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2Nvbm5lY3RGcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW25vZGUuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1BZGRFZGdlKGNvbm5lY3RGcm9tSWQsIG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHsgZnJvbTogY29ubmVjdEZyb21JZCwgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkIH07XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY29udHJvbE5vZGVEcmFnRW5kJywgZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICAvLyBObyBuZWVkIHRvIGRvIF9nZW5lcmF0ZWNsaWNrZXZlbnQoJ2RyYWdFbmQnKSBoZXJlLCB0aGUgcmVndWxhciBkcmFnRW5kIGV2ZW50IGZpcmVzLlxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhZ1N0YXJ0RWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmFnU3RhcnRFZGdlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBlcmZvcm1pbmcgYWxsIHRoZSBhY3R1YWwgZGF0YSBtYW5pcHVsYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBub2RlIG9uIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGlja0RhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcGVyZm9ybUFkZE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZE5vZGUoY2xpY2tEYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBpZDogdXRpbC5yYW5kb21VVUlEKCksXG4gICAgICAgIHg6IGNsaWNrRGF0YS5wb2ludGVyLmNhbnZhcy54LFxuICAgICAgICB5OiBjbGlja0RhdGEucG9pbnRlci5jYW52YXMueSxcbiAgICAgICAgbGFiZWw6ICduZXcnXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWRkTm9kZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczQuaW5Nb2RlID09PSAnYWRkTm9kZScpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgIF90aGlzNC5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLmFkZChmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gZm9yIGFkZCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHR3byBub2RlcyB3aXRoIGEgbmV3IGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHNvdXJjZU5vZGVJZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdGFyZ2V0Tm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BlcmZvcm1BZGRFZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1BZGRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0geyBmcm9tOiBzb3VyY2VOb2RlSWQsIHRvOiB0YXJnZXROb2RlSWQgfTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkZEVkZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGRFZGdlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNS5pbk1vZGUgPT09ICdhZGRFZGdlJykge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgX3RoaXM1LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICBfdGhpczUuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICBfdGhpczUuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBjb25uZWN0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLmFkZChkZWZhdWx0RGF0YSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHR3byBub2RlcyB3aXRoIGEgbmV3IGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHNvdXJjZU5vZGVJZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdGFyZ2V0Tm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BlcmZvcm1FZGl0RWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtRWRpdEVkZ2Uoc291cmNlTm9kZUlkLCB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICAgIGlkOiB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkLFxuICAgICAgICBmcm9tOiBzb3VyY2VOb2RlSWQsXG4gICAgICAgIHRvOiB0YXJnZXROb2RlSWQsXG4gICAgICAgIGxhYmVsOiB0aGlzLmJvZHkuZGF0YS5lZGdlcy5fZGF0YVt0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXS5sYWJlbFxuICAgICAgfTtcbiAgICAgIHZhciBlZUZ1bmN0ID0gdGhpcy5vcHRpb25zLmVkaXRFZGdlO1xuICAgICAgaWYgKCh0eXBlb2YgZWVGdW5jdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShlZUZ1bmN0KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGVlRnVuY3QgPSBlZUZ1bmN0LmVkaXRXaXRob3V0RHJhZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWVGdW5jdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoZWVGdW5jdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBlZUZ1bmN0KGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgPT09IG51bGwgfHwgZmluYWxpemVkRGF0YSA9PT0gdW5kZWZpbmVkIHx8IF90aGlzNi5pbk1vZGUgIT09ICdlZGl0RWRnZScpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmVkZ2VzW2RlZmF1bHREYXRhLmlkXS51cGRhdGVFZGdlVHlwZSgpO1xuICAgICAgICAgICAgICBfdGhpczYuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGRlZmF1bHREYXRhKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFuaXB1bGF0aW9uU3lzdGVtO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNYW5pcHVsYXRpb25TeXN0ZW07XG5cbi8qKiovIH0pLFxuLyogMTkxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQ29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MilbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIHRoaXMucG9zc2libGUgb3B0aW9ucywgeW91IGNhbiBzdXBwbHkgdGhlIHByb3BlcnR5IG5hbWUgaW4gYW55IGZvcm0gdG8gbGlzdCB0aGUgb3B0aW9ucy5cbiAqIEJvb2xlYW4gb3B0aW9ucyBhcmUgcmVjb2duaXNlZCBhcyBCb29sZWFuXG4gKiBOdW1iZXIgb3B0aW9ucyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW2RlZmF1bHQgdmFsdWUsIG1pbiB2YWx1ZSwgbWF4IHZhbHVlLCBzdGVwc2l6ZV1cbiAqIENvbG9ycyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogWydjb2xvcicsICcjZmZmZmZmJ11cbiAqIFN0cmluZ3Mgd2l0aCBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW29wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIC4uXVxuICpcbiAqIFRoZSBvcHRpb25zIGFyZSBtYXRjaGVkIHdpdGggdGhlaXIgY291bnRlcnBhcnRzIGluIGVhY2ggb2YgdGhlIG1vZHVsZXMgYW5kIHRoZSB2YWx1ZXMgdXNlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBhcmVcbiAqL1xuXG52YXIgQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudE1vZHVsZSAgICAgICAgfCB0aGUgbG9jYXRpb24gd2hlcmUgcGFyZW50TW9kdWxlLnNldE9wdGlvbnMoKSBjYW4gYmUgY2FsbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29udGFpbmVyICAgIHwgdGhlIGRlZmF1bHQgY29udGFpbmVyIG9mIHRoZSBtb2R1bGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyZU9wdGlvbnMgICAgfCB0aGUgZnVsbHkgY29uZmlndXJlZCBhbmQgcHJlZGVmaW5lZCBvcHRpb25zIHNldCBmb3VuZCBpbiBhbGxPcHRpb25zLmpzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvICAgICAgICAgIHwgY2FudmFzIHBpeGVsIHJhdGlvXG4gICAqL1xuICBmdW5jdGlvbiBDb25maWd1cmF0b3IocGFyZW50TW9kdWxlLCBkZWZhdWx0Q29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ29uZmlndXJhdG9yKTtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50TW9kdWxlO1xuICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXI7XG4gICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5wb3B1cENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgc2hvd0J1dHRvbjogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG4gICAgdGhpcy5tb2R1bGVPcHRpb25zID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB0aGlzLnBvcHVwTGltaXQgPSA1O1xuICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgdGhpcy5jb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcihwaXhlbFJhdGlvKTtcbiAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKENvbmZpZ3VyYXRvciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBwb3B1cCBoaXN0b3J5IGJlY2F1c2UgdGhlIGluZGljZXMgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuXG4gICAgICAgIHZhciBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmpvaW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkob3B0aW9ucykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgY2Fubm90IGJlIG51bGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0J1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9IG9wdGlvbnMuc2hvd0J1dHRvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IHRydWU7XG4gICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZU9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TW9kdWxlT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgICAgdGhpcy5tb2R1bGVPcHRpb25zID0gbW9kdWxlT3B0aW9ucztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciBzaG93ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBvcHRpb24gaW4gdGhpcy5jb25maWd1cmVPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyZU9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihvcHRpb24sIFtdKTtcbiAgICAgICAgICAgIHNob3cgPSBzaG93IHx8IHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0sIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyID09PSB0cnVlIHx8IGZpbHRlci5pbmRleE9mKG9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGxpbmVicmVhayBiZXR3ZWVuIGNhdGVnb3JpZXNcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgICB0aGlzLl9tYWtlSGVhZGVyKG9wdGlvbik7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgc3ViIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX21ha2VCdXR0b24oKTtcbiAgICAgIHRoaXMuX3B1c2goKTtcbiAgICAgIC8vfiB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1c2goKSB7XG4gICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMud3JhcHBlci5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlcic7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2hvd1BvcHVwSWZOZWVkZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWxldGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbGVhbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhY3R1YWxPcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWYWx1ZShwYXRoKSB7XG4gICAgICB2YXIgYmFzZSA9IHRoaXMubW9kdWxlT3B0aW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmFzZVtwYXRoW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYmFzZSA9IGJhc2VbcGF0aFtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWxsIG9wdGlvbiBlbGVtZW50cyBhcmUgd3JhcHBlZCBpbiBhbiBpdGVtXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IGRvbUVsZW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbWFrZUl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUl0ZW0ocGF0aCkge1xuICAgICAgaWYgKHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpdGVtLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWl0ZW0gdmlzLWNvbmZpZy1zJyArIHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkb21FbGVtZW50cyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBkb21FbGVtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBkb21FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVhZGVyIGZvciBtYWpvciBzdWJqZWN0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VIZWFkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUhlYWRlcihuYW1lKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyJztcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBuYW1lO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0oW10sIGRpdik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGxhYmVsLCBpZiBpdCBpcyBhbiBvYmplY3QgbGFiZWwsIGl0IGdldHMgZGlmZmVyZW50IHN0eWxpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TGFiZWxcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VMYWJlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlTGFiZWwobmFtZSwgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdExhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWxhYmVsIHZpcy1jb25maWctcycgKyBwYXRoLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzxpPjxiPicgKyBuYW1lICsgJzo8L2I+PC9pPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gbmFtZSArICc6JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGRyb3Bkb3duIGxpc3QgZm9yIG11bHRpcGxlIHBvc3NpYmxlIHN0cmluZyBvcHRvaW5zXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VEcm9wZG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdCc7XG4gICAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IDA7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJyLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBhcnIuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBhcnJbaV07XG4gICAgICAgIGlmIChpID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gJ3NlbGVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gYXJyW2ldO1xuICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHNlbGVjdC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHNlbGVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICAgIHZhciBtaW4gPSBhcnJbMV07XG4gICAgICB2YXIgbWF4ID0gYXJyWzJdO1xuICAgICAgdmFyIHN0ZXAgPSBhcnJbM107XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgcmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2UnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIG5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICAgIHJhbmdlLm1pbiA9IG1pbjtcbiAgICAgICAgcmFuZ2UubWF4ID0gbWF4O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgLy8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcgYW5kIHJlbW92ZSB0aGlzIGxpbnQgZXhjZXB0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICByYW5nZS5zdGVwID0gc3RlcDtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBwb3B1cCBzZXR0aW5ncyBpbiBjYXNlIHRoZXkgYXJlIG5lZWRlZC5cbiAgICAgIHZhciBwb3B1cFN0cmluZyA9ICcnO1xuICAgICAgdmFyIHBvcHVwVmFsdWUgPSAwO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmFjdG9yID0gMS4yO1xuICAgICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgLyBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgLyBmYWN0b3IpO1xuICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWF4O1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgaW5wdXQuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VpbnB1dCc7XG4gICAgICBpbnB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgcmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbWUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksIHBhdGgpO1xuICAgICAgfTtcbiAgICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdmFyIGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpO1xuXG4gICAgICAvLyBpZiBhIHBvcHVwIGlzIG5lZWRlZCBBTkQgaXQgaGFzIG5vdCBiZWVuIHNob3duIGZvciB0aGlzIHZhbHVlLCBzaG93IGl0LlxuICAgICAgaWYgKHBvcHVwU3RyaW5nICE9PSAnJyAmJiB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdICE9PSBwb3B1cFZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuICAgICAgICB0aGlzLl9zZXR1cFBvcHVwKHBvcHVwU3RyaW5nLCBpdGVtSW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBidXR0b24gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUJ1dHRvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZ2VuZXJhdGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uJztcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24uaW5uZXJIVE1MID0gJ2dlbmVyYXRlIG9wdGlvbnMnO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9wcmludE9wdGlvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uIGhvdmVyJztcbiAgICAgICAgfTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lcic7XG5cbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKHRoaXMub3B0aW9uc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChnZW5lcmF0ZUJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJlcGFyZSB0aGUgcG9wdXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldHVwUG9wdXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBQb3B1cChzdHJpbmcsIGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUgJiYgdGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlICYmIHRoaXMucG9wdXBDb3VudGVyIDwgdGhpcy5wb3B1cExpbWl0KSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmlkID0gJ3Zpcy1jb25maWd1cmF0aW9uLXBvcHVwJztcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbi1wb3B1cCc7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgICAgdGhpcy5wb3B1cERpdiA9IHsgaHRtbDogZGl2LCBpbmRleDogaW5kZXggfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIHBvcHVwIGZyb20gdGhlIGRvbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZW1vdmVQb3B1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVQb3B1cCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgcG9wdXAgaWYgaXQgaXMgbmVlZGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zaG93UG9wdXBJZk5lZWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93UG9wdXBJZk5lZWRlZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgICAgdmFyIHJlY3QgPSBjb3JyZXNwb25kaW5nRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyAncHgnO1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUudG9wID0gcmVjdC50b3AgLSAzMCArICdweCc7IC8vIDMwIGlzIHRoZSBoZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5wb3B1cERpdi5odG1sLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl9yZW1vdmVQb3B1cCgpO1xuICAgICAgICB9LCAxODAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY2hlY2tib3ggZm9yIGJvb2xlYW4gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VDaGVja2JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQ2hlY2tib3goZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgY2hlY2tib3guY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY2hlY2tib3gnO1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkoZGVmYXVsdFZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy5jaGVja2VkLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgdGV4dCBpbnB1dCBmaWVsZCBmb3Igc3RyaW5nIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tYWtlVGV4dElucHV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VUZXh0SW5wdXQoZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSAndGV4dCc7XG4gICAgICBjaGVja2JveC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy10ZXh0JztcbiAgICAgIGNoZWNrYm94LnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY29sb3IgZmllbGQgd2l0aCBhIGNvbG9yIHBpY2tlciBmb3IgY29sb3IgZmllbGRzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VDb2xvckZpZWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdENvbG9yID0gYXJyWzFdO1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrJztcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2sgbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgZGl2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IHRoZSBjb2xvciBidXR0b25zIHRvIGNhbGwgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaXZcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2hvd0NvbG9yUGlja2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gY2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhpcyBkaXZcbiAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8oZGl2KTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2hvdygpO1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHZhbHVlKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0VXBkYXRlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBjb2xvclN0cmluZyA9ICdyZ2JhKCcgKyBjb2xvci5yICsgJywnICsgY29sb3IuZyArICcsJyArIGNvbG9yLmIgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHJpbmc7XG4gICAgICAgIF90aGlzNS5fdXBkYXRlKGNvbG9yU3RyaW5nLCBwYXRoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbiBjbG9zZSBvZiB0aGUgY29sb3JwaWNrZXIsIHJlc3RvcmUgdGhlIGNhbGxiYWNrLlxuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM1Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXJzZSBhbiBvYmplY3QgYW5kIGRyYXcgdGhlIGNvcnJlY3QgaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHthcnJheX0gW3BhdGg9W11dICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja09ubHk9ZmFsc2VdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZU9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPYmplY3Qob2JqKSB7XG4gICAgICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgY2hlY2tPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdmFyIHNob3cgPSBmYWxzZTtcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgICAgdmFyIHZpc2libGVJblNldCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgc3ViT2JqIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHN1Yk9iaikpIHtcbiAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgaXRlbSA9IG9ialtzdWJPYmpdO1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgc3ViT2JqKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihzdWJPYmosIHBhdGgpO1xuXG4gICAgICAgICAgICAvLyBpZiBuZWVkZWQgd2UgbXVzdCBnbyBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKHNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpdGVtICE9PSAnYm9vbGVhbicgJiYgaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNob3cgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gY2hlY2tPbmx5ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKG5ld1BhdGgpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFycmF5KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gY29sbGFwc2UgdGhlIHBoeXNpY3Mgb3B0aW9ucyB0aGF0IGFyZSBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICB2YXIgZHJhdyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoJ3BoeXNpY3MnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2R1bGVPcHRpb25zLnBoeXNpY3Muc29sdmVyICE9PSBzdWJPYmopIHtcbiAgICAgICAgICAgICAgICAgIGRyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxseSBjb2xsYXBzZSBvcHRpb25zIHdpdGggYW4gZGlzYWJsZWQgZW5hYmxlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW5hYmxlZFBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShuZXdQYXRoLCAnZW5hYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2xhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBfbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RvbnQga25vdyBob3cgdG8gaGFuZGxlJywgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2aXNpYmxlSW5TZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSBhcnJheSB0eXBlIG9mIG9wdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVBcnJheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVBcnJheShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycgJiYgYXJyWzBdID09PSAnY29sb3InKSB7XG4gICAgICAgIHRoaXMuX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICBpZiAoYXJyWzFdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogTnVtYmVyKHZhbHVlKSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpO1xuXG4gICAgICBpZiAodGhpcy5wYXJlbnQuYm9keSAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQoJ2NvbmZpZ0NoYW5nZScsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHBhcmFtIHt7fX0gb3B0aW9uc09ialxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY29uc3RydWN0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgb3B0aW9uc09iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgICAgLy8gd2hlbiBkcm9wZG93biBib3hlcyBjYW4gYmUgc3RyaW5nIG9yIGJvb2xlYW4sIHdlIHR5cGVjYXN0IGl0IGludG8gY29ycmVjdCB0eXBlc1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyW3BhdGhbaV1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9uc09iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcHJpbnRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByaW50T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuaW5uZXJIVE1MID0gJzxwcmU+dmFyIG9wdGlvbnMgPSAnICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKG9wdGlvbnMsIG51bGwsIDIpICsgJzwvcHJlPic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e319IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS52YWx1ZSwgdGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS5wYXRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29uZmlndXJhdG9yO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDb25maWd1cmF0b3I7XG5cbi8qKiovIH0pLFxuLyogMTkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgaHRtbENvbG9ycyA9IHtcbiAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgbmF2eTogJyMwMDAwODAnLFxuICBkYXJrYmx1ZTogJyMwMDAwOEInLFxuICBtZWRpdW1ibHVlOiAnIzAwMDBDRCcsXG4gIGJsdWU6ICcjMDAwMEZGJyxcbiAgZGFya2dyZWVuOiAnIzAwNjQwMCcsXG4gIGdyZWVuOiAnIzAwODAwMCcsXG4gIHRlYWw6ICcjMDA4MDgwJyxcbiAgZGFya2N5YW46ICcjMDA4QjhCJyxcbiAgZGVlcHNreWJsdWU6ICcjMDBCRkZGJyxcbiAgZGFya3R1cnF1b2lzZTogJyMwMENFRDEnLFxuICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMEZBOUEnLFxuICBsaW1lOiAnIzAwRkYwMCcsXG4gIHNwcmluZ2dyZWVuOiAnIzAwRkY3RicsXG4gIGFxdWE6ICcjMDBGRkZGJyxcbiAgY3lhbjogJyMwMEZGRkYnLFxuICBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJyxcbiAgZG9kZ2VyYmx1ZTogJyMxRTkwRkYnLFxuICBsaWdodHNlYWdyZWVuOiAnIzIwQjJBQScsXG4gIGZvcmVzdGdyZWVuOiAnIzIyOEIyMicsXG4gIHNlYWdyZWVuOiAnIzJFOEI1NycsXG4gIGRhcmtzbGF0ZWdyYXk6ICcjMkY0RjRGJyxcbiAgbGltZWdyZWVuOiAnIzMyQ0QzMicsXG4gIG1lZGl1bXNlYWdyZWVuOiAnIzNDQjM3MScsXG4gIHR1cnF1b2lzZTogJyM0MEUwRDAnLFxuICByb3lhbGJsdWU6ICcjNDE2OUUxJyxcbiAgc3RlZWxibHVlOiAnIzQ2ODJCNCcsXG4gIGRhcmtzbGF0ZWJsdWU6ICcjNDgzRDhCJyxcbiAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4RDFDQycsXG4gIGluZGlnbzogJyM0QjAwODInLFxuICBkYXJrb2xpdmVncmVlbjogJyM1NTZCMkYnLFxuICBjYWRldGJsdWU6ICcjNUY5RUEwJyxcbiAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NUVEJyxcbiAgbWVkaXVtYXF1YW1hcmluZTogJyM2NkNEQUEnLFxuICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gIHNsYXRlYmx1ZTogJyM2QTVBQ0QnLFxuICBvbGl2ZWRyYWI6ICcjNkI4RTIzJyxcbiAgc2xhdGVncmF5OiAnIzcwODA5MCcsXG4gIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsXG4gIG1lZGl1bXNsYXRlYmx1ZTogJyM3QjY4RUUnLFxuICBsYXduZ3JlZW46ICcjN0NGQzAwJyxcbiAgY2hhcnRyZXVzZTogJyM3RkZGMDAnLFxuICBhcXVhbWFyaW5lOiAnIzdGRkZENCcsXG4gIG1hcm9vbjogJyM4MDAwMDAnLFxuICBwdXJwbGU6ICcjODAwMDgwJyxcbiAgb2xpdmU6ICcjODA4MDAwJyxcbiAgZ3JheTogJyM4MDgwODAnLFxuICBza3libHVlOiAnIzg3Q0VFQicsXG4gIGxpZ2h0c2t5Ymx1ZTogJyM4N0NFRkEnLFxuICBibHVldmlvbGV0OiAnIzhBMkJFMicsXG4gIGRhcmtyZWQ6ICcjOEIwMDAwJyxcbiAgZGFya21hZ2VudGE6ICcjOEIwMDhCJyxcbiAgc2FkZGxlYnJvd246ICcjOEI0NTEzJyxcbiAgZGFya3NlYWdyZWVuOiAnIzhGQkM4RicsXG4gIGxpZ2h0Z3JlZW46ICcjOTBFRTkwJyxcbiAgbWVkaXVtcHVycGxlOiAnIzkzNzBEOCcsXG4gIGRhcmt2aW9sZXQ6ICcjOTQwMEQzJyxcbiAgcGFsZWdyZWVuOiAnIzk4RkI5OCcsXG4gIGRhcmtvcmNoaWQ6ICcjOTkzMkNDJyxcbiAgeWVsbG93Z3JlZW46ICcjOUFDRDMyJyxcbiAgc2llbm5hOiAnI0EwNTIyRCcsXG4gIGJyb3duOiAnI0E1MkEyQScsXG4gIGRhcmtncmF5OiAnI0E5QTlBOScsXG4gIGxpZ2h0Ymx1ZTogJyNBREQ4RTYnLFxuICBncmVlbnllbGxvdzogJyNBREZGMkYnLFxuICBwYWxldHVycXVvaXNlOiAnI0FGRUVFRScsXG4gIGxpZ2h0c3RlZWxibHVlOiAnI0IwQzRERScsXG4gIHBvd2RlcmJsdWU6ICcjQjBFMEU2JyxcbiAgZmlyZWJyaWNrOiAnI0IyMjIyMicsXG4gIGRhcmtnb2xkZW5yb2Q6ICcjQjg4NjBCJyxcbiAgbWVkaXVtb3JjaGlkOiAnI0JBNTVEMycsXG4gIHJvc3licm93bjogJyNCQzhGOEYnLFxuICBkYXJra2hha2k6ICcjQkRCNzZCJyxcbiAgc2lsdmVyOiAnI0MwQzBDMCcsXG4gIG1lZGl1bXZpb2xldHJlZDogJyNDNzE1ODUnLFxuICBpbmRpYW5yZWQ6ICcjQ0Q1QzVDJyxcbiAgcGVydTogJyNDRDg1M0YnLFxuICBjaG9jb2xhdGU6ICcjRDI2OTFFJyxcbiAgdGFuOiAnI0QyQjQ4QycsXG4gIGxpZ2h0Z3JleTogJyNEM0QzRDMnLFxuICBwYWxldmlvbGV0cmVkOiAnI0Q4NzA5MycsXG4gIHRoaXN0bGU6ICcjRDhCRkQ4JyxcbiAgb3JjaGlkOiAnI0RBNzBENicsXG4gIGdvbGRlbnJvZDogJyNEQUE1MjAnLFxuICBjcmltc29uOiAnI0RDMTQzQycsXG4gIGdhaW5zYm9ybzogJyNEQ0RDREMnLFxuICBwbHVtOiAnI0REQTBERCcsXG4gIGJ1cmx5d29vZDogJyNERUI4ODcnLFxuICBsaWdodGN5YW46ICcjRTBGRkZGJyxcbiAgbGF2ZW5kZXI6ICcjRTZFNkZBJyxcbiAgZGFya3NhbG1vbjogJyNFOTk2N0EnLFxuICB2aW9sZXQ6ICcjRUU4MkVFJyxcbiAgcGFsZWdvbGRlbnJvZDogJyNFRUU4QUEnLFxuICBsaWdodGNvcmFsOiAnI0YwODA4MCcsXG4gIGtoYWtpOiAnI0YwRTY4QycsXG4gIGFsaWNlYmx1ZTogJyNGMEY4RkYnLFxuICBob25leWRldzogJyNGMEZGRjAnLFxuICBhenVyZTogJyNGMEZGRkYnLFxuICBzYW5keWJyb3duOiAnI0Y0QTQ2MCcsXG4gIHdoZWF0OiAnI0Y1REVCMycsXG4gIGJlaWdlOiAnI0Y1RjVEQycsXG4gIHdoaXRlc21va2U6ICcjRjVGNUY1JyxcbiAgbWludGNyZWFtOiAnI0Y1RkZGQScsXG4gIGdob3N0d2hpdGU6ICcjRjhGOEZGJyxcbiAgc2FsbW9uOiAnI0ZBODA3MicsXG4gIGFudGlxdWV3aGl0ZTogJyNGQUVCRDcnLFxuICBsaW5lbjogJyNGQUYwRTYnLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNGQUZBRDInLFxuICBvbGRsYWNlOiAnI0ZERjVFNicsXG4gIHJlZDogJyNGRjAwMDAnLFxuICBmdWNoc2lhOiAnI0ZGMDBGRicsXG4gIG1hZ2VudGE6ICcjRkYwMEZGJyxcbiAgZGVlcHBpbms6ICcjRkYxNDkzJyxcbiAgb3JhbmdlcmVkOiAnI0ZGNDUwMCcsXG4gIHRvbWF0bzogJyNGRjYzNDcnLFxuICBob3RwaW5rOiAnI0ZGNjlCNCcsXG4gIGNvcmFsOiAnI0ZGN0Y1MCcsXG4gIGRhcmtvcmFuZ2U6ICcjRkY4QzAwJyxcbiAgbGlnaHRzYWxtb246ICcjRkZBMDdBJyxcbiAgb3JhbmdlOiAnI0ZGQTUwMCcsXG4gIGxpZ2h0cGluazogJyNGRkI2QzEnLFxuICBwaW5rOiAnI0ZGQzBDQicsXG4gIGdvbGQ6ICcjRkZENzAwJyxcbiAgcGVhY2hwdWZmOiAnI0ZGREFCOScsXG4gIG5hdmFqb3doaXRlOiAnI0ZGREVBRCcsXG4gIG1vY2Nhc2luOiAnI0ZGRTRCNScsXG4gIGJpc3F1ZTogJyNGRkU0QzQnLFxuICBtaXN0eXJvc2U6ICcjRkZFNEUxJyxcbiAgYmxhbmNoZWRhbG1vbmQ6ICcjRkZFQkNEJyxcbiAgcGFwYXlhd2hpcDogJyNGRkVGRDUnLFxuICBsYXZlbmRlcmJsdXNoOiAnI0ZGRjBGNScsXG4gIHNlYXNoZWxsOiAnI0ZGRjVFRScsXG4gIGNvcm5zaWxrOiAnI0ZGRjhEQycsXG4gIGxlbW9uY2hpZmZvbjogJyNGRkZBQ0QnLFxuICBmbG9yYWx3aGl0ZTogJyNGRkZBRjAnLFxuICBzbm93OiAnI0ZGRkFGQScsXG4gIHllbGxvdzogJyNGRkZGMDAnLFxuICBsaWdodHllbGxvdzogJyNGRkZGRTAnLFxuICBpdm9yeTogJyNGRkZGRjAnLFxuICB3aGl0ZTogJyNGRkZGRkYnXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICAgKi9cbn07XG52YXIgQ29sb3JQaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89MV1cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yUGlja2VyKCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENvbG9yUGlja2VyKTtcblxuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5nZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0geyB4OiAyODkgLyAyLCB5OiAyODkgLyAyIH07XG4gICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICB0aGlzLmNvbG9yID0geyByOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAxLjAgfTtcbiAgICB0aGlzLmh1ZUNpcmNsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluaXRpYWxDb2xvciA9IHsgcjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMS4wIH07XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuXG4gICAgLy8gYm91bmQgYnlcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgaW5zZXJ0cyB0aGUgY29sb3JQaWNrZXIgaW50byBhIGRpdiBmcm9tIHRoZSBET01cbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDb2xvclBpY2tlciwgW3tcbiAgICBrZXk6ICdpbnNlcnRUbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRvKGNvbnRhaW5lcikge1xuICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmhhbW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG5cbiAgICAgIHRoaXMuX3NldFNpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VXBkYXRlQ2FsbGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcGRhdGVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDbG9zZUNhbGxiYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2xvc2VDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciBjbG9zaW5nIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaXNDb2xvclN0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3JQaWNrZXJcbiAgICAgKiBTdXBwb3J0ZWQgZm9ybWF0czpcbiAgICAgKiAncmVkJyAgICAgICAgICAgICAgICAgICAtLT4gSFRNTCBjb2xvciBzdHJpbmdcbiAgICAgKiAnI2ZmZmZmZicgICAgICAgICAgICAgICAtLT4gaGV4IHN0cmluZ1xuICAgICAqICdyZ2IoMjU1LDI1NSwyNTUpJyAgICAgIC0tPiByZ2Igc3RyaW5nXG4gICAgICogJ3JnYmEoMjU1LDI1NSwyNTUsMS4wKScgLS0+IHJnYmEgc3RyaW5nXG4gICAgICoge3I6MjU1LGc6MjU1LGI6MjU1fSAgICAgLS0+IHJnYiBvYmplY3RcbiAgICAgKiB7cjoyNTUsZzoyNTUsYjoyNTUsYToxLjB9IC0tPiByZ2JhIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gY29sb3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZ2JhID0gdm9pZCAwO1xuXG4gICAgICAvLyBpZiBhIGh0bWwgY29sb3Igc2hvcnRoYW5kIGlzIHVzZWQsIGNvbnZlcnQgdG8gaGV4XG4gICAgICB2YXIgaHRtbENvbG9yID0gdGhpcy5faXNDb2xvclN0cmluZyhjb2xvcik7XG4gICAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sb3IgPSBodG1sQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvcm1hdFxuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh1dGlsLmlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKTtcbiAgICAgICAgICByZ2JhID0geyByOiByZ2JhQXJyYXlbMF0sIGc6IHJnYmFBcnJheVsxXSwgYjogcmdiYUFycmF5WzJdLCBhOiAxLjAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDUpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA2KS5zcGxpdCgnLCcpO1xuICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICByOiBfcmdiYUFycmF5WzBdLFxuICAgICAgICAgICAgZzogX3JnYmFBcnJheVsxXSxcbiAgICAgICAgICAgIGI6IF9yZ2JhQXJyYXlbMl0sXG4gICAgICAgICAgICBhOiBfcmdiYUFycmF5WzNdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYk9iaiA9IHV0aWwuaGV4VG9SR0IoY29sb3IpO1xuICAgICAgICAgIHJnYmEgPSB7IHI6IHJnYk9iai5yLCBnOiByZ2JPYmouZywgYjogcmdiT2JqLmIsIGE6IDEuMCB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoY29sb3IuciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmcgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5iICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNvbG9yLmEgIT09IHVuZGVmaW5lZCA/IGNvbG9yLmEgOiAnMS4wJztcbiAgICAgICAgICAgIHJnYmEgPSB7IHI6IGNvbG9yLnIsIGc6IGNvbG9yLmcsIGI6IGNvbG9yLmIsIGE6IGFscGhhIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb2xvclxuICAgICAgaWYgKHJnYmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29sb3IgcGFzc2VkIHRvIHRoZSBjb2xvclBpY2tlci4gU3VwcG9ydGVkIGFyZSBzdHJpbmdzOiByZ2IsIGhleCwgcmdiYS4gT2JqZWN0OiByZ2IgKHtyOnIsZzpnLGI6YixbYTphXX0pLiBTdXBwbGllZDogJyArICgwLCBfc3RyaW5naWZ5MlsnZGVmYXVsdCddKShjb2xvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzaG93cyB0aGUgY29sb3IgcGlja2VyLlxuICAgICAqIFRoZSBodWUgY2lyY2xlIGlzIGNvbnN0cnVjdGVkIG9uY2UgYW5kIHN0b3JlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICogT3B0aW9uYWwgYm9vbGVhbiB0byBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIGVhc3kgYWNjZXNzIGxhdGVyIG9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0b3JlUHJldmlvdXM9dHJ1ZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHN0b3JlUHJldmlvdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgbmV4dCB0aW1lO1xuICAgICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdXRpbC5leHRlbmQoe30sIHRoaXMuY29sb3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5pbml0aWFsQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgIC8vIGNhbGwgdGhlIGNsb3NpbmcgY2FsbGJhY2ssIHJlc3RvcmluZyB0aGUgb25jbGljayBtZXRob2QuXG4gICAgICAvLyB0aGlzIGlzIGluIGEgc2V0VGltZW91dCBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciB0aGUgc2hvdyBhZ2FpbiBiZWZvcmUgdGhlIGNsaWNrIGlzIGRvbmUuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLmNsb3NlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2F2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlKCkge1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faGlkZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvdW5kIHRvIGFwcGx5IGJ1dHRvbi4gU2F2ZXMgYnV0IGRvZXMgbm90IGNsb3NlLiBJcyB1bmRvbmUgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5KCkge1xuICAgICAgdGhpcy5hcHBsaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbG9hZExhc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZExhc3QoKSB7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRDb2xvcih0aGlzLnByZXZpb3VzQ29sb3IsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KCdUaGVyZSBpcyBubyBsYXN0IGNvbG9yIHRvIGxvYWQuLi4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGNvbG9yLCBwbGFjZSB0aGUgcGlja2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJnYmFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENvbG9yKHJnYmEpIHtcbiAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBjb2xvclxuICAgICAgaWYgKHNldEluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgcmdiYSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG5cbiAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSTtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLnIgKiBoc3YucztcbiAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgdmFyIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0geCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArICdweCc7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIocmdiYSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gb3BhY2l0eSBjb250cm9sXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldE9wYWNpdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0T3BhY2l0eSh2YWx1ZSkge1xuICAgICAgdGhpcy5jb2xvci5hID0gdmFsdWUgLyAxMDA7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gYnJpZ2h0bmVzcyBjb250cm9sXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldEJyaWdodG5lc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgICBoc3YudiA9IHZhbHVlIC8gMTAwO1xuICAgICAgdmFyIHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgcmdiYVsnYSddID0gdGhpcy5jb2xvci5hO1xuICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGNvbG9yIHBpY2tlci4gQSBibGFjayBjaXJjbGUgb3ZlcmxheXMgdGhlIGh1ZSBjaXJjbGUgdG8gbWltaWMgdGhlIGJyaWdodG5lc3MgZGVjcmVhc2luZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmdiYVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVQaWNrZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUGlja2VyKCkge1xuICAgICAgdmFyIHJnYmEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuY29sb3I7XG5cbiAgICAgIHZhciBoc3YgPSB1dGlsLlJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgfVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLCAwLCAwKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwnICsgKDEgLSBoc3YudikgKyAnKSc7XG4gICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gMTAwICogcmdiYS5hO1xuXG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5pbml0aWFsQ29sb3IuciArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYSArICcpJztcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IGNyZWF0ZSB0byBzZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0U2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaXplKCkge1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLndpZHRoID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQgPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGFsbCBkb20gZWxlbWVudHNcbiAgICAgKiBUT0RPOiBjbGVhbnVwLCBsb3RzIG9mIHNpbWlsYXIgZG9tIGVsZW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtY29sb3ItcGlja2VyJztcblxuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gJ3Zpcy1zZWxlY3Rvcic7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvcik7XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG5cbiAgICAgIGlmICghdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSAnRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzJztcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZSA9ICd2aXMtY29sb3InO1xuXG4gICAgICB0aGlzLm9wYWNpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMub3BhY2l0eURpdi5jbGFzc05hbWUgPSAndmlzLW9wYWNpdHknO1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5jbGFzc05hbWUgPSAndmlzLWJyaWdodG5lc3MnO1xuXG4gICAgICB0aGlzLmFycm93RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmFycm93RGl2LmNsYXNzTmFtZSA9ICd2aXMtYXJyb3cnO1xuXG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWluID0gJzAnO1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSAnMTAwJztcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIC8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nIGFuZCByZW1vdmUgdGhpcyBsaW50IGV4Y2VwdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluID0gJzAnO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5tYXggPSAnMTAwJztcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIC8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nIGFuZCByZW1vdmUgdGhpcyBsaW50IGV4Y2VwdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzRGl2LmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc1JhbmdlKTtcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzcyc7XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lckhUTUwgPSAnYnJpZ2h0bmVzczonO1xuXG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCB2aXMtb3BhY2l0eSc7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbC5pbm5lckhUTUwgPSAnb3BhY2l0eTonO1xuXG4gICAgICB0aGlzLm5ld0NvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZSA9ICd2aXMtbmV3LWNvbG9yJztcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuaW5uZXJIVE1MID0gJ25ldyc7XG5cbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5jbGFzc05hbWUgPSAndmlzLWluaXRpYWwtY29sb3InO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJIVE1MID0gJ2luaXRpYWwnO1xuXG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1idXR0b24gdmlzLWNhbmNlbCc7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5pbm5lckhUTUwgPSAnY2FuY2VsJztcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9oaWRlLmJpbmQodGhpcywgZmFsc2UpO1xuXG4gICAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtYnV0dG9uIHZpcy1hcHBseSc7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLmlubmVySFRNTCA9ICdhcHBseSc7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9hcHBseS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLnNhdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWJ1dHRvbiB2aXMtc2F2ZSc7XG4gICAgICB0aGlzLnNhdmVCdXR0b24uaW5uZXJIVE1MID0gJ3NhdmUnO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9zYXZlLmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtYnV0dG9uIHZpcy1sb2FkJztcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5pbm5lckhUTUwgPSAnbG9hZCBsYXN0JztcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fbG9hZExhc3QuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0Rpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpO1xuXG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2FuY2VsQnV0dG9uKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuc2F2ZUJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubG9hZEJ1dHRvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYmluZCBoYW1tZXIgdG8gdGhlIGNvbG9yIHBpY2tlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19iaW5kSGFtbWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICB0aGlzLnBpbmNoID0ge307XG4gICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG4gICAgICB0aGlzLmhhbW1lci5nZXQoJ3BpbmNoJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuXG4gICAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2VuZXJhdGVIdWVDaXJjbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVIdWVDaXJjbGUoKSB7XG4gICAgICBpZiAodGhpcy5nZW5lcmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgLy8gZHJhdyBodWUgY2lyY2xlXG4gICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGh1ZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHNhdCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHsgeDogdyAqIDAuNSwgeTogaCAqIDAuNSB9O1xuICAgICAgICB0aGlzLnIgPSAwLjQ5ICogdztcbiAgICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJIC8gMzYwO1xuICAgICAgICB2YXIgaGZhYyA9IDEgLyAzNjA7XG4gICAgICAgIHZhciBzZmFjID0gMSAvIHRoaXMucjtcbiAgICAgICAgdmFyIHJnYiA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChodWUgPSAwOyBodWUgPCAzNjA7IGh1ZSsrKSB7XG4gICAgICAgICAgZm9yIChzYXQgPSAwOyBzYXQgPCB0aGlzLnI7IHNhdCsrKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgc2F0ICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICAgIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyBzYXQgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgcmdiID0gdXRpbC5IU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnKSc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDAuNSwgeSAtIDAuNSwgMiwgMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDEpJztcbiAgICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIHRoaXMuaHVlQ2lyY2xlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBzZWxlY3Rvci4gVGhpcyBpcyBjYWxsZWQgYnkgaGFtbWVyIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tb3ZlU2VsZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVNlbGVjdG9yKGV2ZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY29sb3JQaWNrZXJEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbGVmdCA9IGV2ZW50LmNlbnRlci54IC0gcmVjdC5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3A7XG5cbiAgICAgIHZhciBjZW50ZXJZID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50V2lkdGg7XG5cbiAgICAgIHZhciB4ID0gbGVmdCAtIGNlbnRlclg7XG4gICAgICB2YXIgeSA9IHRvcCAtIGNlbnRlclk7XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeCwgeSk7XG4gICAgICB2YXIgcmFkaXVzID0gMC45OCAqIE1hdGgubWluKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgY2VudGVyWCk7XG5cbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJZO1xuICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJYO1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0gbmV3VG9wIC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IG5ld0xlZnQgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuXG4gICAgICAvLyBzZXQgY29sb3JcbiAgICAgIHZhciBoID0gYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgaCA9IGggPCAwID8gaCArIDEgOiBoO1xuICAgICAgdmFyIHMgPSByYWRpdXMgLyB0aGlzLnI7XG4gICAgICB2YXIgaHN2ID0gdXRpbC5SR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgIGhzdi5oID0gaDtcbiAgICAgIGhzdi5zID0gcztcbiAgICAgIHZhciByZ2JhID0gdXRpbC5IU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICAgIHJnYmFbJ2EnXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgICAvLyB1cGRhdGUgcHJldmlld3NcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5jb2xvci5yICsgJywnICsgdGhpcy5jb2xvci5nICsgJywnICsgdGhpcy5jb2xvci5iICsgJywnICsgdGhpcy5jb2xvci5hICsgJyknO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JQaWNrZXI7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbG9yUGlja2VyO1xuXG4vKioqLyB9KSxcbi8qIDE5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGljZWRUb0FycmF5Mik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9GbG95ZFdhcnNoYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTQpO1xuXG52YXIgX0Zsb3lkV2Fyc2hhbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRmxveWRXYXJzaGFsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBLYW1hZGFLYXdhaSBwb3NpdGlvbnMgdGhlIG5vZGVzIGluaXRpYWxseSBiYXNlZCBvblxuICpcbiAqIFwiQU4gQUxHT1JJVEhNIEZPUiBEUkFXSU5HIEdFTkVSQUwgVU5ESVJFQ1RFRCBHUkFQSFNcIlxuICogLS0gVG9taWhpc2EgS0FNQURBIGFuZCBTYXRvcnUgS0FXQUkgaW4gMTk4OVxuICpcbiAqIFBvc3NpYmxlIG9wdGltaXphdGlvbnMgaW4gdGhlIGRpc3RhbmNlIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXBsZW1lbnRlZC5cbiAqL1xudmFyIEthbWFkYUthd2FpID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VTdHJlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gS2FtYWRhS2F3YWkoYm9keSwgZWRnZUxlbmd0aCwgZWRnZVN0cmVuZ3RoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgS2FtYWRhS2F3YWkpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnNwcmluZ0xlbmd0aCA9IGVkZ2VMZW5ndGg7XG4gICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IGVkZ2VTdHJlbmd0aDtcbiAgICB0aGlzLmRpc3RhbmNlU29sdmVyID0gbmV3IF9GbG95ZFdhcnNoYWxsMlsnZGVmYXVsdCddKCk7XG4gIH1cblxuICAvKipcbiAgICogTm90IHN1cmUgaWYgbmVlZGVkIGJ1dCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHNwcmluZyBsZW5ndGggYW5kIHNwcmluZyBjb25zdGFudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEthbWFkYUthd2FpLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNwcmluZ0xlbmd0aCkge1xuICAgICAgICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gb3B0aW9ucy5zcHJpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQpIHtcbiAgICAgICAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gb3B0aW9ucy5zcHJpbmdDb25zdGFudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHZpcy5FZGdlPn0gZWRnZXNBcnJheVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZUNsdXN0ZXJzPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzb2x2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBpZ25vcmVDbHVzdGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIC8vIGdldCBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBEX21hdHJpeCA9IHRoaXMuZGlzdGFuY2VTb2x2ZXIuZ2V0RGlzdGFuY2VzKHRoaXMuYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSk7IC8vIGRpc3RhbmNlIG1hdHJpeFxuXG4gICAgICAvLyBnZXQgdGhlIEwgTWF0cml4XG4gICAgICB0aGlzLl9jcmVhdGVMX21hdHJpeChEX21hdHJpeCk7XG5cbiAgICAgIC8vIGdldCB0aGUgSyBNYXRyaXhcbiAgICAgIHRoaXMuX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KTtcblxuICAgICAgLy8gaW5pdGlhbCBFIE1hdHJpeFxuICAgICAgdGhpcy5fY3JlYXRlRV9tYXRyaXgoKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uc1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDE7XG4gICAgICB2YXIgaW5uZXJUaHJlc2hvbGQgPSAxO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCgxMDAwLCBNYXRoLm1pbigxMCAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgsIDYwMDApKTtcbiAgICAgIHZhciBtYXhJbm5lckl0ZXJhdGlvbnMgPSA1O1xuXG4gICAgICB2YXIgbWF4RW5lcmd5ID0gMWU5O1xuICAgICAgdmFyIGhpZ2hFX25vZGVJZCA9IDAsXG4gICAgICAgICAgZEVfZHggPSAwLFxuICAgICAgICAgIGRFX2R5ID0gMCxcbiAgICAgICAgICBkZWx0YV9tID0gMCxcbiAgICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcblxuICAgICAgd2hpbGUgKG1heEVuZXJneSA+IHRocmVzaG9sZCAmJiBpdGVyYXRpb25zIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgICAgIHZhciBfZ2V0SGlnaGVzdEVuZXJneU5vZGUyID0gdGhpcy5fZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpO1xuXG4gICAgICAgIHZhciBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0SGlnaGVzdEVuZXJneU5vZGUyLCA0KTtcblxuICAgICAgICBoaWdoRV9ub2RlSWQgPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzBdO1xuICAgICAgICBtYXhFbmVyZ3kgPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzFdO1xuICAgICAgICBkRV9keCA9IF9nZXRIaWdoZXN0RW5lcmd5Tm9kZTNbMl07XG4gICAgICAgIGRFX2R5ID0gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlM1szXTtcblxuICAgICAgICBkZWx0YV9tID0gbWF4RW5lcmd5O1xuICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcbiAgICAgICAgd2hpbGUgKGRlbHRhX20gPiBpbm5lclRocmVzaG9sZCAmJiBzdWJJdGVyYXRpb25zIDwgbWF4SW5uZXJJdGVyYXRpb25zKSB7XG4gICAgICAgICAgc3ViSXRlcmF0aW9ucyArPSAxO1xuICAgICAgICAgIHRoaXMuX21vdmVOb2RlKGhpZ2hFX25vZGVJZCwgZEVfZHgsIGRFX2R5KTtcbiAgICAgICAgICB2YXIgX2dldEVuZXJneTIgPSB0aGlzLl9nZXRFbmVyZ3koaGlnaEVfbm9kZUlkKTtcblxuICAgICAgICAgIHZhciBfZ2V0RW5lcmd5MyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldEVuZXJneTIsIDMpO1xuXG4gICAgICAgICAgZGVsdGFfbSA9IF9nZXRFbmVyZ3kzWzBdO1xuICAgICAgICAgIGRFX2R4ID0gX2dldEVuZXJneTNbMV07XG4gICAgICAgICAgZEVfZHkgPSBfZ2V0RW5lcmd5M1syXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbm9kZSB3aXRoIHRoZSBoaWdoZXN0IGVuZXJneVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlQ2x1c3RlcnNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEhpZ2hlc3RFbmVyZ3lOb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBtYXhFbmVyZ3kgPSAwO1xuICAgICAgdmFyIG1heEVuZXJneU5vZGVJZCA9IG5vZGVzQXJyYXlbMF07XG4gICAgICB2YXIgZEVfZHhfbWF4ID0gMCxcbiAgICAgICAgICBkRV9keV9tYXggPSAwO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWR4ID0gMDsgbm9kZUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBub2RlSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W25vZGVJZHhdO1xuICAgICAgICAvLyBieSBub3QgZXZhbHVhdGluZyBub2RlcyB3aXRoIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHNob3VsZCBvbmx5IG1vdmUgbm9kZXMgdGhhdCBoYXZlIG5vIHBvc2l0aW9ucy5cbiAgICAgICAgaWYgKG5vZGVzW21dLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gZmFsc2UgfHwgbm9kZXNbbV0uaXNDbHVzdGVyID09PSB0cnVlICYmIGlnbm9yZUNsdXN0ZXJzID09PSB0cnVlIHx8IG5vZGVzW21dLm9wdGlvbnMuZml4ZWQueCA9PT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnkgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX2dldEVuZXJneTQgPSB0aGlzLl9nZXRFbmVyZ3kobSksXG4gICAgICAgICAgICAgIF9nZXRFbmVyZ3k1ID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0RW5lcmd5NCwgMyksXG4gICAgICAgICAgICAgIGRlbHRhX20gPSBfZ2V0RW5lcmd5NVswXSxcbiAgICAgICAgICAgICAgZEVfZHggPSBfZ2V0RW5lcmd5NVsxXSxcbiAgICAgICAgICAgICAgZEVfZHkgPSBfZ2V0RW5lcmd5NVsyXTtcblxuICAgICAgICAgIGlmIChtYXhFbmVyZ3kgPCBkZWx0YV9tKSB7XG4gICAgICAgICAgICBtYXhFbmVyZ3kgPSBkZWx0YV9tO1xuICAgICAgICAgICAgbWF4RW5lcmd5Tm9kZUlkID0gbTtcbiAgICAgICAgICAgIGRFX2R4X21heCA9IGRFX2R4O1xuICAgICAgICAgICAgZEVfZHlfbWF4ID0gZEVfZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbWF4RW5lcmd5Tm9kZUlkLCBtYXhFbmVyZ3ksIGRFX2R4X21heCwgZEVfZHlfbWF4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGVuZXJneSBvZiBhIHNpbmdsZSBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBtXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRFbmVyZ3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RW5lcmd5KG0pIHtcbiAgICAgIHZhciBfRV9zdW1zJG0gPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKHRoaXMuRV9zdW1zW21dLCAyKSxcbiAgICAgICAgICBkRV9keCA9IF9FX3N1bXMkbVswXSxcbiAgICAgICAgICBkRV9keSA9IF9FX3N1bXMkbVsxXTtcblxuICAgICAgdmFyIGRlbHRhX20gPSBNYXRoLnNxcnQoTWF0aC5wb3coZEVfZHgsIDIpICsgTWF0aC5wb3coZEVfZHksIDIpKTtcbiAgICAgIHJldHVybiBbZGVsdGFfbSwgZEVfZHgsIGRFX2R5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlIGJhc2VkIG9uIGl0J3MgZW5lcmd5XG4gICAgICogdGhlIGR4IGFuZCBkeSBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsaW5lYXIgc3lzdGVtIHByb3Bvc2VkIGJ5IEthbWFkYSBhbmQgS2F3YWlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tb3ZlTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlTm9kZShtLCBkRV9keCwgZEVfZHkpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGQyRV9keDIgPSAwO1xuICAgICAgdmFyIGQyRV9keGR5ID0gMDtcbiAgICAgIHZhciBkMkVfZHkyID0gMDtcblxuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBrbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuXG4gICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgIHZhciBrbWF0ID0ga21baV07XG4gICAgICAgICAgdmFyIGxtYXQgPSBsbVtpXTtcbiAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnBvdyhNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSwgMS41KTtcbiAgICAgICAgICBkMkVfZHgyICs9IGttYXQgKiAoMSAtIGxtYXQgKiBNYXRoLnBvdyh5X20gLSB5X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGQyRV9keGR5ICs9IGttYXQgKiAobG1hdCAqICh4X20gLSB4X2kpICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgZDJFX2R5MiArPSBrbWF0ICogKDEgLSBsbWF0ICogTWF0aC5wb3coeF9tIC0geF9pLCAyKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbWFrZSB0aGUgdmFyaWFibGUgbmFtZXMgZWFzaWVyIHRvIG1ha2UgdGhlIHNvbHZpbmcgb2YgdGhlIGxpbmVhciBzeXN0ZW0gZWFzaWVyIHRvIHJlYWRcbiAgICAgIHZhciBBID0gZDJFX2R4MixcbiAgICAgICAgICBCID0gZDJFX2R4ZHksXG4gICAgICAgICAgQyA9IGRFX2R4LFxuICAgICAgICAgIEQgPSBkMkVfZHkyLFxuICAgICAgICAgIEUgPSBkRV9keTtcblxuICAgICAgLy8gc29sdmUgdGhlIGxpbmVhciBzeXN0ZW0gZm9yIGR4IGFuZCBkeVxuICAgICAgdmFyIGR5ID0gKEMgLyBBICsgRSAvIEIpIC8gKEIgLyBBIC0gRCAvIEIpO1xuICAgICAgdmFyIGR4ID0gLShCICogZHkgKyBDKSAvIEE7XG5cbiAgICAgIC8vIG1vdmUgdGhlIG5vZGVcbiAgICAgIG5vZGVzW21dLnggKz0gZHg7XG4gICAgICBub2Rlc1ttXS55ICs9IGR5O1xuXG4gICAgICAvLyBSZWNhbGN1bGF0ZSBFX21hdHJpeCAoc2hvdWxkIGJlIGluY3JlbWVudGFsKVxuICAgICAgdGhpcy5fdXBkYXRlRV9tYXRyaXgobSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBMIG1hdHJpeDogZWRnZSBsZW5ndGggdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBEX21hdHJpeFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVMX21hdHJpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVMX21hdHJpeChEX21hdHJpeCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IHRoaXMuc3ByaW5nTGVuZ3RoO1xuXG4gICAgICB0aGlzLkxfbWF0cml4ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5MX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZUxlbmd0aCAqIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBLIG1hdHJpeDogc3ByaW5nIGNvbnN0YW50cyB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IERfbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUtfbWF0cml4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlU3RyZW5ndGggPSB0aGlzLnNwcmluZ0NvbnN0YW50O1xuXG4gICAgICB0aGlzLktfbWF0cml4ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZVN0cmVuZ3RoICogTWF0aC5wb3coRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0sIC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgbWF0cml4IHdpdGggYWxsIGVuZXJnaWVzIGJldHdlZW4gbm9kZXNcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUVfbWF0cml4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVfbWF0cml4KCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB0aGlzLkVfbWF0cml4ID0ge307XG4gICAgICB0aGlzLkVfc3VtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgbUlkeCA9IDA7IG1JZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgbUlkeCsrKSB7XG4gICAgICAgIHRoaXMuRV9tYXRyaXhbbm9kZXNBcnJheVttSWR4XV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9tSWR4ID0gMDsgX21JZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgX21JZHgrKykge1xuICAgICAgICB2YXIgbSA9IG5vZGVzQXJyYXlbX21JZHhdO1xuICAgICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICAgIHZhciBkRV9keSA9IDA7XG4gICAgICAgIGZvciAodmFyIGlJZHggPSBfbUlkeDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG4gICAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnNxcnQoTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMikpO1xuICAgICAgICAgICAgdGhpcy5FX21hdHJpeFttXVtpSWR4XSA9IFt0aGlzLktfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pKSAqIGRlbm9taW5hdG9yKSwgdGhpcy5LX21hdHJpeFttXVtpXSAqICh5X20gLSB5X2kgLSB0aGlzLkxfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcildO1xuICAgICAgICAgICAgdGhpcy5FX21hdHJpeFtpXVtfbUlkeF0gPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdO1xuICAgICAgICAgICAgZEVfZHggKz0gdGhpcy5FX21hdHJpeFttXVtpSWR4XVswXTtcbiAgICAgICAgICAgIGRFX2R5ICs9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vU3RvcmUgc3VtXG4gICAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG1ldGhvZCwganVzdCBkb2luZyBzaW5nbGUgY29sdW1uIChyb3dzIGFyZSBhdXRvLXVwZGF0ZWQpICh1cGRhdGUgYWxsIHN1bXMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVFX21hdHJpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVFX21hdHJpeChtKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBjb2xtID0gdGhpcy5FX21hdHJpeFttXTtcbiAgICAgIHZhciBrY29sbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbGNvbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICB2YXIgZEVfZHkgPSAwO1xuICAgICAgZm9yICh2YXIgaUlkeCA9IDA7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcbiAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAvL0tlZXAgb2xkIGVuZXJneSB2YWx1ZSBmb3Igc3VtIG1vZGlmaWNhdGlvbiBiZWxvd1xuICAgICAgICAgIHZhciBjZWxsID0gY29sbVtpSWR4XTtcbiAgICAgICAgICB2YXIgb2xkRHggPSBjZWxsWzBdO1xuICAgICAgICAgIHZhciBvbGREeSA9IGNlbGxbMV07XG5cbiAgICAgICAgICAvL0NhbGMgbmV3IGVuZXJneTpcbiAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnNxcnQoTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMikpO1xuICAgICAgICAgIHZhciBkeCA9IGtjb2xtW2ldICogKHhfbSAtIHhfaSAtIGxjb2xtW2ldICogKHhfbSAtIHhfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgdmFyIGR5ID0ga2NvbG1baV0gKiAoeV9tIC0geV9pIC0gbGNvbG1baV0gKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBjb2xtW2lJZHhdID0gW2R4LCBkeV07XG4gICAgICAgICAgZEVfZHggKz0gZHg7XG4gICAgICAgICAgZEVfZHkgKz0gZHk7XG5cbiAgICAgICAgICAvL2FkZCBuZXcgZW5lcmd5IHRvIHN1bSBvZiBlYWNoIGNvbHVtblxuICAgICAgICAgIHZhciBzdW0gPSB0aGlzLkVfc3Vtc1tpXTtcbiAgICAgICAgICBzdW1bMF0gKz0gZHggLSBvbGREeDtcbiAgICAgICAgICBzdW1bMV0gKz0gZHkgLSBvbGREeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9TdG9yZSBzdW0gYXQgLTEgaW5kZXhcbiAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYW1hZGFLYXdhaTtcbn0oKTsgLy8gZGlzdGFuY2UgZmluZGluZyBhbGdvcml0aG1cblxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBLYW1hZGFLYXdhaTtcblxuLyoqKi8gfSksXG4vKiAxOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiAgVGhlIEZsb3lk4oCTV2Fyc2hhbGwgYWxnb3JpdGhtIGlzIGFuIGFsZ29yaXRobSBmb3IgZmluZGluZyBzaG9ydGVzdCBwYXRocyBpblxuICogIGEgd2VpZ2h0ZWQgZ3JhcGggd2l0aCBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBlZGdlIHdlaWdodHMgKGJ1dCB3aXRoIG5vIG5lZ2F0aXZlXG4gKiAgY3ljbGVzKS4gLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZOKAk1dhcnNoYWxsX2FsZ29yaXRobVxuICovXG52YXIgRmxveWRXYXJzaGFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEZsb3lkV2Fyc2hhbGwoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbXCJkZWZhdWx0XCJdKSh0aGlzLCBGbG95ZFdhcnNoYWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5LjxFZGdlPn0gZWRnZXNBcnJheVxuICAgKiBAcmV0dXJucyB7e319XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShGbG95ZFdhcnNoYWxsLCBbe1xuICAgIGtleTogXCJnZXREaXN0YW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VzKGJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBEX21hdHJpeCA9IHt9O1xuICAgICAgdmFyIGVkZ2VzID0gYm9keS5lZGdlcztcblxuICAgICAgLy8gcHJlcGFyZSBtYXRyaXggd2l0aCBsYXJnZSBudW1iZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc0FycmF5W2ldO1xuICAgICAgICB2YXIgY2VsbCA9IHt9O1xuICAgICAgICBEX21hdHJpeFtub2RlXSA9IGNlbGw7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGxbbm9kZXNBcnJheVtqXV0gPSBpID09IGogPyAwIDogMWU5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHB1dCB0aGUgd2VpZ2h0cyBmb3IgdGhlIGVkZ2VzIGluLiBUaGlzIGFzc3VtZXMgdW5pZGlyZWN0aW9uYWxpdHkuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXNBcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlc0FycmF5W19pXV07XG4gICAgICAgIC8vIGVkZ2UgaGFzIHRvIGJlIGNvbm5lY3RlZCBpZiBpdCBjb3VudHMgdG8gdGhlIGRpc3RhbmNlcy4gSWYgaXQgaXMgY29ubmVjdGVkIHRvIGlubmVyIGNsdXN0ZXJzIGl0IHdpbGwgY3Jhc2ggc28gd2UgYWxzbyBjaGVjayBpZiBpdCBpcyBpbiB0aGUgRF9tYXRyaXhcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIERfbWF0cml4W2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIERfbWF0cml4W2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERfbWF0cml4W2VkZ2UuZnJvbUlkXVtlZGdlLnRvSWRdID0gMTtcbiAgICAgICAgICBEX21hdHJpeFtlZGdlLnRvSWRdW2VkZ2UuZnJvbUlkXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVzQXJyYXkubGVuZ3RoO1xuXG4gICAgICAvLyBBZGFwdGVkIEZsb3lkV2Fyc2hhbGwgYmFzZWQgb24gdW5pZGlyZWN0aW9uYWxpdHkgdG8gZ3JlYXRseSByZWR1Y2UgY29tcGxleGl0eS5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbm9kZUNvdW50OyBrKyspIHtcbiAgICAgICAgdmFyIGtub2RlID0gbm9kZXNBcnJheVtrXTtcbiAgICAgICAgdmFyIGtjb2xtID0gRF9tYXRyaXhba25vZGVdO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlQ291bnQgLSAxOyBfaTIrKykge1xuICAgICAgICAgIHZhciBpbm9kZSA9IG5vZGVzQXJyYXlbX2kyXTtcbiAgICAgICAgICB2YXIgaWNvbG0gPSBEX21hdHJpeFtpbm9kZV07XG4gICAgICAgICAgZm9yICh2YXIgX2ogPSBfaTIgKyAxOyBfaiA8IG5vZGVDb3VudDsgX2orKykge1xuICAgICAgICAgICAgdmFyIGpub2RlID0gbm9kZXNBcnJheVtfal07XG4gICAgICAgICAgICB2YXIgamNvbG0gPSBEX21hdHJpeFtqbm9kZV07XG5cbiAgICAgICAgICAgIHZhciB2YWwgPSBNYXRoLm1pbihpY29sbVtqbm9kZV0sIGljb2xtW2tub2RlXSArIGtjb2xtW2pub2RlXSk7XG4gICAgICAgICAgICBpY29sbVtqbm9kZV0gPSB2YWw7XG4gICAgICAgICAgICBqY29sbVtpbm9kZV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEX21hdHJpeDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZsb3lkV2Fyc2hhbGw7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRmxveWRXYXJzaGFsbDtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./.yarn/cache/visjs-network-npm-4.25.0-2e90efaeed-40bfcbbf2b.zip/node_modules/visjs-network/dist/vis.js\n");

/***/ })

}]);